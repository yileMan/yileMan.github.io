<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>deepseek接入微信实践</title>
      <link href="/posts/37774.html"/>
      <url>/posts/37774.html</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><h1 id="AI-接入微信"><a href="#AI-接入微信" class="headerlink" title="AI 接入微信"></a>AI 接入微信</h1><h2 id="一-前言"><a href="#一-前言" class="headerlink" title="一 前言"></a>一 前言</h2><p>主要还是对别人的项目做了一个部署，踩了不少坑，改进了项目里面的一些东西，写在这里</p><h2 id="二-AI接入个人微信（大模型）"><a href="#二-AI接入个人微信（大模型）" class="headerlink" title="二 AI接入个人微信（大模型）"></a>二 AI接入个人微信（大模型）</h2><ul><li>项目地址：<code>https://github.com/KouriChat/KouriChat.git</code></li><li>项目语言：纯python（我也不太会）</li><li>预期实现效果：一个强大牛逼的个人机器助手，可以私聊也可以拉到群里面@它聊</li></ul><h3 id="2-1-服务器选择"><a href="#2-1-服务器选择" class="headerlink" title="2.1 服务器选择"></a>2.1 服务器选择</h3><ul><li>你可以选择个人电脑（坏处就是要一直开着，然后会弹窗自动发消息，如果消息多了会很烦）</li><li>也可以选择云服务器（推荐的）云服务器参考<strong>3.2</strong></li></ul><h3 id="2-2-环境准备"><a href="#2-2-环境准备" class="headerlink" title="2.2 环境准备"></a>2.2 环境准备</h3><ul><li><p>下载<code>python3.11.9</code>，问就是试了好几个版本</p></li><li><p>windows系统</p></li><li><p>一个微信小号（不介意的话你可以用自己的大号）</p></li><li><p>在你的电脑上登录你的微信号（如果你要登录小号又要登录大号，在项目启动的时候不使用大号的时候关闭大号的微信框，不然容易找错窗口）</p><figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@<span class="built_in">echo</span> off</span><br><span class="line"><span class="built_in">start</span> &quot;&quot; &quot;D:\software\wechat\WeChat.exe&quot;</span><br><span class="line"><span class="built_in">start</span> &quot;&quot; &quot;D:\software\wechat\WeChat.exe&quot;</span><br><span class="line"><span class="keyword">exit</span></span><br></pre></td></tr></table></figure><blockquote><p>微信双开脚本，用记事本编辑保存为 xxx.bat 后双击运行，其中<code>D:\software\wechat\WeChat.exe</code>替换为微信安装位置</p></blockquote></li></ul><h3 id="2-3-AI申请"><a href="#2-3-AI申请" class="headerlink" title="2.3 AI申请"></a>2.3 AI申请</h3><ul><li>项目推荐的是硅基生命的AI:<a href="https://cloud.siliconflow.cn/models，申请后会送你一些余额，绰绰有余，亏我还先重置了10块">https://cloud.siliconflow.cn/models，申请后会送你一些余额，绰绰有余，亏我还先重置了10块</a></li><li>然后申请一个API密钥</li></ul><h3 id="2-4-运行项目"><a href="#2-4-运行项目" class="headerlink" title="2.4 运行项目"></a>2.4 运行项目</h3><ul><li><p>两种方式，推荐直接点击<code>run.bat</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># 手动部署，cmd一个一个执行</span><br><span class="line"># 更新pip</span><br><span class="line">python -m pip install -i https://mirrors.tuna.tsinghua.edu.cn/pypi/web/simple --upgrade pip</span><br><span class="line"></span><br><span class="line"># 安装依赖</span><br><span class="line">pip install -r requirements.txt</span><br><span class="line"></span><br><span class="line">#调整配置文件</span><br><span class="line">python run_config_web.py</span><br><span class="line"></span><br><span class="line"># 启动程序 或 使用WebUI启动 (在此之前，请启动微信！不然会提示未找到窗口句柄...）</span><br><span class="line">python run.py</span><br></pre></td></tr></table></figure></li><li><p>然后你会进入到一个控制台前端（一开始会让你在对话框配置，可以跳过后面配）</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/202503042356128.png" alt="image-20250304235651025"></p></li><li><p>首先是角色设定，创建一个你自己的角色然后配置好，然后去配置中心</p><ul><li><p>用户列表：这里一定要输入的是用户的<strong>昵称或者群名</strong>，且群名里面不能用英文括号（踩坑）</p></li><li><p>API注册地址：硅基流动API</p></li><li><p>AI 模型：自己选</p></li><li><p>API 密钥：2.3里面的</p></li><li><p>然后右边还有一个Prompt配置</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/202503050003721.png" alt="image-20250305000343636"></p></li><li><p>选择好你的机器人</p></li><li><p>点击保存后回到主页，右下角应该会有一个保存成功，你的小黑框里面也应该有你刚刚修改内容，这个时候建议关闭应用重启再启动一下</p></li><li><p>如果你是双开微信，这个时候关闭你的主微信窗口（不是退出）（非机器人的那个）</p></li><li><p>然后启动，会看到项目自动检索你刚刚设置的用户昵称或者群名，然后把他们拉出来形成单独窗口（后期应该就是按照这个来找到对应的对话的）如果报错<code>-初始化失败：Find Control Timeou：&#123;RegexName：&#39;XXX&#39;,ControlType：ListItemControl&#125;</code>八成是你的昵称有问题亲测可以使用<code>-</code>、字母、数组、中文</p></li></ul></li></ul><h3 id="2-5-项目改进"><a href="#2-5-项目改进" class="headerlink" title="2.5 项目改进"></a>2.5 项目改进</h3><blockquote><p> 使用的时候发现，这个机器人回复的太烦了，一条一条的，发送一条消息能回七八条，应该要把他们浓缩为一条消息，</p></blockquote><ul><li><p>找到项目里面的 <code>src/handlers/message.py</code> 里面的 <code>def _handle_text_message</code>方法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">_handle_text_message</span>(<span class="params">self, content, chat_id, sender_name, username, is_group</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;处理普通文本消息&quot;&quot;&quot;</span></span><br><span class="line">        logger.info(<span class="string">&quot;处理普通文本回复&quot;</span>)</span><br><span class="line">        reply = self.get_api_response(content, chat_id)</span><br><span class="line">        <span class="keyword">if</span> <span class="string">&quot;&lt;/think&gt;&quot;</span> <span class="keyword">in</span> reply:</span><br><span class="line">            think_content, reply = reply.split(<span class="string">&quot;&lt;/think&gt;&quot;</span>, <span class="number">1</span>)</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;\n思考过程:&quot;</span>)</span><br><span class="line">            <span class="built_in">print</span>(think_content.strip())</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;\nAI回复:&quot;</span>)</span><br><span class="line">            <span class="built_in">print</span>(reply.strip())</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;\nAI回复:&quot;</span>)</span><br><span class="line">            <span class="built_in">print</span>(reply)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> is_group:</span><br><span class="line">            reply = <span class="string">f&quot;@<span class="subst">&#123;sender_name&#125;</span> <span class="subst">&#123;reply&#125;</span>&quot;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 发送文本回复 这里是罪魁祸首，因为AI模型回复过来的是带有斜杠的，</span></span><br><span class="line">        <span class="comment"># if &#x27;\\&#x27; in reply:</span></span><br><span class="line">        <span class="comment">#     parts = [p.strip() for p in reply.split(&#x27;\\&#x27;) if p.strip()]</span></span><br><span class="line">        <span class="comment">#     for part in parts:</span></span><br><span class="line">        <span class="comment">#         self.wx.SendMsg(msg=part, who=chat_id)</span></span><br><span class="line">        <span class="comment">#         time.sleep(random.randint(2, 4))</span></span><br><span class="line">        <span class="comment"># else:</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># myl修改：不分批次发送，太烦了</span></span><br><span class="line">        reply = reply.replace(<span class="string">&quot;\\&quot;</span>, <span class="string">&quot;,&quot;</span>)</span><br><span class="line">        self.wx.SendMsg(msg=reply, who=chat_id)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 检查回复中是否包含情感关键词并发送表情包</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;\n检查情感关键词...&quot;</span>)</span><br><span class="line">        logger.info(<span class="string">&quot;开始检查AI回复的情感关键词&quot;</span>)</span><br><span class="line">        emotion_detected = <span class="literal">False</span></span><br></pre></td></tr></table></figure></li><li><p>报错重新启动项目，成功</p></li></ul><h2 id="三-AI接入公众号（较小的模型）"><a href="#三-AI接入公众号（较小的模型）" class="headerlink" title="三 AI接入公众号（较小的模型）"></a>三 AI接入公众号（较小的模型）</h2><ul><li>项目地址：<code>https://github.com/NezhaFan/wechat-ai.git</code></li><li>项目语言：纯go（我是纯没用过）</li><li>预期实现效果：用户关注公众号后发起对话可通过大模型返回对话</li></ul><h3 id="3-1-微信公众号"><a href="#3-1-微信公众号" class="headerlink" title="3.1 微信公众号"></a>3.1 微信公众号</h3><ul><li><p>用个人微信创建一个公众号，我是之前有然后好久没用又重新找回了一下，属于个人账号的</p></li><li><p>在公众号管理 - 设置与开发 - 开发接口管理 - 服务器配置里面去开启这个服务器配置</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/202503042244426.png" alt="image-20250304224457300"></p><blockquote><p>我这边是因为已经配置好了，可以看到他需要的是<strong>服务器地址</strong>、<strong>令牌</strong>、<strong>消息加解密密钥</strong>、<strong>消息加密方式</strong></p></blockquote><ul><li><p>服务器地址就是 <strong>3.2</strong> 里面我要去申请的云服务器的IP地址(端口需要是80或者443)：<code>http://服务器IP地址/wx</code></p><blockquote><p>本来打算不申请服务器的，用内网穿刺，把我个人计算机作为服务器，参考<a href="https://blog.csdn.net/MC_chaoji/article/details/135036174，但是我发现这个工具对外暴露的接口是10000~40000，暴露不了微信需要的80、443">https://blog.csdn.net/MC_chaoji/article/details/135036174，但是我发现这个工具对外暴露的接口是10000~40000，暴露不了微信需要的80、443</a></p></blockquote></li><li><p>令牌随便写，等会需要写到项目配置文件里面，两者对应即可</p></li><li><p>消息加解密密钥随机生成</p></li><li><p>加密方式必须是明文模式（项目要求）</p></li></ul></li><li><p>搞到这里，公众号这边算是配置完了，但是先不能启动，因为你的后端服务还没在服务器启动，所以这个时候启动是生效不了的</p></li></ul><h3 id="3-2-服务器资源申请"><a href="#3-2-服务器资源申请" class="headerlink" title="3.2 服务器资源申请"></a>3.2 服务器资源申请</h3><ul><li><p>毫无疑问阿里云，之前申请了域名、对象存储OSS、云服务器，有点点了解，用流量卡注册了一个新号，然后白嫖了一个三个月免费福利 2核2G(卡的要死)的然后注意选windows系统（其实后面看来用linux也不是不行，只是我感觉图形化快一点直观一点）</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/202503042254688.png" alt="image-20250304225413353"></p></li><li><p>然后需要去开一下端口（很重要）：在云服务管理控制台 左侧 - 网络与安全 - 安全组 - 选择刚刚你实例的安全组</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/202503042328021.png" alt="image-20250304232814911"></p></li><li><p>入方向/出方向里面打开你的80端口，我把ipv4、ipv6都打开了</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/202503042329276.png" alt="image-20250304232945233"></p></li><li><p>待会微信接入的就是你的80端口（项目里面配置的，同时也是公众号配置的）</p></li></ul><h3 id="3-3-环境搭建"><a href="#3-3-环境搭建" class="headerlink" title="3.3 环境搭建"></a>3.3 环境搭建</h3><ul><li>安装 <code>Git</code>、<code>go</code>、<code>vscode</code></li></ul><blockquote><p>之前学过java，看得懂一点点，感觉go真简洁</p></blockquote><ul><li><p>这里没啥问题，因为磁盘就40g全在C盘，一路确定（不用该路径太爽了）</p></li><li><p>vscode里面需要再安装一下 <code>Go</code> 插件，然后 F1 输入 <code>Go: Install/Update Tools</code> （咱也不知道是干啥的，安就完事）</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/202503042302971.png" alt="image-20250304230218942"></p></li></ul><h3 id="3-4-第三方AI申请"><a href="#3-4-第三方AI申请" class="headerlink" title="3.4 第三方AI申请"></a>3.4 第三方AI申请</h3><ul><li><p>用的字节那个火山引擎： <a href="https://console.volcengine.com/ark/region:ark+cn-beijing/apiKey">https://console.volcengine.com/ark/region:ark+cn-beijing/apiKey</a> dy扫码注册后生成一个API KEY</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/202503042304309.png" alt="image-20250304230418246"></p></li><li><p>右侧 系统管理 - 开通管理 - 选一个模型（小规模一点）- 开通服务</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/202503042305054.png" alt="image-20250304230523972"></p><blockquote><p>为什么小规模？</p><p>​    规模太大（比如一开始我用的deepseek-R1）模型思考的时间就长，会高于微信公众号那边的最大等待时间导致超时</p></blockquote></li><li><p>接入文档里面（也可以点那个模型）- 新页面里面点击 <a href="https://www.volcengine.com/docs/82379/1298454" title="API调用指南">API调用指南</a>。</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/202503042312556.png" alt="image-20250304231248497"></p><blockquote><p>你需要得到的信息：</p><p>​    URL：POST <a href="https://ark.cn-beijing.volces.com/api/v3/chat/completions">https://ark.cn-beijing.volces.com/api/v3/chat/completions</a> （这个整个平台所有模型应该都是一致的）用于后面的项目url配置</p><p>​    model ID：doubao-1-5-pro-32k-250115</p></blockquote></li><li><p>ok，它上面写的是先使用后付费，我也没充钱，实在不放心可以去右上角 费用 那里去看</p></li></ul><h3 id="3-5-修改项目配置文件部署"><a href="#3-5-修改项目配置文件部署" class="headerlink" title="3.5 修改项目配置文件部署"></a>3.5 修改项目配置文件部署</h3><blockquote><p> 完事具备，只欠东风</p></blockquote><ul><li><p>在服务器上打开项目里面的 <code>config.yaml</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"># 服务端口</span><br><span class="line">port: 80</span><br><span class="line"></span><br><span class="line"># 大模型配置 </span><br><span class="line">llm:</span><br><span class="line">  # 这个是刚刚3.4里面的URL(此处有坑)</span><br><span class="line">  api: https://ark.cn-beijing.volces.com/api/v3 </span><br><span class="line">  # 3.4里面第一步生成的API Key</span><br><span class="line">  key: 888888888888</span><br><span class="line">  # 3.4里面的model ID </span><br><span class="line">  model: doubao-1-5-pro-32k-250115</span><br><span class="line"></span><br><span class="line">  # 人物预设</span><br><span class="line">  prompt: 你是一只可爱的小猫咪，请每句话都带‘喵～’来回复我。</span><br><span class="line">  # 温度 0-2</span><br><span class="line">  temperature: 1.2</span><br><span class="line">  # 单次回复最大token 1-8192, 设置小一点可以减少回复时间</span><br><span class="line">  maxtokens: 300</span><br><span class="line">  # 记忆最近几次对话（一问一答为一次），&lt;=0 表示不记忆</span><br><span class="line">  history: 4</span><br><span class="line"></span><br><span class="line"># 公众号配置 https://mp.weixin.qq.com</span><br><span class="line">wechat:</span><br><span class="line">  # 必填(公众号服务). 与公众号设置保持一致</span><br><span class="line">  token: 这个是3.1里面你填的token</span><br><span class="line">  # 用户关注时主动发送的消息</span><br><span class="line">  subscribeMsg: 你好，我是一只可爱的小猫咪，谢谢关注。</span><br></pre></td></tr></table></figure><blockquote><p> llm.api 为什么不加上 <code>/chat/completions</code> ?</p><p>​    项目全局搜索：<code>LLM.api</code>，发现只有<code>common.go</code>里面使用到了，它在代码里面做了一个拼接，很坑</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">url := strings.TrimSuffix(config.LLM.Api, &quot;/&quot;) + &quot;/chat/completions&quot;</span><br></pre></td></tr></table></figure></blockquote></li><li><p>ok，启动项目，作者在readme里面给的命令是 <code>nohup ./wechat-ai-amd64 &gt;&gt; ./data.log 2&gt;&amp;1 &amp;</code>，这是linux里面的，现在是windows环境</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go run main.go | tee data.log</span><br></pre></td></tr></table></figure><p>我想要在控制台输出日志（用于调式，也方便自己实时观看）的同时还在 项目根目录下的 <code>data.log</code> 里面也输出一样的日志</p></li><li><p>控制台显示就是启动好了</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/202503042325770.png" alt="image-20250304232502737"></p></li><li><p>启动完成后返回到微信公众号那里，点击启用，完成</p><blockquote><p>这个时候微信会通过<code>r.GET(&quot;/wx&quot;, handler.WechatCheck)</code>这个接口来检测能不能通（如果不能转到3.6看第一个测试方法）</p></blockquote></li></ul><h3 id="3-6-测试（含代码修改）"><a href="#3-6-测试（含代码修改）" class="headerlink" title="3.6 测试（含代码修改）"></a>3.6 测试（含代码修改）</h3><blockquote><p>but 我怎么知道我的服务能不能被外面访问到呢，我怎么知道哪个环节出了问题呢</p></blockquote><ul><li><p>首先是不管发送消息，先保证我能访问到这个服务，我在<code>项目根目录/iternal/handler/</code>加了一个<code>ping.go</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> handler</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;net.http&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">PingHandler</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">w.WriteHeader(http.StatusOK)</span><br><span class="line">w.Write([]<span class="type">byte</span>(<span class="string">&quot;Service is running&quot;</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>然后是 <code>main.go</code>里面的<code>func main()</code>加了一个</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">r := bootstrap.New()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 微信消息处理</span></span><br><span class="line">r.POST(<span class="string">&quot;/wx&quot;</span>, handler.ReceiveMsg)</span><br><span class="line"><span class="comment">// 用于公众号自动验证</span></span><br><span class="line">r.GET(<span class="string">&quot;/wx&quot;</span>, handler.WechatCheck)</span><br><span class="line"><span class="comment">// 用于测试 curl &quot;http://127.0.0.1:$PORT/&quot;</span></span><br><span class="line">    <span class="comment">// 这里我也注释掉了，因为报错找不到这个Test</span></span><br><span class="line"><span class="comment">// r.GET(&quot;/&quot;, handler.Test) </span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 添加一个测试接口，用于检查服务是否启动</span></span><br><span class="line">r.GET(<span class="string">&quot;/ping&quot;</span>, handler.PingHandler)</span><br><span class="line"></span><br><span class="line">log.Printf(<span class="string">&quot;启动服务，测试：curl &#x27;http://127.0.0.1:%s?msg=你好&#x27; &quot;</span>, config.Port)</span><br><span class="line"><span class="keyword">if</span> err := http.ListenAndServe(<span class="string">&quot;:&quot;</span>+config.Port, r); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>这时候启动服务后，如果你的服务器地址是 <code>123.123.123.123</code>，浏览器输入 <code>http://120.55.242.43/ping</code> 如果项目成功启动且你的IP是正确的应该会输出Service is running</p></li></ul><blockquote><p>其次是我怎么知道用户发送的消息微信有没有成功转发到我的后端呢</p></blockquote><ul><li><p>在<code>user.go</code>文件中找到 <code>ReceiveMsg</code> 方法</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ReceiveMsg</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">bs, _ := io.ReadAll(r.Body)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印接收到的原始 XML 消息 在这里打印一下，这样用户发送的消息你就可以在控制台看见了(打印的是一个xml格式的文本包含很多信息)</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    &lt;xml&gt;</span></span><br><span class="line"><span class="comment">      &lt;ToUserName&gt;&lt;![CDATA[toUser]]&gt;&lt;/ToUserName&gt;</span></span><br><span class="line"><span class="comment">      &lt;FromUserName&gt;&lt;![CDATA[fromUser]]&gt;&lt;/FromUserName&gt;</span></span><br><span class="line"><span class="comment">      &lt;CreateTime&gt;1348831860&lt;/CreateTime&gt;</span></span><br><span class="line"><span class="comment">      &lt;MsgType&gt;&lt;![CDATA[text]]&gt;&lt;/MsgType&gt;</span></span><br><span class="line"><span class="comment">      &lt;Content&gt;&lt;![CDATA[this is a test]]&gt;&lt;/Content&gt;</span></span><br><span class="line"><span class="comment">      &lt;MsgId&gt;1234567890123456&lt;/MsgId&gt;</span></span><br><span class="line"><span class="comment">      &lt;MsgDataId&gt;xxxx&lt;/MsgDataId&gt;</span></span><br><span class="line"><span class="comment">      &lt;Idx&gt;xxxx&lt;/Idx&gt;</span></span><br><span class="line"><span class="comment">    &lt;/xml&gt;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">log.Printf(<span class="string">&quot;收到消息: %s\n&quot;</span>, <span class="type">string</span>(bs))</span><br><span class="line"></span><br><span class="line">msg := wechat.ParseMsg(bs)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> msg == <span class="literal">nil</span> &#123;</span><br><span class="line">log.Println(<span class="string">&quot;xml格式公众号消息接口，请勿手动调用&quot;</span>)</span><br><span class="line">wechat.EchoSuccess(w)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><blockquote><p>最后就是AI测试了，看你选的模型能不能用，如果选择的是deepseek参数比较大的模型基本上会超时，项目里面设置了会返回到用户：</p><p>​    抱歉，无法在微信限制时间内做出应答</p><p>这条消息，所以如果你的微信端收到了来自公众号的这个消息，排除网络因素大概率是你的模型选的太牛皮了，换一个参数少点的试试</p></blockquote><link rel="stylesheet" href="https://cdn1.tianli0.top/gh/zhheo/Post-Abstract-AI@0.15.2/tianli_gpt.css"><script>let tianliGPT_postSelector = '#post #article-container';let tianliGPT_key = 'c9b7741d290063ab872e';</script><script src="https://cdn1.tianli0.top/gh/zhheo/Post-Abstract-AI@0.15.2/tianli_gpt.js"></script>]]></content>
      
      
      <categories>
          
          <category> study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 杂七杂八点子 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>整理</title>
      <link href="/posts/54082.html"/>
      <url>/posts/54082.html</url>
      
        <content type="html"><![CDATA[<p><a href="https://pdai.tech">https://pdai.tech</a></p><p><a href="https://javaguide.cn">https://javaguide.cn</a></p><p><a href="https://xiaolincoding.com/">https://xiaolincoding.com/</a></p><p><a href="https://www.mianshiya.com/">https://www.mianshiya.com/</a></p><h2 id="一-JavaSE"><a href="#一-JavaSE" class="headerlink" title="一 JavaSE"></a>一 JavaSE</h2><h3 id="1数据类型"><a href="#1数据类型" class="headerlink" title="1数据类型"></a>1数据类型</h3><ul><li>8个基本：boolean(1)、byte(8)、char(16)、short(16)、int(32)、float(32)、long(64)、double(64)</li><li><p>Integer缓存池范围 <code>-128~127</code></p></li><li><p>String的不可变性</p><ul><li>可以缓存hash值</li><li>线程安全（因为不可改变）</li><li><code>StringBuffer</code>是线程安全的，用了<code>synchronized</code>  同步</li></ul></li></ul><h3 id="2-接口"><a href="#2-接口" class="headerlink" title="2 接口"></a>2 接口</h3><ul><li>java8开始可以拥有默认的实现</li></ul><h3 id="3-抽象类"><a href="#3-抽象类" class="headerlink" title="3 抽象类"></a>3 抽象类</h3><ul><li><code>abstract</code>修饰，不能被实例化，包含了抽象方法 </li></ul><h3 id="4-Object类通用方法"><a href="#4-Object类通用方法" class="headerlink" title="4 Object类通用方法"></a>4 <code>Object</code>类通用方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> Class&lt;?&gt; getClass() </span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> <span class="comment">// 返回散列值，判断对象是否等价</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">// 比较地址，一般重写，重写equals的时候一般也会重写hashCode方法，保证相等的对象hash也一样</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object obj)</span> </span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">native</span> Object <span class="title function_">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">notify</span><span class="params">()</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">notifyAll</span><span class="params">()</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">wait</span><span class="params">(<span class="type">long</span> timeout)</span> <span class="keyword">throws</span> InterruptedException</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">wait</span><span class="params">(<span class="type">long</span> timeout, <span class="type">int</span> nanos)</span> <span class="keyword">throws</span> InterruptedException</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">wait</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable &#123;&#125;</span><br></pre></td></tr></table></figure><h3 id="5-static"><a href="#5-static" class="headerlink" title="5 static"></a>5 static</h3><ul><li>初始化顺序：父类静态变量、代码块 ==&gt; 子类… ==&gt; 父类实例变量、代码块 ==&gt; 父类构造函数 ==&gt; 子类… ==&gt; 子类… </li></ul><h3 id="6-反射"><a href="#6-反射" class="headerlink" title="6 反射"></a>6 反射</h3><ul><li><p>相关类</p><ul><li><p><code>Field</code> ：表示类的成员变量，get set方法可以修改</p></li><li><p><code>Method</code> ：表示类的成员方法，<code>invoke()</code> 调用</p></li><li><p><code>Constructor</code> ：表示类的构造方法，新建对象</p></li></ul></li><li><p>class获取方式</p><ul><li><code>类名.class</code></li><li><code>对象.getClass()</code></li><li><code>Class.forName()</code><ul><li>classloader.load 类全限定名</li></ul></li></ul></li></ul><h3 id="7-异常"><a href="#7-异常" class="headerlink" title="7 异常"></a>7 异常</h3><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/image-20240514212224245.png" alt="image-20240514212224245" style="zoom:50%;" /></p><ul><li><code>Error</code>：JVM不可捕获，程序崩溃<ul><li><code>OutOfMemoryError</code>、<code>StackOverflowError</code>…</li></ul></li><li><code>Exception</code>：<ul><li><code>RunTimeException</code></li><li><code>IOException</code></li></ul></li><li>尽量使用标准的异常</li><li>建立异常对象是建立一个普通Object耗时的约20倍，而抛出、接住一个异常对象，所花费时间大约是建立异常对象的4倍。</li></ul><h3 id="8-泛型"><a href="#8-泛型" class="headerlink" title="8 泛型"></a>8 泛型</h3><ul><li><p>泛型数组声明</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;?&gt;[] lists = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;?&gt;[<span class="number">10</span>]; <span class="comment">//OK </span></span><br><span class="line">List&lt;String&gt;[] lists = <span class="keyword">new</span> <span class="title class_">ArrayList</span>[<span class="number">10</span>]; <span class="comment">//OK，但是会有警告</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="9-注解"><a href="#9-注解" class="headerlink" title="9 注解"></a>9 注解</h3><p><a href="https://pdai.tech/md/java/basic/java-basic-x-annotation.html">https://pdai.tech/md/java/basic/java-basic-x-annotation.html</a></p><ul><li><p>java自带的标准注解</p><ul><li><p><code>@Override</code> ：标明重写某个方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.METHOD)</span> <span class="comment">// 注解作用于方法</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.SOURCE)</span> <span class="comment">// 编译时有效</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Override &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>@Deprecated</code>：标明方法过时</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Documented</span> <span class="comment">// 会文档化</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span> <span class="comment">// 运行时有效</span></span><br><span class="line"><span class="meta">@Target(value=&#123;CONSTRUCTOR, FIELD, LOCAL_VARIABLE, METHOD, PACKAGE, PARAMETER, TYPE&#125;)</span></span><br><span class="line"><span class="comment">// 能修饰构造方法，属性，局部变量，方法，包，参数，类型</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Deprecated &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>@SuppressWarnings</code>：标明要忽略的警告</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(&#123;TYPE, FIELD, METHOD, PARAMETER, CONSTRUCTOR, LOCAL_VARIABLE&#125;)</span></span><br><span class="line"><span class="comment">// 类型、属性、方法、参数、构造器、局部变量</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.SOURCE)</span> <span class="comment">// 只能存活在源码时</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> SuppressWarnings &#123;</span><br><span class="line">    String[] value();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>元注解</p><ul><li><code>@Retention</code>：标明注解被保留的阶段<ul><li><code>TYPE</code>、<code>FIELD</code>、<code>METHOD</code>、<code>PARAMETER</code>、<code>CONSTRUCTOR</code>、<code>LOCAL_VARIABLE</code>、<code>ANNOTATION_TYPE</code>、<code>PACKAGE</code>、<code>TYPE_PARAMETER</code>、<code>TYPE_USE</code> </li></ul></li><li><code>@Target</code>：标明注解使用的范围<ul><li><code>SOURCE</code>、<code>CLASS</code>、<code>RUNTIME</code>   </li></ul></li><li><code>@Inherited</code>：标明注解可继承</li><li><code>@Documented</code>：标明是否生成javadoc文档</li></ul></li><li><p>自定义注解</p></li></ul><h3 id="10-SPI机制"><a href="#10-SPI机制" class="headerlink" title="10 SPI机制"></a>10 SPI机制</h3><ul><li><p>整体机制图</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/image-20240514231034618.png" alt="image-20240514231034618" style="zoom:50%;" /></p><ul><li>当服务的提供者提供了一种接口的实现之后，需要在classpath下的<code>META-INF/services/</code>目录里创建一个以服务接口命名的文件，这个文件里的内容就是这个接口的具体的实现类。</li></ul></li><li><p>demo</p><ul><li><p>定义接口与两个实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Search</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">searchDoc</span><span class="params">(String keyword)</span>;   </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileSearch</span> <span class="keyword">implements</span> <span class="title class_">Search</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">searchDoc</span><span class="params">(String keyword)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;文件搜索 &quot;</span> + keyword);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DatabaseSearch</span> <span class="keyword">implements</span> <span class="title class_">Search</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">searchDoc</span><span class="params">(String keyword)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;数据搜索 &quot;</span> + keyword);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>接下来可以在resources下新建META-INF/services/目录，然后新建接口全限定名的文件：<code>com.cainiao.ys.spi.learn.Search</code>，里面加上我们需要用到的实现类</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">com.cainiao.ys.spi.learn.FileSearch</span><br></pre></td></tr></table></figure></li><li><p>测试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestCase</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        ServiceLoader&lt;Search&gt; s = ServiceLoader.load(Search.class);</span><br><span class="line">        Iterator&lt;Search&gt; iterator = s.iterator();</span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">           <span class="type">Search</span> <span class="variable">search</span> <span class="operator">=</span>  iterator.next();</span><br><span class="line">           search.searchDoc(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 最终输出文件搜索</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>SPI机制的广泛应用</p><ul><li>JDBC DriverManager<ul><li>java中定义了<code>java.sql.Driver</code>但是没有实现（由不同的厂商实现）</li><li>mysql的jar包中可以找到<code>META-INF/services</code>目录下有一个<code>java.sql.Driver</code>，文件内容是：<code>com.mysql.cj.jdbc.Driver</code>就是针对Java中定义的接口实现</li></ul></li><li>Spring中的SPI机制<ul><li>自动装配中最终会加载<code>META-INF/spring.factories</code>文件</li></ul></li></ul></li><li><p>SPI机制的一般流程</p><ul><li>定义标准。比如接口<code>java.sql.Driver</code></li><li>具体厂商或框架开发者实现。在<code>META-INF/services</code>目录下定义一个名字为接口全限名的文件，如<code>java.sql.Driver</code>，文件内容是具体的实现名称，比如<code>me.cxis.sql.MyDriver</code>就是对接口的实现</li><li>程序的使用：引用具体厂商jar包来实现功能。</li></ul></li><li><p>缺陷</p><ul><li>不能按需加载，需要遍历所有的实现并实例化</li><li>获取某个实现类的方式不够灵活，只能通过 Iterator 形式获取，不能根据某个参数来获取对应的实现类。</li><li>多个并发线程使用不安全</li></ul></li></ul><h3 id="11-集合框架"><a href="#11-集合框架" class="headerlink" title="11 集合框架"></a>11 集合框架</h3><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/image-20240518130341928.png" alt="image-20240518130341928"></p><ul><li><p><code>Map</code></p><ul><li><p><code>TreeMap</code>：base红黑树</p></li><li><p><code>HashMap</code>：base哈希表,<code>hashCode()</code>和<code>equals()</code>决定了存放的位置</p><ul><li><p>put过程</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/image-20240314172246695.png" alt="image-20240314172246695" style="zoom:67%;" /></p></li><li><p>不考虑内存，1000亿数据要插入到hashmap中，怎么做</p><ul><li>预先申请好hashmap容量，避免频繁的扩容（注意负载因子设置为1，否则750亿左右的时候就扩容了）</li><li>多线程：concurrentHashMap，或者根据hashmap 的哈希函数，预先对数据进行分组，由不同的线程负责不同组，也能避免并发冲突</li></ul></li></ul></li><li><p><code>HashTable</code>：base哈希表，线程安全，但是一般使用<code>ConcurrentHashMap</code> （分段锁）</p></li><li><p><code>LinkedHashSMap</code>：base双向链表，顺序为LRU(最近最少使用)顺序</p></li></ul></li><li><p><code>Collection</code></p><ul><li><p><code>Set</code></p><ul><li><code>TreeSet</code>：base红黑树，有序，查找时间O(logN)</li><li><code>HashSet</code>：base哈希表，无序，查找O(1)</li><li><code>LinkedHashSet</code>：base双向链表，有序，查找O(1)</li></ul></li><li><p><code>Queue</code></p><ul><li><code>LinkedList</code>：双向队列</li><li><code>PriorityQueue</code>：base完全二叉树实现的小顶堆，优先级队列，需要自定义一个 <code>Comparator</code>比较器</li></ul><blockquote><p>完全二叉树：除了最后一层,所有层填满,且叶子节点都在左边</p><p>小顶堆：特殊的完全二叉树,父节点的值小于子节点的值</p><p>移除顶部的过程:</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/image-20240518161346769.png" alt="image-20240518161346769" style="zoom: 50%;" /></p></blockquote></li><li><p><code>List</code></p><ul><li><code>ArrayList</code>：base动态数组，扩容代价大(每次扩容1.5)，最好在创建前指定好容量</li><li><code>Vector</code>：同上，但是线程安全,但是一般用<code>CopyOnWriteArrayList</code></li><li><code>LinkedList</code>：base双向链表，还可以用作栈、队列、双向队列</li></ul></li></ul></li><li><p><code>PriorityQueue</code>的使用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">PriorityQueue&lt;Integer&gt; pq = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;Integer&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Integer e1, Integer e2)</span> &#123;</span><br><span class="line">        <span class="comment">//比较方法</span></span><br><span class="line">        <span class="keyword">return</span> e1 - e2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// or</span></span><br><span class="line"></span><br><span class="line">PriorityQueue&lt;Integer&gt; pq2 = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;((Integer e1, Integer e2) -&gt; &#123;</span><br><span class="line"><span class="keyword">return</span> e1 - e2; <span class="comment">// 升序 1 2 3...</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// or </span></span><br><span class="line">PriorityQueue&lt;Integer&gt; pq3 = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;((a, b) -&gt; a - b);</span><br></pre></td></tr></table></figure></li></ul><h3 id="12-设计模式"><a href="#12-设计模式" class="headerlink" title="12 设计模式"></a>12 设计模式</h3><ul><li><p>创建模式</p><ul><li>工厂模式</li><li>单例模式</li><li>建造者模式：封装一个复杂对象构造过程，并允许按步骤构造。<code>.build()</code>类似</li><li>原型模式</li></ul></li><li><p>结构模式</p><ul><li>适配器模式</li><li>装饰者模式</li><li>代理模式</li><li>门面模式</li><li>桥接模式</li><li>组合模式</li></ul></li><li><p>关系模式</p><ul><li><p>策略模式</p></li><li><p>模板模式</p></li><li><p>观察者模式</p></li><li><p>责任链模式</p></li></ul></li></ul><h3 id="13-设计原则"><a href="#13-设计原则" class="headerlink" title="13 设计原则"></a>13 设计原则</h3><ul><li>单一职责原则</li><li>开放封闭原则： 类，模块，函数等应该是可以扩展的，但是不可以修改</li><li>里式替换原则：所有引用基类(父类)的地方必须能透明的使用其子类的对象</li><li>依赖倒置原则：高层模块(调用端)不应该依赖底层模块，两者都应该依赖于抽象。抽象不应该依赖于细节(实现类),细节应该依赖于抽象。</li><li>迪米特原则：一个软件实体应当少的与其他实体发生相互作用。</li><li>接口隔离原则：一个类对另一个类的依赖应该建立在最小的接口上</li></ul><h2 id="二-JVM"><a href="#二-JVM" class="headerlink" title="二 JVM"></a>二 JVM</h2><h3 id="1-类加载"><a href="#1-类加载" class="headerlink" title="1 类加载"></a>1 类加载</h3><ul><li><p>由JVM将代码生成对应的字节码文件(.class)，有javac编译器、scalac编译器、groovyc编译器、kotlinc编译器，对应不同的编程语言</p><ul><li>.class文件本质上是8位字节为基础的二进制流</li></ul></li><li><p>.class文件的结构</p><ul><li>魔数：头4个字节(cafe babe)，作用就是确定是一个class文件（图片的格式也有对应的魔数）</li><li>常量池：存储变量/方法的属性、类型、名称</li><li>访问标志：表示类的属性和访问类型（接口/类？public？final？）</li><li>类索引、父索引、接口索引：用于确定类的继承关系</li><li>字段表属性：表示变量的属性和访问类型</li><li>方法表属性：表示方法的属性和访问类型</li><li>属性表属性：描述某些场景专有的信息</li></ul></li><li><p>反编译字节码：<code>javap &lt;options&gt; &lt;classes&gt;</code></p></li><li><p>类生命周期</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/image-20240526141058649.png" alt="image-20240526141058649" style="zoom:50%;" /></p><ul><li><p>加载：</p><ul><li>根据类的全限定名来获取定义的二进制字节流</li><li>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构</li><li>在Java堆中生成一个代表这个类的java.lang.Class对象，作为堆方法区数据的访问入口</li></ul></li><li><p>验证：检查文件格式、字节码等</p></li><li><p>准备：在方法区为类的静态变量分配内存，并设置为默认值（0，0L，null，false）</p></li><li><p>解析： 把类中的符号引用转换为直接引用</p></li><li><p>初始化：为类的静态变量赋值</p><blockquote><p> 什么时候初始化类？</p><ul><li>new、访问静态变量/方法、反射、初始化子类，父类也会初始化、启动类</li></ul></blockquote></li><li><p>使用：类访问方法内的数据结构的接口，对象是堆的数据</p></li><li><p>虚拟机结束：执行System.exit()方法、程序结束、程序异常或错误退出、操作系统错误退出程序</p></li></ul></li><li><p>类加载器（从上到下）</p><ul><li>启动类加载器<code>Bootstrap ClassLoader</code>：负责加载JDK\jre\lib下的类</li><li>扩展类加载器<code>Extension ClassLoader</code>：负责加载JDK\jre\lib\ext下的类</li><li>应用程序类加载器<code>Application ClassLoader</code>：负责加载用户类路径(ClassPath)所指定的类</li></ul></li><li><p>类的加载方式</p><ul><li>命令行启动应用的时候JVM加载</li><li><code>Class.forName()</code>：将类加载到JVM中之后还会执行static块</li><li><code>ClassLoader.loadClass()</code>：只加载到JVM中，当newInstance的时候才加载static块</li></ul></li><li><p>类加载机制</p><ul><li>全盘负责、父类委托、缓存机制、<strong>双亲委派</strong></li></ul></li><li><p>双亲委派：</p><ul><li>执行loadClass的时候会优先调用父类的<code>loadClass()</code>方法，然后再调用自己的<code>findClass()</code></li></ul></li><li><p>JVM判断两个对象是否相等的规则：</p><ul><li>类的全类名是否一致</li><li>类的加载器是否一致（保证Java的核心API不会被篡改）</li></ul></li></ul><h3 id="2-内存结构"><a href="#2-内存结构" class="headerlink" title="2 内存结构"></a>2 内存结构</h3><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/image-20240526142905481.png" alt="image-20240526142905481"></p><p>线程私有：程序计数器、虚拟机栈、本地方法区</p><p>线程共享：堆、方法区、堆外内存（java7的永久代或java8的元空间）</p><ul><li><p>程序计数器：用于标注当前线程执行的字节码行号（区别于操作系统的PC寄存器）</p></li><li><p>虚拟机栈：保存局部变量、结果，参与方法的返回和调用</p><ul><li><p>StackOverflowError 、OutOfMemoryError</p></li><li><p>存储单位是栈帧</p></li><li><p>栈帧的内部结构</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/image-20240526143620243.png" alt="image-20240526143620243" style="zoom: 50%;" /></p></li></ul></li><li><p>本地方法区</p><ul><li>本地方法接口</li><li>本地方法栈</li></ul></li><li><p>堆：存储对象实例</p><ul><li>新生代：分为Eden、S1、S2（8:1:1）<ul><li>新生代的GC叫Minor/Young  GC，每次GC从Eden中找幸存者并将他们和S1或者S2的所有对象移到S2或者S1去，并回收S1/S2以及Eden中的剩余对象，多次GC（默认15次）后转移到老年代</li></ul></li><li>老年代<ul><li>Major/Old  GC</li><li>大对象直接进入老年代</li><li>OOM异常</li></ul></li><li>相关JVM参数<ul><li><code>-Xmx</code>：堆起始大小，一般为电脑内存/64</li><li><code>-Xms</code>：堆最大内存，一般为电脑内存/4</li></ul></li></ul></li><li><p>方法区：存储类信息、常量池、静态变量、JIT编译后的代码等数据</p><ul><li>java8之前在堆中(永久代)，java8移到了元空间(本地内存中)</li><li>相关JVM参数<ul><li><code>-XX:PermSize</code>、<code>-xx:MaxPermSize</code>：永久代空间</li><li><code>-XX:MetaspaceSize</code>、<code>-XX:MaxMetaspaceSize</code>：元空间</li><li><code>-XX:+HeapDumpBeforeFullGC</code>、<code>-XX:HeapDumpPath=/httx/logs/dump</code>：OOM的时候自动dump JVM </li></ul></li><li>垃圾回收：常量池中废弃的常量和不再使用的类型</li></ul></li></ul><h3 id="3-java内存模型"><a href="#3-java内存模型" class="headerlink" title="3 java内存模型"></a>3 java内存模型</h3><ul><li><p>负责实现java线程间的通信(JMM)：决定一个线程对共享变量的写入何时对另一个线程可见。是一个抽象的模型</p></li><li><p>重排序：导致内存可见性问题</p><ul><li>编译器优化的重排序：编译器不改变单线程程序语义的前提下做的</li><li>指令级并行的重排序：改变语句对应机器指令的执行顺序</li><li>内存系统的重排序</li></ul></li></ul><h3 id="4-垃圾回收"><a href="#4-垃圾回收" class="headerlink" title="4 垃圾回收"></a>4 垃圾回收</h3><ul><li><p>判断对象是否可被回收</p><ul><li>引用计数算法：计算引用次数，为0就可回收（有循环，所以java不用）</li><li>可达性算法：通过GC Root作为起点进行搜索，不可达的就可回收<ul><li>虚拟机栈中对象、本地方法栈对象、方法区中类静态属性引用的对象、方法区中常量引用的对象、所有被同步锁持有的对象、JNI引用的对象</li></ul></li><li>方法区的回收：主要是常量池和对类的卸载</li></ul></li><li><p>引用类型</p><ul><li><p>强引用：不会被回收</p></li><li><p>软引用：内存不足会被回收</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SoftReference&lt;Object&gt; sf = <span class="keyword">new</span> <span class="title class_">SoftReference</span>&lt;Object&gt;(obj);</span><br></pre></td></tr></table></figure></li><li><p>弱引用：一定会被回收，只能存活到下次垃圾回收前</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">WeakReference&lt;Object&gt; wf = <span class="keyword">new</span> <span class="title class_">WeakReference</span>&lt;Object&gt;(obj);</span><br></pre></td></tr></table></figure></li><li><p>虚引用：为一个对象设置虚引用关联的唯一目的就是能在这个对象被回收时收到一个系统通知。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PhantomReference&lt;Object&gt; pf = <span class="keyword">new</span> <span class="title class_">PhantomReference</span>&lt;Object&gt;(obj);</span><br></pre></td></tr></table></figure></li></ul></li><li><p>垃圾回收算法</p><ul><li>标记-清除</li><li>标记-整理</li><li>复制：（Eden，S1，S2）</li><li>分代收集<ul><li>新生代用复制</li><li>老年代用标记-清除/整理</li></ul></li></ul></li><li><p>垃圾收集器</p><ul><li>Serial 收集器：单线程，GC的时候用户线程停止</li><li>ParNew 收集器：新生代多线程，老年代单线程；，GC的时候用户线程停止</li><li>Parallel Scavenge 收集器：同上，但是其侧重点在于单次的吞吐量（即减少GC的频率）</li><li>Serial Old 收集器：Serial 收集器的老年代版本（不懂）</li><li>Parallel Old 收集器：两个都是多线程，Parallel Scavenge 收集器的老年代版本</li><li>CMS(Concurrent Mark Sweep) 收集器：多线程，GC和用户线程并行<ul><li>初始标记：用户线程暂停，标记GC Root直接关联的对象（很快）</li><li>并发标记：用户线程继续，进行GC Root标记</li><li>重新标记：用户线程暂停，修正并发时间内的变化</li><li>并发清除：用户线程继续</li></ul></li><li>G1 收集器：引入了分区的概念，不再使用新生老年代的划分，将堆区划分为若干等分<ul><li>启发式算法收集高效益的分区</li></ul></li></ul></li><li><p>三色标记法：黑：自身和成员都被标记；灰：自身被标记，成员未被；白：未被标记，最终回收白色的</p><ul><li><p>如何防止在并发标记的时候错删、漏删对象？漏删还好，下次回收即可，错删会引发npe</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/image-20240821180153853.png" style="zoom:33%;" /></p></li><li><p>CMS：写屏障 + 增量更新</p><ul><li>黑色对象建立对白色对象的引用时，把该黑色对象标记为灰色，缺点是会造成重复标记（只记录增加的引用）</li></ul></li><li><p>G1：写屏障 + 原始快照 SATB</p><ul><li>灰色对象断开对白色对象的引用时，把被删除的灰色对象到白色对象的引用记录下来，把白色对象修改为灰色。（只记录删除的引用）</li></ul></li></ul></li></ul><ul><li><p>内存分配和回收策略</p><ul><li>回收策略<ul><li>Minor GC/Young GC：新生代</li><li>Major GC/Old GC：老年代</li><li>Full GC：整个java堆和方法区</li></ul></li><li>内存分配策略<ul><li>优先Eden</li><li>大对象进入老年代</li><li>长期存活进入老年代</li></ul></li><li>Full GC条件<ul><li>调用<code>System.gc()</code>不建议使用</li><li>老年代空间不足</li></ul></li></ul></li></ul><h3 id="5-JVM参数-调优"><a href="#5-JVM参数-调优" class="headerlink" title="5 JVM参数/调优"></a>5 JVM参数/调优</h3><ul><li><p>JVM</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">-Xms -Xmx   <span class="comment"># 堆最小/大值</span></span><br><span class="line">-Xmn    <span class="comment"># 新生代大小,一般为堆的1/4或者1/3</span></span><br><span class="line">-XX:NewRatio    <span class="comment"># 新生代与老年代比值</span></span><br><span class="line">-XX:PermSize  -XX:MaxPermSize  <span class="comment"># 老年代的初始值/最大值</span></span><br><span class="line">-XX:MaxTenuringThreshold    <span class="comment"># 新生代存活次数</span></span><br><span class="line">-XX:SurvivorRatio    <span class="comment"># Eden区与Subrvivor区大小的比值为8就是8:1:1</span></span><br><span class="line">-XX:+HeapDumpBeforeFullGC<span class="comment"># OOM的时候自动dump JVM </span></span><br><span class="line">-XX:HeapDumpPath=/httx/logs/dump    <span class="comment"># dump地址 </span></span><br></pre></td></tr></table></figure></li><li><p>垃圾回收器</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">-XX:+UseSerialGC   <span class="comment"># 串行回收器</span></span><br><span class="line">-XX:+UseParNewGC   <span class="comment"># 新生代使用并行，老年代使用串行</span></span><br><span class="line">-XX:+UseConcMarkSweepGC   <span class="comment"># 新生代使用并行，老年代使用CMS(一般都是使用这种方式)</span></span><br><span class="line">-XX:ParallelGCThreads   <span class="comment"># 指定并行的垃圾回收线程的数量，最好等于CPU数量</span></span><br><span class="line">-XX:+DisableExplicitGC   <span class="comment"># 禁用System.gc()，因为它会触发Full GC，这是很浪费性能的</span></span><br><span class="line">-XX:+PrintGCDetails   <span class="comment"># 开启详细GC日志模式，日志的格式是和所使用的算法有关</span></span><br><span class="line">-XX:+PrintGCDateStamps   <span class="comment"># 将时间和日期也加入到GC日志中</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="6-分析工具"><a href="#6-分析工具" class="headerlink" title="6 分析工具"></a>6 分析工具</h3><ul><li>堆内存溢出OOM<ul><li>添加jvm参数：<code>-XX:+HeapDumpOnOutOfMemoryError</code>：在OutOfMemoryError后获取一份HPROF二进制Heap Dump文件</li></ul></li></ul><h3 id="7-JVM远程调试remote-debug"><a href="#7-JVM远程调试remote-debug" class="headerlink" title="7 JVM远程调试remote debug"></a>7 JVM远程调试remote debug</h3><ul><li><p>前提：远程服务器项目运行且两边代码一致</p></li><li><p>远程服务器启动时附带jvm参数</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-Xdebug -Xrunjdwp:transport=dt_socket,<span class="built_in">suspend</span>=n,server=y,address=<span class="variable">$&#123;debug_port&#125;</span></span><br></pre></td></tr></table></figure></li><li><p>idea打开，设置启动配置，输入远程机器ip和刚刚设置的端口</p><ul><li>打断点，如果断点右上角有√就代表成功了</li></ul></li></ul><h3 id="8-linux-问题排查"><a href="#8-linux-问题排查" class="headerlink" title="8 linux 问题排查"></a>8 linux 问题排查</h3><ul><li>文本<ul><li>文本查找 <code>grep</code></li><li>文本处理 <code>sed</code>（增删改查）</li></ul></li><li>文件<ul><li><code>tail -f filename</code>：循环监听</li><li>查找文件 find</li></ul></li><li>网络进程<ul><li>netstat</li></ul></li></ul><h2 id="三-并发"><a href="#三-并发" class="headerlink" title="三 并发"></a>三 并发</h2><h3 id="1-理论"><a href="#1-理论" class="headerlink" title="1 理论"></a>1 理论</h3><ul><li><p>多线程解决的问题（根本原因速度不同：内存 &gt; CPU &gt; IO设备）</p><ul><li><strong>可见性</strong>：CPU增加了缓存，均衡和内存的速度差异 ==&gt; 同时带来了<strong>可见性</strong>问题：不同线程对变量的修改不会马上被共享</li><li><strong>原子性</strong>：操作系统增加了进程、线程，以分时复用IO，均衡CPU与IO设备的差异 ==&gt; 带来了<strong>原子性</strong>问题：一个操作要么全成功/失败</li><li><strong>有序性</strong>：编译器优化程序指令，使缓存可以更好的利用 ==&gt; 带来了<strong>有序性</strong>问题</li></ul></li><li><p>Java如何解决并发问题：</p><ul><li><p>可见性：<code>volatile</code>关键字修饰的变量被所有线程可见</p></li><li><p>原子性：读取和简单赋值，如果需要更大范围的原子操作可以使用<code>synchronized</code>和<code>Lock</code></p></li><li><p>有序性：<code>volatile</code>禁止了JVM的指令重排，保证了有序性，<code>synchronized</code>和<code>Lock</code>也是</p></li></ul></li><li><p>不可变对象</p><ul><li>final修饰的基本数据类型(如果是对象的话它的成员变量是可以变的)</li><li>String</li><li>枚举</li><li>Number的部分子类,如Long和Double等,BigInteger和BigDecimal 等</li></ul></li></ul><p>​    </p><h3 id="2-线程"><a href="#2-线程" class="headerlink" title="2 线程"></a>2 线程</h3><ul><li><p>线程状态</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/image-20240518171545614.png" alt="image-20240518171545614" style="zoom:50%;" /></p></li><li><p>实现(实现接口更好)</p><ul><li><code>Runnable</code>接口</li><li><code>Callable</code>接口</li><li>继承<code>Thread</code>类：三种方法本质都需要Thread类来启动</li><li>使用线程池</li></ul></li><li><p>线程安全的方法</p><ul><li>互斥同步<ul><li><code>synchronized</code>（JVM级别） 和 <code>ReentrantLock</code>（JDK级别）。</li></ul></li><li>非阻塞同步<ul><li>CAS算法</li></ul></li><li>不涉及共享数据就没有线程安全问题<ul><li><code>ThreadLocal</code> </li></ul></li></ul></li><li><p><code>Executor</code>（看不懂）</p></li><li><p><code>synchronized</code>和<code>ReentrantLock</code></p><ul><li>前者是JVM实现，后者是JDK实现</li><li>两者性能大致相同（因为新版本JVM对<code>synchronized</code>进行了优化，也支持了自旋锁等</li><li>前者不可中断，后者可以</li><li>优先使用前者，因为是JVM原生支持，且不用担心死锁问题，因为JVM会保证锁的释放</li></ul></li><li><p>线程池</p><ul><li>创建<ul><li><code>ThreadPoolExecutor</code>创建（推荐）</li><li>通过<code>Executor</code>框架的工具类 <code>Executors</code> 来创建。</li></ul></li><li>线程池参数：<ul><li>corePoolSize : 任务队列未达到队列容量时，最大可以同时运行的线程数量。</li><li>maximumPoolSize : 任务队列中存放的任务达到队列容量的时候，当前可以同时运行的线程数量变为最大线程数。</li><li>workQueue: 新任务来的时候会先判断当前运行的线程数量是否达到核心线程数，如果达到的话，新任务就会被存放在队列中。</li><li>keepAliveTime：当线程数大于corePoolSize 且没有新的任务提交，多余的空闲线程的等待时间</li><li>unit : keepAliveTime 参数的时间单位。</li><li>threadFactory :executor 创建新线程的时候会用到。</li><li>handler :饱和策略<ul><li><code>ThreadPoolExecutor.AbortPolicy</code>： 抛出 <code>RejectedExecutionException</code>来拒绝新任务的处理。<ul><li>推荐使用，让业务感知异常</li></ul></li><li><code>ThreadPoolExecutor.DiscardPolicy</code>：不处理新任务，直接丢弃掉。</li><li><code>ThreadPoolExecutor.DiscardOldestPolicy</code>： 此策略将丢弃最早的未处理的任务请求。</li><li><code>ThreadPoolExecutor.CallerRunsPolicy</code>：由调用线程处理该任务。如果执行程序已关闭，则会丢弃该任务</li></ul></li></ul></li><li>参数设置原则<ul><li>最佳corePoolSize ，N为CPU的核数<ul><li>如果是IO密集型（CPU计算时间短，而等待IO操作（如读写文件、网络通信等）的时间长）的任务就设置为2N</li><li>文件处理，数据库读写，网络操作等</li><li>如果是CPU密集型（几乎没有IO等待）就设置为N+1</li><li>数值计算、图像视频处理、加密解密、模型训练等</li><li>还可以这样计算：<code>((线程等待时间+线程CPU时间) / 线程CPU时间)* CPU数目</code></li></ul></li></ul></li><li>常用四大线程池<ul><li>newCachedThreadPool——可缓存线程池<ul><li>线程数量无上线，coresize = 0</li></ul></li><li>newFixedThreadPool——指定线程数量<ul><li>不会释放线程</li></ul></li><li>newSingleThreadExecutor——单线程的Executor</li><li>newScheduleThreadPool——定时线程池</li></ul></li></ul></li><li><p>线程池解决了什么问题</p><ul><li>频繁申请/销毁资源和调度资源，将带来额外的消耗</li><li>对资源无限申请缺少抑制手段，易引发系统资源耗尽的风险</li><li>系统无法合理管理内部的资源分布，会降低系统的稳定性</li></ul></li><li>实际使用的问题：参数不好配置<ul><li>最大核心数设置偏小容易导致抛出拒绝异常，触发接口降级</li><li>队列设置过长，大量任务堆积在队列中，任务执行时间长，导致超时</li></ul></li></ul><h3 id="3-锁"><a href="#3-锁" class="headerlink" title="3 锁"></a>3 锁</h3><ul><li><p>Java的锁分类</p><ul><li><p>线程是否锁同步资源</p><ul><li>乐观锁：采用无锁编程实现，CAS算法</li><li>悲观锁：<code>synchronized</code>关键字和<code>Lock</code>的实现类实现<ul><li><code>ReentrantLock</code>、<code>ReadLock</code>、<code>WriteLock</code>（后两者是<code>ReentrantReadWriteLock</code>内部类）</li></ul></li></ul></li><li><p>锁住同步资源失败时，线程要不要阻塞</p><blockquote><p>为什么要非阻塞？阻塞线程要切换CPU的状态，耗时，自旋就是不让线程阻塞（及不放弃CPU的时间片）</p></blockquote><ul><li>阻塞</li><li>非阻塞<ul><li>自旋锁</li><li>适应性自旋锁</li></ul></li></ul></li><li><p>多个线程竞争同步资源的流程细节</p><ul><li>这是针对<code>synchronized</code>的优化，表示锁的四个状态</li><li>无锁</li><li>偏向锁：同一个线程执行同步资源时自动获取资源</li><li>轻量级锁：多个线程竞争时，没获取资源的线程自旋等待所释放</li><li>重量级锁：多个线程竞争时，没获取资源的线程阻塞等待被唤醒</li></ul></li><li><p>多个线程竞争锁时要不要排队</p><ul><li>公平锁</li><li>非公平锁：先尝试插队，失败了再排队</li></ul></li><li><p>一个线程的多个流程能不能获取同一把锁（前提是锁的是同一个对象或者class）</p><ul><li>可重入锁：<code>ReentrantLock</code>(底层是AQS的state变量)和<code>synchronized</code></li><li>不可重入锁</li></ul></li><li><p>多个线程能否共享锁</p><ul><li>共享锁：<code>ReentrantReadWriteLock</code>，本质是里面的两把锁，读锁和写锁</li><li>排他锁：<code>synchronized</code>和JUC中<code>Lock</code>的实现类就是互斥锁。</li></ul></li></ul></li></ul><ul><li><p><code>synchronized</code>原理：依赖于对象的<strong>Markword</strong>。（对象在内存的信息分为三段:对象头(包含了Markword)，实例数据，对齐填充）</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/image-20240821230808058.png" alt="image-20240821230808058" style="zoom:50%;" /></p><ul><li><strong>偏向锁</strong>就是就是将hash值设置为线程id，是否偏向置为1，之后的时间如果这个线程再获取这个锁就不用再加锁了</li><li>如果出现了另一个线程需要找个锁，就会进行<strong>锁膨胀</strong>为<strong>轻量级锁</strong>，自旋等待 </li><li>再膨胀就变为重量级锁，也就是<strong>互斥锁</strong></li></ul></li><li><p>死锁的四大条件</p><ul><li>互斥条件：一个资源每次只能被一个进程使用。</li><li>请求与保持条件：一个进程因请求资源而阻时，对已获得的资源保持不放。</li><li>不剥夺/非抢占条件:进程已获得的资源，在末使用完之前，不能强行剥夺。</li><li>循环等待条件:若干进程之间形成一种头尾相接的循环等待资源关系。</li></ul></li></ul><ul><li><p>死锁的解决</p><ul><li>破坏互斥：让资源可以同时访问（往往行不通）</li><li>破坏非抢占：剥夺式调度算法，但是会导致资源利用率低（不怎么用）</li><li>破坏请求与保持：静态分配策略：在进程执行之前先获取到他需要的所有资源，如果不满足就不开启（会导致资源利用率低，因为部分资源可能在进程后期才会用）</li><li>破坏循环等待：层次分配策略：将资源分层，先释放低层次的资源再获取高层次的资源</li></ul></li></ul><h3 id="4-关键字"><a href="#4-关键字" class="headerlink" title="4 关键字"></a>4 关键字</h3><ul><li><p><code>Synchronized</code></p><ul><li>基于JVM，本质是根据<code>monitorenter</code>和<code>monitorexit</code>指令来控制程序执行</li><li>两个指令是依赖于操作系统的Mutex Lock实现，而Mutex Lock要切换到内核态才能执行，代价昂贵</li></ul></li><li><p><code>volatile</code></p><ul><li><p>作用：防止重排、保证线程之间的可见性、保证原子性(32位系统的long、double的单次读/写)</p><blockquote><p>32位系统一次读/写32位，而long和double是64位的</p></blockquote></li></ul></li><li><p><code>final</code></p><ul><li><p>如果要扩展<code>final</code>关键字修饰的类的功能，怎么做？ <code>final</code>无法继承/实现，所以通过组合</p></li><li><p>关于final的指令重排序（因为final字段必须在构造函数执行完成之前初始化完成）</p><ul><li>对于基本数据类型<ul><li>写：禁止final域写与构造方法重排序(禁止final域写重排序到构造方法之外，保证对象初始化完后，final已经全部初始化)</li><li>读：禁止初次读对象的引用与读该对象包含的final域的重排序。</li></ul></li><li>对于引用数据类型<ul><li>额外增加：禁止在构造函数对一个final修饰的对象的成员域的写入与随后将这个被构造的对象的引用赋值给引用变量 重排序</li></ul></li></ul></li></ul></li></ul><h3 id="5-JUC框架"><a href="#5-JUC框架" class="headerlink" title="5 JUC框架"></a>5 JUC框架</h3><ul><li><p>即java.util.concurrent包</p></li><li><p>主要部分：Lock框架和Tools类、Collections(并发集合)、Atomic(原子类)、Executors(线程池)</p></li><li><p>原子类<code>Atomic</code></p><ul><li>本质是CAS算法(乐观锁)</li><li>如<code>AtomicInteger</code> 有<code>add()</code>方法可以实现不加锁的情况下并发数据的一致性</li><li>还有<code>AtomicBoolean</code>、<code>AtomicLong</code>、<code>AtomicIntegerArray</code>、<code>AtomicLongArray</code>、<code>AtomicReferenceArray</code>等</li><li>如何解决ABA问题？<code>AtomicStampedReference.compareAndSet()</code>方法可以检查</li></ul></li><li><p><code>LockSupport</code>：用来创建锁和其他同步类的基本线程阻塞</p><ul><li><code>park()</code>函数：阻塞线程</li><li><code>unpark()</code>函数：激活线程</li><li><code>Thread.sleep()</code>和<code>LockSupport.park()</code><ul><li>都阻塞当前线程，且都不会释放资源</li><li>前者不能通过外部唤醒，只能自己苏醒；后者可以通过另外一个线程的unpark唤醒</li><li>前者需要抛出InterruptedException中断异常；后者没有</li><li>前者本身是一个native方法；后者底层是调用Unsafe的native方法</li></ul></li></ul></li><li><p>锁的核心类AQS(<code>AbstractQueuedSynchronizer</code>)</p><ul><li>核心思想：如果资源空闲，如果空闲则将请求资源的线程设置为有效的工作线程并锁定资源；如果资源被占用，则将线程加入到CLH队列等待</li><li>AQS定义的资源共享方式：<ul><li>独占：只有一个线程能获取资源，如<code>ReentrantLock</code>，分为公平锁/非公平锁</li><li>共享：多个线程可以同时执行，如<code>Semaphore/CountDownLatch</code>、<code>Semaphore</code>、<code>CountDownLatCh</code>、 <code>CyclicBarrier</code>、<code>ReadWriteLock</code></li></ul></li></ul></li><li><p><code>ReentrantLock</code>：独占锁</p><ul><li>里面有三个内部类<code>Sync extends AQS</code>及其两个子类：<code>NonfairSync</code>、<code>FairSync</code>，分别实现公平/非公平策略</li><li>构造函数默认使用的是<code>NonfairSync</code></li><li>对其操作都转化为了对<code>Sync</code>对象的操作，进而转换为对<code>AQS</code>的操作</li></ul></li><li><p><code>ReentrantReadWriteLock</code>：读写锁(满足多读的场景)</p><ul><li>除了<code>ReentrantLock</code>里面的三个内部类外，还有<code>ReadLock</code>和<code>WriteLock</code>均是<code>Lock</code>的实现</li></ul></li></ul><ul><li><p><code>ConcurrentHashMap</code> </p><ul><li>保存了一个<code>Segment</code>数组，将hash表划分为多段来实现分段锁。每个<code>segment</code>通过<code>ReentrantLock</code></li><li>每个分段里面是数组+链表+红黑树(jdk1.8引进)的方式</li><li>扩容：segment不能扩容(初始默认值是16，也就是16个并发量)，扩容是segment里面的数组扩容</li></ul></li><li><p><code>CopyOnWriteArrayList</code></p><ul><li>属性中有一个<code>ReentrantLock</code>可重入锁，保证线程访问的安全</li><li>写操作的时候，拷贝数组，可能会导致young gc或者full gc</li></ul></li><li><p><code>ConcurrentLinkedQueue</code></p></li><li><p>线程池<code>ThreadPoolExecutor</code></p><ul><li><p>本质是维护一个线程集合和一个阻塞工作队列</p></li><li><p>参数：见 2 线程部分</p></li><li>三种类型<ul><li><code>newFixedThreadPool</code><ul><li>线程池数达到corePoolSize后，即使没有可执行任务也不会释放线程 — <code>maximumPoolSize</code>、<code>keepAliveTime</code>参数无效</li><li>工作队列为无界队列 — 饱和策略参数无效</li></ul></li><li><code>newSingleThreadExecutor</code><ul><li>初始化的线程池只有一个线程，如果该线程异常结束，则会创建一个新的</li><li>工作队列为无界队列 — 饱和策略参数无效</li></ul></li><li><code>newCachedThreadPool</code><ul><li>线程池数量可达到<code>Integer.MAX_VALUE</code>(2147483647)</li><li>正常理解的线程池</li></ul></li></ul></li></ul></li><li><p><code>CountDownLatch</code></p><ul><li>目的是实现不同之间的线程同步</li><li>内部类<code>Sync extends AbstractQueuedSynchronizer</code> </li></ul></li><li><p><code>ThreadLocal</code></p><ul><li><p>线程安全：互斥同步(synchronized 和 ReentrantLock)、非阻塞同步(CAS, AtomicXXXX)、无同步本地存储(ThreadLocal)</p></li><li><p>内部类<code>ThreadLocalMap</code></p><ul><li><p>没有实现Map接口</p></li><li><p>没有public方法</p></li><li><p><code>ThreadLocalMap</code>的<code>Entry</code>实现继承了<code>WeakReference&lt;ThreadLocal&lt;?&gt;&gt;</code></p></li><li><p>该方法仅仅用了一个<code>Entry</code>数组来存储Key, Value; Entry并不是链表形式, 而是每个bucket里面仅仅放一个Entry;</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/image-20240315170346022.png" alt="image-20240315170346022" style="zoom: 25%;" /></p></li></ul></li><li><p>内存泄漏问题：使用线程池的时候可能会出现</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/image-20240315170633122.png" alt="image-20240315170633057" style="zoom: 50%;" /></p><ul><li><code>ThreadLocalMap</code> 中使用的 key 为 <code>ThreadLocal</code> 的弱引用，而 value 是强引用。所以，如果 <code>ThreadLocal</code> 没有被外部强引用的情况下，在垃圾回收的时候，key 会被清理掉，而 value 不会被清理掉。</li><li>如果<code>ThreadLocal</code>没有外部强引用，那么在发生垃圾回收的时候，<code>ThreadLocal</code>就必定会被回收，而<code>ThreadLocal</code>又作为Map中的key，<code>ThreadLocal</code>被回收就会导致一个key为null的entry，外部就无法通过key来访问这个entry，垃圾回收也无法回收，这就造成了内存泄漏</li><li>如何防止：<code>ThreadLocal</code>的<code>remove()</code>方法<ul><li>在get和set的方法中可能会调用这个remove方法</li><li>ThreadLocal虽然提供了避免内存泄露的方法，但是ThreadLocal不会主动去执行这些方法，需要我们在使用完ThreadLocal对象中保存的数据后，在<strong>finally{}代码块中调用ThreadLocal的remove()方法</strong>，加快GC自动垃圾回收，避免内存泄露。</li></ul></li></ul></li></ul></li></ul><h2 id="四-IO"><a href="#四-IO" class="headerlink" title="四 IO"></a>四 IO</h2><h3 id="1-JavaIO类"><a href="#1-JavaIO类" class="headerlink" title="1 JavaIO类"></a>1 JavaIO类</h3><ul><li><p>javaIO从传输方式来说主要分为两大类：字节流(InputStream/OutputStream)和字符流(Reader/Writer)</p></li><li><p>从数据操作来说：</p><ul><li>文件：FileInputStream/OutputStream、FileReader/Writer</li><li>数组：ByteArrayInputStream/OutputStream、CharArrayReader/Writer</li><li>管道：PipedInputStream/OutputStream、PipedReader/Writer</li><li>基本数据类型：DataInputStream/OutputStream、DataReader/Writer</li><li>缓冲操作：BufferInputStream/OutputStream、BufferReader/Writer</li><li>打印：PrintStream/Writer</li><li>对象序列化反序列化：ObjectInputStream/OutputStream</li><li>字节字符流转换：InputStreamReader/OutputStreamWriter</li></ul></li></ul><h3 id="2-JavaIO类设计模式—装饰者"><a href="#2-JavaIO类设计模式—装饰者" class="headerlink" title="2 JavaIO类设计模式—装饰者"></a>2 JavaIO类设计模式—装饰者</h3><ul><li><p>装饰者模式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">CompInterface</span> &#123; <span class="comment">// 顶层</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">action</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Comp1</span> <span class="keyword">implements</span> <span class="title class_">CompInterface</span> &#123; <span class="comment">// 组件1</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">action</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// ...行为1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">CompDecorator</span> <span class="keyword">implements</span> <span class="title class_">CompInterface</span> &#123; <span class="comment">// 顶层抽象装饰器</span></span><br><span class="line">    <span class="keyword">protected</span> CompInterface comp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Decorator1</span> <span class="keyword">extends</span> <span class="title class_">CompDecorator</span> &#123; <span class="comment">// 装饰器1</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Decorator1</span><span class="params">(CompInterface comp)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.comp = comp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">action</span><span class="params">()</span> &#123;</span><br><span class="line">        comp.action();</span><br><span class="line">        <span class="comment">// 自己的动作</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Decorator2</span> <span class="keyword">extends</span> <span class="title class_">CompDecorator</span> &#123; <span class="comment">// 装饰器2</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Decorator2</span><span class="params">(CompInterface comp)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.comp = comp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">action</span><span class="params">()</span> &#123;</span><br><span class="line">        comp.action();</span><br><span class="line">        <span class="comment">// 自己的动作</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">Comp1</span> <span class="variable">comp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Comp1</span>();    <span class="comment">// 声明组件1</span></span><br><span class="line">comp = <span class="keyword">new</span> <span class="title class_">Decorator1</span>(comp); <span class="comment">// 装饰上Decorator1</span></span><br><span class="line">comp = <span class="keyword">new</span> <span class="title class_">Decorator2</span>(comp); <span class="comment">// 装饰上Decorator2</span></span><br><span class="line">comp.action; <span class="comment">// 执行Comp1、Decorator1、Decorator2的action</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/image-20240601151606748.png" alt="image-20240601151606748" style="zoom:50%;" /></p></li><li><p>在IO流相关类的表现：</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/image-20240601151715251.png" alt="image-20240601151715251" style="zoom:50%;" /></p><ul><li><p>FilterInputStream是一个抽象组件，类似于上文的CompDecorator，使用Buffer对FileInputStream进行增加，实现缓冲</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">FileInputStream</span> <span class="variable">fileInputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(filePath);</span><br><span class="line"><span class="type">BufferedInputStream</span> <span class="variable">bufferedInputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedInputStream</span>(fileInputStream);</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="3-IO中常见类的使用"><a href="#3-IO中常见类的使用" class="headerlink" title="3 IO中常见类的使用"></a>3 IO中常见类的使用</h3><ul><li><p>磁盘操作：File</p></li><li><p>字节操作：Input/OutputStream</p></li><li><p>字符操作：Reader/Writer</p></li><li><p>对象操作：</p><ul><li>Serializable(一个空接口，只是一个标准，不实现它就进行序列化会抛异常)</li><li>transient关键字修饰的对象/属性不会被序列化</li></ul></li><li><p>网络操作：</p><ul><li><p>InetAddress：用来表示IP地址</p></li><li><p>URL：统一资源定位符</p></li><li><p>Sockets：使用 TCP 协议实现网络通信</p></li><li><p>Datagram：使用 UDP 协议实现网络通信</p></li></ul></li></ul><h3 id="4-Unix-IO模型"><a href="#4-Unix-IO模型" class="headerlink" title="4 Unix IO模型"></a>4 Unix IO模型</h3><p>一个输入操作通常包括：1. 等待数据准备好  2. 从内核向进程复制数据</p><ul><li>阻塞式I/O：应用进程(不是整个操作系统)被阻塞，直到数据复制到应用进程缓冲区中才返回，执行效率会比较高。</li><li>非阻塞式I/O：应用进程执行系统调用后，内核返回一个错误码，应用进程继续执行，但不断的执行系统调用（轮询polling）来获取IO是否完成。对CPU的利用率较低（因为CPU要不断的处理系统调用）</li><li><p>I/O复用：应用进程使用select或者poll等待数据并阻塞，当一个套接字变为可读时再调用recvfrom复制数据</p><ul><li>单个线程处理多个套接字，即多个IO事件</li></ul></li><li><p>信号驱动I/O：应用进程使用sigaction系统调用，内核立即返回信息，应用进程继续执行，数据准备完毕后内核向应用程序发送SIGIO信号，之后应用进程调用recvfrom获取数据</p></li><li>异步I/O：应用进程使用aio_read系统调用后立即返回，内核准备完数据后向应用进程发送信号</li></ul><blockquote><p>和信号驱动 I/O 的区别在于，异步 I/O 的信号是通知应用进程 I/O 完成，而信号驱动 I/O 的信号是通知应用进程可以开始 I/O。</p></blockquote><ul><li><p>同步IO（前4个）和异步IO区别：同步IO应用进程在调用 recvfrom 操作时会阻塞，</p></li><li><p>4个同步IO的区别主要在于执行recvfrom之前的第一阶段不一样</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/image-20240601222244744.png" alt="image-20240601222244744" style="zoom:50%;" /></p></li><li><p>select/poll/epoll</p><ul><li>select：将socket放到一个文件描述符集合（固定长度1024的 BitsMap）。需要2次遍历文件描述符集合，2次拷贝文件描述符集合</li><li><p>poll：bitsMap变为了链表</p></li><li><p>epoll：</p><ul><li><p>文件描述符使用红黑树O(logn),只在内核维护，减少了很多的遍历和复制</p></li><li><p>使用事件驱动机制，内核维护了一个链表记录就绪事件，当有socket事件发生的时候，通过回调函数内核将其加入到列表中，当用户调用 <code>epoll_wait()</code> 函数时，只会返回有事件发生的文件描述符的个数（<strong>但是还是会拷贝</strong>），不需要像select/poll那样轮询整个socket集合</p></li></ul></li></ul></li></ul><h3 id="5-BIO-NIO-AIO"><a href="#5-BIO-NIO-AIO" class="headerlink" title="5 BIO NIO AIO"></a>5 BIO NIO AIO</h3><ul><li><p>BIO：同步阻塞</p><ul><li>服务器一个连接一个线程</li></ul></li><li><p>NIO：同步非阻塞</p><ul><li><p>特点：非阻塞；面向块传输，普通IO是面向流</p></li><li><p>BIO即阻塞式IO，需要一个服务线程监听一个用户线程，使用多线程技术来实现对不用用户的“异步”，对服务器资源消耗大（线程多了之后CPU切换线程开销大），且利用率不高（阻塞等待的时候客户端不能作别的）。</p></li></ul></li></ul><ul><li><p>Java NIO：和标准IO不同的是，NIO把IO抽象成了块(一个byte[])，一次可以读取多个字节</p></li><li><p>几个要素</p><ul><li>通道<code>Channel</code>：类似于流，但是是双向的。有FileChannel、DatagramChannel、SocketChannel等</li><li>缓冲区<code>Buffer</code>：本质是一个数组，所有数据要先放到buffer中才能传输。有ByteBuffer、CharBuffer、LongBuffer等<ul><li>状态变量：最大容量、当前已读取的字节数、还可以读取的字节数（有点类似于滑动窗口）</li></ul></li><li>选择器<code>Selector</code>：NIO 实现了 IO 多路复用中的 Reactor 模型，一个线程 Thread 使用一个选择器 Selector 通过轮询的方式去监听多个通道 Channel 上的事件，从而让一个线程就可以处理多个事件。</li></ul></li></ul><ul><li>AIO：异步非阻塞</li></ul><h2 id="五-数据库"><a href="#五-数据库" class="headerlink" title="五 数据库"></a>五 数据库</h2><h3 id="1-概述"><a href="#1-概述" class="headerlink" title="1 概述"></a>1 概述</h3><p><a href="https://dsf.berkeley.edu/papers/fntdb07-architecture.pdf">https://dsf.berkeley.edu/papers/fntdb07-architecture.pdf</a></p><ul><li>核心组件<ul><li>进程管理器</li><li>网络管理器</li><li>文件系统管理器</li><li>内存管理器</li><li>安全管理器</li><li>客户端管理器</li></ul></li><li><p>工具</p><ul><li>备份恢复管理器</li><li>查询管理器（解析、重写、优化、执行）</li><li>数据管理器（事务）</li></ul></li><li><p>联接运算符</p><ul><li>合并联接：用于排序的字段比较好</li><li>哈希联接：比较消耗内存，因为要用额外内存存储哈希</li><li>嵌套循环联接（复杂度O(m*n)）：类似于双循环来匹配查询</li></ul><blockquote><p>实际使用的时候采用动态规划、贪心算法、启发式算法来确定用哪些</p></blockquote></li></ul><h3 id="2-关系型数据库—MySQL"><a href="#2-关系型数据库—MySQL" class="headerlink" title="2 关系型数据库—MySQL"></a>2 关系型数据库—MySQL</h3><ul><li><p>为什么需要范式？</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/image-20240602140006102.png" alt="image-20240602140006102" style="zoom:50%;" /></p><ul><li>冗余数据：学生2</li><li>修改异常：修改一个记录中的信息，但是另一个记录的相同信息没有被修改：修改学生2Snam</li><li>删除异常：删除一个信息，会丢失其他信息：删除课程1，学生1也不见了</li><li>插入异常：插入一个学生，但是如果这个学生没选课，就无法插入</li></ul></li><li><p>三大范式</p><ul><li>第一范式：属性不可分</li><li>第二范式：每个非主属性完全函数依赖于键码<ul><li>分解后两个表：Sno-Sname-Sdept-Mname 和 Sno-Cname-Grade</li></ul></li><li>第三范式：非主属性不传递函数依赖于键码（上述关系中Sno -&gt; Sdept -&gt;Mname）<ul><li>分解后变为三个表：Sno-Sname-Sdept、Sdept-Mname、Sno-Cname-Grade</li></ul></li></ul></li><li><p>事务：满足 ACID 特性的一组操作，可以通过Commit提交事务，也可以通过Rollback回滚（通过日志）</p><ul><li>原子性（Atomicity）：所有操作要么全部提交成功，要么全部失败回滚。</li><li>一致性（Consistency）：数据库在事务执行前后都保持一致性状态</li><li>隔离性（Isolation）：一个事务所做的修改在最终提交以前，对其它事务是不可见的。</li><li>持久性（Durability）：一旦事务提交，则其所做的修改将会永远保存到数据库中</li></ul></li><li><p>并发一致性问题：</p><ul><li>修改丢失：两个事务修改数据，后面的事务修改覆盖了前面的事务（貌似不算?）</li><li><strong>脏读</strong>：A修改数据(50-&gt;100)，B读取到新数据后(100)，A回滚数据(50)，此时B读到了脏数据</li><li><strong>不可重复读</strong>：B读取数据(50)，A修改数据(100)，B再读(100)前后不一致</li><li><strong>幻读</strong>：B读取数据(100行)，A插入一行，B再读取(101行)前后不一致</li></ul></li><li><p>隔离级别：</p><ul><li>未提交读(READ UNCOMMITTED)</li><li>提交读(READ COMMITTED)：解决了脏读</li><li>可重复读(REPEATABLE READ)：解决了不可重复读</li><li>可串行化(SERIALIZABLE)：解决了幻读</li></ul></li><li><p>锁</p><ul><li>从粒度上划分：行级锁、表级锁</li><li>类型上划分：读写锁(排它锁/写锁/X锁、共享锁/读锁/S 锁)、意向锁(X/S锁要扫描行耗时，所以搞了IS/IX表锁，即意向锁，要获取X/S锁之前必须先获取IX/IS锁)</li><li>临键锁Next-Key Locks：<ul><li>记录锁Record Locks：锁定一个记录上的索引，如果没有设置索引，InnoDB 会自动在主键上创建隐藏的聚簇索引</li><li>间隙锁Gap Locks：锁定索引之间的间隙，但是不包含索引本身</li><li>Next-Key Locks就是记录锁和间隙锁的结合</li></ul></li></ul></li><li><p>MVCC：多版本并发控制</p><ul><li>是Mysql的InnoDB实现隔离级别的一种方式，实现提交读和可重复读这两种隔离级别。（可串行化需要对所有读取的行都加锁，单纯使用 MVCC 无法实现）</li><li>如何解决幻读：MVCC + 间隙锁(Next-Key Locks)</li><li>版本号：系统版本号（每开始一个新的事务，系统版本号就会自动递增）、事务版本号（创建/删除）</li><li><p>针对可重复读隔离级别的执行：</p><ul><li>Insert：将当前系统版本号作为数据行快照的创建版本号。</li><li>Delete：将当前系统版本号作为数据行快照的删除版本号。</li><li>Update：将当前系统版本号作为更新前的数据行快照的删除版本号，并将当前系统版本号作为更新后的数据行快照的创建版本号。（先delete再update）</li><li>Select：如果是正在修改的事务T在读取就不管。如果是不修改数据的事务B要读取，B读取的数据行快照的创建版本号必须小于 B的版本号，且删除版本号必须大于 B 的版本号</li></ul></li><li><p>MVCC原理</p><ul><li><p><strong>4个隐式字段</strong></p><ul><li>DB_ROW_ID：如果没有主键就会自动创建，并加一个聚餐索引(索引结构和数据一起存放的索引)</li><li>DB_TRX_ID：最近修改/插入的事务ID</li><li>DB_ROLL_PTR：回滚指针，指向这条记录的上一个版本</li><li>DELETED_BIT：记录被更新或删除并不代表真的删除，而是删除flag变了</li></ul></li><li><p><strong>undolog</strong>：只记录insert、update、delete操作</p><ul><li>Insert undo log，至少记录主键，回滚的时候直接删除就行了</li><li>Update undo log，至少要把修改这条记录前的旧值都记录下来</li><li>Delete undo log，至少要把这条记录中的内容都记下来</li></ul></li><li><p><strong>read view</strong>：主要是用来做可见性判断的</p></li></ul></li></ul></li><li><p>Mysql架构：</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/image-20240602145759098.png" alt="image-20240602145759098" style="zoom:67%;" /></p></li><li><p>buffer pool：</p><ul><li><p>默认128MB</p></li><li><p>存储的是数据页，16KB</p></li><li><p>基于冷热数据分离的LRU链表存储</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/202409221442306.png" alt="image-20240922144204022" style="zoom:50%;" /></p></li></ul></li><li><p>存储引擎：MyISAM和InnoDB</p><ul><li>事务：MyISAM不支持事务，后者可以commit和rollback（undo log）</li><li>并发：MyISAM 只支持表级锁，而 InnoDB 还支持行级锁</li><li>崩溃恢复能力：InnoDB依靠redo log</li></ul></li><li><p>日志</p><ul><li>binlog</li><li>undolog：写的是逻辑上的事务，用于事务回滚</li><li>redolog：两阶段提交(保证和binlog的一致性)：先写redolog，再写binlog，最后将redolog设置为commit状态</li></ul></li><li><p>索引——数据结构：</p><ul><li>hash表：快，但是不支持范围查询</li><li>二叉查找树：性能很依赖其平衡性</li><li>AVL树(高度差不超过1)：需要频繁地进行旋转操作来保持平衡，且一个节点只存一个数据，磁盘IO性能开销大</li><li>红黑树：自平衡二叉查找树，平衡性稍弱（不追求完全的平衡）所以有些查询效率较低(多次IO)，但是增删效率高</li><li>B树：所有节点既存放key又存放date</li><li><strong>B+树</strong>：多路平衡查找树，更稳定快速。原因：数据存放在叶子节点，保证了其他节点能够存放更多的索引，大大压缩了树的高度，减少磁盘IO次数；且叶子节点之间用双向链表连接<ul><li>myisam中叶子节点存放的是数据的地址</li><li>innodb中叶子节点存放的是主键+索引列数据</li></ul></li></ul></li><li><p>索引的优缺点</p><ul><li><p>优点：加快搜索；唯一索引可以保证唯一性</p></li><li><p>缺点：创建索引需要时间空间；修改数据需要额外维护索引</p></li></ul></li><li><p>索引——分类</p><ul><li><p>主键索引：加速查询 + 列值唯一（不可以有 NULL）+ 表中只有一个</p><ul><li>除了这个其他的索引都是二级索引，二级索引数据位置存储的是主键</li></ul></li><li><p>普通索引：加速查询</p></li><li><p>唯一索引：加速查询 + 列值唯一（可以有 NULL）</p></li><li><p>覆盖索引：一个索引包含（或者说覆盖）所有需要查询的字段的值</p></li><li><p>联合索引：多列值组成一个索引，专门用于组合搜索，其效率大于索引合并（最左匹配原则）</p><ul><li><p>最左匹配原则：如果建立了(a,b,c)索引，查表的时候需要包含 a 或者 ab 或者abc，顺序无所谓，优化器会自动优化</p><ul><li>如果是(a,c)也会走索引，只不过只会走a索引</li></ul></li><li><p>索引下推：通过联合索引对索引进行过滤，减少回表的次数（ 5.6版本）</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span>  <span class="keyword">from</span> t_user <span class="keyword">where</span> name <span class="keyword">like</span> <span class="string">&#x27;l%&#x27;</span> <span class="keyword">and</span> age <span class="operator">=</span> <span class="number">17</span>; # 索引是(name, age)</span><br><span class="line"><span class="comment">-- 第一步：取name 比如得到 li lisi lisa ll 四个</span></span><br><span class="line"><span class="comment">-- 第二步：在这四个中取 age = 17的 得到li，对应id为123</span></span><br><span class="line"><span class="comment">-- 第三步：回表去找id=123的数据</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 如果没有开启索引下推，会回表4次</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>全文索引：对文本的内容进行分词，一般不会使用，效率较低，通常使用搜索引擎如 ElasticSearch 代替</p></li></ul></li><li><p>Mysql性能优化</p><ul><li>优化数据访问：<ul><li>减少请求数据量：列用select，行用limit，使用缓存</li><li>减少服务端扫描的行数：索引来覆盖查询</li></ul></li><li>重构查询方式：<ul><li>切分大查询，防止锁住很多的数据</li><li>分解大查询，分解为单表查询，在业务逻辑中关联</li></ul></li></ul></li><li><p>Mysql分库分表：垂直/水平</p><ul><li>Sharding策略(水平)：哈希取模、范围切分、映射表</li><li>Sharding策略的问题及解决<ul><li>事务：使用分布式事务解决</li><li>链接：JOIN变为多个单表查询，在业务代码中链接</li><li>ID唯一性：全局唯一ID/每个分片指定ID范围/分布式ID生成器（Snowflake 算法）</li></ul></li></ul></li><li><p>Mysql主从复制和读写分离</p><ul><li>binlog线程：负责将主服务器上的数据更改写入二进制日志中。</li><li>I/O线程：负责从主服务器上读取二进制日志，并写入从服务器的中继日志中。</li><li>SQL线程：负责读取中继日志并重放其中的 SQL 语句。</li></ul></li><li><p>SQL执行过程</p><ul><li>java业务端的数据库连接池：Druid、C3P0、DBCP。数据库也有类似的池子</li><li>查询缓存池</li><li>分析器</li><li>查询优化器：选择查询成本最小的索引<ul><li>IO成本：即从磁盘把数据加载到内存的成本</li><li>CPU成本：与行数有关</li></ul></li><li>执行器：调用存储引擎的接口完成执行</li><li>存储引擎：InnoDB</li></ul></li><li><p>慢查询问题</p><ul><li>定位：开启慢查询：<code>slow_query_log = ON</code>、<code>slow_query_log</code>为时间</li><li>分析：explain命令：<code>EXPLAIN SELECT * FROM t1</code></li><li>优化：<ul><li>不使用子查询</li><li>读取适当的记录，limit M, N</li><li>分组统计禁止排序</li><li>联表放到业务代码</li><li>varchar字段建立索引指定索引长度</li><li>避免索引失效（最左匹配原则）</li><li>左模糊查询匹配不了索引</li><li>回表的性能评估</li></ul></li></ul></li><li><p>索引实验 2838426行数据</p><p>是否使用索引是由查询优化器决定</p></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">-- EXPLAIN SELECT from_date, salary from salaries WHERE salary &gt; 50000; </span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- SELECT salary from salaries WHERE salary &gt; 50000; # &gt; 时间: 1.351s 索引前</span></span><br><span class="line"><span class="comment">-- SELECT from_date, salary from salaries WHERE salary &gt; 50000; # 时间: 1.407s 索引前</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># salary加普通索引</span><br><span class="line"><span class="comment">-- ALTER TABLE `salaries` ADD INDEX (`salary`) # 时间: 9.011s</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> from_date, salary <span class="keyword">from</span> salaries <span class="keyword">WHERE</span> salary <span class="operator">&gt;</span> <span class="number">50000</span>; # 时间: <span class="number">1.082</span>s 索引后</span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> from_date, salary <span class="keyword">from</span> salaries <span class="keyword">WHERE</span> salary <span class="operator">&gt;</span> <span class="number">50000</span>; #  发生了回表:extra列中有<span class="keyword">Using</span> <span class="keyword">where</span> 和 <span class="keyword">Using</span> index</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> salary <span class="keyword">from</span> salaries <span class="keyword">WHERE</span> salary <span class="operator">&gt;</span> <span class="number">50000</span>; # <span class="operator">&gt;</span> 时间: <span class="number">0.993</span>s 索引后</span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> from_date, salary <span class="keyword">from</span> salaries <span class="keyword">WHERE</span> salary <span class="operator">&gt;</span> <span class="number">50000</span>; #  发生了回表:extra列中有<span class="keyword">Using</span> <span class="keyword">where</span> 和 <span class="keyword">Using</span> index</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="operator">-</span> <span class="keyword">Using</span> <span class="keyword">where</span></span><br><span class="line">表示查询需要通过索引回表查询数据。</span><br><span class="line"><span class="operator">-</span> <span class="keyword">Using</span> index</span><br><span class="line">表示查询需要通过索引，索引就可以满足所需数据。</span><br><span class="line"><span class="operator">-</span> <span class="keyword">Using</span> filesort</span><br><span class="line">表示查询出来的结果需要额外排序，数据量小在内存，大的话在磁盘，因此有<span class="keyword">Using</span> filesort建议优化。</span><br><span class="line"><span class="operator">-</span> <span class="keyword">Using</span> temprorary</span><br><span class="line">查询使用到了临时表，一般出现于去重、分组等操作。</span><br></pre></td></tr></table></figure><ul><li>有1000万行的数据，主键是id，查询 <code>select * from table where id = 122</code> 会发生几次IO<ul><li>B+ 树存储，一页是16kb</li><li>主键是int(4字节即可)<code>-2,147,483,648</code> 到 <code>2,147,483,647</code>。一个非叶子节点有4字节的主键 + 6字节的指针</li><li>一页就有1600条数据</li><li>第一层 1600 条、第二层 1600 * 1600 = 256万、第三层就能覆盖</li><li>所以打开是3次IO</li></ul></li></ul><h3 id="3-NoSQL—Redis"><a href="#3-NoSQL—Redis" class="headerlink" title="3 NoSQL—Redis"></a>3 NoSQL—Redis</h3><ul><li><p>redis：Remote Dictionary Server</p></li><li><p>特点：</p><ul><li>读写性能优异</li><li>数据类型丰富</li><li>原子性：redis所有操作都是原子性的，同时支持几个操作全合并后的原子性执行</li><li>持久化：RDB，AOF持久化方式</li><li>发布/订阅模式</li><li>分布式：redis cluster</li></ul></li><li><p>使用场景：</p><ul><li>热点数据缓存</li><li>限时业务</li><li>计数器相关（incrby命令可以实现原子性的递增）</li><li>分布式锁：setnx</li><li>延时操作（一般用mq）</li><li>排行榜（Zset）</li><li>点赞、好友等相互关系的存储（集合命令求交并差集）</li><li>队列</li></ul></li><li><p>redis三种高效缓存读写策略</p><ul><li><p>旁路缓存（常用）</p><ul><li><p>写：先写数据库再删缓存</p></li><li><p>读：先读缓存：未命中再读数据库，随后写入缓存再返回</p></li></ul></li><li><p>读写穿透</p><ul><li><p>写：先读缓存：未命中则更新数据库，命中则更新缓存，利用cache服务同步更新数据库</p></li><li><p>读：先读缓存：未命中再读数据库，随后写入缓存再返回</p></li></ul></li><li><p>异步缓存写入</p><ul><li>写：只更新缓存，异步批量更新数据库</li></ul></li></ul></li><li><p>3.1 数据类型</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/image-20240623194222947.png" alt="image-20240623194222947" style="zoom: 50%;" /></p><ul><li><p>基本数据类型</p><ul><li>String</li><li>List</li><li>Set</li><li>Zset</li><li>Hash</li></ul></li><li><p>特殊数据类型</p><ul><li>HyperLogLogs（基数统计）：用来算两个set中的不重复元素数量(会有一定的误差量)，用于网站的注册IP数，每日IP数等统计</li><li>Bitmap （位存储）：用于统计用户活跃度等（0，1）</li><li>geospatial (地理位置)</li><li><p>redis-stream：redis5.0新增的数据结构，是redis对消息队列的完善</p><ul><li><p>redis实现消息队列</p><ul><li>发布/订阅模式，缺点是无法持久化，如果网络断开、redis宕机消息会丢失</li><li>基于List LPUSH+BRPOP 或者 基于Sorted-Set的实现，缺点是不支持多播、分组广播</li></ul></li><li><p>针对上述不足提出了stream结构</p></li><li><p>key：唯一的索引，首次使用xadd时自动创建</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">XADD：添加消息</span><br><span class="line">XTRIM：修剪消息，限制长度</span><br><span class="line">XDEL：删除消息</span><br><span class="line">XLEN：获取流长度</span><br><span class="line">XRANGE：获取消息列表</span><br><span class="line">XREVRANGE：反向获取，id由大到小</span><br><span class="line">XREAD：以阻塞/非阻塞获取消息列表</span><br></pre></td></tr></table></figure></li></ul></li></ul></li><li><p>操作</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># string</span></span><br><span class="line"><span class="built_in">set</span> counter 2</span><br><span class="line">incr/decr counter <span class="comment"># +/- 1</span></span><br><span class="line">incrby/decrby counter 100 <span class="comment"># 加/减100</span></span><br><span class="line"><span class="comment"># List</span></span><br><span class="line">增:rpush, lpush ,linsert </span><br><span class="line">查:lrange,lindex,llen </span><br><span class="line">删:lpop,rpop,ltrim,ltrim </span><br><span class="line">阻塞操作:blpop,brpop</span><br><span class="line"><span class="comment"># Set</span></span><br><span class="line">增：sadd myset hao hao1 xiaohao hao</span><br><span class="line">删：srem key member1 [member2]</span><br><span class="line">查：smembers myset(返回成员) scard myset(返回数量)</span><br><span class="line"><span class="comment"># Hash</span></span><br><span class="line">增：hset myHash sub-key1 value1</span><br><span class="line">查：hget myHash sub-key1</span><br><span class="line">删：hdel myHash sub-key1</span><br><span class="line"><span class="comment"># Zset</span></span><br><span class="line">增：zadd myscoreset 100 hao 90 xiaohao</span><br><span class="line">查：zscore myscoreset hao <span class="comment"># 100 </span></span><br><span class="line">   zrange myscoreset 0 10 WITHSCORES <span class="comment"># hao xiaohao</span></span><br><span class="line">删：zrem myscoreset hao</span><br><span class="line"><span class="comment"># HyperLogLogs</span></span><br><span class="line">pfadd key1 a b c</span><br><span class="line">pfadd key2 c d e</span><br><span class="line">pfmerge key3 key1 key2 <span class="comment"># 合并key1 key2</span></span><br><span class="line">pfcount key3 <span class="comment"># 5</span></span><br><span class="line"><span class="comment"># Bitmap</span></span><br><span class="line">setbit key sub-key1 0</span><br><span class="line">setbit key sub-key2 1</span><br><span class="line">getbit key sub-key1</span><br><span class="line">bitcount key <span class="comment"># 1</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>3.2 redis底层数据结构</p><ul><li><p>SDS 简单动态字符串：redis是C语言写的，但是其字符串对象不是，是SDS，分为头部、数据和结尾标识\0（C语言是以空字符结尾）</p><blockquote><p>为什么设计SDS？O(1)获取长度；避免内存溢出；空间预分配</p></blockquote><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/image-20240623210112381.png" alt="image-20240623210112381" style="zoom:50%;" /></p><ul><li>特点：字符长度len在头部，O(1)时间就可以获取，也杜绝了缓存区溢出</li></ul></li><li><p>ZipList 压缩列表</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/image-20240623210707073.png" alt="image-20240623210707073" style="zoom:50%;" /></p><p>​    </p><ul><li>从左到右含义：整个ZipList所占内存字节数、最后一个entry的偏移量(以快速完成pop)、entry总量、列表内部数据、终止标识</li><li>为什么ZipList省内存：不同的entry存储空间不同(一般的list是以最大的entry大小为单位存储)，这样一来如何遍历？增加了一个prelen字段记录上一个entry的长度</li><li>缺点：因为每个entry都没有预留空间，所以修改节点导致容量变大时最坏会导致所有entry重新计算内存O(N)</li></ul></li><li><p>QuickList 快表：以ZipList为节点的双端链表</p></li><li><p>HashTable 字典/哈希表</p><ul><li>哈希冲突怎么解决：链地址法</li></ul></li><li><p>IntSet 整数集</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/image-20240623211639543.png" alt="image-20240623211639543" style="zoom:50%;" /></p><ul><li>int16 or int32：优先int16，当插入一个int32时，所有的修改为int32(删除最后一个int32的时候不会变回int16，节省开支)</li></ul></li><li><p>ZSkipList 跳表：只在ZSet中使用，log(N)的增删查</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/image-20240623212155416.png" alt="image-20240623212155416" style="zoom:50%;" /></p><ul><li>缺点是存储空间大</li><li>with 平衡树(AVL、红黑树)：范围查找平衡树复杂，且增删可能会触发自平衡</li><li>with B+树：B+的核心是减少IO过程快速定位到索引，不是redis的关注方式</li></ul></li></ul></li><li><p>3.3 redis持久化</p><ul><li>RDB(Redis DataBase )：快照<ul><li>触发方式：<ul><li>手动触发：<code>save</code>和<code>bgsave</code>，前者会阻塞主进程，后者fork一个子进程</li><li>自动触发：redis.conf中配置<code>save m n</code>，m秒有n次修改会触发；主从复制时会触发；执行debug reload命令重新加载redis时；执行shutdown命令时，如果没有开启AOF持久化会触发</li></ul></li><li>如何保持数据一致性？（进行RDB的时候发送了数据的写）<ul><li>Copy-on-Write，复制一个副本来写</li></ul></li><li>优劣：redis加载RDB速度快，文件体积小；无法做到秒级持久化，每次bgsave都要fork进程开销大，二进制文件难读</li></ul></li><li>AOF<ul><li>写后日志，先写内存后写日志。（mysql就是写前）<ul><li>好处是：避免了额外的检查开销(写进来的日志都是成功执行的)；不会阻塞当前的写操作</li><li>风险是：写完然后还没写日志发生宕机丢失数据；主线程写磁盘压力大，导致写盘慢，阻塞后续操作</li></ul></li><li>实现：<ul><li>命令追加(append)：开启AOF后，将被执行写命令追加到服务器aof_buf缓冲区</li><li>文件写入(write)：分为同步写回、每秒写回、操作系统控制的写回</li><li>和文件同步(sync)</li></ul></li><li>AOF重写：优化一些冗余的AOF操作，减少AOF文件的大小。<ul><li>后台fork一个bgrewriteaof进程来进行，数据是写时复制，fork子进程时会复制父进程的页表(类似于指针)</li><li>什么时候会阻塞主进程：fork子进程拷贝页表；主进程有bigkey写入操作系统会创建页面的副本，并拷贝原有的数据；子进程重写日志完成后，主进程追加aof重写缓冲区时可能会对主线程阻塞</li></ul></li></ul></li><li>AOF和RDB混用：redis4.0推出<ul><li>内存快照以一定的频率执行，在两次快照之间，使用 AOF 日志记录这期间的所有命令操作。</li><li>避免了AOF文件过大</li></ul></li><li>redis启动：<ul><li>判断有无AOF？有则加载AOF启动</li><li>判断有无RDB？有则加载RDB启动</li><li>都没有就直接启动</li></ul></li></ul></li><li><p>3.4 redis事件机制</p><ul><li>文件事件：用于处理 Redis 服务器和客户端之间的网络IO（基于IO多路复用）<ul><li>redis单线程：指的是网络IO和键值对读取是由一个线程完成，但是其他的(持久化、异步删除、集群数据同步等是fork的进程完成)</li><li>文件事件是对套接字操作的抽象，每当一个套接字准备好执行 <code>accept</code>、<code>read</code>、<code>write</code>和 <code>close</code> 等操作时，就会产生一个文件事件</li></ul></li><li>时间事件：redis服务中的一些定时操作<ul><li>定时事件、周期事件</li></ul></li></ul></li><li><p>3.5 redis事务</p><ul><li><p>本质是一组命令的集合</p></li><li><p>使用</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">MULTI：开启事务</span><br><span class="line">EXEC：执行事务</span><br><span class="line">DISCARD：取消事务</span><br><span class="line">WATCH：监视一个或多个key</span><br><span class="line">UNWATCH：取消监视</span><br><span class="line"></span><br><span class="line"><span class="comment"># 例子</span></span><br><span class="line"><span class="built_in">set</span> k1 v1</span><br><span class="line"><span class="built_in">set</span> k2 v2</span><br><span class="line">MULTI</span><br><span class="line"><span class="built_in">set</span> k1 12</span><br><span class="line"><span class="built_in">set</span> k2 24</span><br><span class="line">EXEC</span><br></pre></td></tr></table></figure></li><li><p>lua脚本：Redis可以保证脚本内的命令一次性、按顺序地执行，其同时也不提供事务运行错误的回滚，执行过程中如果部分命令运行错误，剩下的命令还是会继续运行完</p></li></ul></li><li><p>3.6 redis高可用</p><ul><li><p>主从：故障恢复、负载均衡、高可用</p><ul><li>读写分离：主库读写，从库读</li><li>全量同步：主要依靠RDB文件</li><li>增量同步：slave提交自己的offset到master，master获取repl_baklog中从offset之后的命令给slave</li></ul></li><li><p>哨兵机制：监控、自动故障转移、通知</p><ul><li>哨兵如何监控主从集群：哨兵向主库发送info，主库返回所有slave列表，从而可以与从库通信</li><li>哨兵集群：基于redis的 pub/sub 机制来互相获取IP的端口进行通信</li><li>哨兵如何判断主库下线？主观下线(任何一个哨兵判断)、客观下线(哨兵集群判断)</li><li>哨兵集群的选举：raft算法：拿到半数赞成，拿到的赞成票大于配置的quorum 值</li><li>哨兵leader完成主从切换：主库客观下线后，过滤掉不健康的从库，选择优先级最大的，然后向别的从库发送消息新的主库</li></ul></li><li><p>redis cluster：弥补主从和哨兵的不足：写能力和存储能力依赖于主库的问题</p><ul><li><p>哈希槽(Hash Slot)：有16384(即2的14次方）个哈希槽，每个key通过对16384取模后来决定放哪里，cluster每个节点负责一部分hash槽(只有master才可以占据槽)</p><blockquote><p>普通的哈希算法的缺陷：如果节点增加或减少，之前的缓存就失效了需要重新计算存储位置(即重新set)，容易引发雪崩</p><p>一致性哈希算法：普通哈希算法是对服务器数量取模，一致性哈希算法是对 2^32 取模(形成一个哈希环)，对服务器ip或者其他关键字段进行hash后确定其在环上的位置，然后插入新数据的时候计算hash后对2^32 取模得到其在哈希环上的位置，并顺时针找，找到的第一个服务器就是其存储的服务器</p><p>为什么不用一致性哈希算法？增删节点可能会带来雪崩(会对相邻的节点产生影响)、也可能会出现数据倾斜的状况</p><p>为什么是16384？为了发送槽的全量状态，用bitmap发送，16384只需要2k的空间(16384 / 8 / 1024 = 2k)</p></blockquote></li></ul></li><li><p>缓存问题</p><ul><li><p>一致性问题：最佳实践：先写DB再删缓存</p><ul><li><p><a href="https://itwanger.gitee.io/tobebetterjavaer/#/docs/mysql/redis-shuju-yizhixing">https://itwanger.gitee.io/tobebetterjavaer/#/docs/mysql/redis-shuju-yizhixing</a></p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/image-20240311214614711.png" alt="image-20240311214614711" style="zoom:67%;" /></p></li></ul></li><li><p>缓存击穿：缓存失效后大量请求打在DB上（同一个key）</p><ul><li>热点数据不过期；加互斥锁；接口限流；熔断降级</li></ul></li><li><p>缓存穿透：频繁访问一个DB和缓存都不存在的key</p><ul><li>增加入口校验；DB中未取到可以设置到缓存中为null(有效时间短一点)；布隆过滤器</li></ul><blockquote><p>布隆过滤器</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/image-20240629162249949.png" style="zoom:50%;" /></p></blockquote></li><li><p>缓存雪崩：大量数据过期，过多请求打在DB上</p><ul><li>缓存过期时间随机；热点数据部署在不同缓存数据库中；设置热点数据不过期</li></ul></li></ul></li><li><p>缓存淘汰策略：不淘汰、设置过期时间、LRU</p></li></ul></li><li><p>3.7 解决方案——大value、多key合并方案</p><ul><li><p>单key存储的value大</p><ul><li><p>如果是每次都整存整取：可以尝试将对象拆分为几个kv，用multiGet获取值，这样做的意义在于分拆单次操作压力，将操作压力平摊到多个redis实例中，降低对单个redis的IO影响</p></li><li><p>如果是每次只读取部分数据：可以将这个存储在一个hash中，每个field代表一个具体的属性</p></li></ul></li><li><p>hash、set、zset、list存储过多的元素：</p><ul><li>分拆，用取模的方式（比如固定一个桶的数量）确定key，然后将field放在计算出的key中</li></ul></li><li>一个集群存储了上亿的key<ul><li>带来的问题：key占存储空间大；集群模式中服务端需要建立slot2key的映射，这些指针也会占用大量空间</li><li>key如果有很强的关联关系：就可以放在hash中</li><li>key如果没有很强的关联关系：还是放在hash中，但是key是由桶的数量取模来计算得到的</li></ul></li><li>大Bitmap或者布隆过滤器拆分</li></ul></li><li><p>美团squirrel：基于redis</p><ul><li><p>如何保证数据可靠性</p><ul><li>多副本存储策略：同一份数据的多副本存储，保证一个副本宕机的情况下其他副本依旧有全量数据</li><li>多机房部署容灾策略：将多个副本部署在不同的机房中，避免机房掉电以及断网带来的数据丢失</li><li>持久化</li></ul></li><li><p>主从一致：弱一致性，为了保证高性能</p></li></ul></li></ul><h3 id="4-NoSQL—ES"><a href="#4-NoSQL—ES" class="headerlink" title="4 NoSQL—ES"></a>4 NoSQL—ES</h3><ul><li><p>一般语法</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 一般索引查询</span></span><br><span class="line">GET /bank/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;query&quot;</span>: &#123; </span><br><span class="line">    <span class="string">&quot;match_all&quot;</span>: &#123;</span><br><span class="line">    &#125; </span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">&quot;sort&quot;</span>: [</span><br><span class="line">    &#123; </span><br><span class="line">      <span class="string">&quot;account_number&quot;</span>: <span class="string">&quot;asc&quot;</span> </span><br><span class="line">    &#125;</span><br><span class="line">  ],</span><br><span class="line">  <span class="string">&quot;from&quot;</span>: 10, </span><br><span class="line">  <span class="string">&quot;size&quot;</span>: 10</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment"># 特定字段查询：match_all就改为&quot;match&quot;: &#123; &quot;address&quot;: &quot;mill lane&quot; &#125; 意思为address中包含mill或者lane</span></span><br><span class="line"><span class="comment"># &quot;match_phrase&quot;: &#123; &quot;address&quot;: &quot;mill lane&quot; &#125; address包含mill lane</span></span><br><span class="line"><span class="comment"># 条件查询：</span></span><br><span class="line"><span class="string">&quot;query&quot;</span>: &#123;</span><br><span class="line">  <span class="string">&quot;bool&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;must&quot;</span>: [</span><br><span class="line">      &#123; <span class="string">&quot;match&quot;</span>: &#123; <span class="string">&quot;age&quot;</span>: <span class="string">&quot;40&quot;</span> &#125; &#125;</span><br><span class="line">    ],</span><br><span class="line">    <span class="string">&quot;must_not&quot;</span>: [</span><br><span class="line">      &#123; <span class="string">&quot;match&quot;</span>: &#123; <span class="string">&quot;state&quot;</span>: <span class="string">&quot;ID&quot;</span> &#125; &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>聚合查询，类似于mysql的group by</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;size&quot;</span>: 0, <span class="comment"># 返回的文档数为0</span></span><br><span class="line">  <span class="string">&quot;aggs&quot;</span>: &#123; <span class="comment"># 标识聚合查询</span></span><br><span class="line">    <span class="string">&quot;group_by_state&quot;</span>: &#123; <span class="comment"># 自定义名称，用于标识聚合查询的结果</span></span><br><span class="line">      <span class="string">&quot;terms&quot;</span>: &#123; <span class="comment"># 定义了一个聚合</span></span><br><span class="line">        <span class="string">&quot;field&quot;</span>: <span class="string">&quot;state.keyword&quot;</span> <span class="comment"># 根据state进行分组</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">ps: 字符串类型有text和keyword，后者不会分词</span><br></pre></td></tr></table></figure></li><li><p>基本概念</p><ul><li>文档：一条完整的数据，包括索引、名称等，以json方式存储</li><li>字段：文档中的具体字段，类似于表格的列</li><li>索引：就是相同类型的文档的集合，类似于表。eg：用户的索引、商品的索引、订单的索引…</li><li>映射(mapping)：索引中字段的约束信息，类似于表的结构约束。</li></ul></li><li><p>倒排索引</p></li></ul><h2 id="六-计算机网络"><a href="#六-计算机网络" class="headerlink" title="六 计算机网络"></a>六 计算机网络</h2><h3 id="6-1-base"><a href="#6-1-base" class="headerlink" title="6.1 base"></a>6.1 base</h3><ul><li><p>网络模型</p><ul><li>应用层：HTTP、websocket、FTP、Telnet、DNS、SMTP等协议（传输单位是消息或报文message）</li><li>传输层：TCP(面向字节流)、UDP（面向报文，传输单位是段segment）</li><li>网络层：IP(寻址和路由)（传输单位是包packet）</li><li>网络接口层：ARP协议（传输单位是数据帧frame）</li></ul><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/image-20240707162501116.png" alt="image-20240707162501116" style="zoom: 33%;" /></p></li><li><p>从键入网址到网页显示，发生了什么</p><ul><li><p>解析url</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/image-20240707162735960.png" alt="image-20240707162735960" style="zoom: 67%;" /></p></li><li><p>生成http请求信息，<strong>Http报文</strong></p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/image-20240428104302925.png" alt="image-20240428104302925" style="zoom:67%;" /></p></li><li><p>查询服务器域名对应的 IP 地址（DNS）</p></li><li>TCP建立可靠传输，如果Http消息过大会切分数据分块发送，组装好<strong>TCP头部</strong>交给下一层</li><li>根据IP协议，生成<strong>IP头部</strong>组装后交给下一层</li><li>根据ARP协议，获取到两点MAC地址，组装<strong>MAC头部</strong></li><li>通过网卡将包数据转为电信号，通过网线发送</li><li>交换机基于mac地址进行路由发送到路由器（之后mac头部就没用了，就会被丢弃）</li><li>路由器基于ip发送转发内容</li><li>数据包抵达服务端进行数据处理，并发送响应数据，完成数据传输</li></ul></li></ul><h3 id="6-2-Http"><a href="#6-2-Http" class="headerlink" title="6.2 Http"></a>6.2 Http</h3><ul><li>为什么不直接使用TCP呢？为了防止<strong>粘包</strong>：区分出不同批次的数据包，by header</li><li>超文本传输协议，<strong>H</strong>yper<strong>T</strong>ext <strong>T</strong>ransfer <strong>P</strong>rotocol</li><li>状态码<ul><li>1xx</li><li>2xx：成功 200</li><li>3xx：重定向，需要客户端重新发送请求</li><li>4xx：客户端错误，请求报文有误  400请求报文有误；403服务端禁止访问资源；404请求资源在服务端找不到</li><li>5xx：服务端错误 500服务端错误；501请求的功能尚未开放；502通常是网关或者代理时返回；503服务器忙无法处理</li></ul></li><li>http字段<ul><li>Host字段：客户端发送请求的时候，用于表示服务端域名</li><li>Content-Length：服务端返回响应的时候，用于表明数据长度</li><li>Connection：通常用于表示是长连接(<code>Connection: Keep-Alive</code>)<ul><li>http/1.1默认长连接，这个字段是为了兼容老版本http</li></ul></li><li>Content-Type：用于告诉客户端，本次数据的格式</li><li>Content-Encoding：用于说明数据的压缩方式</li><li>Accept-Encoding：用于客户端表示自己可以接收的压缩方式</li></ul></li><li>版本发展<ul><li>Http/1.0：无状态</li><li>Http/1.1：长连接；body压缩</li><li>Http/2.0：多路复用；二进制帧；header压缩；服务器推送（客户端请求1个资源的时候服务端一起发送其他的）</li><li>Http/3.0：对udp进行改进，引入quic协议，无需建立连接；</li></ul></li><li>Http和Https：HTTPS 协议需要向 CA（证书权威机构）申请数字证书<ul><li>对称加密和非对称加密结合的「混合加密」</li><li>Https默认端口是443，http是80</li><li>多了一个TLS握手的过程。目的是为了通过非对称加密握手协商或者交换出对称加密密钥</li></ul></li><li><p>如何优化https</p><ul><li>硬件方面：是计算密集型任务，所以增强CPU，加速TLS过程</li><li>软件方面：协议优化升级，linux内核升级</li><li>协议方面：优化密钥交换算法</li><li>证书优化：</li></ul></li><li><p>为什么有了HTTP还有websocket</p><ul><li>为了解决服务器向客户端主动推送数据的需求(也可能通过客户端轮询http请求实现)</li><li>基于TCP全双工的特性，设计出来的一种新协议，即websocket</li><li>为了兼容http使用场景，三次握手建立连接后，如果是普通的http请求则维持原状，反之则在http请求头中增强特殊的header，开始进行websocket握手连接，此后就是websocket了。</li></ul></li></ul><h3 id="6-3-TCP"><a href="#6-3-TCP" class="headerlink" title="6.3 TCP"></a>6.3 TCP</h3><ul><li><p>抓包工具：Wireshark    </p></li><li><p>特点：面向连接、可靠、基于字节流。</p></li><li><p>结构</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/image-20240423172112523.png" alt="image-20240423172112523" style="zoom:67%;" /></p><ul><li>序号（sequence number）：标识本报文段所发送数据的第一个字节的序号</li><li>确认序列（acknowledgement number）：期望收到对方下一个报文段的第一个数据字节序号，只有ACK为1的时候才生效</li><li>数据偏移：TCP报文段数据起始举例TCP报文段起始有多远</li><li>6个控制位<ul><li>URG：紧急位，=1时可以插队</li><li>ACK：确认位，连接后置为1</li><li>PSH：推送位，=1时，接收方尽快交付接收应用进程，不再等到缓存填满再向上交付</li><li>RST：复位，=1时，表明TCP连接中出现严重差错，必须释放连接再重新建立连接 </li><li>SYN：同步位，=1时表明是一个连接请求/连接接收报文</li><li>FIN：终止位，=1时候表明此报文发送方数据已发送完，要求释放连接</li></ul></li><li>窗口：发送方发送窗口的大小，用来给接收方来调整接收窗口大小</li></ul></li><li><p>TCP校验和的过程：由发送端计算，然后由接收端验证。其目的是为了发现TCP首部和数据在发送端到接收端之间发生的任何改动</p><ul><li><p>覆盖TCP首部和TCP数据</p></li><li><p>伪首部：都是从IP数据报头获取的，12字节，包含源IP地址、目的IP地址、保留字节(置0)、传输层协议号(TCP是6)、TCP报文长度(报头+数据)。</p></li><li><p>计算过程：</p><ul><li><p>把伪首部、TCP报头、TCP数据划分为16位的一个个16进制数</p></li><li><p>将这些数逐个相加，记得溢出的部分加到最低位上</p></li><li><p>最后将得到的结果取反，则可以得到检验和位</p></li></ul></li></ul></li><li><p>三次握手</p><ul><li>客户端发送连接请求报文段，无应用层数据<ul><li>SYN=1，seq=x，seq是序号</li></ul></li><li>服务端为改TCP连接分配缓存和变量，并给客户端返回确认报文，无应用层数据<ul><li>SYN=1，ACK=1，seq=y，ack=x+1，ack是确认序列</li></ul></li><li>客户端为该TCP连接分配缓存和变量，并给客户端发送确认，可以携带数据<ul><li>SYN=0，ACK=1，seq=x+1,ack=y+1</li></ul></li></ul></li><li><p>四次挥手</p><p>·1  <img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/image-20240809224708031.png" alt="image-20240809224708031" style="zoom:33%;" /></p><ul><li>主动方发送连接释放报文段。进入状态FIN_WAIT_1<ul><li>FIN=1，seq=u</li></ul></li><li>被动方回送一个确认报文段。进入CLOSED_WAIT状态，主动方接收后进入FIN_WAIT_2<ul><li>ACK=1，seq=v，ack=u+1</li></ul></li><li>被动方发送完数据，发出连接释放报文段。进入LAST_ACK状态。<ul><li>FIN=1，ACK=1，seq=w，ack=u+1</li></ul></li><li>主动方回送一个确认报文段。进入TIME_WAIT状态。再等待时间计时器设置的2MSL（最长报文段寿命）后进入CLOSE。<ul><li>ACK=1，seq=u+1，ack=w+1</li></ul></li></ul></li></ul><blockquote><p>为什么需要四次挥手？</p><ul><li>TCP的半关闭造成的</li></ul><p>为什么中间的ACK和FIN不可以像三次握手那样合为一个报文段呢？</p><ul><li>socket网络编程中，执行close()方法会触发内核发送FIN报文（用户态调用的close()）,但是如果被动关闭方还有数据要处理，会等数据处理完毕后再调用close()，而ACK报文是系统内核完成，过程很快，所以ACK和FIN不能和为一个包</li></ul><p>为什么TIME_WAIT是2MSL？</p><ul><li>保证最后的ACK可以送达到被动关闭方，能够正常关闭</li></ul></blockquote><ul><li><p>可靠传输：</p><ul><li>校验：与UDP一样，增加伪首部</li><li>序号：一个报文段第一个字节的序号</li><li>确认：累计确认机制</li><li>重传：超时重传</li></ul></li><li><p>重传机制：</p><ul><li><p>超时重传：超时未收到指定的ACK报文就再发送，略大于RTT(一个往返时间)</p></li><li><p>快速重传：服务A发送seq1~6给服务B，但是seq2丢失，服务A只会收到ACK2，然后就再发送seq2</p><blockquote><p>A只知道seq2未送达，所以发seq2，是否需要一起发送seq3~6？引入SACK</p></blockquote></li><li><p>SACK：双方开启，在TCP头部加入SACK，可以将已接收的信息发送到发送方，避免少发或者多发</p></li><li><p>D-SACK(Duplicate )：</p></li></ul></li><li><p>滑动窗口：</p><ul><li>已发送且收到ACK确认</li><li>已发送但未收到ACK确认</li><li>未发送但大小在接收方处理范围</li><li>未发送但总大小超过接收方处理范围</li></ul></li><li><p>流量控制：控制接收方窗口，为了防止接收方爆炸</p><ul><li>通过设置报文段中的窗口字段来实现动态控制</li><li>零窗口问题：发送方收到了接收方的零窗口通知，启动计时器，一段时间后再询问接收方窗口大小(防止接收方窗口变更消息丢失而引发的死锁)</li><li>小窗口问题(糊涂窗口综合症)：由于接收方处理数据能力，导致缓冲区的大小越来越小(20,10,5,4,2,1…)，进而发送方可发送的数据量也越来越小，最终造成流量的浪费。解决：设置最小窗口阈值</li></ul></li><li><p>拥塞控制：控制发送方窗口cwnd，为了防止网络环境爆炸</p><ul><li><p>慢启动：建立连接后，先发送1个单位，接收ack应答后再发送2个单位，接收后再发送4个单位，直到达到慢启动门限，一般是2^16：65535字节</p></li><li><p>拥塞避免：达到慢启动门限后，指数增长变成线性（收到一个ack增加一个字节）</p></li><li><p>超时重传：cwdn变为1，再重新慢启动</p></li><li><p>快恢复</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/image-20240714112452253.png" alt="image-20240714112452253" style="zoom:50%;" /></p></li></ul></li><li><p>TCP的半连接队列(SYN队列)和全连接队列(accept 队列)</p><ul><li><p>建立握手前，服务端接收到客户端请求后，内核会将连接存储在半连接队列中，并发送SYN+ACK</p></li><li><p>接收到客户端的第三次握手后，内核会移除SYN队列，创建完全的连接，加入到accept队列中</p></li><li><p>半连接队列满之后，就无法接收新的TCP连接了（SYN洪泛攻击就是利用这个特性）</p><blockquote><p>SYN洪泛攻击如何解决？</p><p>利用SYN cookie：不保存半连接队列，生成一个序列(cookie)发送给请求连接方，cookie为由源IP、目的IP、源端口、目的端口以及一个服务器密钥组合后生成的hash，请求方第三次的握手需要携带这个序列，然后再由服务端来解析判断是不是同一组请求，如果第三次握手没有携带这个序列，则被判断为是攻击者，不做任何处理，也就避免了半连接队列爆</p></blockquote></li></ul></li><li><p>如何优化TCP连接？</p><ul><li><p>三次握手的优化</p><ul><li>客户端：SYN重传次数</li><li>服务端：SYN半连接队列、accept 全连接队列长度、ACK+SYN的重传次数</li></ul></li><li><p>四次挥手的优化</p><ul><li>主动方：FIN报文重传次数、FIN_WAIT_2状态时间、TIME_WAIT状态上限</li><li>被动方：</li></ul></li><li><p>数据传输的优化：主要是针对滑动窗口</p><ul><li>扩大窗口大小：连接的缓存区（滑动窗口）根据网络传输能力设置</li><li>调整发送方缓存区范围</li><li>调整接收方缓存区范围</li><li>打开缓存区动态调节</li><li>调整内存范围</li></ul></li></ul></li><li><p>怎么理解TCP是面向字节流的传输？（UDP是面向报文）</p><ul><li>一次消息通过多次发送——粘包问题</li><li>解决粘包：固定长度、特殊字符(HTTP)、自定义消息结构体</li></ul></li><li><p>为什么TCP每次建立连接的时候，初始化序列号不一样？</p><ul><li>防止历史报文被错误接收。四次挥手的时候不是有一个2MSL的时长吗？（如果没有正常的断开，有错误的可能）</li><li>随机生成的序列号会冲突吗？是基于时钟计时器递增的，基本不会出现</li></ul></li><li><p>syn包什么时候会被丢弃</p><ul><li>TCP两个队列满了（半连接SYN队列和全连接accpet队列），造成SYN报文丢弃</li></ul></li><li><p>已建立连接的TCP，客户端突然掉线了，服务端不知道，客户端再上线的时候发起SYN握手，服务器怎么做？</p><ul><li>客户端的 IP、服务端 IP、目的端口都没变，关键看源端口和上次是否一致？<ul><li>一致：但是大概率与服务端的期望SYN不一致，服务端会返回期望的ACK报文，客户端收到后发现也不是期望的报文，于是回RST报文，释放连接</li><li>不一致：相当于建立一个新的连接。原来的连接由客户端内核返回一个RST报文，兜底是服务端检测客户端没有活动，释放连接</li></ul></li></ul></li><li><p>四次挥手的时候如果FIN报文比ACK先到达主动方会发生什么（第三次比第二次快到）</p><ul><li>在FIN_WAIT_2状态的时候收到了乱序的FIN报文，会被加入到乱序队列中，并不会加入到TIME_WAIT状态，等再次收到数据包的时候（第二次挥手的包），会从乱序队列中找对应的乱序的FIN报文（有FIN标志），则进入TIME_WAIT状态</li></ul></li><li><p>拔掉网线后，之前的TCP连接还在吗</p><ul><li>拔掉网线后，有数据传输：如果在超时重传阈值之前恢复，则没有影响，反之服务端会断开连接，客户端再次发送的时候，服务端内核就会恢复RST报文</li><li>拔掉网线后没有数据传输：没有开启TCP保活机制，则会一直存在，开启的话会探活，超出次数则断开</li></ul></li><li><p>HTTPS中TCP和TLS顺序？</p><ul><li>先TCP三次握手再TLS</li></ul></li><li><p>TCP协议的缺点</p><ul><li>升级困难，因为是在内核中的，应用程序无法升级</li><li>TCP建立连接延迟：三次握手</li><li>TCP存在队头阻塞的情况：如果seq1~5中seq2丢失，内核是无法处理seq3~5的</li><li>网络迁移需要重新建立TCP连接：四元组发生了变化（源 IP、源端口、目的 IP、目的端口）</li></ul></li><li><p>如何基于UDP实现可靠传输？<strong>QUIC</strong>协议</p></li><li><p>UDP和TCP可以使用同样的端口吗？可以，因为在内核中是两个完全独立的软件模块。</p></li><li><p>半包：发送方发送的数据过大，超过了缓冲区，导致数据接收不完整的问题</p></li><li>粘包：拆包后进行合并，由于信息不完整导致的信息错乱问题</li></ul><h3 id="6-4-IP"><a href="#6-4-IP" class="headerlink" title="6.4 IP"></a>6.4 IP</h3><ul><li><p>类型</p><ul><li>A类：      0 +   7位网络号 + 24位主机号</li><li>B类：    10 + 14位网络号 + 16位主机号</li><li>C类：  110 + 21位网络号 +   8位主机号</li><li>D类：1110 + 28位组播地址，多用于多播</li><li>E类： 1111 + 预留后用</li></ul></li><li><p>主机号全为0指某个网络，全为1指定某个网络下的所有主机，用于广播</p></li><li><p>优点：简单明了、选路（基于网络地址）简单（因为可以通过前3位快速判断是ABC类）</p></li><li><p>缺点：</p><ul><li>同一网络下没有地址层次</li><li>ABC不能很好的与现实匹配，C类地址的主机只有254，B类却有65534</li></ul></li><li><p>无分类地址CIDR：表示形式 <code>a.b.c.d/x</code>，前x位为网络号</p></li><li><p>子网划分：将主机号部分再分为子网网络号 + 子网主机号</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/image-20240715221921171.png" alt="image-20240715221921171" style="zoom:50%;" /> </p></li><li><p>IPv6：128位，每16位作为一组 </p></li><li><p>NAT技术：IP地址有32位，最多只能 2 ^ 32 = 4294967296 台设备加入互联网，为了解决地址不足的问题，引入NAT</p></li><li><p>IP协议的相关技术</p><ul><li><p>DNS 域名解析：越往右层级越高</p><ul><li>查缓存 ==&gt; 查操作系统本机域名解析文件 <code>hosts</code> ==&gt; 进行DNS域名查询</li></ul></li><li><p>ARP 与 RARP 协议：查询IP地址的下一跳对应的MAC地址，RARP相反</p><ul><li>主机广播发送ARP请求 ==&gt; 同一链路的所有设备查询如果有就返回ARP响应</li></ul></li><li><p>DHCP 动态获取 IP 地址</p><ul><li>DHCP 客户端进程监听的是 68 端口号，DHCP 服务端进程监听的是 67 端口号</li><li>客户端发起<strong>DHCP发现报文</strong>，但是此时客户端没有IP地址，也不知道DHCP服务器IP地址，就通过广播发送UDP</li><li>服务端收到后发送<strong>DHCP 提供报文</strong>，也是广播发送：提供可租约的 IP 地址、子网掩码、默认网关、DNS 服务器以及 IP 地址租用期。</li><li>客户端收到一个或多个报文后，选择一个服务端，发送<strong>DHCP 请求报文</strong></li><li>服务端 DHCP ACK 报文对 DHCP 请求报文进行响应，应答所要求的参数</li></ul></li><li><p>NAT 网络地址转换：IP 地址 + 端口号一起进行转换</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/image-20240715223854138.png" alt="image-20240715223854138" style="zoom:50%;" /></p><ul><li>缺点：<ul><li>外部无法主动与NAT内部服务建立连接，因为没有转换记录</li><li>转换地址的性能开销</li><li>依赖于转换表，如果NAT路由器重启了，所有TCP连接都将会重置</li></ul></li><li>如何解决？<ul><li>Ipv6</li><li>NAT穿透技术</li></ul></li></ul></li><li><p>ICMP 互联网控制报文协议：确认 IP 包是否成功送达目标地址、报告发送过程中 IP 包被废弃的原因和改善网络设置等。</p><ul><li>查询报文（诊断）和差错报文（通知出错原因）</li><li>常见差错报文类型<ul><li>目标不可达消息 —— 类型 为 <code>3</code></li><li>原点抑制消息 —— 类型 <code>4</code></li><li>重定向消息 —— 类型 <code>5</code></li><li>超时消息 —— 类型 <code>11</code></li></ul></li></ul></li><li><p>IGMP 因特网组管理协议：管理D类地址，组播</p></li></ul></li><li><p>Ping的原理：基于ICMP协议进行</p></li><li><p>断网了还能ping 127.0.0.1吗？可以</p></li><li><p>localhost 和 127.0.0.1</p><ul><li>本质上localhost 是域名，是在本机中的hosts文件中定义的指向127.0.0.1</li></ul></li></ul><h2 id="七-操作系统"><a href="#七-操作系统" class="headerlink" title="七 操作系统"></a>七 操作系统</h2><h3 id="7-1-硬件结构"><a href="#7-1-硬件结构" class="headerlink" title="7.1 硬件结构"></a>7.1 硬件结构</h3><ul><li><p>内存；CPU；总线；输入、输出设备</p></li><li><p>存储器的结构：寄存器、CPU Cache(L1,L2,L3)、内存、SSD/HDD 硬盘</p><ul><li>L1 L2是各核心独有的</li></ul></li><li><p>多核心CPU的缓存一致性(L1 L2)</p><ul><li>通过写传播和事务的串行化</li></ul></li><li><p>总线嗅探：写传播的实现，通过广播来告诉其他核心数据变化</p></li><li><p>MESI协议</p><ul><li><em>Modified</em>，已修改</li><li><em>Exclusive</em>，独占</li><li><em>Shared</em>，共享</li><li><em>Invalidated</em>，已失效</li></ul></li><li><p>CPU如何执行任务的</p><ul><li>如何读写数据：CPU三级缓存<ul><li>伪共享问题：CPU从内存中读取数据是Cache Line 为单位(一组数据)，如果两个核AB读取了空间上连续的变量ab，分别只修改了a、b，但是会造成数据的不一致问题</li><li>如何避免：多个线程共享的热点数据，避免这些数据在同一个Cache Line中</li></ul></li><li>如何选择线程：linux内核中，线程和进程都是 <code>task_struct</code> 结构体<ul><li>调度算法</li></ul></li></ul></li><li><p><code>0.1 + 0.2 == 0.3?</code></p><ul><li><p>负数的二进制：1(符号位，正数是0) +( 正数部分的补码+1)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-1 : 1 1111111 11111111 11111111</span><br><span class="line">1  : 0 0000000 00000000 00000001 (int类型)</span><br><span class="line">补码: 1 1111111 11111111 11111110</span><br><span class="line">再+1: 1 1111111 11111111 11111111</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="7-2-操作系统结构"><a href="#7-2-操作系统结构" class="headerlink" title="7.2 操作系统结构"></a>7.2 操作系统结构</h3><ul><li>内核的能力<ul><li>管理进程、线程，决定哪个进程、线程使用 CPU，也就是进程调度的能力；</li><li>管理内存，决定内存的分配和回收，也就是内存管理的能力；</li><li>管理硬件设备，为进程与硬件设备之间提供通信能力，也就是硬件通信能力；</li><li>提供系统调用，如果应用程序要运行更高权限运行的服务，那么就需要有系统调用，它是用户程序与操作系统之间的接口。</li></ul></li></ul><h3 id="7-3-内存管理"><a href="#7-3-内存管理" class="headerlink" title="7.3 内存管理"></a>7.3 内存管理</h3><ul><li><p>虚拟内存：为了让不同的进程同时运行而互不干涉，操作系统提供一种映射，将不同进程的虚拟地址和物理地址映射</p><ul><li>如果没有虚拟内存，同一个代码多线程运行的时候就会产生物理地址冲突</li><li>虚拟内存可以使得<strong>进程对运行内存超过物理内存大小</strong>，因为程序运行符合局部性原理，CPU 访问内存会有很明显的重复访问的倾向性，对于那些没有被经常使用到的内存，我们可以把它换出到物理内存之外，比如硬盘上的 swap 区域。</li><li>由于每个进程都有自己的页表，所以每个进程的虚拟内存空间就是相互独立的。进程也没有办法访问其他进程的页表，所以这些页表是私有的，这就<strong>解决了多进程之间地址冲突的问题</strong>。</li><li>页表里的页表项中除了物理地址之外，还有一些标记属性的比特，比如控制一个页的读写权限，标记该页是否存在等。在内存访问方面，操作系统提供了<strong>更好的安全性</strong>。</li></ul></li><li><p>如何管理虚拟地址和物理地址之间的关系</p><ul><li><p>内存分段：带来内存外碎片和内存交换效率低(解决碎片进行swap重分配的过程)的问题</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/image-20240717222754454.png" alt="image-20240717222754454" style="zoom:33%;" /></p></li><li><p>内存分页：会出现内存内碎片、对进程来说不太友好</p><ul><li>换入Swap In和换出Swap Out是指操作系统内存不够时候将页表写到硬盘暂时释放的过程，因为一次只写几页，所以效率较高</li></ul><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/image-20240717223025442.png" alt="image-20240717223025442" style="zoom:33%;" /></p><ul><li>带来的问题：页表内存大 ==&gt; 多级页表</li></ul></li><li><p>段页式内存管理：对于进程来说看到的是段表，对物理内存来说看到的是页表</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/image-20240717223731697.png" alt="image-20240717223731697" style="zoom:50%;" /></p></li></ul></li><li><p>操作系统怎么分配内存的？ <code>malloc()</code>：分配的是虚拟内存，如果没有被访问是不会映射到物理内存的，当程序开始读写的时候才分配</p></li><li><p>内存满了怎么办？当物理内存满了，会发送<strong>缺页中断</strong>，进程切换到内核态</p><ul><li>后台内存回收：异步的，不阻塞进程</li><li>直接内存回收：同步的，会阻塞进程，后台回收更不上的时候触发</li><li>触发OOM机制：根据算法kill占用物理内存高的进程</li></ul></li><li><p>回收哪些文件？文件页、匿名页</p></li><li><p>4GB的物理内存机器申请8GB的内存</p><ul><li>32位操作系统：无法申请，最多3GB（内核1GB，用户3GB）</li><li>64位操作系统：可以，但是如果使用的时候超出了4GB，且没有开启swap机制，会OOM</li></ul></li><li><p>如何避免预读失效和缓存污染的问题？本质是LRU算法</p><ul><li>Redis的做法是LRU，Mysql和Linux的做法是改进的LRU算法</li><li>Linux读取：在文件系统中增加Page Cache页缓存，属于内存里的数据，加快访问速度</li><li><p>Mysqld读取：Innodb存储引擎中设计了一个Buffer Pool缓冲池，属于内存里的数据，修改数据直接修改缓冲池，后台再写入磁盘</p></li><li><p>Linux和Mysql的LRU操作单位都是页</p></li><li>什么是预读？如果需要磁盘A的0-3kb数据，linux会读取一个页(0-4kb)，为了减少将来的IO次数，会预读3个page，也就是0-16kb都会读取。</li><li>什么是预读失效？就是后面预读的数据没有被用到</li><li>如何避免预读失效？改进的LRU<ul><li>Linux：实现两个LRU链表，活跃LRU、非活跃LRU链表</li><li>Mysql：在一个LRU链表中划分为：young 区域 和 old 区域</li><li>预读的数据就放在非活跃链表/old区域即可</li></ul></li><li>什么是缓存污染？只访问一次的数据放到链表头部，多了之后就会淘汰热点数据，如果这些数据长时间不被访问就会造成污染，导致下次访问热点数据的时候产生大量的IO</li><li>如何解决缓存污染？<ul><li>Linux：非活跃链表的数据读取两次才进入活跃LRU头部</li><li>Mysql：old区域被访问两次且两次时间间隔在1s以上才会进入young区域</li></ul></li></ul></li><li><p>深入理解虚拟内存</p><ul><li><p>划分：</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/image-20240718220702762.png" alt="image-20240718220702762" style="zoom:33%;" /></p><ul><li>代码段：用户的代码</li><li>数据段：代码中指定的初始值的全局变量和静态变量</li><li>BSS段：没有指定初始值的全局变量和静态变量，加载进内存后初始化为0</li><li>堆：以上是编译阶段申请的，堆是用于存放运行过程中动态生成的内存</li><li>文件映射与匿名映射区：动态链接库中的代码段、数据段、BSS段，以及内存映射区域的文件映射与匿名映射区</li><li>栈：程序调用函数过程中使用到的局部方法和函数参数</li></ul></li><li><p>范围</p><ul><li>32位系统中指针的寻址范围是2^32，所能表达的区域大小就是4GB，其中用户态3GB，内核空间1GB</li><li>64位系统中指针的寻址范围是2^64，但是只用了48位来描述空间，也就是256TB，内核、用户各一半</li></ul></li><li><p>内核是如何划分和管理的？</p><ul><li><p><code>mm_struct</code> 结构体定义上述不同区域的范围，通过task_size 域来划分用户和内核空间</p></li><li><p>若干个<code>vm_area_struct</code>结构体一一对应了上述的区域</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/image-20240718222727080.png" alt="image-20240718222727080" style="zoom: 50%;" /></p></li></ul></li></ul></li></ul><h3 id="7-4-进程管理"><a href="#7-4-进程管理" class="headerlink" title="7.4 进程管理"></a>7.4 进程管理</h3><ul><li><p>进程：代码编译为二进制可执行文件，运行文件后装载进入内存，CPU会执行程序中的命令，运行中的命令就是进程</p></li><li><p>线程：进程由若干个线程组成，操作系统中执独立运行的最小单位</p></li><li><p>并发：单个CPU一个时间段执行了多个进程</p></li><li><p>并行：多个CPU一个时间点执行了多个进程</p></li><li><p>进程状态：</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/image-20240719201817005.png" alt="image-20240719201817005" style="zoom: 50%;" /></p><ul><li>多个进程阻塞的时候，会占用物理内存空间，所以在虚拟内存管理的操作系统中，会把阻塞状态的进程的物理内存换出到磁盘，这个时候进程的状态就变成了<strong>挂起</strong></li></ul></li><li><p>PCB(process control block)：进程控制块，用于描述进程，1对1</p><ul><li>进程描述信息：进程标识符、用户标识符(进程归属的进程)</li><li>进程控制和管理信息：当前进程的状态、进程优先级</li><li>资源分配清单：有关内存地址空间或虚拟地址空间的信息</li><li>CPU相关信息：CPU中各个寄存器的值，进程被切换的时候需要保存CPU的状态信息</li></ul></li><li><p>多个PCB通过链表的结构把状态相同的进程串在一起，组成各种队列：阻塞队列、就绪队列等</p></li><li><p>进程的控制</p><ul><li>创建进程：申请一个空白的PCB，填入相关信息，分配内存资源，并加入到就绪队列中</li><li>终止进程（正常结束、异常结束以及外界干预(信号 <code>kill</code> 掉)）：查找PCB、如果处于执行状态，就立即结束、如果有子进程就交给1号进程管理、归还资源给操作系统、从PCB队列删除</li><li>阻塞进程：找到PCB、阻塞、插入到阻塞队列中</li><li>唤醒进程：找到PCB、设置状态为就绪、插入就绪队列</li></ul></li><li><p>进程的上下文切换：一个进程切换到另一个进程运行</p><ul><li>CPU 寄存器和程序计数是 CPU 在运行任何任务前，所必须依赖的环境，这些环境就叫做 <strong>CPU 上下文</strong>。</li><li>所以就是存储和读取PCB中的CPU相关信息的过程，</li></ul></li><li><p>线程和进程</p><ul><li>进程是资源（包括内存、打开的文件等）分配的单位，线程是 CPU 调度的单位；</li><li>进程拥有一个完整的资源平台，而线程只独享必不可少的资源，如寄存器和栈；</li><li>线程同样具有就绪、阻塞、执行三种基本状态，同样具有状态之间的转换关系；</li><li>线程能减少并发执行的时间和空间开销；</li></ul><blockquote><p>为什么线程能减少并发执行的时间和空间开销？</p><ul><li>线程的<strong>创建时间</strong>比进程快，因为进程在创建的过程中，还需要资源管理信息，比如内存管理信息、文件管理信息，而线程在创建的过程中，不会涉及这些资源管理信息，而是共享它们；</li><li>线程的<strong>终止时间</strong>比进程快，因为线程释放的资源相比进程少很多；</li><li>同一个进程内的线程切换比进程切换快，因为线程具有相同的地址空间（虚拟内存共享），这意味着同一个进程的线程都具有同一个页表，那么在切换的时候<strong>不需要切换页表</strong>。而对于进程之间的切换，切换的时候要把页表给切换掉，而页表的切换过程开销是比较大的；</li><li>由于同一进程的各线程间共享内存和文件资源，那么在线程之间数据传递的时候，就<strong>不需要经过内核</strong>了，这就使得线程之间的数据交互效率更高了；</li></ul></blockquote></li><li><p>线程的上下文切换和进程的区别</p><ul><li>如果是不同进程的线程切换，就和切换进程一样</li><li>如果是同一进程内的线程切换，只需要切换线程的私有数据、寄存器等不共享的数据，开销会小很多(没了虚拟内存等资源切换)</li></ul></li><li><p>线程的实现：</p><ul><li>用户线程：在用户空间实现的线程</li><li>内核线程：在内核中实现的线程，是由内核管理的线程，多个用户线程对1个内核线程</li><li>轻量级线程：在内核中来支持用户线程；</li></ul></li><li><p>用户线程的管理：基于用户态的线程管理库来实现的。线程控制块（Thread Control Block, TCB） 也是在库里面来实现的，</p><ul><li>对于操作系统而言是看不到这个TCB的，TCB是进程的私有</li><li>TCB中跟踪记录了各个线程的状态信息（PC、栈指针、寄存器）</li><li>优点：切换由线程管理库实现，不用用户态和内核态切换，速度快；由TCB记录线程信息</li><li>缺点：操作系统不参与其调度，如果一个线程发起系统调用而阻塞，那进程所包含的用户线程都不能执行了；</li></ul></li><li><p>内核线程的管理：也是通过TCB</p><ul><li>内核线程的TCB是操作系统来管理的</li><li>优点：如果某个内核线程发起系统调用而被阻塞，并不会影响其他内核线程的运行；</li><li>缺点：内核来维护进程和线程的上下文信息，如 PCB 和 TCB；线程的创建、终止和切换都是通过系统调用的方式来进行，开销大</li></ul></li><li><p>进程之间的通信：关键是如何通过内核空间来通信</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/image-20240803220346902.png" alt="image-20240803220346902" style="zoom:50%;" /></p><ul><li><p>管道：<code>mkfifo myPipe</code>创建一个管道，本质是内核空间里面的内存（队列），两端分别实现读写</p><ul><li>如果是父子进程，在fork的时候就会创建管道，并绑定到</li><li>如果不是父子进程，则是通过共同父进程例如shell</li><li>但是效率低</li></ul></li><li><p>消息队列：本质是保存在内核中的消息链表</p><ul><li>通信异步但是不适合大数据的传输    </li><li>还存在用户态到内核态的数据拷贝开销</li></ul></li><li><p>共享内存</p><ul><li>解决用户态、内核态的开销，虚拟内存映射到相同的物理内存中即可</li><li>带来了写写问题</li></ul></li><li><p>信号量：表示资源的数量 <code>&gt;= 0</code> 表示可以访问</p><ul><li>用于进程之间的互斥和同步</li></ul></li><li><p>信号：<code>kill -l</code> 查看所有的信号</p><ul><li>用于异常情况下的工作模式，比如shell中<code>ctrl + C</code> 产生<code>SIGINT</code>信号，表示终止进程</li></ul></li><li><p>socket：用于跨网络与不同主机的进程通信</p><ul><li><p>系统调用：<code>int socket(int domain, int type, int protocal)</code></p></li><li><p>简述TCP</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/image-20240803223017983.png" alt="image-20240803223017983" style="zoom: 50%;" /></p><ul><li>服务端、客户端初始化socket，得到文件描述符</li><li>服务端调用<code>bind</code>，绑定IP和端口</li><li>服务端调用<code>listen</code>，进行监听</li><li>服务端调用<code>accept</code>，等待客户端连接</li><li>客户端调用<code>connet</code>，请求连接</li><li>服务端调用<code>accept</code>，返回用于传输<code>socket</code>的文件描述符</li><li>客户端调用<code>write</code>写数据，服务端调用<code>read</code>读数据</li><li>客户端调用<code>close</code>断开，服务端<code>read</code>的时候就会读到<code>EOF</code>，处理完毕后，服务端调用<code>close</code>，关闭</li></ul></li></ul></li><li><p>多线程冲突问题</p><ul><li>锁：加锁、解锁</li><li>信号量：P(-1)、V(+1)操作,实现对临界区的互斥访问</li></ul></li><li><p>死锁问题</p><ul><li>互斥条件：多个线程不能同时使用同一个资源</li><li>持有并等待条件：线程在等待资源的同时不会释放自己持有的资源</li><li>不可剥夺条件：线程正在使用的资源不可被剥夺</li><li><p>循环等待条件：死锁发生时，两个线程获取资源构成了链</p></li><li><p>从以上四个条件进行破坏</p></li></ul></li><li><p>锁分类</p><ul><li>乐观锁：CAS</li><li>悲观锁：互斥锁、自旋锁</li></ul></li><li><p>一个进程可以创建多少线程</p><ul><li>进程虚拟内存空间的上限（32位3G，64位128T）</li><li>系统参数的限制</li></ul></li><li><p>线程崩溃进程也会崩溃吗？不一定，比如线程崩溃不会导致JVM进程崩溃</p><ul><li>线程崩溃后通过信号（SIGSEGV ）来告诉进程，JVM自定义了自己的信号处理函数，拦截了SIGSEGV 信号</li></ul></li></ul></li></ul><h3 id="7-5-调度算法"><a href="#7-5-调度算法" class="headerlink" title="7.5 调度算法"></a>7.5 调度算法</h3><ul><li>进程调度算法<ul><li>先到先服务</li><li>最短作业时间</li><li>高响应比优先调度算法：优先权= (等待时间 + 要求服务时间) / 要求服务时间</li><li>时间片轮转调度算法</li><li>最高优先级调度算法</li><li>多级反馈队列调度算法：时间片+ 优先级<ul><li>优先级越高时间片越短，最开始进入优先级最高的队列，没执行完进入下一级队列</li></ul></li></ul></li><li>内存页面置换算法：当出现缺页异常，需调入新页面而内存已满时，选择被置换的物理页面<ul><li>最佳页面置换算法：选择未来最长时间不访问的页面。</li><li>先进先出置换算法：选择在内存驻留时间很长的页面进行中置换</li><li>最近最久未使用的置换算法（LRU）</li><li>时钟页面置换算法</li></ul></li><li>磁盘调度算法：优化磁盘的访问请求顺序<ul><li>先来先服务</li><li>最短寻道时间优先算法</li><li>扫描算法：避免磁头在一个小区域来回扫动</li><li>循环扫描算法</li><li>LOOK 与 C-LOOK算法</li></ul></li></ul><h3 id="7-6-文件系统"><a href="#7-6-文件系统" class="headerlink" title="7.6 文件系统"></a>7.6 文件系统</h3><ul><li><p>linux文件数据结构</p><ul><li>索引节点<em>inode</em>：记录文件的元信息，唯一标识，会被存储于硬盘</li><li>目录项<em>dentry</em>：记录文件名、与其他目录项的层级关系，由内核维护，缓存于内存（与inode多对一）</li></ul></li><li><p>文件如何存储在硬盘？</p><ul><li><p>磁盘最小读取单位是扇区 512B，为提高效率，linux以逻辑块为单位：8个扇区 4KB</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/image-20240804120447481.png" alt="image-20240804120447481" style="zoom:50%;" /></p></li></ul></li><li><p>虚拟文件系统（Virtual File System，VFS）</p><ul><li>针对文件系统种类繁多(磁盘、内存、网络)，为给用户提供统一的接口，在用户层和文件系统中提供的中间层</li></ul></li><li><p>文件存储</p><ul><li>连续存储</li><li>非连续：链表+索引(指向文件头)</li></ul></li><li><p>空闲空间管理</p><ul><li><p>空闲表法</p></li><li><p>空闲链表法</p></li><li><p>位图（linux使用），每位代表 块</p><ul><li><p>假设是在一个块中，共可以表示 <code>4 * 1024 * 8 = 2^15</code> 个空闲块，最大的空间是 <code>2^15 * 4 * 1024 = 2^27</code> 个 byte，也就是 128M。</p></li><li><p>N个 一个块的位图 + 一系列的块 称为块组，用来表示文件</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/image-20240804124456116.png" alt="image-20240804124456116" style="zoom:50%;" /></p></li></ul></li></ul></li><li><p>软链接和硬链接：给某个文件取个别名</p><ul><li>硬链接：多个目录项中的「索引节点」指向一个文件，删除所有的硬链接以及源文件才彻底删除</li><li>软链接：相当于重新创建一个文件，有独立的inode，内容是另一个文件的路径</li></ul></li><li><p>文件IO</p><ul><li>缓存IO/非缓存IO：前者是通过标准库的缓存实现文件的加速访问，标准库再通过系统调用访问文件。</li><li>直接与非直接 IO：是否使用了内核缓存</li><li><p>阻塞与非阻塞IO：用户线程执行<code>read</code>线程是否会被阻塞</p><ul><li>阻塞等待的是「内核数据准备好」和「数据从内核态拷贝到用户态」这两个过程</li></ul></li><li><p>同步与异步IO：</p></li></ul></li></ul><h3 id="7-7-设备管理"><a href="#7-7-设备管理" class="headerlink" title="7.7 设备管理"></a>7.7 设备管理</h3><ul><li><p>从键盘敲入字母发生了什么</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/image-20240804133806467.png" alt="image-20240804133806467" style="zoom:50%;" /></p><ul><li>输入字符后，<strong>键盘控制器</strong>就会产生扫描码数据，并将其缓冲在键盘控制器的寄存器中，紧接着键盘控制器通过总线给 CPU 发送<strong>中断请求</strong></li><li>CPU 收到中断请求后，操作系统会<strong>保存被中断进程的 CPU 上下文</strong>，然后调用键盘的<strong>中断处理程序</strong></li><li>键盘中断处理程序：<strong>键盘驱动程序</strong>初始化注册的，功能是从键盘控制器的寄存器缓冲区读取扫描码，再根据扫描码找到字符，并翻译为对应的ASCII码,放到显示字符读缓冲区队列,由显示器读取</li></ul></li></ul><h3 id="7-8-网络管理"><a href="#7-8-网络管理" class="headerlink" title="7.8 网络管理"></a>7.8 网络管理</h3><ul><li><p>DMA—直接内存访问(Direct Memory Access) 技术</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/image-20240804135136727.png" alt="image-20240804135136727" style="zoom: 67%;" /></p><ul><li>为了解决CPU读取磁盘内容带来的CPU中断问题,DMA读取完数据后发送中断信号给CPU,让CPU读数据</li><li>完成内核态与对应硬件设备（磁盘、网卡等）之间的数据拷贝。</li></ul></li><li><p>传统的文件传输</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/image-20240804135524908.png" alt="image-20240804135524908" style="zoom:50%;" /></p><ul><li>过程<ul><li>CPU发送指令给IO设备的DMA，由DMA拷贝数据从磁盘到内核空间</li><li>DMA拷贝完成，触发CPU的中断，CPU开始将数据从内核空间拷贝到用户空间</li><li>CPU继续将数据从用户空间拷贝到内核的socket buffer</li><li>DMA将数据从socket buffer拷贝到硬件设备（网卡）</li></ul></li><li>发生了4次用户态内核态的转换以及4次数据拷贝,如何优化?<ul><li>减少切换次数和数据拷贝次数</li></ul></li></ul></li><li><p>零拷贝技术（kafka，nginx使用）</p><ul><li><p><code>mmap()</code>：将<code>read()</code> 改为<code>mmap()</code> 。改进是在内存中建立一个到磁盘的映射，数据直接同步在内存，由操作系统异步同步内存到硬盘的数据。适合小数据的传输，rocketMQ</p><ul><li>4次上下文切换(用户态 -&gt; 内核态 -&gt; 用户态 -&gt; 内核态 -&gt; 用户态)和3次拷贝(磁盘DMA拷贝到内核缓冲区 -&gt; 内核缓冲区CPU拷贝到socket缓冲区 -&gt; socket缓冲区DMA拷贝到协议引擎)</li></ul></li><li><p><code>sendfile()</code>：将<code>read()</code> 改为<code>sendfile()</code>。 改进是直接在内核态中进行缓存区到socket缓冲区的数据拷贝</p><ul><li><p>2次上下文切换(用户态 -&gt; 内核态 -&gt; 用户态)和2次拷贝(磁盘DMA拷贝到内核缓冲区 -&gt; 内核缓冲区DMA拷贝到协议引擎)</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/image-20240908151341005.png" alt="image-20240908151341005" style="zoom:50%;" /></p><ul><li>为什么还需要CPU中断？因为DMA不知道拷贝的地址，这个是由CPU指定的，DMA的寻址范围比CPU小，一般会预留低位的地址给DMA使用</li></ul></li></ul></li><li><p>对<code>sendfile()</code>的改进：去掉步骤2中的CPU拷贝<code>sendfile+DMA scatter/gather</code></p><ul><li><p>内核缓存区kernel buffer中的数据不再拷贝到socket buffer中，而是直接在后者里面存储一个内存地址和偏移量，这样网卡的DMA访问到socket buffer后可以直接定位到内核缓存区进行数据拷贝，实现CPU的零拷贝</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/image-20240908152101567.png" alt="image-20240908152101567" style="zoom: 33%;" /></p></li></ul></li></ul></li><li><p><code>page cache</code>：缓存最近被访问的数据，零拷贝技术的基础</p><ul><li>解决机械硬盘寻址慢的问题</li></ul></li><li><p>直接IO与缓存IO：对于大文件，不适合使用page cache这种缓存IO，对于磁盘，异步 I/O 只支持直接 I/O。</p></li><li><p>网络socket基本过程：见进程管理部分</p><ul><li>最大连接数限制：文件描述符(socket也是文件)限制1024默认、系统内存限制</li></ul></li><li><p>IO多路复用：一个进程维护多个Socket</p><ul><li><p>select：将socket放到一个文件描述符集合（固定长度1024的 BitsMap）。需要2次遍历文件描述符集合，2次拷贝文件描述符集合</p></li><li><p>poll：bitsMap变为了链表</p></li><li><p>epoll：</p><ul><li><p>文件描述符使用红黑树O(logn),只在内核维护，减少了很多的遍历和复制</p></li><li><p>使用事件驱动机制，内核维护了一个链表记录就绪事件，当有socket事件发生的时候，通过回调函数内核将其加入到列表中，当用户调用 <code>epoll_wait()</code> 函数时，只会返回有事件发生的文件描述符的个数（<strong>但是还是会拷贝</strong>），不需要像select/poll那样轮询整个socket集合</p></li></ul></li></ul></li></ul><ul><li><p>Reactor/Proactor：对IO多路复用的封装</p><ul><li>Reactor(同步非阻塞)、Proactor(异步)</li><li>对象<ul><li>reactor：监听和分发事件</li><li>acceptor：获取事件</li><li>handler：处理业务</li></ul></li><li>单reactor/单进程线程模型<ul><li>只有一个进程；handler处理业务的时候进程无法处理其他的连接</li></ul></li><li>单reactor/多线程进程模型<ul><li>reactor通过select（IO多路复用接口）监听，根据事件类型分发给handler和acceptor</li></ul></li><li>多reactor/多线程进程模型（nginx）<ul><li>主线程接收连接，子线程处理连接</li></ul></li><li>Proactor</li></ul></li><li><p>一致性哈希：解决多个请求分配客户端请求的问题</p><ul><li><p>哈希算法的不足：比如取模，如果节点的数量发生变化，则需要进行额外的数据迁移</p></li><li><p>一致性哈希算法解决的问题：分布式系统扩容或缩容的数据迁移问题</p></li><li><p>步骤：计算在哈希环中的位置，顺时针取遇到的第一个节点</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/image-20240804150519055.png" alt="image-20240804150519055" style="zoom: 33%;" /></p><ul><li>如果发生节点的增删，只影响前后节点，对全局其他节点无影响</li></ul></li><li><p>问题：</p><ul><li>不保证数据的均匀性</li></ul></li><li><p>改进：增加虚拟节点，环上的点就是虚拟节点，增加一个映射到真实节点</p></li></ul></li></ul><h2 id="八-工具"><a href="#八-工具" class="headerlink" title="八 工具"></a>八 工具</h2><h3 id="1-git"><a href="#1-git" class="headerlink" title="1 git"></a>1 git</h3><ul><li><p>命令</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">git init</span><br><span class="line"></span><br><span class="line">git status</span><br><span class="line"></span><br><span class="line">git <span class="built_in">clone</span> url <span class="comment"># 支持http(s) ssh git等协议</span></span><br><span class="line"></span><br><span class="line">git checkout branch|tag|commit <span class="comment"># 切换到指定分支</span></span><br><span class="line"></span><br><span class="line">git merge branchName <span class="comment"># 将branchName的修改合并到当前分支中</span></span><br><span class="line"></span><br><span class="line">git add .</span><br><span class="line"></span><br><span class="line">git commit -m <span class="string">&quot;message&quot;</span></span><br><span class="line"></span><br><span class="line">git push origin master <span class="comment"># 将本地的 master 分支推送到 origin 主机的 master 分支</span></span><br><span class="line"></span><br><span class="line">git reset HEAD <span class="comment"># 取消已经暂存的文件</span></span><br><span class="line"></span><br><span class="line">git revert HEAD <span class="comment"># 撤销前一次操作</span></span><br><span class="line">git revert commit <span class="comment"># 撤销指定操作 </span></span><br><span class="line"></span><br><span class="line">git remote add origin git@github.com:JSLite/test.git <span class="comment"># 添加一个新的远程仓库 add &lt;remote_name&gt; &lt;remote_url&gt;</span></span><br><span class="line"></span><br><span class="line">git diff --<span class="built_in">stat</span>   <span class="comment"># 查看简单的diff结果   </span></span><br><span class="line">git diff branch     <span class="comment"># 比较Worktree和branch之间的差异 </span></span><br><span class="line"></span><br><span class="line">git merge --squash branchName <span class="comment"># 将branchName的多次提交统一变更到当分支（此后还需要再add commit push）</span></span><br><span class="line"></span><br><span class="line">git <span class="built_in">log</span> <span class="comment"># 日志相关</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>已经push的操作如何回退？</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/image-20240519144816183.png" alt="image-20240519144816183"></p><ul><li><p>要回到vesion2</p></li><li><p>不保留git记录</p><ul><li><p>先reset到要回退的版本：<code>git reset commitID</code></p></li><li><p>然后强制push上去： <code>git push origin master:master -f</code> </p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/image-20240519145122665.png" alt="image-20240519145122665" style="zoom:33%;" /></p></li></ul></li><li><p>保留git记录</p><ul><li><p><code>git revert commitID</code>，选择merge</p></li><li><p>然后push</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/image-20240519145010549.png" alt="image-20240519145010549" style="zoom:33%;" /></p></li></ul></li></ul></li><li><p>分支的多次commit变成一次提交到master</p><ul><li><p>方法一：先从版本库回退内容到暂存区，再重新提交工作区的内容</p><ul><li><code>git reset --soft commitID</code>，此时版本回到commitID对应的状态，但是保留了改动(也就是之后多次的commit修改内容)</li><li>然后git add commit push</li></ul></li><li><p>方法二：rebase</p><ul><li><p>git log 查看提交记录，找到最早的那次提交的commitID的前一次</p><ul><li>我想合并commit1678 就找到commit1的前一次的id</li></ul><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/image-20240519155033222.png" alt="image-20240519155033222"></p></li><li><p><code>git rebase -i commitID</code>，随后在vim编辑器中修改前面的提交由pick变为fixup</p><ul><li>fixup：使用commit，丢弃commit信息。</li><li>pick：使用commit。</li><li>squash：使用commit，将commit信息合入上一个commit。</li><li>reword：使用commit，修改commit信息。</li></ul><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/image-20240519154428674.png" alt="image-20240519154428674" style="zoom:67%;" /><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/image-20240519155543233.png" alt="image-20240519155543233" style="zoom: 67%;" /></p><ul><li>可以通过<code>git reflog</code>取消rebase</li></ul></li><li><p>最后<code>git push --force</code>即可</p></li></ul></li></ul></li></ul><h3 id="2-maven"><a href="#2-maven" class="headerlink" title="2 maven"></a>2 maven</h3><h2 id="九-Spring"><a href="#九-Spring" class="headerlink" title="九 Spring"></a>九 Spring</h2><h3 id="9-1-简介"><a href="#9-1-简介" class="headerlink" title="9.1 简介"></a>9.1 简介</h3><ul><li>特性：<ul><li>非侵入</li><li>控制反转IOC：由框架管理bean，是一种思想</li><li>依赖注入DI：控制反转的实现方式，是一种实现方式</li><li>切面AOP</li><li>容器管理</li></ul></li></ul><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/image-20240706162256753.png" alt="image-20240706162256753" style="zoom:50%;" /></p><ul><li>core container：spring核心容器，由Beans、Core、Context、SpEL模块组成<ul><li>Beans：基础，提供了控制反转和依赖注入</li><li>Core：封装了底层，包括资源访问、类型转化等工具</li><li>Context上下文：ApplicationContext接口</li><li>SpEL：语言表达式支持</li></ul></li><li>Data Access/Integration：数据访问/集成<ul><li>JDBC：提供了JDBC模块，</li><li>ORM：提供了ORM框架集成的API，包括JPA、JDO、Hibernate 和 MyBatis 等</li><li>OXM：提供了XML与Java对象的转化功能</li><li>JMS：Java消息服务，异步通信</li><li>Transactions：编程和声明式事务的管理</li></ul></li><li>Web：web模块<ul><li>Web</li><li>Servlet：提供了spring mvc web框架实现</li><li>WebSocket：实现双向通信</li><li>Webflux</li><li>Portlet 模块</li></ul></li><li>AOP、Aspects、Instrumentation和Messaging</li><li>Test模块：支持Junit 和 TestNG 测试框架，还有模型http请求等功能</li><li>spring的启动过程<ul><li>加载配置文件：xml，javaConfig类，配置数据库连接、事务管理、AOP等</li><li>实例化容器：实例化BeanFactory，如创建ApplicationContext；并加载BeanDefinitions</li><li>解析BeanDefinitions：Bean的元数据、作用域、依赖关系等</li><li>实例化Bean</li><li>依赖注入</li><li>处理Bean生命周期初始化方法</li><li>处理BeanPostProcessor</li><li>代理切面处理</li><li>发布事件</li><li>完成启动</li></ul></li></ul><h3 id="9-2-控制反转IOC、及DI"><a href="#9-2-控制反转IOC、及DI" class="headerlink" title="9.2 控制反转IOC、及DI"></a>9.2 控制反转IOC、及DI</h3><ul><li><p>三种配置方式</p><ul><li><p>xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag"> http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- services --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;tech.pdai.springframework.service.UserServiceImpl&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;userDao&quot;</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- additional collaborators and configuration for this bean go here --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- more bean definitions for services go here --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>java配置：创建配置类，<code>@Configuration</code>注解声明，在bean中用<code>@bean</code>声明</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BeansConfig</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> user dao</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean(&quot;userDao&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> UserDaoImpl <span class="title function_">userDao</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">UserDaoImpl</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> user service</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean(&quot;userService&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> UserServiceImpl <span class="title function_">userService</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">UserServiceImpl</span> <span class="variable">userService</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserServiceImpl</span>();</span><br><span class="line">        userService.setUserDao(userDao());</span><br><span class="line">        <span class="keyword">return</span> userService;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>注解配置：<code>@Component</code>，<code>@Controller</code>，<code>@Service</code>，<code>@Repository</code>，但是要配置spring 的注解扫描器ComponentScan</p></li></ul></li><li><p>依赖注入：一种设计模式，用于解耦成员和管理类之间的关系，核心思想是将对象的创建交给外部（IOC）容器管理</p><ul><li><p>构造方法注入，xml中<code>&lt;constructor-arg&gt;</code></p></li><li><p>setter注入，xml中的<code>&lt;property&gt;</code></p></li></ul></li><li><p>自动装配：是依赖注入的一种自动化形式，不需要开发者显示的指定哪些依赖要注入到哪个类中，由spring自动完成</p><ul><li><p>byName</p></li><li><p>byType：如果多个bean类型相同，则需要byName</p></li><li><p>构造器注入：容器查找类型相匹配的bean注入</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span> <span class="comment">// 三个属性Constructor，byType，byName，默认byType(查找set方法)</span></span><br><span class="line"><span class="meta">@Qualifier(&quot;helloWorldDao&quot;)</span> <span class="comment">// byName,如果没有找到会抛异常，防止这个可以@Autowired(required = false)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Inject</span> <span class="comment">// byType,javaEE提供</span></span><br><span class="line"><span class="meta">@Resource</span> <span class="comment">// byName,javaEE提供</span></span><br><span class="line"><span class="meta">@Named</span> <span class="comment">// 和Qualifier一样，javaEE提供</span></span><br><span class="line"><span class="keyword">private</span> HelloDao helloDao;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>spring IOC的设计</p><ul><li>加载Bean的配置(如xml)</li><li>根据bean定义加载生成bean的实例，并放置在容器中</li><li>统一管理bean(工厂模式)</li></ul></li><li><p><code>interface BeanFactory</code></p></li><li><p><code>interface ApplicationContext</code>：IoC容器的接口类</p><ul><li>除了对bean的管理外，还包括了资源访问、国际化、应用事件</li></ul></li><li><p>循环依赖：三级缓存</p><ul><li><p>一级缓存singletonObjects：已经初始化好的bean，即已经完成初始化好的注入对象的代理</p></li><li><p>二级缓存earlySingletonObjects：还没有完全被初始化好的中间对象代理</p></li><li><p>三级缓存singletonFactory：存放的是还未初始化完的bean，不是代理对象</p></li><li><p>为什么需要三级？</p><ul><li>针对于AOP，singletonFactory缓存相当于是返回的是A的代理</li></ul></li><li><p>过程：<a href="https://www.cnblogs.com/daimzh/p/13256413.html">https://www.cnblogs.com/daimzh/p/13256413.html</a></p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/image-20240321165705162.png" alt="image-20240321165705162" style="zoom: 50%;" /></p></li><li><p>ps：</p><ul><li>不能解决构造器的依赖（使用<code>@Lazy</code>解决）</li><li>只能解决单例bean的循环依赖（多实例Bean是每次调用一次getBean都会执行一次构造方法并且给属性赋值，根本没有三级缓存，因此不能解决循环依赖）</li></ul></li><li><p>自动装配（spring boot）</p><ul><li>依赖注入的plus，简化了依赖注入的配置而生成的</li><li>主启动类上的注解<strong><code>@SpringbootApplication</code></strong>是一个复合注解，其中比较重要的<ul><li><code>@SpringbootConfiguration</code>：springboot的相关配置</li><li><code>@EnableAutoConfiguration</code></li><li><code>@ComponentScan</code>：扫描一些包并注入</li></ul></li><li>重点<strong><code>@EnableAutoConfiguration</code></strong>，也是一个复合注解<ul><li><code>@import(AutoConfigurationImportSelect.class)</code></li></ul></li><li><p><code>AutoConfigurationImportSelect</code> implements了<strong><code>DeferredImportSelector</code></strong></p><ul><li><p>因为是Deferred,所以自动配置类会放在最后加载,方便扩展和覆盖</p></li><li><p>其中重写了<strong><code>selectImports()</code></strong>方法：获取所有符合条件的类的全限定类名，加载到IOC容器中</p><ul><li><p>判断是否开启了自动装配：<code>spring.boot.enableautoconfiguration=true</code></p></li><li><p>获取<code>@EnableAutoConfiguration</code>中的<code>exclude</code>和<code>excludeName</code></p></li><li><p>读取所有spring boot start下面的classpath:/META-INF/spring.factories文件(key-value形式)</p></li><li><p>通过<code>@ConditionalOn</code>排除无效的自动配置类</p></li></ul></li></ul></li><li>配置文件的信息如何加载到bean中：classpath:/META-INF/spring.factories文件存储了一些键信息（<strong>SpringBoot约定大于配置的理念</strong>），然后加载的时候配置文件的值就被加载到这个文件中了</li><li>两种<ul><li><code>@Autowired</code>：根据类型自动注入<ul><li><code>@Qualifier</code>：格外指定bean的id（当IOC根据属性类型去容器中找找到多个相同类型的组件的时候需要使用）</li></ul></li><li><code>@Resource</code>：根据bean的名称自动注入<ul><li>这个是Java规范</li></ul></li></ul></li></ul></li></ul></li></ul><h3 id="9-3-AOP"><a href="#9-3-AOP" class="headerlink" title="9.3 AOP"></a>9.3 AOP</h3><ul><li>目的：AOP 的目的是将横切关注点（如日志记录、事务管理、权限控制、接口限流、接口幂等等）从核心业务逻辑中分离出来，通过动态代理、字节码操作等技术，实现代码的复用和解耦，提高代码的可维护性和可扩展性。</li><li>概念：<ul><li>连接点：表示需要在程序中插入横切关注点的扩展点</li><li>切入点：选择一组相关连接点的模式，即可以认为连接点的集合</li><li>通知：前置通知、后置通知、环绕通知、最终通知、异常通知<ul><li><code>@After @Around @Before @AfterReturning @AfterThrowing</code></li></ul></li><li>切面：公共代码</li><li>引入：引入允许我们向现有的类添加新方法或属性</li><li>织入：把切面应用到目标对象并创建新的代理对象的过程<ul><li>动态织入：通过动态代理完成，运行期织入（Spring AOP采用的方式）</li><li>静态织入：AspectJ，编译期织入</li></ul></li><li>AOP代理：JDK(反射)和CGLib(继承)两种方式<ul><li>都是运行期间生成字节码，jdk直接生成class字节码，cglib使用ASM框架写的class字节码。后者更加复杂，代理类生成效率更低</li><li>jdk动态代理是通过反射机制来执行方法，cglib是通过FastClass机制（索引分配直接调用）直接调用方法，后者动态代理类执行效率更高，但是cglib无法增强final方法(AspectJ可以)</li></ul></li></ul></li><li><p>最佳实践</p><ul><li><code>@Aspect</code>：定义切面</li><li><code>@pointcut</code>：定义切点</li><li><code>@After @Around @Before @AfterReturning @AfterThrowing</code>：定义通知</li></ul></li><li><p>Spring AOP和AspectJ关系：Spring AOP更易用，AspectJ更强大</p></li></ul><h3 id="9-4-Sping-MVC"><a href="#9-4-Sping-MVC" class="headerlink" title="9.4 Sping MVC"></a>9.4 Sping MVC</h3><ul><li><p>Spring MVC是Spring在Spring Container Core和AOP等技术基础上，遵循上述Web MVC的规范推出的web开发框架，目的是为了简化Java栈的web开发</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/image-20240706173809020.png" alt="image-20240706173809020" style="zoom: 67%;" /></p><ul><li>核心组件<ul><li>DispatcherServlet：前端控制器，负责将请求分派给相应的处理器(Controller)</li><li>HandlerMapping：适配找到Handler</li><li>HandlerAdapter：适配处理器，用来找到Controller方法</li><li>Controller：处理用户请求，返回ModelAndView对象</li><li>ModelAndView：包含模型和视图</li><li>ViewResolver：解析视图</li></ul></li></ul></li><li><p>拦截器 Interceptor，类似于servlet中的Filter（但是Filter是基于Servlet层面的，会比Interceptor先被执行）</p><ul><li><p>实现<code>HandlerInterceptor</code>接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">HandlerInterceptor</span> &#123;</span><br><span class="line">    <span class="keyword">default</span> <span class="type">boolean</span> <span class="title function_">preHandle</span><span class="params">(...)</span></span><br><span class="line">    <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">postHandle</span><span class="params">(...)</span></span><br><span class="line">    <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">afterCompletion</span><span class="params">(...)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>注册拦截器：实现<code>WebMvcConfigurer</code>接口，重写<code>addInterceptors()</code>方法注册拦截器</p></li><li><p>配置拦截器：<code>addPathPatterns()</code>设计对应url路径，<code>excludePathPatterns()</code>排除路径</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebMvcConfig</span> <span class="keyword">implements</span> <span class="title class_">WebMvcConfigurer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> PermissionInterceptor permissionInterceptor;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> CookieInterceptor cookieInterceptor;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> &#123;</span><br><span class="line">        registry.addInterceptor(permissionInterceptor).addPathPatterns(<span class="string">&quot;/**&quot;</span>);</span><br><span class="line">        registry.addInterceptor(cookieInterceptor).excludePathPatterns(<span class="string">&quot;/path&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>配置类上使用<code>@EnableWebMvc</code>启动mvc配置</p></li></ul></li></ul><h3 id="9-5-Bean"><a href="#9-5-Bean" class="headerlink" title="9.5 Bean"></a>9.5 Bean</h3><ul><li><p>生命周期</p><ul><li><code>BeanFactoryPostProcessor</code>如果和bean关联，则<code>postProcessBeanFactory()</code>：尝试从Bean工厂中获取Bean</li><li><code>InstantiationAwareBeanPostProcessor</code> <ul><li>postProcessBeforeInstantiation()，如果这里返回了bean实例，就会直接跳到postProcessAfterInitialization()</li><li>postProcessAfterInstantiation()，bean实例化完后调用</li></ul></li><li>bean构造函数</li><li>bean调用setter方法初始化</li><li>如果实现了<code>xxxAware</code>接口(bean需要实现这些接口)，调用对应的<code>setxxx()</code> 方法<ul><li><code>BeanNameAware</code>接口：传入当前 Bean 的 id 值</li><li><code>BeanClassLoaderAware</code>接口：传入classLoader的引用</li><li><code>BeanFactoryAware</code>：传入当前工厂实例的引用</li><li><code>EnvironmentAware</code>传入当前 Environment 实例的引用</li><li><code>ApplicationContextAware</code>传入当前 ApplicationContext 实例的引用</li></ul></li><li>如果实现了<code>BeanPostProcessor</code>接口<ul><li><code>postProcessBeforeInitialzation()</code>，bean的init方法之前，Spring 的 AOP 就是利用它实现的</li></ul></li><li>如果实现了<code>InitializingBean</code>接口(或者@PostConstruct) ，则调用<code>afterPropertiesSet()</code>方法</li><li>调用bean自身的<code>initMethod()</code>方法（<code>@Bean</code>注解）</li><li><p>如果实现了<code>BeanPostProcessor</code>接口</p><ul><li><code>postProcessAfterInitialization()</code>，bean初始化后</li></ul></li><li><p>使用bean</p></li><li>如果实现了<code>DisposableBean</code>接口，则销毁的时候调用<code>destroy()</code>方法</li><li>执行bean自身的<code>destroyMethod()</code>方法 （<code>@Bean</code>注解）</li></ul></li></ul><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/image-20240706180733761.png" alt="image-20240706180733761"></p><ul><li>作用域<ul><li>singleton 单例 </li><li>prototype 原型</li><li>request</li><li>session</li><li>application</li><li>websoket</li></ul></li></ul><h3 id="9-6-事务"><a href="#9-6-事务" class="headerlink" title="9.6 事务"></a>9.6 事务</h3><ul><li><p><code>@Transactional</code>：原理是基于ThreadLocal，动态代理</p></li><li><p>什么时候spring 的事务会失效？</p><ul><li>多线程</li><li>异常被catch了，没有抛出，这样事务无法捕获到异常</li><li>同一个类方法的调用如果没有用代理类会失败</li><li>注解作用于非public方法，或者final、static方法，无法被代理，事务失效</li><li>数据库用的MyISAM，引擎本身不支持事务</li></ul></li></ul><h3 id="9-7-常用注解"><a href="#9-7-常用注解" class="headerlink" title="9.7 常用注解"></a>9.7 常用注解</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@PropertyResource</span></span><br><span class="line"><span class="meta">@Conditional</span>：类加载条件</span><br><span class="line"><span class="meta">@Bean</span>、<span class="meta">@Component</span>、<span class="meta">@Controller</span>、<span class="meta">@Service</span>、<span class="meta">@Repository</span></span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="meta">@Primary</span>：用于声明接口多个实现类优先加载的bean</span><br><span class="line"><span class="meta">@Value(&quot;$&#123;app.version&#125;&quot;)</span></span><br><span class="line"><span class="meta">@Profile(&quot;dev&quot;)</span>：标注bean加载的环境</span><br><span class="line"><span class="meta">@PostConstruct</span>、<span class="meta">@PreDestroy</span>：声明周期方法</span><br><span class="line"><span class="meta">@ResponseBody</span>、<span class="meta">@ResponseStatus</span>：标注在方法上</span><br><span class="line"><span class="meta">@PathVariable</span>、<span class="meta">@RequestBody</span>、<span class="meta">@ModelAttribute</span>、<span class="meta">@RequestHeader</span>、<span class="meta">@CookieValue</span>、<span class="meta">@SessionAttribute</span>、<span class="meta">@Valid</span>：标注在参数上</span><br><span class="line">    <span class="comment">// @Valid表示开启参数验证(对象上要有字段约束，如@NotNull)</span></span><br><span class="line"><span class="meta">@ExceptionHandler(xxxException.class)</span></span><br><span class="line"><span class="meta">@Schedule(cron = &quot;...&quot;)</span></span><br></pre></td></tr></table></figure><h2 id="十-Spring-Boot"><a href="#十-Spring-Boot" class="headerlink" title="十 Spring Boot"></a>十 Spring Boot</h2><ul><li>解决spring配置重量级的问题，约定大于配置</li></ul><h3 id="10-1-常用注解"><a href="#10-1-常用注解" class="headerlink" title="10.1 常用注解"></a>10.1 常用注解</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span> <span class="comment">// main</span></span><br><span class="line"><span class="meta">@EnableAutoConfiguration</span> <span class="comment">// 自动装配 src/main/resources的META-INF/spring.factories 的bean</span></span><br><span class="line"><span class="meta">@ImportResource</span> <span class="comment">// 加载xml 启动类上</span></span><br><span class="line"><span class="meta">@Value</span> <span class="comment">// application.properties的属性</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/api/demo&quot;)</span></span><br><span class="line"><span class="meta">@RequestParam(value = &quot;demo&quot;, required = false)</span> <span class="comment">// 作用于request入参 https://www.d.com/info?demo=ddd</span></span><br><span class="line"><span class="meta">@PathVariable(&quot;name&quot;)</span> <span class="comment">// 用于获取url请求中的参数 https://www.d.com/name/info</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="meta">@Bean(name = &quot;xxx&quot;, initMethod = &quot;xxx&quot;, destoryMethod = &quot;xxx&quot;)</span></span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@Repository</span> <span class="comment">// 用于标注数据访问组件</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@ComponentScan</span></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="meta">@Qualifier(&quot;beanName&quot;)</span> <span class="comment">// 和@Autowired一起使用，表示byName方式加载bean</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@Import(Config.class)</span></span><br><span class="line"><span class="meta">@ControllerAdvice</span></span><br><span class="line"><span class="meta">@ControllerAdvice</span>、<span class="meta">@ExceptionHandler</span>：分别作用于类和方法</span><br></pre></td></tr></table></figure><h3 id="10-2-开发实践"><a href="#10-2-开发实践" class="headerlink" title="10.2 开发实践"></a>10.2 开发实践</h3><ul><li><p>对参数进行统一校验：为了解决在Controller中频繁对入参对象校验的不优雅</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- spring validation是对hibernate validation的二次封装，后者是对validation-api标准的实现 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-validation<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span> </span><br></pre></td></tr></table></figure><p>定义入参对象类，在字段中添加相关注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@NotEmpty(message = &quot;xxx&quot;)</span></span><br><span class="line"><span class="meta">@Email(message = &quot;xxx&quot;)</span></span><br><span class="line"><span class="meta">@Pattern(regexp = &quot;xxx&quot;, message = &quot;xxx&quot;)</span> <span class="comment">// 正则匹配</span></span><br><span class="line"><span class="meta">@Length(min = 0, max = 10, message = &quot;xxx&quot;)</span></span><br><span class="line"><span class="meta">@Range(min = 0, max = 10, message = &quot;xxx&quot;)</span></span><br></pre></td></tr></table></figure><p>Controller中入参添加<code>@Valid</code>注释</p></li><li><p>统一异常处理：<code>@ControllerAdvice</code>及<code>@ExceptionHandler</code></p></li><li><p>接口版本控制：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">相同URL，用不同的版本参数区分</span><br><span class="line">api.man.tech/user?version=v1 </span><br><span class="line">api.man.tech/user?version=v2 </span><br><span class="line">区分不同的接口域名，不同的版本有不同的子域名, 路由到不同的实例:</span><br><span class="line">v1.man.pdai.tech/user </span><br><span class="line">v2.man.pdai.tech/user </span><br><span class="line">网关路由不同子目录到不同的实例</span><br><span class="line">api.man.tech/v1/user</span><br><span class="line">api.man.tech/v2/user</span><br><span class="line">同一实例，用注解隔离不同版本控制</span><br></pre></td></tr></table></figure></li><li><p>接口文档生成swagger</p></li><li><p>访问外部接口（调三方服务）</p><ul><li>采用原生http请求</li><li>feign消费（依赖 + <code>@EnableFeignClients</code>）：本质也是http</li><li>采用RestTemplate方法</li></ul></li><li><p>保证接口的幂等性：</p><blockquote><p> 哪些操作需要保证幂等性？PUT和POST，DELETE如果需要返回删除的行数则也需要</p></blockquote><ul><li>数据库加悲观锁</li><li>唯一索引：注意是分布式ID，针对插入操作</li><li>乐观锁：版本号，针对更新操作</li><li>分布式锁：redis</li></ul></li><li><p>针对接口进行签名：防篡改</p><ul><li><p>认证和授权</p></li><li><p>https</p></li><li><p>接口签名(加密)：1. 对请求参数按key进行字母排序 2. 排序完连接用&amp; 3. 加密字符串得到sig，拼接到后面</p><p><code>https://man.xxxx.com/info?key=value&amp;timetamp=xxxx&amp;sign=xxxx-xxx-xxx-xxxx</code></p></li></ul></li><li><p>接口限流</p><ul><li>单实例：限流总资源数、总并发数、某接口的请求总量、某个时间窗的请求数</li><li>分布式：redis+lua 或者 nginx+lua</li></ul></li><li><p>跨域请求</p><ul><li><p><code>@Configuration</code>实现WebMvcConfigurer接口，重写addCorsMappings方法，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyWebMvcConfigurer</span> <span class="keyword">implements</span> <span class="title class_">WebMvcConfigurer</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addCorsMappings</span><span class="params">(CorsRegistry registry)</span> &#123;</span><br><span class="line">        registry.addMapping(<span class="string">&quot;/user/*&quot;</span>)</span><br><span class="line">            .allowedOrigins(<span class="string">&quot;http://localhost:8080&quot;</span>)</span><br><span class="line">            .allowedMethods(<span class="string">&quot;GET&quot;</span>, <span class="string">&quot;POST&quot;</span>, <span class="string">&quot;PUT&quot;</span>, <span class="string">&quot;DELETE&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="10-3-其他"><a href="#10-3-其他" class="headerlink" title="10.3 其他"></a>10.3 其他</h3><ul><li><p>自动装配——SpringBoot约定大于配置的理念的产物</p><ul><li>依赖注入的plus，简化了依赖注入的配置而生成的</li><li>主启动类上的注解<strong><code>@SpringbootApplication</code></strong>是一个复合注解，其中比较重要的<ul><li><code>@SpringbootConfiguration</code>：springboot的相关配置</li><li><code>@EnableAutoConfiguration</code></li><li><code>@ComponentScan</code>：扫描一些包并注入</li></ul></li><li>重点<strong><code>@EnableAutoConfiguration</code></strong>，也是一个复合注解<ul><li><code>@import(AutoConfigurationImportSelect.class)</code></li></ul></li><li><p><code>AutoConfigurationImportSelect</code> implements了<strong><code>DeferredImportSelector</code></strong></p><ul><li><p>因为是Deferred,所以自动配置类会放在最后加载,方便扩展和覆盖</p></li><li><p>其中重写了<strong><code>selectImports()</code></strong>方法：获取所有符合条件的类的全限定类名，加载到IOC容器中</p><ul><li><p>判断是否开启了自动装配：<code>spring.boot.enableautoconfiguration=true</code></p></li><li><p>获取<code>@EnableAutoConfiguration</code>中的<code>exclude</code>和<code>excludeName</code></p></li><li><p>读取所有spring boot start下面的classpath:/META-INF/spring.factories文件(key-value形式)</p></li><li><p>通过<code>@ConditionalOn</code>排除无效的自动配置类</p></li></ul></li></ul></li><li>配置文件的信息如何加载到bean中：classpath:/META-INF/spring.factories文件存储了一些键信息（<strong>SpringBoot约定大于配置的理念</strong>），然后加载的时候配置文件的值就被加载到这个文件中了</li><li>两种<ul><li><code>@Autowired</code>：根据类型自动注入<ul><li><code>@Qualifier</code>：格外指定bean的id（当IOC根据属性类型去容器中找找到多个相同类型的组件的时候需要使用）</li></ul></li><li><code>@Resource</code>：根据bean的名称自动注入<ul><li>这个是Java规范</li></ul></li></ul></li></ul></li><li><p>springboot启动web服务的过程：<code>run()</code>方法里面会创建web服务器，默认是TomcatWebServer，还有jettyWebServer、NettyWebServer、UndertowServletWebServer、UndertowWebServer</p><ul><li>Tomcat：默认</li><li>Jetty：轻量级，适合嵌入式和IoT应用</li><li>Undertow：非常轻量级，启动速度快，支持非阻塞IO</li><li>Netty：高性能</li></ul></li><li><p>配置文件优先级：<code>.properties &gt; .yml</code></p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/image-20240826143834619.png" alt="image-20240826143834619"></p></li><li><p>spring boot的jar包结构</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">mySpringboot.jar</span><br><span class="line">|—— Boot-INF/</span><br><span class="line">| |—— classes/</span><br><span class="line">| |—— lib/</span><br><span class="line">| |—— META-INF/</span><br><span class="line">|—— MEAT-INF/</span><br><span class="line"> |—— MANIFEST.MF 指定了启动类和主类</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">普通jar.jar</span><br><span class="line">|—— com/</span><br><span class="line">|—— MEAT-INF/</span><br><span class="line"> |—— MANIFEST.MF 指定了启动类和主类</span><br></pre></td></tr></table></figure></li></ul><h3 id="10-4-spring-cloud"><a href="#10-4-spring-cloud" class="headerlink" title="10.4 spring cloud"></a>10.4 spring cloud</h3><ul><li>四大板块<ul><li>服务注册中心与配置中心</li><li>负载均衡</li><li>服务容错</li><li>服务治理</li></ul></li><li>配置中心：Zookeeper，nacos。这两个也可以做注册中心</li><li><p>CAP：一致性、可用性、分区容忍性</p><ul><li><p>CA：</p></li><li><p>CP：</p></li></ul></li><li><p>Eureka(AP)、Zookeeper(CP)、Nacos(AP和CP)</p></li><li><p>Nacos：分级存储模型</p><ul><li><p>NameSpace</p></li><li><p>Group</p></li><li><p>Service</p></li><li><p>Cluster</p></li><li><p>instance</p></li></ul></li><li><p>服务降级、服务熔断、服务限流</p></li><li>网关：路由转发、鉴权、缓存加速、协议转换、日志监控、服务保护</li></ul><h2 id="十一-其他中间件"><a href="#十一-其他中间件" class="headerlink" title="十一 其他中间件"></a>十一 其他中间件</h2><h3 id="1-Mybatis"><a href="#1-Mybatis" class="headerlink" title="1 Mybatis"></a>1 Mybatis</h3><ul><li>一种半自动ORM：查询关联对象或关联集合对象时，需要手动编写 sql 来完成</li><li><p>全自动ORM查询时可以不再写SQL。典型的框架如Hibernate</p></li><li><p>xml开发方式</p><ul><li>定义xml</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;tech.pdai.springboot.mysql57.mybatis.xml.dao.IUserDao&quot;</span>&gt;</span>  定义mapper关联的dao</span><br><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">type</span>=<span class="string">&quot;tech.pdai.springboot.mysql57.mybatis.xml.entity.User&quot;</span> <span class="attr">id</span>=<span class="string">&quot;UserResult&quot;</span>&gt;</span>  定义sql返回对象</span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;findById&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;Long&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;UserResult&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">delete</span> <span class="attr">...</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">update</span> <span class="attr">...</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">insert</span> <span class="attr">...</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>定义dao：<code>IUserDao</code>，使用<code>@mapper</code>注解关联，定义xml中相关的对应方法</li><li>定义service及实现类调用dao</li><li>定义controller调用service</li></ul></li><li><p>注解开发</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Results(</span></span><br><span class="line"><span class="meta">        id = &quot;UserResult1&quot;,</span></span><br><span class="line"><span class="meta">        value = &#123;</span></span><br><span class="line"><span class="meta">                @Result(id = true, property = &quot;id&quot;, column = &quot;id&quot;),</span></span><br><span class="line"><span class="meta">                @Result(property = &quot;userName&quot;, column = &quot;user_name&quot;),</span></span><br><span class="line"><span class="meta">                @Result(property = &quot;password&quot;, column = &quot;password&quot;)</span></span><br><span class="line"><span class="meta">        &#125;</span></span><br><span class="line"><span class="meta">)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@ResultMap(&quot;UserResult1&quot;)</span></span><br><span class="line"><span class="meta">@Select(&quot;select u.id, u.password, u.user_name from tb_user u&quot;)</span></span><br></pre></td></tr></table></figure></li><li><p>PageHelper：底层是使用的ThreadLocal存储分页数据-</p><ul><li>只有紧跟在PageHelper.startPage方法后的第一个Mybatis的查询（Select）方法会被分页</li></ul></li><li><p>数据库连接池：C3P0、DBCP、BoneCP、Druid(best)</p></li><li><p>文件上传：异步、分片、断点续传、秒传(如果之前上传过就马上到100%)</p><ul><li>异步：<code>@EnableAsync</code>开启异步，<code>@Async</code>作用于方法，开启子线程执行</li><li>分片：先切割再上传</li><li>断点续传：将分片的chuck md5信息保存在db中，记录上传记录</li><li>秒传：类似断点续传</li></ul></li></ul><h3 id="2-RabbitMQ"><a href="#2-RabbitMQ" class="headerlink" title="2 RabbitMQ"></a>2 RabbitMQ</h3><ul><li>优势在于稳定</li><li>命名中心：namesrv，存储broker、主题、生产消费信息</li><li>路由键、绑定键</li><li>对象<ul><li>producer</li><li>consumer</li><li>exchange：不存储消息，只是用来转发消息<ul><li>direct exchange：根据消息路由键精确匹配队列</li><li>fanout exchange：消息广播</li><li>topic exchange：根据消息路由键匹配队列（通配符* #）</li><li>headers exchange：根据消息头匹配队列</li></ul></li><li>queue</li><li>brocker</li></ul></li><li>如何进入死信队列？<ul><li>消息被拒绝，且requeue参数为false</li><li>消息在队列中过期（TTL）未消费</li><li>队列超出长度限制</li></ul></li><li><p>消息如何路由</p><ul><li>生产者发送消息到交换机</li><li>交换机根据路由键和绑定键发送到一个或多个队内中</li></ul></li><li><p>消息的持久化</p><ul><li><p>将队列和交换机的Durable设置为True</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/image-20240819175128997.png" alt="image-20240819175128997"></p></li></ul></li><li><p>不足</p><ul><li>性能：相比于kafka来说性能较低，常用于中小企业</li><li>开发语言限制，是erlang</li></ul></li><li>rabbitMQ实现延迟队列<ul><li>本身不支持，通过TTL（消息存活时间） 和 DLX（死信交换机）</li></ul></li></ul><h3 id="3-kafka"><a href="#3-kafka" class="headerlink" title="3 kafka"></a>3 kafka</h3><ul><li><p>优势在于快、吞吐量大</p></li><li><p>命名中心：zookeeper，存储broker、主题、生产消费信息，协调服务实现故障监听与转移</p><ul><li>特点：强一致性，zookeeper中某个节点发生数据变化，会通知其他节点通知更新，超过半数更新完毕才算写入完成</li></ul></li><li><p>对象：</p><ul><li><p>producer</p></li><li><p>consumer</p><ul><li>需要自己从 broker 拉取消息，一个 consumer 连接到一个 partition ，从中依次读取消息，动态的更新 offset</li><li>采用pull的方式的好处是可以避免consumer处的消息堆积</li><li>多个 consumer 构成一个消费组group，一个group只负责一个topic，group会保证一条消息只被一个consumer消费</li></ul></li><li><p>brocker：服务器，多个brocker组成集群</p></li><li><p>topic：消息主题</p></li><li><p>partition：主题内分区，物理上分区，实现负载均衡</p><ul><li>一个topic分为多个partition，partition内部的消息是有序的(offset偏移量)，但是对于topic来说，消息是无序的</li><li>消息写入partition：hash（注意热点问题）、轮询、自定义</li><li>多个partition可以放到多个broker，进行水平能力的扩展</li></ul></li><li><p>group：消费者组</p><ul><li>1个topic可以对应多个group</li></ul><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/image-20240828145638999.png" style="zoom:50%;" /></p></li></ul></li><li><p>特性</p><ul><li>高吞吐、低延迟，收发消息很快（零拷贝技术<code>sendfile()</code>）</li><li>高伸缩性：每个主题topic包含多个分区partition，主题中的分区可以分布在不同的主机brocker中</li><li>持久行、可靠性：可持久化数据，底层十基于Zookeeper存储的</li><li>容错性：允许集群中的节点失败，某个节点宕机、kafka集群能够正常工作</li></ul></li><li><p>使用场景</p><ul><li>活动跟踪：跟踪用户行为，浏览数据发送的kafka，生成报告进行个性化展示</li><li>传递消息</li><li>日志记录：把数据库的更新发送到Kafka上，用来记录数据库更新，落hive表等</li><li>流式处理</li><li>限流、削峰、解耦</li></ul></li><li><p>模式</p><ul><li>点对点</li><li>发布订阅模式</li></ul></li><li><p><strong>为什么kafka快？</strong></p><ul><li>顺序读写：<ul><li>kafka将来自product的数据，顺序追加在partition，partition就是一个文件，以此实现顺序写入</li><li>consumer从broker读取数据时，因为自带了偏移量，接着上次读取的位置继续读，以此是实现顺序读</li></ul></li><li>零拷贝<code>sendfile()</code>。最重要<ul><li>为什么rocketmq不用<code>sendfile</code>而用<code>mmap</code>，因为其将所有的队列的数据都写入了commitLog，消费者批量消费时需要读出来进行应用层过滤(要进入用户态)，所以不用</li></ul></li><li>页缓存(page cache)：消息写道page cache中，等系统统一写入磁盘（可能会有丢失，比如断电）</li><li>批量接收和发送消息。减少网络开销</li></ul></li><li><p>美团mafka相对于kafka的改进</p><ul><li>多租户支持，隔离流量</li><li>性能优化</li><li>内支持运维工具，兼容性</li></ul></li><li><p>如何保证消息不丢失？</p><ul><li>从生产者到broker：做好try catch，以及重试</li><li>brocker存储消息：在消息刷盘后再给生产者响应，集群部署的话还需要写到副本</li><li>从broker到消费者：保证消费者消费完业务后再返回给brocker信息，然后是注意消息消费的幂等性（版本号、唯一键、关键key等）</li></ul></li><li><p>如何保证消息不被重复消费？</p><ul><li>消息队列的幂等性机制，全局id</li><li>消费者自身维护消息的消费记录</li><li>分布式锁</li></ul></li><li><p>消息堆积问题？</p><ul><li>增加topic分区数量，对消费者扩容</li><li>下游拉取数据的时候提高获取批量</li></ul></li><li><p>kafka的事务？让插入的多个topic要么全成功，要么全失败</p></li><li><p>如何保证消息的有序性？</p><ul><li>单分区内消息的有序的，消费者根据offset来顺序消费消息</li><li>生产者：利用key来指定特定的分区，通过单分区的有序性来保证有序性</li><li>消费者：确保每个分区仅被组内一个消费者实例消费，可通过设置消费者组内消费者的并发度为分区数或小于分区数来达到这个目的。</li><li>以上是对于并发比较低的情况（所有消息都存储在了一个分区），对于多分区下的顺序消费：对业务加id，比如订单ID，用户ID等</li></ul></li><li><p>kafka分区数量怎么确定</p><ul><li>分区对生产者、消费者、broker的影响<ul><li>生产者：客户端producer有个参数batch.size，为分区缓存消息，分区越多，这部分越大</li><li>broker：维护分区成本</li><li>消费者：数据获取的内存；创建线程的开销</li></ul></li></ul></li></ul><ul><li>如何确定：<ul><li>创建只有1个分区的topic</li><li>测试这个topic的生产消费者吞吐量</li><li>分区数 = 目标吞吐量 / max(生产者，消费者)</li></ul></li></ul><ul><li><p>如何提高kafka的吞吐量</p><ul><li><p>分区</p><ul><li>大型数据的时候使用随机选择分区</li></ul></li><li><p>broker</p></li><li><p>生产者</p><ul><li>批量发送（减少IO和网络）：batch.size</li></ul></li><li><p>消费者</p><ul><li>使用固定大小的缓存区，最好是堆外内存（gc）</li><li>批量获取</li></ul></li></ul></li></ul><ul><li>消费者数量和分区数量：可以将消费者数量设置为Kafka集群分区数量的两到三倍</li></ul><h2 id="十二-RPC"><a href="#十二-RPC" class="headerlink" title="十二 RPC"></a>十二 RPC</h2><ul><li><strong>RPC</strong>（<strong>R</strong>emote <strong>P</strong>rocedure <strong>C</strong>all），又叫做<strong>远程过程调用</strong>。它本身并不是一个具体的协议，而是一种<strong>调用方式</strong><ul><li>gRPC，thrift</li></ul></li><li>发展历史：TCP ==&gt; RPC ==&gt; HTTP</li><li>为什么有了RPC还要有HTTP？<ul><li>RPC 是针对于Client/Server (C/S) 架构下使用的，如果只需要连接自家的服务器，用RPC是足够的，但是浏览器Browser/Server (B/S)架构，需要访问其他公司的服务器，所以诞生了HTTP</li></ul></li><li>RPC框架<ul><li>Dubbo：阿里巴巴开源，仅支持java</li><li>Spring Cloud：仅支持java</li><li>gRPC：google开源，多语言</li><li>Thrift：facebook开源，多语言</li></ul></li><li>Thrift组件<ul><li>Transport：传输组件，负责网络读写相关</li><li>Protocol：协议和解编码组件，负责对网络数据传输的序列/反序列化</li><li>Processor：服务调用组件</li><li>Server：服务器</li></ul></li><li>基本过程<ul><li>客户端发起调用</li><li>客户端存根stub处理：根据调用的方法名、参数等打包编码为特定格式的消息体</li><li>网络传输</li><li>服务端存根stub处理：进行拆包和解码，获取方法名和参数</li><li>服务端执行调用</li><li>逆向返回结果</li></ul></li><li>泛化调用<ul><li>在不依赖服务A（没有服务A提供的接口）情况下远程调用服务A的接口</li><li>只要调用端将服务需要知道的信息：接口名、业务分组名、参数等封装为请求发送给服务器，服务端解析并处理即可</li><li>实现：<ul><li>通过一个<code>GenericService</code>来生成动态代理，来实现在没有接口情况下的RPC调用</li><li>对于服务端，在获取Tprotocol时，会判断是否泛化调用，如果是泛化调用，会向泛化调用，会向链路中添加泛化调用标识，用于服务端判断是否是泛化调用</li><li>在调用时，与普通的调用基本一致，会在请求中额外添加被调用的服务名、方法名等信息在请求header中，用于服务端处理时查找相应的类信息</li><li>处理请求时，根据客户端传递的标识，判断是否是泛化调用，如果是则使用<code>GenericServiceTProcessor</code>处理请求</li></ul></li></ul></li><li>如何手写一个RPC框架？<ul><li>动态代理（屏蔽底层调用细节）</li><li>序列化（网络传输扁平化数据）：二进制、json等</li><li>协议（识别数据）</li><li>网络传输（I/O相关，一般使用netty，基于Java NIO做的封装）：同步非阻塞IO</li><li>对于多集群来说，还需要一个注册中心做服务发现、路由、负载均衡、异常重试、限流熔断等</li></ul></li><li>RPC和HTTP？<ul><li>层级<ul><li>Http位于应用层，基于TCP/IP</li><li>RPC不是网络模型中的具体层级的协议，它的实现可以依赖于HTTP(应用层)，也可以依赖于TCP(多数)或者UDP</li></ul></li><li>服务发现：<ul><li>HTTP是通过DNS获取到IP地址和端口信息</li><li>RPC是通过专门的中间服务去做。注册中心</li></ul></li><li>底层连接形式：<ul><li>主流的Http1.1建立TCP连接后会保持连接(keep live)，之后的请求相应复用</li><li>RPC一般会有一个连接池。不过不少的编程语言会给http加一个连接池(golang)</li></ul></li><li>传输内容<ul><li>HTTP以传输文本为主，一般header和body使用JSON序列号反序列化做</li><li>RPC定制化程度高，可以采用定制化的协议存储数据结构体</li><li>ps：其实http2之后进行了很多的改进，性能可能比RPC更好，gRPC底层用的就是Http2</li></ul></li><li>通信瓶颈：<ul><li>RPC主要在于网络、序列反序列化开销、服务器负载、协议开销</li><li>http主要在于TCP连接建立、http头部冗余、请求/响应模型的限制、加密解密的开销</li></ul></li></ul></li></ul><h2 id="十三-异步"><a href="#十三-异步" class="headerlink" title="十三 异步"></a>十三 异步</h2><ul><li>为什么需要异步？<ul><li>调用多个下游服务，串行调用容易导致时间过长的问题</li></ul></li><li>异步和多线程的区别？<ul><li>资源利用率：异步通常基于回调机制，允许在等待IO的时候释放线程，线程池会阻塞等待</li><li>编码复杂性：多线程需要处理线程同步，线程安全等问题</li><li>场景：异步适用于IO密集，多线程适用于CPU密集型</li></ul></li></ul><h3 id="13-1-CompletableFuture"><a href="#13-1-CompletableFuture" class="headerlink" title="13.1 CompletableFuture"></a>13.1 CompletableFuture</h3><p><a href="https://tech.meituan.com/2022/05/12/principles-and-practices-of-completablefuture.html">https://tech.meituan.com/2022/05/12/principles-and-practices-of-completablefuture.html</a></p><ul><li><p>实现了两个接口：<code>Future</code> 和 <code>Completionstage</code>，前者是java5引入的异步计算，后者用于表示异步执行过程中的一个步骤(<code>thenApply()</code>、<code>thenCombine()</code>等都是<code>Completionstage</code>的方法)</p></li><li><p>原理：观察者模式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CompletableFuture</span>&lt;T&gt; <span class="keyword">implements</span> <span class="title class_">Future</span>&lt;T&gt;, CompletionStage&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">volatile</span> Object result; <span class="comment">// 存储CF执行结果</span></span><br><span class="line">    <span class="keyword">volatile</span> Completion stack;<span class="comment">// 栈结构，stack为栈顶。表示当前CF当前完成后需要触发的依赖动作</span></span><br><span class="line">    <span class="comment">// CompletableFuture中的每个方法都对应了一个Completion子类，Completion本身是观察者的基类</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>Future</code>的局限性</p><ul><li>向线程池提交异步任务发起RPC调用，主线程只能阻塞获取Future结果</li><li>调用RPC服务通常需要回调的方法完成Future，Future的执行结果依赖向线程池提交的任务返回结果，不支持通过回调的方式来设置返回结果</li><li>多个RPC串行执行，后一个RPC依赖前一个响应结果，主线程阻塞组装调用关系，没有回调唤醒机制，主线程反复被阻塞</li><li>多个RPC串行执行，后面的RPC依赖前两个RPC的结果作为入参。主线程阻塞等待，当相互依赖的RPC较多时，代码可读性差</li><li>Future提供的接口没有异常处理的功能，不能异步处理异常，只能try检查get方法是否抛出异常</li></ul></li><li><p>使用</p><ul><li><p>创建</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> CompletableFuture&lt;Void&gt; <span class="title function_">runAsync</span><span class="params">(Runnable runnable)</span>; <span class="comment">// 创建无返回任务的异步任务</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> CompletableFuture&lt;Void&gt; <span class="title function_">runAsync</span><span class="params">(Runnable runnable, Executor ex)</span>; <span class="comment">// 指定线程池</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;U&gt; CompletableFuture&lt;U&gt; <span class="title function_">supplyAsync</span><span class="params">(Supplier&lt;U&gt; supplier)</span>; <span class="comment">// 创建有返回值的...</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;U&gt; CompletableFuture&lt;U&gt; <span class="title function_">supplyAsync</span><span class="params">(Supplier&lt;U&gt; supplier, Executor ex)</span>; <span class="comment">// </span></span><br></pre></td></tr></table></figure></li><li><p>异步回调</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;U&gt; CompletionStage&lt;U&gt; <span class="title function_">thenApply</span><span class="params">(Function&lt;? <span class="built_in">super</span> T, ? extends U&gt; var1)</span>; <span class="comment">// 串行,返回的是一个嵌套的CF，需要get() join()解开</span></span><br><span class="line">CompletionStage&lt;Void&gt; <span class="title function_">thenAccept</span><span class="params">(Consumer&lt;? <span class="built_in">super</span> T&gt; var1)</span>; <span class="comment">// 串行，无返回值</span></span><br><span class="line">thenCombine <span class="comment">// 二元依赖 A B都执行完再到C，直接返回CF，比thenApply方便</span></span><br><span class="line">thenCompose <span class="comment">// 串行执行</span></span><br><span class="line">allOf</span><br><span class="line">anyOf</span><br></pre></td></tr></table></figure></li><li><p>异常处理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">handle</span><br></pre></td></tr></table></figure></li><li><p>结果获取(注意设置超时时间)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">join</span><br><span class="line">get</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="13-2-Loader"><a href="#13-2-Loader" class="headerlink" title="13.2 Loader"></a>13.2 Loader</h3><ul><li>为解决代码难以读懂的问题，一个Loader加载若干个异步调用，通过Loader工厂加载loader</li></ul><h3 id="13-3-Director"><a href="#13-3-Director" class="headerlink" title="13.3 Director"></a>13.3 Director</h3><ul><li>为解决代码难以调试的问题，本质是维护一个有向无环图，来实现异步调用的加载</li></ul><h2 id="十四-项目场景"><a href="#十四-项目场景" class="headerlink" title="十四 项目场景"></a>十四 项目场景</h2><h3 id="14-1-课程秒杀活动"><a href="#14-1-课程秒杀活动" class="headerlink" title="14.1 课程秒杀活动"></a>14.1 课程秒杀活动</h3><ul><li><p>瞬间流量</p><ul><li><p>前端：</p><ul><li><p>缓存静态资源</p></li><li><p>防止多次重复点击</p></li><li><p>前端到后端的限流（若干个请求取随机部分到后端）</p></li></ul></li><li><p>后端</p><ul><li>热点数据行，删除库存变为insert（容易超卖——lua脚本）</li><li>库存拆分，分解到不同的数据库中减小单库压力</li><li>消息队列：削峰填谷，非核心业务放到后面做</li></ul></li></ul></li><li><p>超卖（数据一致性）</p><ul><li>分布式锁（redis）</li><li>redis+lua，保证操作的原子性——这里注意添加一条消息存储订单数据</li><li>幂等性设计</li></ul></li><li><p>业务降级和代码降级</p></li></ul><h3 id="14-2-订单超时取消"><a href="#14-2-订单超时取消" class="headerlink" title="14.2 订单超时取消"></a>14.2 订单超时取消</h3><ul><li>定时任务：xxl-job，比如定时1min扫描一次表，以时间戳+状态来取数据，判断数据是否超时</li><li>redis缓存，设置缓存存在时间：在点击下单的时候给redis设置一个定时缓存，支付的时候再判断缓存是否存在</li><li>延时队列<ul><li>消息队列的延时任务：下单的是发送一条延时队列（rocketMQ支持，rabbit MQ和kafka需要设计）</li><li>redis zset 也可以实现：任务添加到zset，到期时间作为score，获取score值最小的元素与系统时间的关系，没到期就sleep</li></ul></li></ul><h3 id="14-3-统计接口的调用次数"><a href="#14-3-统计接口的调用次数" class="headerlink" title="14.3 统计接口的调用次数"></a>14.3 统计接口的调用次数</h3><ul><li>ConcurrentHashMap&lt;接口名, 次数&gt; + AtomicInteger + 定时任务</li><li>MQ</li><li>日志打点记录，后台记录到es中</li></ul><h3 id="14-4-项目中的文件上传系统"><a href="#14-4-项目中的文件上传系统" class="headerlink" title="14.4 项目中的文件上传系统"></a>14.4 项目中的文件上传系统</h3><ul><li>大文件上传：分块上传，再合并，比较md5码</li><li>如何避免重复文件：md5</li><li>限流：限制上传次数、频次、总文件大小</li></ul><h3 id="14-5-限流怎么做"><a href="#14-5-限流怎么做" class="headerlink" title="14.5 限流怎么做"></a>14.5 限流怎么做</h3><ul><li>redis 分布式锁、incr对象</li><li>漏桶算法（宽进严出）：队列实现</li><li>令牌桶算法：定速往桶里放令牌，请求来的时候如果桶里有令牌就拿令牌走，没令牌就放弃（面对突发流量有更好的表现）</li></ul><h3 id="14-6-序列化错误问题"><a href="#14-6-序列化错误问题" class="headerlink" title="14.6 序列化错误问题"></a>14.6 序列化错误问题</h3><ul><li>设计<code>StereoWarehouse</code>的后期新增了一个字段，运行客户端打开之前做的案例的时候发现模型无法正常打开，查看报错发现反序列化失败，后续排查的时候发现<code>BaseObj</code>对象是被序列化存储在磁盘中的，未显示的指定<code>serialVersionUID</code>，jdk会根据当前类的结构，继承关系等信息计算出一个序列号，当类的信息发生变化的也发生了变化，导致反序列化失败</li><li>解决：设计的demo模型比较简单，重新做了一个并fix了这个bug</li><li>也可以回退版本，显示的指定序列号后保存，再更新到当前版本后打开。</li></ul><h2 id="十五-面试"><a href="#十五-面试" class="headerlink" title="十五 面试"></a>十五 面试</h2><h3 id="8-23-快手1"><a href="#8-23-快手1" class="headerlink" title="8.23 快手1"></a>8.23 快手1</h3><ul><li>自我介绍 MT 4min，FS 3min，XC没让介绍了，基本就在问MT实习，问了下实习了多久</li><li>介绍一下做的项目中给你带来最多收获的 ： 统一履约接口，事件分发，RPC，泛化调用，异步框架</li><li>RPC用的什么，为什么快： thrift，<ul><li>自定义传输协议，精简；二进制传输，http是json序列反序列；RPC服务基于TCP/IP，长连接</li></ul></li><li>说一下泛化调用 ： 调用方没有服务方提供的API（SDK）的情况下，对服务方进行调用</li><li>RPC最主要的是什么 ： 一开始说了代理、网关面试官提示了一下，是服务注册上报</li><li>MQ用的什么： kafka，</li><li>怎么了解的 kafka：对比了rabbitMQ和kafka的区别：分区；顺序读写；零拷贝；页缓存(数据丢失原因)；批量收发</li><li>异步框架是什么：CF，loader，director框架，讲了一下框架的底层原理</li><li>讲一个业务开发，设计到了什么技术：KA，讲了一下kafka2hive，讲了日志打点的设计发展历程体现一下自己的思考（rpc接口 —&gt; 耦合高；注解解耦 —&gt; 历史代码不好处理；最后才一个一个搞）<ul><li>补充了一下sdk的方式</li></ul></li><li>MT转正情况</li><li>怎么理解error和exception：都继承了Throwable，前者不可恢复，后者用于catch处理业务异常IOException和RuntimeException</li><li><strong>为什么只有java才有exception</strong><ul><li>准确的说是只有java会强制check exception，核心目标是划分责任</li></ul></li><li><strong>数据结构：堆和栈</strong><ul><li>堆：堆通常是一个可以被看做一棵树的数组对象</li><li>栈：是只允许在一端进行插入或删除的线性表</li></ul></li><li><strong>操作系统：堆和栈</strong><ul><li>堆：堆是在程序运行时申请的动态内存，而不是在程序编译时，申请某个大小的内存空间。</li><li>栈：是操作系统在建立某个进程时或者线程，为这个线程建立的存储区域，在编译的时候可以指定需要的栈的大小</li></ul></li><li>DFS和BFS：深度和广度优先</li><li>网络4层结构和7层：应用层、传输层、网络层、网络接口层<ul><li><strong>7层</strong>：应用层、表示层、会话层、传输层、网络层、数据链路层、物理层</li></ul></li><li>http和https区别：多了一个tls，CA非对称加密算法</li><li><p>为什么用非对称又用对称加密：速度</p></li><li><p>讲一下设计模式</p><ul><li>build模式：实现构造器的按需创建</li><li>工厂模式：封装对象的创建，IOC思想</li><li>装饰模式：IO</li></ul></li><li>spring中的设计模式<ul><li>工厂模式：Factory</li><li>代理模式：AOP</li><li>单例模式：单例bean</li><li>适配器模式：Spring AOP的<code>AdvicorAdapter</code></li><li>观察者模式：<code>ApplicationListener</code>，CF也使用到了观察者模式</li><li>责任链模式</li></ul></li><li><p>手撕：两数之和</p><ul><li>用一个map，O(N)，当时没反应过来，用的for</li></ul></li><li><p>总结：面试官太好了 疯狂给机会</p></li></ul><h3 id="8-24-快手2"><a href="#8-24-快手2" class="headerlink" title="8.24 快手2"></a>8.24 快手2</h3><ul><li><p>自我介绍 MT 3min40s，FS 2min，XC 2min</p></li><li><p>上线是自己上的还是？mentor</p></li><li><p>困难点？RPC，异步框架</p></li><li><p>遇到的问题？升级jar依赖冲突，回滚</p></li><li><p>事后有复盘吗？没有</p></li><li><p><strong>BeanFactory和FactoryBean</strong>？BeanFactory是IOC基础，常用ApplicationContext；FactoryBean是工厂类的接口，负责创建bean</p><ul><li><p>BeanFactory</p><ul><li>bean实例化和管理：BeanFactory负责创建、初始化和管理Bean的生命周期。它会根据配置文件中定义的Bean定义来创建Bean的实例。</li><li>依赖注入：BeanFactory负责解决Bean之间的依赖关系，确保每个Bean都能获取它所依赖的其他Bean</li><li>配置元数据的管理：xml、注解、Java配置的数据</li><li>延迟初始化：lazy</li><li>AOP支持</li><li>通常不直接使用，用ApplicationContext</li></ul></li><li><p>FactoryBean</p><ul><li><p>自定义bean创建过程</p></li><li><p>懒加载</p></li><li><p>bean的包装：创建代理</p></li><li><p>处理复杂逻辑</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">FactoryBean</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">OBJECT_TYPE_ATTRIBUTE</span> <span class="operator">=</span> <span class="string">&quot;factoryBeanObjectType&quot;</span>;</span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    T <span class="title function_">getObject</span><span class="params">()</span> <span class="keyword">throws</span> Exception;</span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    Class&lt;?&gt; getObjectType();</span><br><span class="line">    <span class="keyword">default</span> <span class="type">boolean</span> <span class="title function_">isSingleton</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AFactoryBean</span> <span class="keyword">implements</span> <span class="title class_">FactoryBean</span>&lt;A&gt; &#123;</span><br><span class="line"><span class="keyword">public</span> A <span class="title function_">getObject</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">A</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">getBean(<span class="string">&quot;A&quot;</span>)会得到A这个bean</span><br><span class="line"><span class="title function_">getBean</span><span class="params">(<span class="string">&quot;&amp;A&quot;</span>)</span>会得到AFactoryBean</span><br></pre></td></tr></table></figure></li></ul></li></ul></li></ul><ul><li><p><strong>举例一下FactoryBean，可以从框架出发</strong></p><ul><li>mybatis：SqlSessionFactory</li></ul></li><li><p>spring的设计模式：单例、责任链、代理、观察者、工厂</p></li><li><p>为什么用单例模式：</p><ul><li>一个全局使用的类频繁地创建与销毁</li><li>节省系统资源</li></ul></li><li><p>消息堆积怎么处理？</p><ul><li>生产者：业务层面消息精简</li><li>broker：增加分区，先持久化存储</li><li>消费者：扩容</li><li>批量消费</li><li>降级处理</li></ul></li><li><p>能无线扩容吗？不能，举例了redis集群分片哈希槽</p></li><li><p><strong>关于跨域问题？</strong></p><ul><li>由于浏览器的同源策略：协议、主机名、端口号，任何一个不一致都会导致跨域问题</li><li>JSONP：利用了<code>&lt;script&gt;</code>标签不受同源策略限制的特性</li><li>CORS：Http请求头，服务器在响应头添加<code>Access-Control-Allow-Origin</code></li><li>反向代理：反向代理服务器和服务端在一个域名下，可以实现转发</li><li>WebSocket：可以用于跨域通信</li><li>spring处理方案<ul><li>Controller添加<code>@CrossOrigin</code>注解</li><li>添加<code>WebMvcConfiguration</code>全局配置</li><li>Filter</li><li>GateWay端增加CorsFilter拦截器</li></ul></li></ul></li><li><p>ThreadLocal的理解？ThreadLocalMap，对Entry是一个弱引用，内存泄漏风险</p><ul><li>Entry的key是ThreadLocal，v是设置的值</li><li>gc的时候如果外部对ThreadLocal没有强引用会回收ThreadLocal，导致entry的key是null，但是value没有被回收</li></ul></li><li><p>ThreadLocal可以被继承吗？不能</p></li><li><p>如果子线程需要继承怎么办？<code>public class InheritableThreadLocal&lt;T&gt; extends ThreadLocal&lt;T&gt;</code></p></li><li><p>mysql的锁机制？</p><ul><li>乐观锁</li><li>悲观锁<ul><li>表锁</li><li>行锁 innodb<ul><li>行锁</li><li>间隙锁（幻读）</li></ul></li></ul></li></ul></li><li><p>MVCC的理解</p><ul><li>隐藏主键</li><li>undolog</li><li>readview</li></ul></li><li><p>MVCC和锁？MVCC不加锁，事务并发修改</p></li><li><p><strong>如果遇到网站攻击怎么处理？</strong>讲了大量请求用黑名单、直接攻击数据库用redis缓存</p><ul><li>CC攻击（应用层）：大量的请求——网关黑名单</li><li>DDOS攻击（多个层面）：利用大量的计算机和代理服务器同时向服务端发送大量请求。比如SYN攻击、UDP攻击、ICMP攻击<ul><li>流量清洗</li></ul></li><li>CC攻击模拟了正常请求，更能防御</li></ul></li><li><p>做的项目用了什么设计模式？</p><ul><li>AOP</li></ul></li><li><p>手撕：int num交换两位使得数字结果最大，上午刚写完oppo笔试手感火热秒了</p></li><li><p>聊天环节：电商、直播、广告、游戏，前三者基本饱和，目前发展游戏——自研化、精品化</p><ul><li>对内平台工具、对外登录、支付、防沉迷等</li><li>杭州</li></ul></li></ul><h3 id="8-26-淘天1"><a href="#8-26-淘天1" class="headerlink" title="8.26 淘天1"></a>8.26 淘天1</h3><ul><li>淘工厂</li><li>自我介绍 MT 3min，FS 2min，XC 跳过</li><li>转正情况</li><li>MT技术架构</li><li>项目有没有本地运行</li><li>spring没有启动起来怎么排查问题：启动日志</li><li>日志输出在哪里？log4j</li><li>升级jar包后bean没有依赖的问题是什么？这段答的比较差</li><li>mybatis使用的是声明？xml，显式的时候sql</li><li>显式的使用sql有什么问题</li><li>写sql的时候考虑的效率问题？慢查询——联表放在业务、命中索引</li><li>如何考虑建立索引？</li><li>索引的类型</li><li>如何分析慢查询？explain</li><li>MT redis使用场景？缓存、分布式锁</li><li>redis和mysql如何保证数据一致性？旁路缓存、读写穿透、异步缓存</li><li>为什么先更新数据库再删除redis？高并发下的数据一致</li><li>kafka使用场景</li><li>为什么需要kafka2hive？方便查询</li><li>PRC调用的流程？依赖client、配置bean、调用</li><li>RPC版本升级怎么处理？如果接口中新增参数，会不匹配报错</li><li><strong>如果接口的对象删除了一个字段有没有问题？</strong><ul><li>用的json，会忽略额外的字段，比如A对象ab 2个字段，传入的JSON有abc 3个字段，那么序列化的时候只会注入ab两个字段</li></ul></li><li>反问环节？业务：淘工厂</li></ul><h3 id="8-26-字节1"><a href="#8-26-字节1" class="headerlink" title="8.26 字节1"></a>8.26 字节1</h3><ul><li>MT 3min，FS 2min，XC 0</li><li>遇到的问题？商家履约一体化对RPC和异步的理解</li><li>RPC的超时时间？全局定义，bean定义</li><li>CF的理解？底层是维护了一个栈结构</li><li>多次部分退背景，面临的问题，如何处理涉及商品券商品的处理</li><li>灰度、降级开关的目的，设置原则</li><li>灰度如何实现？代码层面，也有平台层面</li><li>上线后如何观测？业务上商家反馈，代码上观察日志</li><li>KA大盘上报过程？监控平台提供上报SDK，wm sg yy phf调用<ul><li>可以说一下方式的演变（KS）</li></ul></li><li>线上问题举一个例子？网关无限重试问题<ul><li>线下环境一直推送订单给KD，KD因为缓存接口地址错误，导致一直请求到线上，出现大量告警</li><li>初步措施：网关限流</li><li>排查：网关回调和通知策略一致，导致失败的时候还进行了重试，引发循环调用</li><li>为什么线上没有问题：7.9-7.11hive没有失败数据</li><li>短期方案：改为不额外通知，只有最后失败的时候才通知</li><li>长期方案：<ul><li>网关对推送加标，进行过滤</li><li>WM差异化处理延迟和回调接口</li></ul></li></ul></li><li>没有做打点吗？这里记错了，客诉产生的同时也出现了线上告警</li><li>并发安全？分布式锁；并发集合类</li><li>分布式锁怎么用的？订单索引模型，redis setnx</li><li>分布式锁过期问题？看门狗机制，代码中没用过</li><li>线程池？复用线程减少创建销毁的性能开销，核心参数</li><li>核心线程数设置原则？任务类型，IO or CPU</li><li>消息队列？解耦，削峰填谷，<strong>异步</strong></li><li>如何保证消息不被重复消费？保证事务的幂等，给消息设置一个全局唯一的id</li><li>spring bean的生命周期<ul><li>bean构造函数、setter、aware接口、BeanPostProcessor接口、InitializingBean接口、init方法、BeanPostProcessor接口、使用、DisposableBean接口，DisposableBean方法</li></ul></li><li>mysql 慢查询问题？explain<ul><li>开启慢查询日志</li></ul></li><li><p><strong>最左匹配原则</strong>，(a,b,c) 如果使用了(a,c)也会使用，只不过只会命中a </p></li><li><p>链表倒数第k个节点</p></li><li>做的中台</li></ul><h3 id="8-27-百度1"><a href="#8-27-百度1" class="headerlink" title="8.27 百度1"></a>8.27 百度1</h3><ul><li>MT 2min30s，FS 2min30s，XC 30s</li><li>web服务和客户端的区别？资源的存放</li><li><p>简述一下履约组的业务，怎么学习的，技术架构，如何划分的微服务？订单全生命周期</p></li><li><p>RPC和HTTP？</p></li><li><p>HTTP和TCP长连接的含义？</p><ul><li>HTTP协议的长连接和短连接，本质上是TCP协议的长连接和短连接。</li><li>HTTP1.0默认短连接，当客户访问一个web资源的时候，每遇到一个资源就建立一个tcp连接</li><li>HTTP1.1默认长连接，当一个网页打开后不会断开，复用TCP的连接</li></ul></li><li>短连接谁主动断开？一般是客户端</li><li><strong>长连接如何判断包的顺序</strong>？比如发出A，B两个请求，如何判断收到的C响应对应的哪个？<ul><li>传输层：TCP层面来说有序列号</li><li>应用层：HTTP在请求头或者请求体中添加UUID</li><li>HTTP2使用了流来隔离每个请求和响应</li></ul></li><li>异步框架？CF</li><li>线程池如何定义？核心线程数设置原则</li><li>最大线程数的设置原则</li><li><p>线程池释放空闲线程是怎么选择的？推测可能是LRU</p><ul><li>根据keepAliveTime，JVM当前状态等，具体会删哪个无法推测</li></ul></li><li><p>IOC和AOP</p></li><li>bean的生命周期</li><li>IOC底层的数据结构</li><li><p>循环依赖</p></li><li><p>kafka？分区、0拷贝</p></li><li>0拷贝？没有用户态和内核态的切换，没有CPU的拷贝（DMA）</li><li><strong>分区数量和生产者、消费者的数量关系</strong><ul><li>1个 producer 可以生产不同 topic 的消息，</li><li>1个 topic 的消息被存放到不同的分区 partition 中，可以指定也可以 hash 自动计算</li><li>partition 的消息以 offset 的偏移顺序存储</li><li>1个topic的消息被多个consumer消费，这些consumer组成group，单个partition的消息只能由单个consumer消费，主动拉取的方式并更新offset偏移量</li><li>1个topic也可以有多个consumer group</li></ul></li><li>字符串中第一个只出现1次的字符。用的linkedHashMap<ul><li>用一个int[52] 即可</li></ul></li></ul><h3 id="8-31-得物1（全八股）"><a href="#8-31-得物1（全八股）" class="headerlink" title="8.31 得物1（全八股）"></a>8.31 得物1（全八股）</h3><ul><li><p>自我介绍</p></li><li><p>mysql索引结构，其他的数据结构呢？hash、二叉树、AVI树、红黑树、B+树</p></li><li>如何考虑自建索引？</li><li>mysql事务</li><li><p>不可重复读和幻读的解决？MVCC，以及加间隙锁</p></li><li><p>间隙锁的缺点？并发性能，死锁问题</p></li><li><p>死锁条件以及破坏？4个</p></li><li><p>redis分布式锁</p></li><li>redis setnx为什么是原子性？单线程</li><li>IO模型，多路复用这些</li><li>异步模型的应用？讲了Future，</li><li>算法：三数之和为0<ul><li>三指针，排序，固定a，然后从b=a+1 c=arr[n-1]，b c指针向中间靠，复杂度O(n2)</li></ul></li></ul><h3 id="8-31-pdd1"><a href="#8-31-pdd1" class="headerlink" title="8.31 pdd1"></a>8.31 pdd1</h3><ul><li>自我介绍</li><li>MT主要难点：RPC的异步编排，Loader，Director</li><li>如果是一个任务不涉及到RPC，用单线程还是多线程？单线程<ul><li>ListenableFuture</li></ul></li><li>使用线程池的缺点？只讲到了线程上下文切换的性能开销<ul><li>切换性能开销</li><li>线程池管理开销</li><li>任务调度延迟</li></ul></li><li>java的线程是用户态还是内核态？用户态</li><li>两者区别，<strong>从用户切换的内核方式</strong>？系统调用<ul><li>中断：当硬件设备（如时钟、中断控制器、I/O设备）发生事件时，会触发中断。中断会强制CPU从当前正在执行的用户态代码切换到内核态，以执行相应的中断处理程序。</li><li>系统调用</li><li>异常：异常是由CPU在执行指令时检测到某些错误或特殊情况（如除零、无效内存访问、缺页等）引发的。异常会导致从用户态切换到内核态，以便操作系统处理这些异常。</li></ul></li><li>ConcurrentHashMap</li><li>java锁的底层锁的是什么？只回答到了对象上的描述文件（忘了叫啥了）<ul><li>对象头的Mark Word：存储锁的信息，如锁的状态、线程ID、哈希码</li><li>java对象头<ul><li>Mark Word：哈希码（HashCode）、GC标记、锁标志位、锁的线程ID、偏向锁的线程ID、年龄信息等。</li><li>Class Pointer（类型指针）：通过它找到存储的实例</li><li>Array Length（数组长度，只有数组对象有）</li></ul></li></ul></li><li>JVM结构</li><li>堆的划分：老年和新生，CMS和G1</li><li>MT用的什么：CMS</li><li>新生代细分：Eden，S0，S1</li><li>手撕：很离谱的手撕（面试官自己想的）<ul><li>一个list存储了若干个Item，Item的内部有一个String text的对象，表示RPC请求内容，要求将这个list表示的若干个请求分发为多次发送，使得每次请求的Item数量不超过一个max值且数量尽可能的均匀，对于每次请求，是由若干个Item组成，要求Item的长度尽可能的相等（一个Item可以被切割为若干份）</li><li>不知道他在说什么，题目也改来改去</li></ul></li></ul><h3 id="9-2-oppo1"><a href="#9-2-oppo1" class="headerlink" title="9.2 oppo1"></a>9.2 oppo1</h3><ul><li>自我介绍</li><li>多次部分退背景，做了哪些开发</li><li>设计模式，开发过程中用了哪些模式</li><li>fs开发，怎么做的节拍统计</li><li>遇到的问题？fs的立体仓库堆垛机</li><li>MT的困难？异步的理解过程</li><li>设计rpc接口的异常处理</li></ul><h3 id="9-2-字节2（十分开放）"><a href="#9-2-字节2（十分开放）" class="headerlink" title="9.2 字节2（十分开放）"></a>9.2 字节2（十分开放）</h3><ul><li>自我介绍</li><li>学习路线是怎么制定的</li><li>minIO实现分布式的部署怎么去做？类举了redis集群</li><li>哈希槽理解？哈希映射</li><li>哈希槽的扩容缩容问题？<ul><li>渐进式rehash</li></ul></li><li>redis集群？<ul><li>主从</li><li>集群</li><li>数据持久化</li></ul></li><li>es，如果一个es对应多个实体，如何避免回表<ul><li>同步双写</li><li>异步双写：消息队列、内存队列</li><li>定期同步</li><li><strong>数据订阅：利用binlog：canal Server 是一个伪装的slave节点，接收到binlog日志后，发送到MQ, 其他的 存储消费 MQ里边 的binlog日志，实现数据订阅。</strong>（业务侵入小、实时性好）</li><li>增量更新：只更新ES中需要变更的字段，但是更新mysql表的时候需要知道表的列对应的es字段</li></ul></li><li><p>如果读取到的mysql从节点的数据不是最新的怎么办？利用版本号判断，如果不是采用重试机制</p></li><li><p>做指标监控？</p><ul><li>同环比监控</li><li>接口时延、成功率等进行监控</li></ul></li><li><p>SLA指标？</p><ul><li>可用性TP99</li><li>准确性</li><li>系统容量QPS</li></ul></li><li>如何减少告警后人为的干预？AI训练</li><li>手撕：字符串的无重复组合。递归秒了</li></ul><h3 id="9-2-阿里1"><a href="#9-2-阿里1" class="headerlink" title="9.2 阿里1"></a>9.2 阿里1</h3><ul><li>20min极速，开门见山，自我介绍都不用（KPI）</li><li>项目过程中遇到的问题。异步编排</li><li>技术上的挑战？KA，AOP的思路</li><li>日志文件怎么收集到kafka？定时任务</li><li>为什么用kafka，和rabbitMQ对比？kafka的吞吐量、分区</li><li>如何检测异常？同环比对比</li><li>kafka2Hive，如何减少？用缓存</li><li>mysql索引结构？B+</li><li>es和mysql区别？倒排索引的过程</li><li>docker了解吗？</li><li>JWT原理？无状态，header、payload、签名三部分</li><li>如果用户退出登录，要让这个JWT立即失效怎么做？<ul><li>JWT设置有效时间</li><li>退出后将用户设置到一个退出名单中（有点session的意思）</li><li>JWT增加版本号，退出后改变版本号</li><li>服务端设置加密的key，为每个用户生成唯一的key，失效则改变key</li></ul></li></ul><h3 id="9-3-阿里云1"><a href="#9-3-阿里云1" class="headerlink" title="9.3 阿里云1"></a>9.3 阿里云1</h3><ul><li>八股盛宴</li><li>JDK、JRE、JVM关系</li><li>concurrentHashmap和hashTable</li><li><strong>concurrentHashmap两种实现方法</strong><ul><li>jdk8之前：分段锁，segment进行分段加锁</li><li>jdk8及之后：节点锁，对节点进行加锁，粒度更细。同时也支持CAS算法进行无锁操作</li></ul></li><li>垃圾回收算法：标记清除、复制、标记整理、分代收集</li><li>新生代和老年代</li><li>内存泄漏和内存溢出的区别<ul><li>泄露memory leak：指程序在申请内存后，无法释放已申请的内存空间（threadlocal）</li><li>溢出out of memory：指程序在申请内存时，没有足够的内存空间供其使用</li></ul></li><li><strong>进程被杀掉后泄漏的内存会被回收吗</strong>？操作系统会回收这部分的内存</li><li>线程同步和互斥的方法？<ul><li>同步：信号量、事件、消息队列</li><li>互斥：互斥锁、临界区、读写锁、原子操作</li></ul></li><li><strong>事件的理解</strong><ul><li>事件可以是一个信号、一个消息、一个状态变化等，它使得线程或任务能够基于这个条件进行等待或继续执行。</li></ul></li><li>死锁的理解？四大条件</li><li>操作系统进程和线程区别</li><li>TCP三次握手</li><li>TCP的可靠传输：确认机制、超时重传、流量控制、拥塞控制</li><li><p>Https过程</p></li><li><p>数据库的事务：原子性、一致性、隔离性、持久性</p></li><li><p>索引优缺点</p></li><li><p>索引不用B+树可以吗？IO、范围查询、数据结构优化三方面</p></li><li><p>设计模式</p></li><li><p>观察者模式解决的问题：实现对象之间的一对多依赖关系，当一个对象的状态发生变化时，所有依赖于它的对象都得到通知并被自动更新。</p></li><li>不用观察者模式怎么做：轮询、发布-订阅模式、回调机制、状态共享或事件驱动架构</li><li>算法：一个序列非常非常大，找出最大最小值。<ul><li>可以分段，使用并行的方式去找，最后再同步结果</li></ul></li><li>一致性哈希：哈希环</li><li>MT最大的挑战</li><li>RPC过程</li><li>FS挑战</li><li>做的公共云，AI的应用，后续还有两轮技术</li></ul><h3 id="9-3-百度2"><a href="#9-3-百度2" class="headerlink" title="9.3 百度2"></a>9.3 百度2</h3><ul><li>介绍一下多次部分退的内容</li><li>如何设计一个配置中心，实现热部署？（开放性问题）发生变化时服务端主动的去推送</li><li>如何保证更新数据顺利推送到？类似于TCP的一个响应报文</li><li>如果服务有很多怎么做？做配置中心集群，每个集群负责一部分的服务</li><li>如何保证集群数据的一致性？可以使用缓存记录数据的版本，通过版本来判断当前key是不是最新的</li><li>如何实现发布的新配置分批次的更新到服务中？（类似于灰度）讲了灰度设计的逻辑，通过机器的mac地址进行运算得到百分比</li><li>如何得到机器的信息呢？注册中心</li><li>KA大盘的建设怎么做的？将了一下设计思路的演变过程</li><li>上报的过程中需要注意什么<ul><li>异步的上报，不阻塞主要的逻辑</li><li>对异常进行处理，不影响到主业务</li></ul></li><li>hashcode和equals区别</li><li><code>@Service</code>是线程安全的吗？不安全，因为bean的默认作用范围是单例的，所以<code>@service</code>对应的bean就是单例的<ul><li>可以通过<code>@Scope</code>更改</li></ul></li><li>一个url请求的过程</li><li>http和tcp的长连接和短连接？本质是tcp的长短连接</li><li>如果一个传输的过程中断网了，会发生什么？</li><li>手撕：一个字符串，去掉所有的非数字字符后能够拿到的最大数字。比如asd612fsad13sd能得到最大的数字是63211<ul><li>用一个list先存储所有的数字，然后排序</li><li>用一个优先级队列直接存储</li><li>用两个栈代替优先级队列</li><li>用一个int[] 数组，长度为10，表示所有数字的出现次数，然后拼接（最优）</li></ul></li><li>问了一下如果给offer会来实习吗</li></ul><h3 id="9-4-顺丰1"><a href="#9-4-顺丰1" class="headerlink" title="9.4 顺丰1"></a>9.4 顺丰1</h3><ul><li><p>怎么学习java的</p></li><li><p>8个基本数据类型</p></li><li><p>string是不是，为什么是不可变</p></li><li><p>jdk和jre?</p></li><li><p>jdk包含了什么？</p><ul><li><p>编译器javac等</p></li><li><p>JRE</p></li><li><p>开发工具</p></li><li><p>类库</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/202409041945768.png" alt="image-20240904194526485" styl="zoom: 67%;" /></p></li></ul></li><li><p>接口和抽象类的区别</p></li><li><p>重写和重载</p><ul><li><strong>只有返回值类型不同的不是重载</strong>，JVM是通过方法签名（方法名和参数列表）来判断方法的</li></ul></li><li><p>线程池的参数</p></li><li>runnable和callable<ul><li>callable有返回值，允许异常抛出</li></ul></li><li>G1垃圾回收器</li><li>设计模式</li><li>springboot中如何自定义注解实现aop<ul><li>定义一个注解：声明好<code>@Target</code>、<code>@Rerention</code>等</li><li>创建一个AOP切面类<code>@Aspect</code> </li><li>定义方法，声明增强方式：<code>@Around(&quot;@annotation(注解名)&quot;)</code></li><li>在方法中去解析注解中的内容</li><li>最后使用注解</li></ul></li><li><strong>mysql支持json吗</strong><ul><li>5.7之后支持JSON字段的基本操作、相关函数及索引使用如何索引JSON字段，之前都是一个text</li></ul></li><li>联合索引使用</li><li>redis缓存雪崩</li></ul><h3 id="9-5-字节3-全场景"><a href="#9-5-字节3-全场景" class="headerlink" title="9.5 字节3 全场景"></a>9.5 字节3 全场景</h3><ul><li>部分退的困难点</li><li>金额的计算问题怎么处理？1元分为了0.335 0.335 0.335，如果三次退会导致超出1元怎么处理</li><li>值班遇到的线上问题，怎么处理的？优先回滚，事后分析</li><li>有什么规范性的收获？代码的可降级，异常的处理，缓存的使用</li><li>接口和子类</li><li>如果有多个任务abcd，e依赖于abcd，怎么提高效率？异步执行，观察者模式，照着CF原理讲的</li><li>超时怎么处理？设置异常返回</li><li>线程池拒绝策略</li><li>如果有一个任务对实时性要求非常高，用什么策略</li><li>个人评价和他人对自己评价</li><li>手撕：返回二叉树倒数第k小的值，用的中序遍历</li><li>问了一下提升的地方：介绍项目从大到小；线上异常处理</li></ul><h3 id="9-6-招商1"><a href="#9-6-招商1" class="headerlink" title="9.6 招商1"></a>9.6 招商1</h3><ul><li>多次部分退</li><li>如何防止重复退</li><li>涉及到商品券怎么处理</li><li>KA监控怎么做的</li><li>网关重试问题</li><li>手撕：排序数组返回最大的质数（试除法）</li></ul><h3 id="9-7-得物2（吊打）"><a href="#9-7-得物2（吊打）" class="headerlink" title="9.7 得物2（吊打）"></a>9.7 得物2（吊打）</h3><ul><li>做中间件的，果然牛皮</li><li><p>sleep和wait的区别</p><ul><li><code>sleep()</code>属于<code>Thread</code>类方法；<code>wait()</code>属于<code>Object</code>类，需要在<code>synchronized</code>块或方法中调用</li><li><code>sleep()</code>不释放锁，线程一直占用CPU，只是暂停执行一段时间自动苏醒；<code>wait()</code>会释放锁，由<code>notify()</code>或<code>notifyAll()</code>唤醒</li><li><code>sleep()</code>不抛出异常；<code>wait()</code>会</li><li><code>sleep()</code>用于模拟延迟操作；<code>wait()</code>用于线程间通信</li></ul></li><li><p>sleep指定时间苏醒的底层</p><ul><li>挂起进程（或线程）并修改其运行状态，当时间结束，定时器会触发，内核收到中断后修改进程（或线程）的运行状态。例如线程会被标志为就绪而进入就绪队列等待调度。</li></ul></li><li>一个对象有一个short类型一个byte类型的成员变量，new这个对象的时候需要分配多大的空间<ul><li>short 2字节，byte 1字节，对象头12~16字节</li><li>32位JVM：12字节对象头（8字节 Mark Word + 4字节存储类指针）；64位JVM：16/12字节（8字节 Mark Word + 8字节存储类指针(压缩指针为4字节)）</li><li>以12字节对象头为例，共15字节。</li><li>Java对象通常是8字节对齐的，15字节对应补齐到16字节</li></ul></li><li><p>BIO和NIO：同步阻塞IO和同步非阻塞IO</p></li><li><p>可见性和原子性</p></li><li>可见性是怎么保证的<ul><li><code>volatile</code> 修饰的话，对这个变量的修改都是在主存中进行，底层是<code>lock</code>前缀指令，线程写入后会强制刷新主存，根据MESI 协议，其他的线程的缓存数据就无效了<ul><li>MESI 协议：当 CPU 写数据时，如果发现操作的变量是共享变量，即在其他CPU中也存在该变量的副本，会发出信号通知其他CPU将该变量的缓存行置为无效状态，因此当其他CPU需要读取这个变量时，发现自己缓存中缓存该变量的缓存行是无效的，那么它就会从内存重新读取。</li></ul></li><li>使用同步机制比如锁或者<code>synchronized</code></li></ul></li><li><p>使用TCP从服务A发送数据到服务B会发生几次拷贝。使用零拷贝</p><ul><li>数据存放在内核空间，到A的socket网卡会发生一次DMA拷贝</li><li>到B的网卡后，B会发生一次DMA拷贝到B的内核空间，如果需要存储，则会再发生一次拷贝。</li></ul></li><li><p>使用<code>sendFile</code>是几次</p></li><li>连续发送3次http请求，可以发吗</li><li><p>503和504区别</p><ul><li>502：机器挂了，nginx执行请求的时候，却收到了上游服务器的无效响应</li><li>503：服务器当前无法处理请求，请求被拒绝</li><li>504：dns查询过程超时或者nginx配置错误</li></ul></li><li><p>redis是怎么请求处理的</p><ul><li>基于reactor模式的事件驱动程序来实现事件的并发处理，即通过epoll来监听多个fd</li><li>请求过来，注册一个fd到epoll中，并设置回调函数</li><li>readQueryFromClient 读取请求命令：从socket中读取数据放到缓冲区中，并进行解析</li><li>processCommand 处理命令请求：</li><li>addReply 返回执行结果：将结果返回到输出缓冲区，</li></ul></li><li><p>zset底层：跳表</p></li><li>场景：如何实现一个直播间踢出某个用户</li></ul><h3 id="9-9-oppo2"><a href="#9-9-oppo2" class="headerlink" title="9.9 oppo2"></a>9.9 oppo2</h3><ul><li>超出预期的事情？FS</li><li>怎么做的立库可视化</li><li>挫败的事情？MT异步调用过程</li><li>有挑战的事情？线上无限重试问题</li><li>一个业务或者需求实现的全流程</li><li>反问：<ul><li>做的供应链这块，面向公司内部的IT平台开发</li><li>base东莞</li></ul></li></ul><h3 id="9-14-HW1"><a href="#9-14-HW1" class="headerlink" title="9.14 HW1"></a>9.14 HW1</h3><ul><li><p>30min问答 + 25min手撕</p></li><li><p>代码量</p></li><li><p>如何保证写的代码的正确性（单侧 + 自测）</p></li><li><p>怎么看待单元测试，怎么用的？方法，接口逻辑判断；mock</p></li><li><p>实习过程中印象比较深刻的事情</p></li><li><p>怎么分析的效率</p></li><li><p>java六大设计原则</p><ul><li>单一职责原则</li><li>开放封闭原则： 类，模块，函数等应该是可以扩展的，但是不可以修改</li><li>里式替换原则：所有引用基类(父类)的地方必须能透明的使用其子类的对象</li><li>依赖倒置原则：高层模块(调用端)不应该依赖底层模块，两者都应该依赖于抽象。抽象不应该依赖于细节(实现类),细节应该依赖于抽象。</li><li>迪米特原则：一个软件实体应当少的与其他实体发生相互作用。</li><li>接口隔离原则：一个类对另一个类的依赖应该建立在最小的接口上</li></ul></li><li><p>偏向锁和自旋锁</p></li><li><p>进程、线程、协程</p></li><li><p>B树、B+树</p></li><li><p>手撕：数组中前k个最频繁的数（<code>hashMap + PriorityQueue</code>）O(NlogN)</p><ul><li>更好的方法：桶排序 O(N)</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] topKFrequent(<span class="type">int</span>[] nums, <span class="type">int</span> k) &#123;</span><br><span class="line">    Map&lt;Integer, Integer&gt; frequencyMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 统计每个数字出现的频率</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line">            frequencyMap.put(num, frequencyMap.getOrDefault(num, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">   </span><br><span class="line">        <span class="comment">// 创建桶，桶的索引是频率，值是具有相同频率的数字列表</span></span><br><span class="line">        List&lt;Integer&gt;[] buckets = <span class="keyword">new</span> <span class="title class_">List</span>[nums.length + <span class="number">1</span>]; <span class="comment">// 比如1出现了3次，1就会在索引为3的桶出现</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> key : frequencyMap.keySet()) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">frequency</span> <span class="operator">=</span> frequencyMap.get(key);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (buckets[frequency] == <span class="literal">null</span>) &#123;</span><br><span class="line">                buckets[frequency] = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">            &#125;</span><br><span class="line">            buckets[frequency].add(key);</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// 从高频到低频遍历桶，收集前 k 个频率最高的元素</span></span><br><span class="line">        List&lt;Integer&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> buckets.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (buckets[i] == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (result.size() &gt;= k) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (result.size() &lt; k &amp;&amp; index &lt; buckets[i].size()) &#123;</span><br><span class="line">                result.add(buckets[i].get(index++));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 转换为数组返回</span></span><br><span class="line">        <span class="keyword">return</span> result.stream().mapToInt(i -&gt; i).toArray();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>4.24 笔试回顾</p><ul><li><p>t1：输入两行，一行是数组，一行是一个目标数，根据数组构造一个满平衡二叉树，输出查找路径，S表示跟节点，R向右，L向左，Y表示找到，N表示没找到</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BalancedBST</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 构建平衡的满二叉搜索树</span></span><br><span class="line">    <span class="comment">// TreeNode自定义：int val, TreeNode left，right</span></span><br><span class="line">    <span class="keyword">private</span> TreeNode <span class="title function_">buildBST</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> start, <span class="type">int</span> end)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (start &gt; end) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> start + (end - start) / <span class="number">2</span>;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(nums[mid]);</span><br><span class="line">        root.left = buildBST(nums, start, mid - <span class="number">1</span>);</span><br><span class="line">        root.right = buildBST(nums, mid + <span class="number">1</span>, end);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 搜索给定的数</span></span><br><span class="line">    <span class="keyword">private</span> String <span class="title function_">search</span><span class="params">(TreeNode root, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="string">&quot;N&quot;</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (root.val == target) <span class="keyword">return</span> <span class="string">&quot;Y&quot;</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (target &lt; root.val) <span class="keyword">return</span> <span class="string">&quot;L&quot;</span> + search(root.left, target);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="string">&quot;R&quot;</span> + search(root.right, target);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] nums = ....</span><br><span class="line">        <span class="type">int</span> <span class="variable">target</span> <span class="operator">=</span> ....</span><br><span class="line">        </span><br><span class="line">        <span class="type">BalancedBST</span> <span class="variable">bst</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BalancedBST</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 构建平衡的满二叉搜索树</span></span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> bst.buildBST(nums, <span class="number">0</span>, nums.length - <span class="number">1</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 搜索给定的数</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> bst.search(root, target);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 输出结果</span></span><br><span class="line">        System.out.print(<span class="string">&quot;S&quot;</span>);</span><br><span class="line">        System.out.println(result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>t2：K教练正在对足球队的 n nn 名球员进行射门能力评估。评估共进行 m mm 次训练,每次训练时,若球员射门得分则记为1,否则记为0。现在K教练需要根据以下规则对球员进行排名:</p><ul><li>进球总数较多的球员排名靠前。</li><li>如果进球总数相同,则最长连续进球次数较多的球员排名靠前。</li><li>如果最长连续进球次数也相同,则第一次未进球的训练序号较大的球员排名靠前。如果第一次未进球的训练序号也相同,则比较第二次、第三次……直到比较出结果。</li><li>如果按照前三条规则仍然无法区分排名,则编号较小的球员排名靠前。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 自定义一个结构体，然后优先级队列</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><ul><li><p>t3：</p><ul><li><p>输入：第一行为n，表示微服务数量；第二行为n的数组edges, edges[i] 表示 服务i对服务edges[i]的调用关系</p></li><li><p>定义</p><ul><li>群组：调用关系形成一个环的多个微服务组</li><li>内聚值 = 群组微服务数量 - 能够调用到该群组内微服务的数量</li></ul></li><li><p>已知：至少存在一个群组</p></li><li><p>输出：内聚值最大的群组，按照调用关系输出群组内的服务编号</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 输入</span></span><br><span class="line"><span class="comment">// 4</span></span><br><span class="line"><span class="comment">// 3 3 0 2</span></span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line"><span class="comment">// 0 3 2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">首先，我们记录每个点的入度，然后进行拓扑排序找环，扫一遍找到每个环上最小的id以及该环内聚值，内聚值显然是等于环的总入度减去环的大小，最后从最小id的位置遍历环，输出答案。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MicroserviceGroup</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> scanner.nextInt();</span><br><span class="line">        <span class="type">int</span>[] edges = <span class="keyword">new</span> <span class="title class_">int</span>[n]; <span class="comment">// n个调用关系</span></span><br><span class="line">        <span class="type">int</span>[] du = <span class="keyword">new</span> <span class="title class_">int</span>[n]; <span class="comment">// 每个节点的入度</span></span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; groups = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(); <span class="comment">// 群组</span></span><br><span class="line">        <span class="type">boolean</span>[] visited = <span class="keyword">new</span> <span class="title class_">boolean</span>[n]; <span class="comment">// 用于搜索</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 读取调用关系并记录入度</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            edges[i] = scanner.nextInt();</span><br><span class="line">            du[edges[i]]++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 拓扑排序查找环</span></span><br><span class="line">        Queue&lt;Integer&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (du[i] == <span class="number">0</span>) &#123;</span><br><span class="line">                queue.offer(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 排除掉非环结构，while之后只剩下环了，也就是只剩下群组了</span></span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">pos</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">            <span class="keyword">if</span> (--du[edges[pos]] == <span class="number">0</span>) &#123; <span class="comment">// edges[pos] 就是 pos调用的下游</span></span><br><span class="line">                queue.offer(edges[pos]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 深度优先搜索找群组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (du[i] != <span class="number">0</span> &amp;&amp; !visited[i]) &#123;</span><br><span class="line">                List&lt;Integer&gt; currentGroup = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">                dfs(i, edges, visited, currentGroup);</span><br><span class="line">                groups.add(currentGroup);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 计算内聚值并找出最大的群组</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">maxId</span> <span class="operator">=</span> n, maxCount = -<span class="number">1</span>, selectedGroupIndex = -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; groups.size(); i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>, id = -<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j : groups.get(i)) &#123;</span><br><span class="line">                count += du[j];</span><br><span class="line">                id = Math.max(id, j);</span><br><span class="line">            &#125;</span><br><span class="line">            count -= groups.get(i).size();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (count &gt; maxCount) &#123;</span><br><span class="line">                maxId = id;</span><br><span class="line">                maxCount = count;</span><br><span class="line">                selectedGroupIndex = i;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (count == maxCount &amp;&amp; id &lt; maxId) &#123;</span><br><span class="line">                maxId = id;</span><br><span class="line">                selectedGroupIndex = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 输出结果</span></span><br><span class="line">        List&lt;Integer&gt; selectedGroup = groups.get(selectedGroupIndex);</span><br><span class="line">        Collections.sort(selectedGroup);</span><br><span class="line">        <span class="type">int</span> <span class="variable">startPos</span> <span class="operator">=</span> selectedGroup.get(<span class="number">0</span>);</span><br><span class="line">        System.out.print(startPos + <span class="string">&quot; &quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (edges[startPos] != selectedGroup.get(<span class="number">0</span>)) &#123;</span><br><span class="line">            startPos = edges[startPos];</span><br><span class="line">            System.out.print(startPos + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        scanner.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> pos, <span class="type">int</span>[] edges, <span class="type">boolean</span>[] visited, List&lt;Integer&gt; currentGroup)</span> &#123;</span><br><span class="line">        visited[pos] = <span class="literal">true</span>;</span><br><span class="line">        currentGroup.add(pos);</span><br><span class="line">        <span class="keyword">if</span> (!visited[edges[pos]]) &#123;</span><br><span class="line">            dfs(edges[pos], edges, visited, currentGroup);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="9-19-联洲1"><a href="#9-19-联洲1" class="headerlink" title="9.19 联洲1"></a>9.19 联洲1</h3><ul><li>奖励和成绩</li><li>kafka消费的顺序如何保证</li><li>hashmap查询时间复杂度</li><li>哈希冲突的解决方法：开放地址；再哈希法；链地址法；建立公共溢出区</li><li>红黑树的特点</li><li>TCP可靠性：校验和、序号、确认机制、重传机制、拥塞避免、滑动窗口</li><li>TCP如何保证修改了包不被发现<ul><li>数据校验和</li></ul></li></ul><h3 id="9-19-中兴1"><a href="#9-19-中兴1" class="headerlink" title="9.19 中兴1"></a>9.19 中兴1</h3><ul><li>机器学习有了解吗</li><li>计算机网络状态返回码 1 2 3 4 5含义</li><li>200和204区别：204没有返回内容</li><li>Hibernate和mybatis的区别：<ul><li>前者是全ORM框架，自动生成sql，对于复杂的sql查询性能不太好</li></ul></li><li>kafka消息顺序性怎么保证</li><li>怎么定位瓶颈优化的FS</li><li>分片多线程</li><li>怎么定义返回，状态码</li><li>保研成绩，一等奖学金，竞赛，小论文，专利</li><li>哪里人，工作地点，独生子女</li><li>怎么了解中兴文化、工作、生活</li><li>岗位：软件开发，java后端</li><li>业务：<ul><li>网管：通信设备的管理系统，OTN</li><li>工具：设备的巡检和升级（new）<ul><li>巡检：设备的运行状况，温度、cpu、利用率等</li><li>升级：扩容</li></ul></li></ul></li></ul><h3 id="9-20-联洲2"><a href="#9-20-联洲2" class="headerlink" title="9.20 联洲2"></a>9.20 联洲2</h3><ul><li>多次部分退的灰度和降级方案</li><li>配置中心理解和原理</li><li>docker用过吗</li><li>日志hive过程</li><li>为什么使用minio：轻量，golang</li><li>redis类型</li><li>redis缓存问题</li><li>JWT</li><li>mysql索引数据结构</li><li>手撕：快排</li></ul><h3 id="9-22-得物3"><a href="#9-22-得物3" class="headerlink" title="9.22 得物3"></a>9.22 得物3</h3><ul><li><p>kafka还得看</p></li><li><p>同一个tcp连接发送多个http请求？</p><ul><li>http1.1两个请求的生命周期不能重叠，http2提供了多路传输特性，每个请求通过流(Stream ID)来区分，可以（http1.1时代为了提高响应会维护多个tcp连接）</li><li>流：ID唯一、双向传输、基于帧来传输，每个帧携带stream ID</li></ul></li></ul><h3 id="9-25-海康1"><a href="#9-25-海康1" class="headerlink" title="9.25 海康1"></a>9.25 海康1</h3><ul><li>遇到的问题，异步调用</li><li>线程死锁</li><li>RPC和http</li><li>mybatis两级缓存、<code>#&#123;&#125;</code>和<code>%&#123;&#125;</code>区别（占位符和替换）</li><li>线上问题</li><li>实习收获</li><li>学校里遇到的较大的问题</li><li>机器学习有没有了解</li></ul><h3 id="9-25-迈瑞1"><a href="#9-25-迈瑞1" class="headerlink" title="9.25 迈瑞1"></a>9.25 迈瑞1</h3><ul><li>遇到的问题</li><li>异步的理解</li><li>线上问题</li><li>FS优化过程</li><li>手撕：快排</li></ul><h3 id="9-29-迈瑞2"><a href="#9-29-迈瑞2" class="headerlink" title="9.29 迈瑞2"></a>9.29 迈瑞2</h3><ul><li>开发</li><li>学习路线</li><li>自己的优势劣势</li><li>对工作的看法</li></ul><link rel="stylesheet" href="https://cdn1.tianli0.top/gh/zhheo/Post-Abstract-AI@0.15.2/tianli_gpt.css"><script>let tianliGPT_postSelector = '#post #article-container';let tianliGPT_key = 'c9b7741d290063ab872e';</script><script src="https://cdn1.tianli0.top/gh/zhheo/Post-Abstract-AI@0.15.2/tianli_gpt.js"></script>]]></content>
      
      
      <categories>
          
          <category> study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络</title>
      <link href="/posts/28758.html"/>
      <url>/posts/28758.html</url>
      
        <content type="html"><![CDATA[  <a href="https://www.bilibili.com/video/BV19E411D78Q/" class="bilibili_box" id="BV19E411D78Q"></a>  <script>    bilibili()    function bilibili() {      let dom = document.getElementById('BV19E411D78Q')      fetch('https://api.320.ink/api/b?id=BV19E411D78Q').then(res=>res.json()).then(data=>{        dom.innerHTML = `        <div class="bilibili_cover">          <img src="https://s1.hdslb.com/bfs/static/player/img/play.svg" class="play_icon no-lazyload">          <img src="${data.pic + '&h=300'}" class="no-lazyload">          <span>:39</span>        </div>        <div class="bilibili_info">          <div class="title">${data.title}</div>          <div class="desc">${data.desc}</div>          <div class="stat">            <span><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 20 20" fill="none" class="icon"><path fill-rule="evenodd" clip-rule="evenodd" d="M4.67735 4.2798C5.98983 4.1725 7.85812 4.0625 10 4.0625C12.1421 4.0625 14.0105 4.17252 15.323 4.27983C16.2216 4.3533 16.9184 5.04049 16.9989 5.9318C17.0962 7.00837 17.1875 8.43614 17.1875 10C17.1875 11.5639 17.0962 12.9916 16.9989 14.0682C16.9184 14.9595 16.2216 15.6467 15.323 15.7202C14.0105 15.8275 12.1421 15.9375 10 15.9375C7.85812 15.9375 5.98983 15.8275 4.67735 15.7202C3.77861 15.6467 3.08174 14.9593 3.00119 14.0678C2.90388 12.9908 2.8125 11.5627 2.8125 10C2.8125 8.43727 2.90388 7.00924 3.00119 5.93221C3.08174 5.04067 3.77861 4.35327 4.67735 4.2798ZM10 2.8125C7.81674 2.8125 5.9136 2.92456 4.5755 3.03395C3.07738 3.15643 1.8921 4.31616 1.75626 5.81973C1.65651 6.92379 1.5625 8.39058 1.5625 10C1.5625 11.6094 1.65651 13.0762 1.75626 14.1803C1.8921 15.6838 3.07738 16.8436 4.5755 16.966C5.9136 17.0754 7.81674 17.1875 10 17.1875C12.1835 17.1875 14.0868 17.0754 15.4249 16.966C16.9228 16.8436 18.108 15.6841 18.2438 14.1807C18.3435 13.077 18.4375 11.6105 18.4375 10C18.4375 8.38948 18.3435 6.92296 18.2438 5.81931C18.108 4.31588 16.9228 3.15645 15.4249 3.03398C14.0868 2.92458 12.1835 2.8125 10 2.8125ZM12.1876 10.722C12.7431 10.4013 12.7431 9.59941 12.1876 9.27866L9.06133 7.47373C8.50577 7.15298 7.81133 7.55392 7.81133 8.19542V11.8053C7.81133 12.4468 8.50577 12.8477 9.06133 12.527L12.1876 10.722Z" fill="#9499A0"/></svg>${data.view}</span>            <span><svg width="36" height="36" viewBox="0 0 36 36" xmlns="http://www.w3.org/2000/svg" class="icon"><path fill-rule="evenodd" clip-rule="evenodd" d="M9.77234 30.8573V11.7471H7.54573C5.50932 11.7471 3.85742 13.3931 3.85742 15.425V27.1794C3.85742 29.2112 5.50932 30.8573 7.54573 30.8573H9.77234ZM11.9902 30.8573V11.7054C14.9897 10.627 16.6942 7.8853 17.1055 3.33591C17.2666 1.55463 18.9633 0.814421 20.5803 1.59505C22.1847 2.36964 23.243 4.32583 23.243 6.93947C23.243 8.50265 23.0478 10.1054 22.6582 11.7471H29.7324C31.7739 11.7471 33.4289 13.402 33.4289 15.4435C33.4289 15.7416 33.3928 16.0386 33.3215 16.328L30.9883 25.7957C30.2558 28.7683 27.5894 30.8573 24.528 30.8573H11.9911H11.9902Z"></path></svg>${data.like}</span>            <span><svg width="28" height="28" viewBox="0 0 28 28" xmlns="http://www.w3.org/2000/svg" class="icon" style="fill:;"><path fill-rule="evenodd" clip-rule="evenodd" d="M14.045 25.5454C7.69377 25.5454 2.54504 20.3967 2.54504 14.0454C2.54504 7.69413 7.69377 2.54541 14.045 2.54541C20.3963 2.54541 25.545 7.69413 25.545 14.0454C25.545 17.0954 24.3334 20.0205 22.1768 22.1771C20.0201 24.3338 17.095 25.5454 14.045 25.5454ZM9.66202 6.81624H18.2761C18.825 6.81624 19.27 7.22183 19.27 7.72216C19.27 8.22248 18.825 8.62807 18.2761 8.62807H14.95V10.2903C17.989 10.4444 20.3766 12.9487 20.3855 15.9916V17.1995C20.3854 17.6997 19.9799 18.1052 19.4796 18.1052C18.9793 18.1052 18.5738 17.6997 18.5737 17.1995V15.9916C18.5667 13.9478 16.9882 12.2535 14.95 12.1022V20.5574C14.95 21.0577 14.5444 21.4633 14.0441 21.4633C13.5437 21.4633 13.1382 21.0577 13.1382 20.5574V12.1022C11.1 12.2535 9.52148 13.9478 9.51448 15.9916V17.1995C9.5144 17.6997 9.10883 18.1052 8.60856 18.1052C8.1083 18.1052 7.70273 17.6997 7.70265 17.1995V15.9916C7.71158 12.9487 10.0992 10.4444 13.1382 10.2903V8.62807H9.66202C9.11309 8.62807 8.66809 8.22248 8.66809 7.72216C8.66809 7.22183 9.11309 6.81624 9.66202 6.81624Z"></path></svg>${data.coin}</span>          </div>          <div class="owner">            <span class="tip">视频</span>            <img src="${data.face + '&h=100'}" class="no-lazyload">            <span>${data.owner}</span>          </div>        </div>        `      })    }  </script>  <ul><li>考一下研</li></ul><h1 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h1><h2 id="Cp0-简介"><a href="#Cp0-简介" class="headerlink" title="Cp0 简介"></a>Cp0 简介</h2><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/image-20240418220253346.png" alt="image-20240418220253346"></p><ul><li>计算机网络组成：硬件、软件、协议</li></ul><h3 id="1-1-分类"><a href="#1-1-分类" class="headerlink" title="1.1 分类"></a>1.1 分类</h3><ul><li>广域网（WAN）、城域网（MAN）、局域网（LAN）、个域网（PAN）<ul><li>MAN和LAN是以太网技术</li></ul></li></ul><h3 id="1-2-性能指标"><a href="#1-2-性能指标" class="headerlink" title="1.2 性能指标"></a>1.2 性能指标</h3><ul><li>速率：即数据率/数据传输率/比特率<ul><li>连接在计算机网络上的主机在数字信道上传输数据位数的速率</li></ul></li><li>带宽：表示网络中单位时间从网络某一点到另一点所能通过的“最高数据率”单位和速率一样</li><li><p>吞吐量：单位时间通过某个网络的数据量</p></li><li><p>时延：指数据（报文/分组/比特流）从网络（或链路）的一端传送到另一端所需的时间。</p><ul><li>发送时延：数据长度/信道带宽</li><li>传播时延：取决于电磁波传播速度和链路长度</li><li>排队时延</li><li>处理时延</li></ul></li><li><p>时延带宽积：传播时延 * 带宽</p><p><img src="C:\Users\H\AppData\Roaming\Typora\typora-user-images\image-20240421112251506.png" alt="image-20240421112251506"></p></li><li><p>往返RTT：从发送方发送数据开始，到发送方收到接收方的确认总共经历的时延</p><ul><li>RTT越大，在收到确认前，可以发送的数据越多 </li></ul></li><li><p>利用率：信道利用率和网络利用率</p><h3 id="1-3-分层结构"><a href="#1-3-分层结构" class="headerlink" title="1.3 分层结构"></a>1.3 分层结构</h3></li><li><p>实体、接口(上层使用下层服务的入口)、服务(下层对上层)、协议(对等实体数据交换建立的规则)</p></li><li><p>7层ISO/OSI分层参考模型</p><ul><li><p>应用层：FTP、SMTP、HTTP</p></li><li><p>表示层：数据格式变换、加密等</p></li><li><p>会话层：向表示层实体/用户进程提供建立连接并在连接上有序地传输数据，建立同步（SYN）</p></li><li><p>传输层：负责两个进程的通信，端到端。传输单位是报文段/用户数据报 TCP、UDP</p><ul><li>可靠传输、不可靠传输、</li><li>差错控制</li><li>流量控制</li><li>复用分用</li></ul></li><li><p>网络层：把分组从源端传到目的端，传输单位是数据报</p><ul><li>路由选择</li><li>流量控制</li><li>差错控制</li><li>拥塞控制</li></ul></li><li><p>数据链路层：将网络层传下来的数据报组装成帧，传输单位是帧</p><ul><li>成帧</li><li>差错控制</li><li>流量控制</li><li>访问（接入）控制</li></ul></li><li><p>物理层：在物理媒体上实现比特流的透明传输：100010101…转为电磁波信号</p><ul><li>定义接口特性</li><li>定义传输模式（单工、半双工、双工）</li><li>定义传输速率</li><li>比特同步</li></ul><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/image-20240421122840677.png" alt="image-20240421122840677"></p></li></ul></li><li><p>4层TCP/IP参考模型</p><ul><li>应用层：HTTP、FTP、DNS</li><li>传输层：TCP、UDP</li><li>网际层：IP</li><li>网络接口层：</li></ul></li><li><p>5层参考模型</p><ul><li>应用层：支持各种网络应用、<ul><li>FTP、SMTP、HTTP</li></ul></li><li>传输层：进程-进程的数据传输<ul><li>TCP、UDP</li></ul></li><li>网络层：源主机到目的主机的数据分组路由与转发<ul><li>IP、ICMP、OSPF</li></ul></li><li>数据链路层：将网络层传下来的数据报组装成帧<ul><li>Ethernet、PPP</li></ul></li><li>物理层：比特传输</li></ul></li><li><p>TCP/IP 协议栈</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/image-20240422140744903.png" alt="image-20240422140744903" style="zoom: 67%;" /></p></li></ul><h2 id="Cp1-物理层"><a href="#Cp1-物理层" class="headerlink" title="Cp1 物理层"></a>Cp1 物理层</h2><h3 id="1-1-概述"><a href="#1-1-概述" class="headerlink" title="1.1 概述"></a>1.1 概述</h3><ul><li>解决如何在连接各种计算机的传输媒体上传输数据比特流</li><li>主要任务：确定传输媒体接口相关特性（定义标准）</li></ul><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/image-20240421152541900.png" alt="image-20240421152541900"></p><ul><li>数据通信三个问题<ul><li>单工/半双工/全双工：信道的数量不同</li><li>串行传输/并行传输：表示一个字符的8位二进制用一条信道发送还是多条信道<ul><li>串行适合远距离</li></ul></li><li>同步/异步传输<ul><li>同步以数据区块位单位传输，需要一个SYN同步字符</li><li>异步传输要加字符起始位和字符终止位</li></ul></li></ul></li><li>码元：指用一个固定时长的信号波形（数字脉冲），代表不同离散数值的基本波形，是数字通信中数字信号的计量单位，1码元可以携带多个比特的信号量<ul><li>二进制1码元携带1个比特，4进制携带2个，16进制携带4个</li></ul></li><li>速率：指数据传输速率<ul><li>码元传输速率</li><li>信息传输速率</li></ul></li></ul><h3 id="1-2-编码与调制"><a href="#1-2-编码与调制" class="headerlink" title="1.2 编码与调制"></a>1.2 编码与调制</h3><ul><li><p>信道：信号的传输媒介，用来表示向某个方向传送信息的介质（发送信道/接收信道）</p></li><li><p>信道上传送的信号</p><ul><li>基带信号</li><li>宽带信号</li></ul></li><li><p>编码：数据 ==&gt; 数字信号</p><ul><li>非归零编码、反向不归零编码、曼彻斯特编码、差分曼彻斯特编码</li></ul></li><li>调制：数据 ==&gt; 模型信号</li></ul><h3 id="1-3-数据交换方式"><a href="#1-3-数据交换方式" class="headerlink" title="1.3 数据交换方式"></a>1.3 数据交换方式</h3><ul><li><p>电路交换：适合低频次、大量的传输</p><ul><li><p>优点：</p><ul><li>传输时延小，实时性强</li><li>全双工</li></ul></li><li><p>缺点：</p><ul><li>建立/释放需要时间</li><li>线路被通信双方独占，利用率低</li><li>线路分配灵活性差</li><li>不能检查数据</li></ul></li></ul></li><li><p>报文交换：由发送方、接收方及数据组成，称为报文，传输过程采用<strong>存储转发</strong>方式</p><ul><li>优点：<ul><li>通信前无需建立连接</li><li>数据以报文为单位被交换节点存储转发，通信线路可灵活分配</li><li>用户无需独占一条线路，线路利用率高</li><li>交换节点支持差错控制</li></ul></li><li>缺点<ul><li>报文不定长，不方便存储转发</li><li>长报文存储转发时间开销大，存储开销大</li><li>长报文容易出错，重传代价高</li></ul></li></ul></li><li><p>分组交换：将一个长报文切开分成多份(packet)，并添加头信息（源、目的地址 ）及分组号</p><ul><li>分组交换机：路由器</li><li>缺点：相对于初始报文，控制信息占比增加</li></ul></li></ul><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/image-20240421160929973.png" alt="image-20240421160929973" style="zoom:67%;" /></p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/image-20240421103843177.png" alt="image-20240421103843177" style="zoom:67%;" /></p><ul><li>虚电路交换技术：结合了数据包和电路交换方式</li></ul><h3 id="1-3-传输介质-设备"><a href="#1-3-传输介质-设备" class="headerlink" title="1.3 传输介质/设备"></a>1.3 传输介质/设备</h3><ul><li><p>传输介质：导向传输介质/非导向传输介质</p></li><li><p>导向传输介质</p><ul><li>双绞线</li><li>同轴电缆</li><li>光纤：很多光纤捆一起 ==&gt; 光缆</li></ul></li><li>非导向传输介质<ul><li>无线电波：信号向所有方向传播</li><li>微波：信号固定方向传播<ul><li>地面微波接力通信</li><li>卫星通信</li></ul></li><li>红外线、激光：固定方向</li></ul></li><li>物理层设备：中继器/集线器</li><li>中继器：对信号进行再生和还原，对衰减信号放大（点对点）</li><li>集线器：对信号进行再生方法转发，对衰减信号放大（广播）</li></ul><h2 id="Cp2-数据链路层"><a href="#Cp2-数据链路层" class="headerlink" title="Cp2 数据链路层"></a>Cp2 数据链路层</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">数据链路层--&gt; A(功能)</span><br><span class="line">A--&gt;封装成帧和透明传输</span><br><span class="line">A--&gt;差错控制</span><br><span class="line">A--&gt;流量控制</span><br><span class="line">A--&gt;可靠传输</span><br><span class="line">数据链路层--&gt; 应用</span><br><span class="line">应用--&gt;两种链路/信道</span><br><span class="line">应用--&gt;链路层设备</span><br></pre></td></tr></table></figure><h3 id="2-0-概述"><a href="#2-0-概述" class="headerlink" title="2.0 概述"></a>2.0 概述</h3><ul><li>定义与作用：在物理层上提供服务的基础上向网络层提供服务，主要作用是加强物理层传输原始比特流的功能，将物理层提供的可能出错的物理连接改造为逻辑上无差错的数据链路</li><li><p>功能</p><ul><li>为网络层提供服务：无确认无连接服务、有确认无连接服务、有确认有连接服务</li><li>链路管理</li><li>组帧</li><li>流量控制</li><li>差错控制（帧错、位错）</li></ul></li><li><p>结点：主机、路由器</p></li><li>链路：网络中两个结点之间的物理通道</li><li>数据链路：两个结点之间的逻辑通道</li><li>帧：链路层的协议数据单元，封装网络层数据报</li></ul><h3 id="2-1-封装成帧和透明传输"><a href="#2-1-封装成帧和透明传输" class="headerlink" title="2.1 封装成帧和透明传输"></a>2.1 封装成帧和透明传输</h3><ul><li>封装成帧：在一段数据的前后部分添加首部和尾部，构成一个帧</li></ul><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/image-20240421163901028.png" alt="image-20240421163901028" style="zoom:67%;" /></p><ul><li><p>帧同步：接收方从接收到的二进制比特流中区分处帧的起始和终止</p></li><li><p>透明传输：指不管所传数据是什么样的比特组合，都应该能在链路上传输</p></li><li><p>组帧的方法</p><ul><li><p>字符计数法：帧首部使用一个计数字段表明帧长度</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/image-20240421164219005.png" alt="image-20240421164219005"></p></li><li><p>字符填充法：为了防止数据开始和结束字符被错误的判断</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/image-20240421164413269.png" alt="image-20240421164413269"></p></li><li><p>零比特填充法</p><ul><li>在发送端，只要连续5个1就立即填充1个0</li><li>接收的时候发现连续5个1就删除1个0</li></ul></li><li>违规编码法</li></ul></li></ul><h3 id="2-2-差错控制"><a href="#2-2-差错控制" class="headerlink" title="2.2 差错控制"></a>2.2 差错控制</h3><ul><li>产生原因：<ul><li>全局性：本身的电气特性，信道固有的，随机存在的。解决：提高信噪比</li><li>局部性：外界特定的短暂原因所造成的冲击噪声。解决：利用编码技术</li></ul></li><li>分类：<ul><li>位错：1变成0，0变成1</li><li>帧错：发送  #[1]#[2]#[3]<ul><li>丢失：收到  #[1]#[3]</li><li>重复：收到  #[1]#[2]#[2]#[3]</li><li>失序：收到  #[3]#[1]#[2]</li></ul></li></ul></li></ul><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/image-20240421165102895.png" alt="image-20240421165102895" style="zoom:50%;" /></p><ul><li>奇偶校验码：前n-1位1的个数是奇数还是偶数个</li><li><p>CRC循环冗余码：除以一个数，看余数是否相同</p><ul><li>将数据分组</li><li>每个组的后面都加上冗余码</li></ul></li><li><p>纠错编码：海明码</p><ul><li>确定校验码位数r</li><li>确定校验码和数据的位置</li><li>求出校验码的值</li><li>检查并纠错</li></ul></li></ul><h3 id="2-3-流量控制、可靠传输"><a href="#2-3-流量控制、可靠传输" class="headerlink" title="2.3 流量控制、可靠传输"></a>2.3 流量控制、可靠传输</h3><ul><li><p>流量控制方法：</p><ul><li><p>停止-等待协议（发送窗口大小 = 接收窗口大小 = 1）</p><ul><li><p>发送数据后等待接收方的ACK包后再继续发送</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/image-20240421170921124.png" alt="image-20240421170921124" style="zoom: 50%;" /></p></li></ul></li><li><p>滑动窗口协议</p><ul><li>后退N帧协议（发送窗口大小 &gt; 1 接收窗口大小 = 1）GBN协议</li><li>选择重传协议（发送窗口大小 &gt; 1 接收窗口大小 &gt; 1）SR协议</li></ul></li></ul></li><li><p>GBN协议</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/image-20240421170501209.png" alt="image-20240421170501209" style="zoom:50%;" /></p><ul><li>发送窗口组成：发完被确认、已经发送待确认、还能发送、还不能发送</li><li>发送方响应的三件事<ul><li>上层调用：上层要发送数据，发送方先检查发送窗口是否满，满了的话就返回数据给上层，暗示窗口已满，上层会等一会再发送</li><li>确认方式：对n好帧的确认采用累计确认，表明接收方收到n号帧及之前的全部帧</li><li>超时事件</li></ul></li><li>接收方要做的事：<ul><li>正确收到了n号帧，并且按序，则为n帧发送一个ACK，表示前n号帧都接收完毕</li><li>其余情况都丢弃帧，并为最近按序接收的帧重新发送一个ACK，表明下一个需要接收的帧<ul><li>收到245号帧，则ACK响应2，并丢第45号帧</li></ul></li></ul></li></ul></li><li><p>选择重传协议：</p><ul><li><p>发送方窗口：发完确认、发完等待确认、还能发送、还不能发送</p></li><li><p>接收方窗口：希望收到但未收到、收到确认的、等待接收</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/image-20240421172522401.png" alt="image-20240421172522401" style="zoom:50%;" /></p></li><li><p>发送方：</p><ul><li>上层调用：类似GBN</li><li>收到了一个ACK后：加入帧序号在窗口中，则SR发送方标记那个帧未已接收，如果是窗口的下界，则移动窗口到当前最小未被确认的地方，然后发送新的窗口未确认的帧</li><li>超时事件：超时后重传一个帧</li></ul></li><li><p>接收方：</p><ul><li>不按序，失序的帧被缓存，并发送给发送方一个确认帧，知道所有帧被接收，将这一批帧返回给上层，然后移动窗口</li></ul></li><li><p>发送窗口最好等于接收窗口</p></li></ul></li></ul><h3 id="2-4-两种链路-信道"><a href="#2-4-两种链路-信道" class="headerlink" title="2.4 两种链路/信道"></a>2.4 两种链路/信道</h3><ul><li><p>点对点链路：PPP协议，常用于广域网</p></li><li><p>广播式链路：早期的总线以太网、无线局域网，常用于局域网</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/image-20240421205127193.png" alt="image-20240421205127193"></p></li><li><p>介质访问控制：采取一定的措施，使得两队节点之间的通信不会发生互相干扰的情况</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/image-20240421204840402.png" alt=""></p></li><li><p>静态划分信道：信道划分介质访问控制</p><ul><li>频分多路复用 FDM：一个用户占一个频段</li><li>时分多路复用 TDM：交替使用</li><li>波分多路复用 WDM</li><li>码分多路复用 CDM</li></ul></li><li><p>动态划分信道</p><ul><li>轮询访问介质访问控制：令牌传递协议<ul><li>令牌：一个特殊格式的MAC控制帧，不含任何信息</li><li>问题：<ul><li>令牌开销</li><li>等待延迟</li><li>单点故障</li></ul></li></ul></li><li>随机访问介质访问控制<ul><li>ALOHA协议：（不听就说）<ul><li>纯ALOHA协议：不监听信道，不按时间槽发送，随机发送（吞吐量低，效率更低）</li><li>时隙ALOHA协议：时间分为时间片，只能在时间片开始的时候发送</li></ul></li><li>CSMA协议：（先听再说）在发送数据之前先检测一些总线上是否有其他计算机在发送数据，信道空闲就发送，信道忙就推迟发送<ul><li>CS：载波监听</li><li>MA：多点接入</li></ul></li><li>CSMA/CD协议：用于总线以太网（有线）<ul><li>CD：冲突检测（边发送边监听）</li></ul></li><li>CSMA/CA协议：用于无线局域网<ul><li>CA：碰撞避免</li></ul></li></ul></li></ul></li></ul><h3 id="2-5-局域网-LAN"><a href="#2-5-局域网-LAN" class="headerlink" title="2.5 局域网 LAN"></a>2.5 局域网 LAN</h3><ul><li><p>决定局域网的要素：</p><ul><li>网络拓扑：星型、总线型、环形、树型</li><li>传输介质：有线（双绞线、同轴电缆、光纤），无线（电磁波）</li><li>介质访问控制方法：CSMA/CD、令牌总线、令牌环</li></ul></li><li><p>分类</p><ul><li>以太网：最广泛，使用CSMA/CD</li><li>令牌环网：明日黄花 </li><li>FDDI网：</li><li>ATM网</li><li>无线局域网（WLAN）</li></ul></li><li><p>以太网：是多个公司联合开发的<strong>基带总线局域网规范</strong></p><ul><li><p>速率（10Mb/s~10Gb/s）、便宜、简单</p></li><li><p>无连接：无握手过程</p></li><li>不可靠：不可对发送方的数据帧编号，接收方不想发送方确认，差错帧直接丢弃，纠错由高层负责</li><li><p>传输介质发展：粗同轴电缆、细同轴电缆、双绞线+集线器</p></li><li><p>适配器与MAC地址：48位二进制地址，前24未由IEEE规定（代表厂家）、后24位由厂家指定</p></li><li>以太网MAC帧：目前最常用是以太网V2格式</li></ul></li><li><p>无线局域网 </p><ul><li>IEEE 802.11是无线局域网通用的标准（WIFI）</li></ul></li><li><p>VLAN</p><ul><li>传统局域网局限<ul><li>缺乏流量隔离</li><li>管理用户不便</li><li>路由器成本高</li></ul></li><li>VLAN：虚拟局域网，将局域网内的设备划分成与物理位置无关的逻辑组的技术，每个VLAN是一个单独的广播域/不同的子网</li><li>VLAN实现：路由器和三层交换机<ul><li>VLAN表（绑定端口或者MAC地址）</li></ul></li></ul></li></ul><h3 id="2-6-广域网-WAN"><a href="#2-6-广域网-WAN" class="headerlink" title="2.6 广域网 WAN"></a>2.6 广域网 WAN</h3><ul><li>通信子网主要使用分组交换技术，如Internet</li><li>PPP协议<ul><li>简单：对于链路层的帧，无需纠错，无需序号，无需流量控制</li><li>封装成帧：帧定界符</li><li>透明传输</li><li>多种网络层学医</li><li>多种类型链路</li><li>差错检测</li><li>检测连接状态</li><li>最大传送单元</li><li>网络层地址协商</li><li>数据压缩协商</li></ul></li></ul><h3 id="2-7-链路层设备"><a href="#2-7-链路层设备" class="headerlink" title="2.7 链路层设备"></a>2.7 链路层设备</h3><ul><li><p>网桥&amp;交换机</p><ul><li><p>网桥根据MAC帧的目的地址对帧进行过滤、转发。（收到一个帧时，不向所有的接口转发此帧，而是先检查此帧的目的MAC地址，再转发到对应接口）</p></li><li><p>分类</p><ul><li>透明网桥：”透明“指以太网上的站点并不知道所发送的帧将经过哪几个网桥（动态更新一个转发表，记录MAC地址和网桥接口的对应关系）</li><li>源路由网桥：在发送帧时，把详细的最佳路由信息（路由最少/时间最短）放在帧首部，</li></ul></li></ul></li></ul><h2 id="Cp3-网络层"><a href="#Cp3-网络层" class="headerlink" title="Cp3 网络层"></a>Cp3 网络层</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">网络层 --&gt; 转发</span><br><span class="line">转发 --&gt; 硬件结构</span><br><span class="line">转发 --&gt; 协议</span><br><span class="line">转发 --&gt; IPv4分组</span><br><span class="line">转发 --&gt; 网络层编址</span><br><span class="line">转发 --&gt; 网络地址转换NAT</span><br><span class="line">转发 --&gt; IPv6</span><br><span class="line">转发 --&gt; 移动IP</span><br><span class="line">网络层 --&gt; 路由选择</span><br><span class="line">路由选择 --&gt; 路由选择算法</span><br><span class="line">路由选择 --&gt; 路由选择协议</span><br><span class="line">路由选择 --&gt; IP组播</span><br></pre></td></tr></table></figure><ul><li><p>功能</p><ul><li>路由选择与分组转发</li><li><p>异构网络互联 </p></li><li><p>拥塞控制</p></li></ul></li></ul><h3 id="3-1-路由算法"><a href="#3-1-路由算法" class="headerlink" title="3.1 路由算法"></a>3.1 路由算法</h3><ul><li>路由表/转发表：目的网络IP地址、子网掩码、下一IP地址、接口 </li><li>分类<ul><li>静态：手动配置</li><li>动态：</li></ul></li></ul><h3 id="3-2-IP数据报"><a href="#3-2-IP数据报" class="headerlink" title="3.2 IP数据报"></a>3.2 IP数据报</h3><ul><li><p>组成</p><ul><li>首部：分为固定部分（20字节或160位）和可变部分</li><li>数据部分（TCP/UDP段）</li></ul></li><li><p>首部</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/image-20240422141810076.png" alt="image-20240422141810076"></p><ul><li><p>版本(4bit)：IPv4或者IPv6</p></li><li><p>首部长度(4bit)：至少是20Byte(固定部分就20B)，所以是0101-1111</p></li><li><p>区分服务(8bit)：期望获得哪种类型服务</p></li><li><p>总长度(16bit)：首部+数据大小，因为有16bit，所以上限是2^16-1=26635Byte，实际不会这么大，会分片</p></li><li><p>标识(16bit)：同一个数据报分片使用同一标识</p></li><li><p>标志(3bit)：只有2bit有意义</p><ul><li>中间位DF=1 禁止分片；DF=0 允许分片</li><li>最低位MF=1 后面还有分片 MF=0 最后一片 </li></ul></li><li><p>片偏移(13bit)：改分片在原来数据报的位置</p></li><li><p>生存时间TTL(8bit)：每经过一个路由器就减1，变0就丢弃</p></li><li><p>协议(4bit)：数据部分使用的协议</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/image-20240422142213527.png" alt="image-20240422142213527"></p></li><li><p>首部检验和(8bit)：只检验首部</p></li><li>源地址、目的地址(32bit)：IPv4/IPv6地址</li><li>填充字段：大小不固定，全是0，让首部大小为4整数倍</li></ul></li></ul><h3 id="3-3-IPv4地址"><a href="#3-3-IPv4地址" class="headerlink" title="3.3 IPv4地址"></a>3.3 IPv4地址</h3><ul><li>32位/4字节，标识路由器主机的接口</li><li><p>网络号+主机号</p></li><li><p>分类的IP地址</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/image-20240422144401519.png" alt="image-20240422144401519"></p></li><li><p>IPv6</p><ul><li>CIDR NAT治标不治本</li><li>十六进制</li></ul></li></ul><h3 id="3-4-网络地址转换NAT"><a href="#3-4-网络地址转换NAT" class="headerlink" title="3.4 网络地址转换NAT"></a>3.4 网络地址转换NAT</h3><ul><li>在专用网连接到英特网上的路由器上安装NAT软件，安装了NAT软件的路由器叫NAT路由器，它至少有一个有效的外部全球IP地址</li></ul><h3 id="3-5-子网划分"><a href="#3-5-子网划分" class="headerlink" title="3.5 子网划分"></a>3.5 子网划分</h3><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/image-20240422145124633.png" alt="image-20240422145124633" style="zoom: 67%;" /></p><ul><li>子网掩码：网络号全为1，主机号全为0</li></ul><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/image-20240422145327188.png" alt="image-20240422145327188" style="zoom: 50%;" /></p><ul><li>eg：IP地址是141.14.72.24 子网掩码是255.255.192.0，则网络地址是：141.14.64.0<ul><li>192对应11000000，72对应01001000，所以网络地址第三部分是01000000，也就是64</li></ul></li></ul><h3 id="3-5-无分类编制CIDR"><a href="#3-5-无分类编制CIDR" class="headerlink" title="3.5 无分类编制CIDR"></a>3.5 无分类编制CIDR</h3><ul><li>IP地址后加上<code>/</code>，然后写上网络前缀（任意长度）。如128.14.32.0/20（前20位是网络位）</li></ul><h3 id="3-6-协议"><a href="#3-6-协议" class="headerlink" title="3.6 协议"></a>3.6 协议</h3><ul><li><p><strong>ARP协议</strong>：由IP地址获取MAC地址</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/image-20240422151730682.png" alt="image-20240422151730682" style="zoom:67%;" /></p><ul><li>ARP高速缓存：IP地址和MAC地址的映射</li><li>过程：<ul><li>检查ARP高速缓存，有则写入MAC帧</li><li>没有则用目的MAC地址位FF-FF-FF-FF-FF-FF的帧封装并广播ARP请求</li><li>同一局域网所有主机收到请求，目的主机会给源主机单播一个ARP响应分组</li><li>源主机收到后写入ARP高速缓</li></ul></li><li><p>ARP协议四种典型情况</p><ul><li>主机A ==&gt; 本网络上主机B：用ARP找到主机B的MAC地址</li><li>主机A ==&gt; 另一网络上主机B：用ARP找到本网络上一个路由器（网关）的MAC地址</li><li>路由器 ==&gt; 本网络上主机A：用ARP找到主机A的MAC地址</li><li>路由器 ==&gt; 另一个网络上的主机B：用ARP找到本网络上一个路由器（网关）的MAC地址</li></ul></li><li><p>例子：主机A发送IP数据报给主机B，经过了5个路由器，这个过程使用了6次ARP协议</p></li></ul></li><li><p><strong>DHCP协议</strong>：解决主机获取IP地址的问题</p><ul><li>dhcp协议是应用层协议，基于UDP</li><li>主机可以从服务器动态获取IP地址、子网掩码、默认网关、DNS服务器名称与IP地址，允许地址重用</li><li>过程<ul><li>主机广播DHCP发现报文（有没有DHCP服务器）</li><li>DHCP服务器广播DHCP提供报文（有）</li><li>主机广播DHCP请求报文（我用了你给我的IP地址了）</li><li>DHCP服务器广播DHCP确认报文（好的）</li></ul></li></ul></li><li><p><strong>ICMP协议</strong>：差错报告</p><ul><li>ICMP报文：在IP数据报的数据部分</li></ul><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/image-20240422153505396.png" alt="image-20240422153505396"></p><ul><li>ICMP报文类型<ul><li>ICMP差错报文：终点不可达、源点抑制、时间超过、参数问题、改变路由</li></ul></li><li>例子<ul><li>PING</li><li>Traceroute：跟踪一个分组从源点到终点</li></ul></li></ul></li><li><p>路由选择协议</p><ul><li>内部网关协议：RIP、OSPF</li><li>外部网关协议：BGP</li></ul></li></ul><h3 id="3-7-IP组播"><a href="#3-7-IP组播" class="headerlink" title="3.7 IP组播"></a>3.7 IP组播</h3><ul><li>单播：点对点</li><li>广播：点对多</li><li><p>组播：给特定组的用户发送数据，也是点对多</p></li><li><p>IP组播地址：让源设备能够发送给一组设备（一群共同需求主机的相同标识）</p><ul><li>224.0.0.0~239.255.255.255（D类地址）</li></ul></li><li>特点<ul><li>用的UDP</li><li>对组播数据包不产生ICMP差错报文</li><li>并非所有D类地址都可以作为组播地址</li></ul></li><li>硬件组播：MAC地址</li><li>IGMP协议和组播路由选择协议</li></ul><h3 id="3-8-网络层设备"><a href="#3-8-网络层设备" class="headerlink" title="3.8 网络层设备"></a>3.8 网络层设备</h3><ul><li><p>路由器：具有多个输入输出端口的专用计算机，任务是分组转发</p><ul><li>路由选择：根据所顶的路由选择协议构造路由表，并动态更新维护</li><li>分组转发：根据转发表对分组进行转发</li><li>路由器输入端口处理</li></ul><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/image-20240423154923646.png" alt="image-20240423154923646" style="zoom:50%;" /></p><ul><li><p>输出端口处理</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/image-20240423154947452.png" alt="image-20240423154947452" style="zoom:50%;" /></p></li></ul></li><li><p>三层设备区别</p><ul><li>路由器：可以互联不同网络层的网段</li><li>网桥：可以互联物理层和数据链路层的不同网段</li><li>集线器：不能互联物理层的不同网段</li></ul></li></ul><h2 id="Cp4-传输层"><a href="#Cp4-传输层" class="headerlink" title="Cp4 传输层"></a>Cp4 传输层</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">传输层 --&gt; TCP</span><br><span class="line">TCP --&gt; 可靠传输</span><br><span class="line">TCP --&gt; 流量控制</span><br><span class="line">TCP --&gt; 拥塞控制</span><br><span class="line">传输层 --&gt; UDP</span><br></pre></td></tr></table></figure><h3 id="4-1-概述"><a href="#4-1-概述" class="headerlink" title="4.1 概述"></a>4.1 概述</h3><ul><li><p>只有主机才有的层次，为应用层提供服务，使用网络层的服务</p></li><li><p>功能</p><ul><li>提供进程和进程之间的逻辑通信</li><li>复用和分用</li></ul></li><li><p>复用：应用层所有的应用进程都可以通过传输层再传输到网络层</p></li><li><p>分用：传输层从网络层收到数据后交付指明的应用进程</p></li><li><p>端口号：长度为16bit，范围0~65536</p><ul><li><p>服务端使用</p><ul><li><p>熟知端口号，给TCP/IP最重要的一些应用程序，让所有用户都知道。0~1023</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/image-20240423171028770.png" alt="image-20240423171028770"></p></li><li><p>登记端口号，1024~49151</p></li></ul></li><li><p>客户端使用：49152~65536</p></li></ul></li><li><p>套接字：主机号+端口</p></li><li><p>两个协议：UDP和TCP</p></li></ul><h3 id="4-2-UDP"><a href="#4-2-UDP" class="headerlink" title="4.2 UDP"></a>4.2 UDP</h3><ul><li><p>在IP数据服务上增加了<strong>复用分用</strong>和<strong>差错检测</strong>的功能</p></li><li><p>特点</p><ul><li><p>无连接</p></li><li><p>连接不可靠</p></li><li><p>面向报文，适合一次性传输少量数据的网络应用（应用层给多长的报文，UDP就照样发送）</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/image-20240423171214541.png" alt="image-20240423171214541" style="zoom:50%;" /></p></li><li><p>UDP无拥塞控制，适合实时应用</p></li><li><p>首部开销小，8Byte</p></li></ul></li><li><p>UDP首部：共8Byte</p><ul><li>16bit源端口号 + 16bit源目的号 + 16bitUDP长度 + 16bit校验和</li></ul></li></ul><h3 id="4-3-TCP"><a href="#4-3-TCP" class="headerlink" title="4.3 TCP"></a>4.3 TCP</h3><ul><li><p>特点</p><ul><li><p>面向连接</p></li><li><p>点对点</p></li><li><p>连接可靠</p></li><li><p>提供全双工通信（发送缓存、接收缓存）</p></li><li><p>面向字节流</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/image-20240423172055897.png" alt="image-20240423172055897"></p></li></ul></li><li><p>TCP首部：20Byte</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/image-20240423172112523.png" alt="image-20240423172112523" style="zoom:67%;" /></p><ul><li>序号（sequence number）：标识本报文段所发送数据的第一个字节的序号</li><li>确认号（acknowledgement number）：期望收到对方下一个报文段的第一个数据字节序号，只有ACK为1的时候才生效</li><li>数据偏移：TCP报文段数据起始举例TCP报文段起始有多远</li><li>6个控制位<ul><li>URG：紧急位，=1时可以插队</li><li>ACK：确认位，连接后置为1</li><li>PSH：推送位，=1时，接收方尽快交付接收应用进程，不再等到缓存填满再向上交付</li><li>RST：复位，=1时，表明TCP连接中出现严重差错，必须释放连接再重新建立连接 </li><li>SYN：同步位，=1时表明是一个连接请求/连接接收报文</li><li>FIN：终止位，=1时候表明此报文发送方数据已发送完，要求释放连接</li></ul></li><li>窗口：发送方发送窗口的大小，用来给接收方来调整接收窗口大小</li></ul></li><li><p>TCP连接管理</p><ul><li>建立连接<ul><li>客户端发送连接请求报文段，无应用层数据<ul><li>SYN=1，seq=x，seq是序号</li></ul></li><li>服务端为改TCP连接分配缓存和变量，并给客户端返回确认报文，无应用层数据<ul><li>SYN=1，ACK=1，seq=y，ack=x+1，ack是确认号</li></ul></li><li>客户端为该TCP连接分配缓存和变量，并给客户端发送确认，可以携带数据<ul><li>SYN=0，ACK=1，seq=x+1,ack=y+1</li></ul></li></ul></li><li>数据传送</li><li>连接释放<ul><li>客户端发送连接释放报文段<ul><li>FIN=1，seq=u</li></ul></li><li>服务器回送一个确认报文段，客户端==&gt;服务器方向连接释放，半关闭状态<ul><li>ACK=1，seq=v，ack=u+1</li></ul></li><li>服务器发送完数据，发出连接释放报文段<ul><li>FIN=1，ACK=1，seq=w，ack=u+1</li></ul></li><li>客户端回送一个确认报文段，再等待时间计时器设置的2MSL（最长报文段寿命）后，连接彻底关闭<ul><li>ACK=1，seq=u+1，ack=w+1</li></ul></li></ul></li></ul></li><li><p>SYN洪泛攻击</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/image-20240423173844705.png" alt="image-20240423173844705"></p></li><li><p>TCP可靠传输</p><ul><li>校验：与UDP一样，增加伪首部</li><li>序号：一个报文段第一个字节的序号</li><li>确认：累计确认机制</li><li>重传：超时重传</li></ul></li><li>TCP流量控制<ul><li>滑动窗口，通过设置报文段中的窗口字段来实现动态控制</li></ul></li><li>TCP拥塞控制<ul><li>慢开始</li><li>拥塞避免</li><li>快重传</li><li>快恢复</li></ul></li></ul><h2 id="Cp5-网络层"><a href="#Cp5-网络层" class="headerlink" title="Cp5 网络层"></a>Cp5 网络层</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">应用层 --&gt; 模型</span><br><span class="line">模型 --&gt; C/S</span><br><span class="line">模型 --&gt; P2P</span><br><span class="line">应用层 --&gt; 应用程序相关</span><br><span class="line">应用程序相关 --&gt; DNS</span><br><span class="line">应用程序相关 --&gt; 文件传输FTP</span><br><span class="line">应用程序相关 --&gt; 万维网WWW</span><br><span class="line">应用程序相关 --&gt; 电子邮件</span><br></pre></td></tr></table></figure><ul><li>应用层：对应用程序的通信提供服务<ul><li>应用程序交换的报文类型：请求or响应</li><li>报文的用法，如报文中各个字段的详细描述</li><li>字段的语义</li><li>进程何时及如何发送报文，以及如何响应报文</li></ul></li><li>功能<ul><li>文件传输、访问和管理：FTP</li><li>电子邮件：SMTP、POP3</li><li>虚拟终端 ：HTTP</li><li>查询服务和远程作业登录：DNS</li></ul></li></ul><h3 id="5-1-网络应用模型"><a href="#5-1-网络应用模型" class="headerlink" title="5.1 网络应用模型"></a>5.1 网络应用模型</h3><ul><li><p>C/S模型</p><ul><li>服务器：提供服务<ul><li>永久提供服务</li><li>永久性的访问地址/域名</li></ul></li><li>客户端：请求计算服务的主机<ul><li>与服务器通信</li><li>间歇性接入网络</li><li>可能是动态IP地址</li><li>不与其他客户机直接通信</li></ul></li></ul></li><li><p>P2P模型：没有服务器</p><ul><li><p>每个主机既可以提供服务，也可以请求服务</p></li><li><p>节点可能动态IP</p></li><li>网络健壮性好</li></ul></li></ul><h3 id="5-2-DNS系统"><a href="#5-2-DNS系统" class="headerlink" title="5.2 DNS系统"></a>5.2 DNS系统</h3><ul><li>域名到IP地址的转换</li><li>域名：n级别域名.n-1级域名….二级域名.顶级域名<ul><li>顶级域名：com cn org gov等</li><li>二级域名：com edu gov等</li></ul></li><li>域名解析过程<ul><li>递归查询：一步一步向上查询（A查B，B查不到然后B去查C）</li><li>迭代查询：A查B，B查不到返回一个上层服务器地址C，A再去查C</li></ul></li><li>高速缓存</li></ul><h3 id="5-3-文件传输协议"><a href="#5-3-文件传输协议" class="headerlink" title="5.3 文件传输协议"></a>5.3 文件传输协议</h3><ul><li>FTP：提供不同类型的主机之间的文件传输，基于C/S的协议</li><li>FTP工作原理<ul><li>使用TCP实现可靠传输</li><li>控制连接，数据连接</li></ul></li></ul><h3 id="5-4-电子邮件"><a href="#5-4-电子邮件" class="headerlink" title="5.4 电子邮件"></a>5.4 电子邮件</h3><ul><li>信封</li><li>内容</li><li>组成结构<ul><li>用户代理：电子邮件客户端软件（与邮件服务器SMTP，TCP连接）</li><li>邮件服务器：发送方邮件服务器（与邮件服务器SMTP，TCP连接）</li><li>邮件服务器：接收方邮件服务器（与邮件服务器POP3，TCP连接）</li><li>用户代理：收件人用户代理</li></ul></li><li>协议：<ul><li>发送使用SMTP</li><li>接收使用POP3</li></ul></li><li>SMTP协议<ul><li>规定了两个相互通信的SMTP进程之间如何交换信息</li><li>基于TCP连接，端口号25</li></ul></li><li>MIME协议：对SMTP的扩充，使之可以满足音频、图像、视频等传输</li><li>POP3协议<ul><li>基于TCP连接，端口号110</li></ul></li><li>IMAP协议<ul><li>比POP协议复杂</li></ul></li></ul><h3 id="5-5-万维网和HTTP"><a href="#5-5-万维网和HTTP" class="headerlink" title="5.5 万维网和HTTP"></a>5.5 万维网和HTTP</h3><ul><li><p>URL一般形式：<code>协议://主机:端口/路径</code></p></li><li><p>HTTP</p><ul><li>建立TCP连接</li><li>HTTP请求报文</li><li>HTTP响应报文</li><li>释放TCP连接</li></ul></li><li>用户输入URL过程<ul><li>浏览器分析URL</li><li>浏览器向DNS请求解析IP地址</li><li>DNS解析处IP地址</li><li>浏览器与服务器建立TCP连接</li><li>浏览器发出取文件命令</li><li>服务器响应</li><li>释放TCP连接</li><li>浏览器显示</li></ul></li><li><p>HTTP特点</p><ul><li>无状态</li><li>无连接（TCP是传输层的连接）</li></ul></li><li><p>HTTP报文结构：因为是面向文本的，所以报文中每个字段都是一些ASCII码串</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/image-20240428104302925.png" alt="image-20240428104302925" style="zoom:67%;" /></p></li></ul><link rel="stylesheet" href="https://cdn1.tianli0.top/gh/zhheo/Post-Abstract-AI@0.15.2/tianli_gpt.css"><script>let tianliGPT_postSelector = '#post #article-container';let tianliGPT_key = 'c9b7741d290063ab872e';</script><script src="https://cdn1.tianli0.top/gh/zhheo/Post-Abstract-AI@0.15.2/tianli_gpt.js"></script>]]></content>
      
      
      <categories>
          
          <category> study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统</title>
      <link href="/posts/1079.html"/>
      <url>/posts/1079.html</url>
      
        <content type="html"><![CDATA[  <a href="https://www.bilibili.com/video/BV19r4y1b7Aw/" class="bilibili_box" id="BV19r4y1b7Aw"></a>  <script>    bilibili()    function bilibili() {      let dom = document.getElementById('BV19r4y1b7Aw')      fetch('https://api.320.ink/api/b?id=BV19r4y1b7Aw').then(res=>res.json()).then(data=>{        dom.innerHTML = `        <div class="bilibili_cover">          <img src="https://s1.hdslb.com/bfs/static/player/img/play.svg" class="play_icon no-lazyload">          <img src="${data.pic + '&h=300'}" class="no-lazyload">          <span>20:37</span>        </div>        <div class="bilibili_info">          <div class="title">${data.title}</div>          <div class="desc">${data.desc}</div>          <div class="stat">            <span><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 20 20" fill="none" class="icon"><path fill-rule="evenodd" clip-rule="evenodd" d="M4.67735 4.2798C5.98983 4.1725 7.85812 4.0625 10 4.0625C12.1421 4.0625 14.0105 4.17252 15.323 4.27983C16.2216 4.3533 16.9184 5.04049 16.9989 5.9318C17.0962 7.00837 17.1875 8.43614 17.1875 10C17.1875 11.5639 17.0962 12.9916 16.9989 14.0682C16.9184 14.9595 16.2216 15.6467 15.323 15.7202C14.0105 15.8275 12.1421 15.9375 10 15.9375C7.85812 15.9375 5.98983 15.8275 4.67735 15.7202C3.77861 15.6467 3.08174 14.9593 3.00119 14.0678C2.90388 12.9908 2.8125 11.5627 2.8125 10C2.8125 8.43727 2.90388 7.00924 3.00119 5.93221C3.08174 5.04067 3.77861 4.35327 4.67735 4.2798ZM10 2.8125C7.81674 2.8125 5.9136 2.92456 4.5755 3.03395C3.07738 3.15643 1.8921 4.31616 1.75626 5.81973C1.65651 6.92379 1.5625 8.39058 1.5625 10C1.5625 11.6094 1.65651 13.0762 1.75626 14.1803C1.8921 15.6838 3.07738 16.8436 4.5755 16.966C5.9136 17.0754 7.81674 17.1875 10 17.1875C12.1835 17.1875 14.0868 17.0754 15.4249 16.966C16.9228 16.8436 18.108 15.6841 18.2438 14.1807C18.3435 13.077 18.4375 11.6105 18.4375 10C18.4375 8.38948 18.3435 6.92296 18.2438 5.81931C18.108 4.31588 16.9228 3.15645 15.4249 3.03398C14.0868 2.92458 12.1835 2.8125 10 2.8125ZM12.1876 10.722C12.7431 10.4013 12.7431 9.59941 12.1876 9.27866L9.06133 7.47373C8.50577 7.15298 7.81133 7.55392 7.81133 8.19542V11.8053C7.81133 12.4468 8.50577 12.8477 9.06133 12.527L12.1876 10.722Z" fill="#9499A0"/></svg>${data.view}</span>            <span><svg width="36" height="36" viewBox="0 0 36 36" xmlns="http://www.w3.org/2000/svg" class="icon"><path fill-rule="evenodd" clip-rule="evenodd" d="M9.77234 30.8573V11.7471H7.54573C5.50932 11.7471 3.85742 13.3931 3.85742 15.425V27.1794C3.85742 29.2112 5.50932 30.8573 7.54573 30.8573H9.77234ZM11.9902 30.8573V11.7054C14.9897 10.627 16.6942 7.8853 17.1055 3.33591C17.2666 1.55463 18.9633 0.814421 20.5803 1.59505C22.1847 2.36964 23.243 4.32583 23.243 6.93947C23.243 8.50265 23.0478 10.1054 22.6582 11.7471H29.7324C31.7739 11.7471 33.4289 13.402 33.4289 15.4435C33.4289 15.7416 33.3928 16.0386 33.3215 16.328L30.9883 25.7957C30.2558 28.7683 27.5894 30.8573 24.528 30.8573H11.9911H11.9902Z"></path></svg>${data.like}</span>            <span><svg width="28" height="28" viewBox="0 0 28 28" xmlns="http://www.w3.org/2000/svg" class="icon" style="fill:;"><path fill-rule="evenodd" clip-rule="evenodd" d="M14.045 25.5454C7.69377 25.5454 2.54504 20.3967 2.54504 14.0454C2.54504 7.69413 7.69377 2.54541 14.045 2.54541C20.3963 2.54541 25.545 7.69413 25.545 14.0454C25.545 17.0954 24.3334 20.0205 22.1768 22.1771C20.0201 24.3338 17.095 25.5454 14.045 25.5454ZM9.66202 6.81624H18.2761C18.825 6.81624 19.27 7.22183 19.27 7.72216C19.27 8.22248 18.825 8.62807 18.2761 8.62807H14.95V10.2903C17.989 10.4444 20.3766 12.9487 20.3855 15.9916V17.1995C20.3854 17.6997 19.9799 18.1052 19.4796 18.1052C18.9793 18.1052 18.5738 17.6997 18.5737 17.1995V15.9916C18.5667 13.9478 16.9882 12.2535 14.95 12.1022V20.5574C14.95 21.0577 14.5444 21.4633 14.0441 21.4633C13.5437 21.4633 13.1382 21.0577 13.1382 20.5574V12.1022C11.1 12.2535 9.52148 13.9478 9.51448 15.9916V17.1995C9.5144 17.6997 9.10883 18.1052 8.60856 18.1052C8.1083 18.1052 7.70273 17.6997 7.70265 17.1995V15.9916C7.71158 12.9487 10.0992 10.4444 13.1382 10.2903V8.62807H9.66202C9.11309 8.62807 8.66809 8.22248 8.66809 7.72216C8.66809 7.22183 9.11309 6.81624 9.66202 6.81624Z"></path></svg>${data.coin}</span>          </div>          <div class="owner">            <span class="tip">视频</span>            <img src="${data.face + '&h=100'}" class="no-lazyload">            <span>${data.owner}</span>          </div>        </div>        `      })    }  </script>  <h1 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h1><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/image-20240415204817080.png" alt="image-20240415204817080"></p><ul><li><p>应用软件到计算机硬件的中间件  </p></li><li><p>管理硬件</p><ul><li>CPU管理</li><li>内存管理</li><li>终端管理</li><li>磁盘管理</li><li>文件管理</li><li>网络管理</li><li>多核管理</li><li>电源管理</li></ul></li><li><p>冯 诺伊曼存储程序思想</p><ul><li><p>将程序和数存放到计算机内部的存储器中，计算机在程序的控制下一步一步处理</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/image-20240408200356742.png" alt="image-20240408200356742" style="zoom:67%;" /></p></li></ul></li><li><p>操作系统的启动</p><ul><li>引导扇区：512字节，启动设备的第一个扇区，启动设备信息被设置在其中<ul><li>其中的代码是汇编代码（更好的控制内存）</li><li>引导扇区代码：bootsect.s</li></ul></li></ul></li><li><p>操作系统接口</p><ul><li>表现为函数调用，又由系统提供，所以称为<strong>系统调用</strong></li></ul></li><li><p>系统调用的实现</p><ul><li><p>用户态：不能访问内核空间数据</p></li><li><p>内核态：可以访问任何数据</p></li><li><p>如何分离：CPL DPL越小表示权限越高</p><ul><li>内核 DPL = 0</li><li>用户 CPL = 3</li><li>CPL &lt;= DPL方可调用，所以一般用户态无法访问内核态</li></ul></li><li><p>如何切换：中断（唯一方法）int 0x80</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/image-20240408204828529.png" alt="image-20240408204828529"></p></li><li><p>完整过程</p><p><img src="C:\Users\H\AppData\Roaming\Typora\typora-user-images\image-20240408205211541.png" alt="image-20240408205211541" style="zoom:67%;" /></p><ul><li>开始判断用户态CPL=3  &gt;  内核 DPL= 0，不能直接访问，走系统调用</li><li>根据系统调用号(exa=72)发送 int 0x80指令到达系统（因为_system_call的DPL=3，故可以调用）</li><li>当调用_system_call后CPL置为0，此时再访问内核就可以了</li></ul></li></ul></li><li><p>系统调用核心：</p><ul><li>用户程序中包含一段<strong>int指令</strong>代码</li><li>操作系统写<strong>中断处理</strong>，获取想调程序的编号</li><li>操作系统更具编号执行相应代码</li></ul></li></ul><h2 id="一-CPU管理"><a href="#一-CPU管理" class="headerlink" title="一 CPU管理"></a>一 CPU管理</h2><ul><li>CPU工作原理<ul><li>自动的取指-执行：从指定的地址中取出指令执行</li><li>只需要设置要PC初值即可，后续可以不断的自动取指执行</li></ul></li><li><p>并发：一个CPU上交替执行多个程序（为了提高利用率）</p></li><li><p><strong>线程</strong>切换</p><ul><li>需要 记录线程切换出去时候的信息？用<strong>进程</strong>来描述</li></ul></li></ul><h3 id="1-1-多进程图像"><a href="#1-1-多进程图像" class="headerlink" title="1.1 多进程图像"></a>1.1 多进程图像</h3><ul><li><p>开机的时候<code>fork()</code>了第一个进程，随后每执行一个子任务，<code>fork()</code>新的进程</p></li><li><p><code>PCB(Process Control Block)</code>：用来记录进程信息的数据结构</p></li><li><p><code>TCB(Thread Control Block)</code>：用来记录线程信息的数据结构</p></li><li><p>进程状态</p><ul><li>新建态</li><li>就绪态</li><li>运行态</li><li>阻塞态</li><li>终止态</li></ul><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/image-20240408214304327.png" alt="image-20240408214304327" style="zoom:67%;" /></p></li><li><p>进程队列</p><ul><li>就绪队列</li><li>阻塞队列</li></ul></li><li><p>多进程组织：PCB + 状态 + 队列</p></li><li><p>多进程如何交替</p><ul><li>进程A启动磁盘读写</li><li>修改进程A状态为阻塞态</li><li>将进程A放入阻塞队列</li><li><code>schedule()</code>：进行上下文切换<ul><li><code>getNext()</code>：在就绪队列中找到下一个进程B（线程的调度）</li><li><code>switch_to()</code>：<ul><li>CPU中的信息保存在进程A对应的PCB中，方便下次恢复</li><li>读取进程B中的PCB信息，恢复信息</li></ul></li></ul></li></ul></li></ul><h3 id="1-2-用户级线程"><a href="#1-2-用户级线程" class="headerlink" title="1.2 用户级线程"></a>1.2 用户级线程</h3><ul><li>进程 = 一个资源 + 多个指令执行序列</li><li>多个进程共享资源，可以保留并发的特点，且避免了进程切换的代价</li><li>一个线程一个栈</li><li><code>yield()</code>：线程的切换<ul><li>将当前线程的下一条指令压入栈中（方便后续返回时读取到命令）</li><li>切换TCB</li><li>根据TCB来切换栈</li><li>PC切换（从栈从弹出PC指针）</li><li>执行新的线程</li></ul></li><li><code>create()</code>：生成新的线程<ul><li>申请内存生成栈</li><li>申请内存生成TCB，关联TCB和栈</li><li>将第一条命令放到栈中</li></ul></li></ul><h3 id="1-3-内核级线程"><a href="#1-3-内核级线程" class="headerlink" title="1.3 内核级线程"></a>1.3 内核级线程</h3><ul><li><p>用户级线程：每个线程每个栈</p></li><li><p>内核级线程：因为既要在用户态跑又要在内核态跑，所以有两套栈（内核栈，用户栈）</p></li><li><p>切换<code>switch_to()</code>：</p><ul><li><p>首先线程A从用户态A1<strong>中断</strong>进入内核态A2</p></li><li><p>根据内核态A2的TCB找到切换的线程B的内核态B2的TCB</p></li><li><p>然后再根据B2通过<code>iret</code><strong>中断返回</strong>得到线程B的用户态B1 </p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/image-20240409210815697.png" alt="image-20240409210815697" style="zoom: 50%;" /></p></li></ul></li><li><p>初始化<code>ThreadCreate()</code></p><ul><li>申请内存空间</li><li>创建TCB<ul><li>创建内核栈、用户栈</li></ul></li><li>关联栈和TCB</li></ul></li></ul><h3 id="1-4-用户级、核心级线程对比"><a href="#1-4-用户级、核心级线程对比" class="headerlink" title="1.4 用户级、核心级线程对比"></a>1.4 用户级、核心级线程对比</h3><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/image-20240409210345072.png" alt="image-20240409210345072" style="zoom:67%;" /></p><h3 id="1-5-CPU调度策略"><a href="#1-5-CPU调度策略" class="headerlink" title="1.5 CPU调度策略"></a>1.5 CPU调度策略</h3><ul><li><p>进程阻塞的时候调用<code>Schedule()</code>函数获取下一个可执行的进程</p></li><li><p>IO约束型任务（前台进程特征，这类的优先级应该高一点）和CPU约束型任务</p></li><li>调度算法：<ul><li>FCFS：先来先服务</li><li>SJF：短作业优先</li><li>RR：时间片轮转（保证响应时间）</li></ul></li></ul><h3 id="1-6-进程同步与信号量"><a href="#1-6-进程同步与信号量" class="headerlink" title="1.6 进程同步与信号量"></a>1.6 进程同步与信号量</h3><ul><li><p>进程同步：让进程走走停停保证多进程合作</p></li><li><p>信号量：用来解决只发送信号来实现同步的不足，更全面的表达进程的信息</p><ul><li><p>记录有多少进程睡眠和唤醒</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/image-20240409220845574.png" alt="image-20240409220845574" style="zoom:67%;" /></p></li><li><p>和信号的区别：信号只有1和0两个状态，信号量可以有多个状态</p></li><li><p>eg：一个资源数量是8，对应的信号量是2，则表示当前有2个资源可以使用，如果是-2则表示有两个进程等待这个资源</p></li></ul></li><li><p>信号量解决生产者消费者问题案例</p><ul><li>生产者停的条件：缓冲区满</li><li>消费者停的条件：缓冲区空</li><li>信号量：缓冲区当前大小，初始为buffer_size</li><li>双方在执行的时候判断信号量</li><li>注意：信号量是线程间<strong>互斥</strong>的资源（不能同时读写）</li></ul></li></ul><h3 id="1-7-信号量的临界区保护"><a href="#1-7-信号量的临界区保护" class="headerlink" title="1.7 信号量的临界区保护"></a>1.7 信号量的临界区保护</h3><ul><li>共同修改信号量会造成错误，因此需要保护</li><li><strong>临界区</strong>：一次只允许一个进程进入的该进程的那段代码</li><li>如何找到进程中的临界区代码：读写信号量的代码</li><li>基本原则：互斥</li><li>好的保护原则：有空让进；有限等待</li><li>常见方法：<ul><li>Peterson算法：结合了标记+轮转的算法</li><li>面包店算法</li></ul></li></ul><h3 id="1-8-死锁处理"><a href="#1-8-死锁处理" class="headerlink" title="1.8 死锁处理"></a>1.8 死锁处理</h3><ul><li>成因：<ul><li>互斥使用</li><li>不可抢占</li><li>请求和保持：进程必须占有资源再去申请新的资源</li><li>循环等待：在资源分配图中有环路</li></ul></li><li>死锁预防：破坏死锁出现的条件<ul><li>一次性申请所有需要的资源（资料浪费，编程难）</li><li>资源申请按序进行（资源浪费）</li></ul></li><li>死锁避免：检测每个资源请求，如果造成死锁就拒绝<ul><li>先试用在判断安全序列（算法时间复杂度高）</li></ul></li><li>死锁检测+恢复：检测到死锁的时候让进程回滚，让出资源<ul><li>（恢复困难）</li></ul></li><li>死锁忽略：等重启就解决了<ul><li>（用的多）</li></ul></li></ul><h2 id="二-内存管理"><a href="#二-内存管理" class="headerlink" title="二 内存管理"></a>二 内存管理</h2><h3 id="2-1-内存使用与分段"><a href="#2-1-内存使用与分段" class="headerlink" title="2.1 内存使用与分段"></a>2.1 内存使用与分段</h3><ul><li><p>重定位</p></li><li><p>交换</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/image-20240410102659773.png" alt="image-20240410102659773" style="zoom:50%;" /></p></li><li><p>使用过程</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/image-20240410103406408.png" alt="image-20240410103406408" style="zoom:50%;" /></p><ul><li>进程1申请到一段内存，PCB指向2000地址，进程2申请到另一端内存，PCB指向1000地址</li><li>当进程1执行的时候，PC指针取址100，放到CPU中</li><li>根据进程1的基地址(2000)得到进程1的代码地址2100</li><li>当需要切换到进程2的时候，先根据PCB切换到进程2的基地址1000 </li><li>执行进程2，PC指针继续取址执行</li></ul></li><li><p>内存分段：程序并不是整段放到内存中，分段放在不同的地方</p><ul><li><p>段+段内偏移</p></li><li><p>PCB中此时不只是一个基址了，而是每个段的基址（LDT表）</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/image-20240410104432330.png" alt="image-20240410104432330" style="zoom:67%;" /></p></li></ul></li></ul><h3 id="2-2-内存分区和分页"><a href="#2-2-内存分区和分页" class="headerlink" title="2.2 内存分区和分页"></a>2.2 内存分区和分页</h3><ul><li>内存分区<ul><li>可变分区：空闲分区表+已分配分区表</li><li>固定分区</li></ul></li><li>内存分区问题<ul><li>内存外碎片</li><li>如果需要内存紧缩的话就很耗时</li></ul></li><li>内存分页：<ul><li>会造成内碎片，但是可以根据页的大小来控制碎片的大小</li></ul></li></ul><h3 id="2-3-多级页表与块表"><a href="#2-3-多级页表与块表" class="headerlink" title="2.3 多级页表与块表"></a>2.3 多级页表与块表</h3><ul><li><p>问题：为提高内存利用率，页应该很小，但是页小了页表就大了</p></li><li><p>方法一：只存放用到的页</p><ul><li>带来的问题：页表中的页号不连续，需要比较、查找，线性的查找耗时</li></ul></li><li><p>方法二：<strong>多级页表</strong>：页目录表（章）+页表（节）</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/image-20240410155109348.png" alt="image-20240410155109348" style="zoom: 67%;" /></p><ul><li>空间利用率高，但是增加了访问的次数</li></ul></li><li><p><strong>块表</strong>：TLB，一组相联快速存储，是寄存器</p><ul><li>一次比对就可以找到（类似于书签，redis）</li><li>如果在块表中没有命中再查多级页表，然结果再放到TLB中</li><li>关键是提高TLB的命中率</li></ul></li></ul><h3 id="2-4-段页结合的内存管理"><a href="#2-4-段页结合的内存管理" class="headerlink" title="2.4 段页结合的内存管理"></a>2.4 段页结合的内存管理</h3><ul><li><p>程序员希望用段，物理内存希望用页</p></li><li><p>虚拟内存</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/image-20240410161014066.png" alt="image-20240410161014066" style="zoom: 50%;" /></p></li><li><p>对于用户来说是段式存储，对于物理内存来说是页式存储</p></li><li><p>根据段号得到一个基址(虚拟地址)，由基址得到一个页号，再根据页号查找页表得到真实的物理地址</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/image-20240410161448350.png" alt="image-20240410161448350" style="zoom:50%;" /></p></li></ul><h3 id="2-5-内存换入换出"><a href="#2-5-内存换入换出" class="headerlink" title="2.5 内存换入换出"></a>2.5 内存换入换出</h3><ul><li><p>用换入换出来实现“大内存”</p><ul><li>虚拟内存4G，实际内存1G，给用户一种4G的感觉</li></ul></li><li><p>换入：请求调页</p><ul><li>用户给一个基址，在虚拟内存中查发现物理地址中缺页，CPU从磁盘中载入相应资源到物理内存中</li></ul></li><li><p>换出：选择一页淘汰，换出到磁盘中</p><ul><li>FIFO</li><li>MIN</li><li><strong>LRU</strong></li></ul></li><li><p>LRU实现换出</p><ul><li><p>方法一：每页维护一个时间戳，淘汰最小的时间戳对应的页</p></li><li><p>方法二：维护一个页码栈，淘汰栈底 </p></li><li><p>方法三近似实现Clock算法：每个页加一个引用位，每访问一页，硬件自动设置该位1，淘汰时如果是1就置为0，如果是0就淘汰</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/image-20240410164923481.png" alt="image-20240410164923481" style="zoom:67%;" /></p></li><li><p>方法四Clock改进：两个扫描指针：一个用来清除R位，移动速度快；一个用来淘汰页，移动速度慢</p></li></ul></li><li><p>另一个问题：进程分配的页框</p><ul><li>太多了内存利用率不高</li><li>太少了导致缺页率高 ==&gt; 磁盘的换入换出频率高 ==&gt; 进程等待时间长，发生<strong>颠簸</strong></li></ul></li></ul><h2 id="三-磁盘、文件管理"><a href="#三-磁盘、文件管理" class="headerlink" title="三 磁盘、文件管理"></a>三 磁盘、文件管理</h2><h3 id="3-1-IO与显示器"><a href="#3-1-IO与显示器" class="headerlink" title="3.1 IO与显示器"></a>3.1 IO与显示器</h3><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/image-20240415205054190.png" alt="image-20240415205054190" style="zoom:50%;" /></p><ul><li><p>对外设的使用本质是向他们</p><ul><li>发送指令(<strong>out 指令</strong>)</li><li>将out指令做成接口（<strong>文件视图</strong>）</li><li>进行设备的<strong>中断处理</strong></li></ul></li><li><p>printf：先创建缓存buf将格式化都输出在那里，然后再write(1, buf, …)</p><ul><li>printf</li><li>系统调用(wirte)</li><li>字符设备接口(crw_table)</li><li>tty设备写(tty_wirte)</li><li>显示器写(con_wirte)</li></ul></li></ul><h3 id="3-2-键盘"><a href="#3-2-键盘" class="headerlink" title="3.2 键盘"></a>3.2 键盘</h3><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/image-20240415214935201.png" alt="image-20240415214935201" style="zoom:67%;" /></p><h3 id="3-3-生磁盘的使用"><a href="#3-3-生磁盘的使用" class="headerlink" title="3.3 生磁盘的使用"></a>3.3 生磁盘的使用</h3><ul><li>磁盘访问单位：扇区（512字节）<ul><li>升级到盘块，一次读取的内容变多，减少磁盘寻道(瓶颈)时间，用空间换时间</li></ul></li><li><p>只要往控制器中写柱面、磁头、扇区、缓存位置</p></li><li><p>过程</p><ul><li>进程得到盘块号，算出扇区号</li><li>用扇区号make req，用电梯算法add_request</li><li>进程sleep</li><li>磁盘中断处理</li><li>算出cyl,head,sector</li><li>调用outp()完成端口写</li></ul></li></ul><link rel="stylesheet" href="https://cdn1.tianli0.top/gh/zhheo/Post-Abstract-AI@0.15.2/tianli_gpt.css"><script>let tianliGPT_postSelector = '#post #article-container';let tianliGPT_key = 'c9b7741d290063ab872e';</script><script src="https://cdn1.tianli0.top/gh/zhheo/Post-Abstract-AI@0.15.2/tianli_gpt.js"></script>]]></content>
      
      
      <categories>
          
          <category> study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>杂七杂八点子</title>
      <link href="/posts/37774.html"/>
      <url>/posts/37774.html</url>
      
        <content type="html"><![CDATA[<h4 id="中文外挂标签测试"><a href="#中文外挂标签测试" class="headerlink" title="中文外挂标签测试"></a>中文外挂标签测试</h4><p><a href="https://myxiaochuang.gitee.io/posts/7d73fc91/#%E5%AE%89%E8%A3%85">https://myxiaochuang.gitee.io/posts/7d73fc91/#%E5%AE%89%E8%A3%85</a></p><div class="video"><video controls preload><source src='https://myl-mdimg.oss-cn-beijing.aliyuncs.com/video/demo.mp4' type='video/mp4'>Your browser does not support the video tag.</video></div><h4 id="哔哩哔哩卡片标签"><a href="#哔哩哔哩卡片标签" class="headerlink" title="哔哩哔哩卡片标签"></a>哔哩哔哩卡片标签</h4><p><a href="https://myxiaochuang.gitee.io/posts/7d73fc91/#%E5%AE%89%E8%A3%85">https://myxiaochuang.gitee.io/posts/7d73fc91/#%E5%AE%89%E8%A3%85</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% bilibili 视频链接 [视频时长 隐藏简介] %&#125;</span><br></pre></td></tr></table></figure>  <a href="https://www.bilibili.com/video/BV1PC4y1q7F2/" class="bilibili_box" id="BV1PC4y1q7F2"></a>  <script>    bilibili()    function bilibili() {      let dom = document.getElementById('BV1PC4y1q7F2')      fetch('https://api.320.ink/api/b?id=BV1PC4y1q7F2').then(res=>res.json()).then(data=>{        dom.innerHTML = `        <div class="bilibili_cover">          <img src="https://s1.hdslb.com/bfs/static/player/img/play.svg" class="play_icon no-lazyload">          <img src="${data.pic + '&h=300'}" class="no-lazyload">          <span>03:29</span>        </div>        <div class="bilibili_info">          <div class="title">${data.title}</div>          <div class="desc">${data.desc}</div>          <div class="stat">            <span><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 20 20" fill="none" class="icon"><path fill-rule="evenodd" clip-rule="evenodd" d="M4.67735 4.2798C5.98983 4.1725 7.85812 4.0625 10 4.0625C12.1421 4.0625 14.0105 4.17252 15.323 4.27983C16.2216 4.3533 16.9184 5.04049 16.9989 5.9318C17.0962 7.00837 17.1875 8.43614 17.1875 10C17.1875 11.5639 17.0962 12.9916 16.9989 14.0682C16.9184 14.9595 16.2216 15.6467 15.323 15.7202C14.0105 15.8275 12.1421 15.9375 10 15.9375C7.85812 15.9375 5.98983 15.8275 4.67735 15.7202C3.77861 15.6467 3.08174 14.9593 3.00119 14.0678C2.90388 12.9908 2.8125 11.5627 2.8125 10C2.8125 8.43727 2.90388 7.00924 3.00119 5.93221C3.08174 5.04067 3.77861 4.35327 4.67735 4.2798ZM10 2.8125C7.81674 2.8125 5.9136 2.92456 4.5755 3.03395C3.07738 3.15643 1.8921 4.31616 1.75626 5.81973C1.65651 6.92379 1.5625 8.39058 1.5625 10C1.5625 11.6094 1.65651 13.0762 1.75626 14.1803C1.8921 15.6838 3.07738 16.8436 4.5755 16.966C5.9136 17.0754 7.81674 17.1875 10 17.1875C12.1835 17.1875 14.0868 17.0754 15.4249 16.966C16.9228 16.8436 18.108 15.6841 18.2438 14.1807C18.3435 13.077 18.4375 11.6105 18.4375 10C18.4375 8.38948 18.3435 6.92296 18.2438 5.81931C18.108 4.31588 16.9228 3.15645 15.4249 3.03398C14.0868 2.92458 12.1835 2.8125 10 2.8125ZM12.1876 10.722C12.7431 10.4013 12.7431 9.59941 12.1876 9.27866L9.06133 7.47373C8.50577 7.15298 7.81133 7.55392 7.81133 8.19542V11.8053C7.81133 12.4468 8.50577 12.8477 9.06133 12.527L12.1876 10.722Z" fill="#9499A0"/></svg>${data.view}</span>            <span><svg width="36" height="36" viewBox="0 0 36 36" xmlns="http://www.w3.org/2000/svg" class="icon"><path fill-rule="evenodd" clip-rule="evenodd" d="M9.77234 30.8573V11.7471H7.54573C5.50932 11.7471 3.85742 13.3931 3.85742 15.425V27.1794C3.85742 29.2112 5.50932 30.8573 7.54573 30.8573H9.77234ZM11.9902 30.8573V11.7054C14.9897 10.627 16.6942 7.8853 17.1055 3.33591C17.2666 1.55463 18.9633 0.814421 20.5803 1.59505C22.1847 2.36964 23.243 4.32583 23.243 6.93947C23.243 8.50265 23.0478 10.1054 22.6582 11.7471H29.7324C31.7739 11.7471 33.4289 13.402 33.4289 15.4435C33.4289 15.7416 33.3928 16.0386 33.3215 16.328L30.9883 25.7957C30.2558 28.7683 27.5894 30.8573 24.528 30.8573H11.9911H11.9902Z"></path></svg>${data.like}</span>            <span><svg width="28" height="28" viewBox="0 0 28 28" xmlns="http://www.w3.org/2000/svg" class="icon" style="fill:;"><path fill-rule="evenodd" clip-rule="evenodd" d="M14.045 25.5454C7.69377 25.5454 2.54504 20.3967 2.54504 14.0454C2.54504 7.69413 7.69377 2.54541 14.045 2.54541C20.3963 2.54541 25.545 7.69413 25.545 14.0454C25.545 17.0954 24.3334 20.0205 22.1768 22.1771C20.0201 24.3338 17.095 25.5454 14.045 25.5454ZM9.66202 6.81624H18.2761C18.825 6.81624 19.27 7.22183 19.27 7.72216C19.27 8.22248 18.825 8.62807 18.2761 8.62807H14.95V10.2903C17.989 10.4444 20.3766 12.9487 20.3855 15.9916V17.1995C20.3854 17.6997 19.9799 18.1052 19.4796 18.1052C18.9793 18.1052 18.5738 17.6997 18.5737 17.1995V15.9916C18.5667 13.9478 16.9882 12.2535 14.95 12.1022V20.5574C14.95 21.0577 14.5444 21.4633 14.0441 21.4633C13.5437 21.4633 13.1382 21.0577 13.1382 20.5574V12.1022C11.1 12.2535 9.52148 13.9478 9.51448 15.9916V17.1995C9.5144 17.6997 9.10883 18.1052 8.60856 18.1052C8.1083 18.1052 7.70273 17.6997 7.70265 17.1995V15.9916C7.71158 12.9487 10.0992 10.4444 13.1382 10.2903V8.62807H9.66202C9.11309 8.62807 8.66809 8.22248 8.66809 7.72216C8.66809 7.22183 9.11309 6.81624 9.66202 6.81624Z"></path></svg>${data.coin}</span>          </div>          <div class="owner">            <span class="tip">视频</span>            <img src="${data.face + '&h=100'}" class="no-lazyload">            <span>${data.owner}</span>          </div>        </div>        `      })    }  </script>  <link rel="stylesheet" href="https://cdn1.tianli0.top/gh/zhheo/Post-Abstract-AI@0.15.2/tianli_gpt.css"><script>let tianliGPT_postSelector = '#post #article-container';let tianliGPT_key = 'c9b7741d290063ab872e';</script><script src="https://cdn1.tianli0.top/gh/zhheo/Post-Abstract-AI@0.15.2/tianli_gpt.js"></script>]]></content>
      
      
      <categories>
          
          <category> study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 杂七杂八点子 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>实招</title>
      <link href="/posts/56035.html"/>
      <url>/posts/56035.html</url>
      
        <content type="html"><![CDATA[<p><a href="https://javaguide.cn/">https://javaguide.cn/</a></p><p><a href="https://itwanger.gitee.io/tobebetterjavaer/#/">https://itwanger.gitee.io/tobebetterjavaer/#/</a></p><p><a href="https://pdai.tech/">https://pdai.tech/</a></p><h2 id="一-基础"><a href="#一-基础" class="headerlink" title="一 基础"></a>一 基础</h2><h3 id="1-JavaSE"><a href="#1-JavaSE" class="headerlink" title="1 JavaSE"></a>1 JavaSE</h3><p><a href="https://javaguide.cn/java/basis/java-basic-questions-01.html">https://javaguide.cn/java/basis/java-basic-questions-01.html</a></p><ul><li><code>StringBuilder</code>和<code>StringBuffer</code>:后者是线程安全的，每个公开方法都被<code>synchronized</code> 修饰了</li></ul><blockquote><p>hashMap新增元素</p></blockquote><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/image-20240314172246695.png" alt="image-20240314172246695" style="zoom:67%;" /></p><hr><blockquote><p>ThreadLocal内存泄漏</p></blockquote><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/image-20240315170346022.png" alt="image-20240315170346022" style="zoom: 33%;" /></p><ul><li>一个<code>Thread</code>里面有多个<code>ThreadLocal</code>对象，每个<code>ThreadLocal</code>对象对应一个值，所有的<code>ThreadLocal</code>放在<code>ThreadLocalMap</code>中，里面有一个<code>Entry</code>数组，根据<code>ThreadLocal</code>对象的哈希值来确定在数组中的位置。</li><li>内存泄露的根本原因：</li></ul><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/image-20240315170633122.png" alt="image-20240315170633057" style="zoom: 50%;" /></p><ul><li><code>ThreadLocalMap</code> 中使用的 key 为 <code>ThreadLocal</code> 的弱引用，而 value 是强引用。所以，如果 <code>ThreadLocal</code> 没有被外部强引用的情况下，在垃圾回收的时候，key 会被清理掉，而 value 不会被清理掉。</li><li>如果ThreadLocal没有外部强引用，那么在发生垃圾回收的时候，ThreadLocal就必定会被回收，而ThreadLocal又作为Map中的key，ThreadLocal被回收就会导致一个key为null的entry，外部就无法通过key来访问这个entry，垃圾回收也无法回收，这就造成了内存泄漏</li><li>如何防止：<code>ThreadLocal</code>的<code>remove()</code>方法<ul><li>在get和set的方法中可能会调用这个remove方法</li><li>ThreadLocal虽然提供了避免内存泄露的方法，但是ThreadLocal不会主动去执行这些方法，需要我们在使用完ThreadLocal对象中保存的数据后，在<strong>finally{}代码块中调用ThreadLocal的remove()方法</strong>，加快GC自动垃圾回收，避免内存泄露。</li></ul></li></ul><hr><blockquote><p>synchronized底层原理</p></blockquote><ul><li>Java 对象底层都会关联一个 monitor，使用 synchronized 时 JVM 会根据使用环境找到对象的 monitor，根据 monitor 的状态进行加解锁的判断。如果成功加锁就成为该 monitor 的唯一持有者，monitor 在被释放前不能再被其他线程获取。</li><li>执行 monitorenter 指令时，首先尝试获取对象锁。如果这个对象没有被锁定，或当前线程已经持有锁，就把锁的计数器加 1，执行 monitorexit 指令时会将锁计数器减 1。一旦计数器为 0 锁随即就被释放。cc</li></ul><hr><blockquote><p>重写equals方法的时候为什么一定要重写hashcode方法？</p></blockquote><ul><li>通常判断两个对象是否相等会先判断<code>hashcode()</code>返回值，如果不等则一定不等，相等了就继续判断<code>equals()</code>——性能</li><li>以HashMap举例，当put元素的时候：<ul><li>会先计算对象的<code>hashcode()</code>,而Object方法中的<code>hashcode()</code>对比的是不同对象的地址，所以结果一定是false，导致这个元素被认为是新的key被添加，就会出现重复key的情况</li></ul></li><li>Set也是这样</li></ul><hr><blockquote><p>获取.Class方式</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Class</span> <span class="variable">alunbarClass</span> <span class="operator">=</span> TargetObject.class; <span class="comment">// 知道了具体的类</span></span><br><span class="line"><span class="type">Class</span> <span class="variable">alunbarClass1</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;cn.javaguide.TargetObject&quot;</span>); <span class="comment">// Class.forName传入全路径</span></span><br><span class="line"><span class="type">Class</span> <span class="variable">alunbarClass2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TargetObject</span>().getClass(); <span class="comment">// 通过对象实例getClass()方法</span></span><br><span class="line"><span class="type">Class</span> <span class="variable">alunbarClass3</span> <span class="operator">=</span> ClassLoader.getSystemClassLoader().loadClass(<span class="string">&quot;cn.javaguide.TargetObject&quot;</span>); <span class="comment">// classLoader</span></span><br></pre></td></tr></table></figure><hr><blockquote><p>ArrayList 扩容？</p></blockquote><ul><li><p><code>grow()</code>函数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">newCapacity</span> <span class="operator">=</span> oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>); <span class="comment">// 每次扩容1.5倍</span></span><br><span class="line"><span class="comment">// 如果小于最小容量，就设置newCapacity为最小容量</span></span><br><span class="line"><span class="comment">// 如果大于最大容量，则更新最大容量</span></span><br></pre></td></tr></table></figure></li></ul><blockquote><p>RandomAccess 接口</p></blockquote><ul><li>一个标记接口，表明实现该接口的类支持随机访问</li></ul><blockquote><p>hashMap 扩容</p></blockquote><ul><li><code>resize()</code>：会伴随一次重新的hash分配，遍历hash表中的所有元素，非常耗时</li><li>扩容为原来的两倍</li></ul><blockquote><p>ConcurrentHashMap</p></blockquote><ul><li>1.7之前<ul><li>由多个segment数组组成，每个segment是一个类似于HashMap的结构，可以扩容，但是segment数组不能扩</li><li>默认是16个segment，也就是默认的并发数量16</li></ul></li><li>1.8及之后<ul><li>node数组+链表/红黑树</li></ul></li></ul><blockquote><p>CopyOnWriteArrayList</p></blockquote><ul><li>写时复制，只有写写操作的时候才会互斥</li></ul><blockquote><p>为什么String不可变</p></blockquote><ul><li>线程安全</li><li>缓存Hash值，将String作为Key在hash表中查找时，由于hashCode不变，所以查找速度快</li><li>安全性，如果可以变的话会被攻击（密码），因为string不可变，所以对应的hash也不可变</li><li>避免重复创建字符串，提高效率</li></ul><h3 id="2-Spring"><a href="#2-Spring" class="headerlink" title="2 Spring"></a>2 Spring</h3><blockquote><p>Spring、Spring boot、Spring MVC</p></blockquote><ul><li>Spring是一个IOC容器，用来管理Bean，使用依赖注入来实现控制反转，可以很方便的整合各种框架，提供AOP机制弥补面向对象的OOP的代码重复问题，更方便的将不同类不同方法中的共同处理抽取成切面、自动注入给方法执行，比如日志、异常等</li><li>Spring MVC是spring对web框架的一个解决方案，提供了一个总的前端控制器servlet：DispatcherServlet，用来接收请求，然后定义了一套路由策略（从url到handle 的映射）以及适配执行handle，将handler结果使用视图解析技术生成视图展现给前端</li><li>springboot是spring提供的一个快速开发工具包，让程序员更方便、更快速的开发spring+springmvc应用，简化了配置（约定了默认配置），整合了一系列的解决方案（starter机制）、redis、mongodb、es可以开箱即用</li></ul><hr><blockquote><p>为什么SpringBoot的jar包可以直接运行</p></blockquote><ul><li>引入了spring-boot-maven-plugin</li><li>springBoot程序打包后生成了一个 Fat jar(jar中包含jar)，包含了依赖的jar包和springboot loader相关类</li><li><code>java -jar</code>会去找jar中的mainfest文件，在那里找到启动类</li></ul><blockquote><p>SpringBoot如何支持跨域请求</p></blockquote><ul><li><p>CORS：跨源资源共享</p><ul><li><p>Controller方法上<code>@CrossOrigin(&quot;http://localhost:8081&quot;)</code>设置某一个接口允许跨域</p></li><li><p>实现<code>WebMvcConfigurer</code>，重写其中的<code>addCorsMappings(CorsRegistry registry)</code>方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyWebMvcConfigurer</span> <span class="keyword">implements</span> <span class="title class_">WebMvcConfigurer</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addCorsMappings</span><span class="params">(CorsRegistry registry)</span> &#123;</span><br><span class="line">        registry.addMapping(<span class="string">&quot;/user/*&quot;</span>)</span><br><span class="line">            .allowedOrigins(<span class="string">&quot;http://localhost:8080&quot;</span>)</span><br><span class="line">            .allowedMethods(<span class="string">&quot;GET&quot;</span>, <span class="string">&quot;POST&quot;</span>, <span class="string">&quot;PUT&quot;</span>, <span class="string">&quot;DELETE&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>通过配置一个bean控制所有的请求</p></li></ul></li><li><p>Nginx反向代理</p><ul><li><p>比如前端要发送跨域的请求就统一加上一个 /cors/</p></li><li><p>在nginx中配置location</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">location</span> /cors/ &#123;</span><br><span class="line"><span class="attribute">proxy_pass</span> http://localhost:8080/user/;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><hr><blockquote><p>spring AOP </p></blockquote><ul><li>AOP 的目的是将横切关注点（如日志记录、事务管理、权限控制、接口限流、接口幂等等）从核心业务逻辑中分离出来，通过动态代理、字节码操作等技术，实现代码的复用和解耦，提高代码的可维护性和可扩展性。</li><li>为减少代码冗余，使开发专注于核心业务逻辑，减少代码维护成本而提出的一种思想，是通过动态代理的方式来实现的，将需要注入切面的对象进行代理，在进行调用的时候，将公共的逻辑直接添加进去，而不需要修改原有业务的逻辑代码，只需要在原来的业务逻辑基础之上做一些增强功能即可。<ul><li>切面 ==&gt;  公共代码：通知和切点的结合。通知和切点共同定义了切面的全部内容——它是什么，在何时和在何处完成其功能</li><li>切点： 定义了需要执行在哪些连接点上执行通知。</li><li>连接点：是在应用执行过程中能够插入切面的一个点。</li><li>引入：引入允许我们向现有的类添加新方法或属性</li><li>织入：把切面应用到目标对象并创建新的代理对象的过程</li><li>通知：定义了何时，做什么。<code>@After @Around @Before @AfterReturning @AfterThrowing</code></li></ul></li></ul><hr><blockquote><p>spring IOC</p></blockquote><ul><li>使用的<code>interface ApplicationContext</code>是<code>BeanFactory</code>的子类</li><li>继承了多个接口扩展功能</li><li><p>有两个具体实现的子类</p><ul><li><code>ClassPathXmlApplicationContext</code>：从class path 中加载配置文件，更常用一些；</li><li><code>FileSystemXmlApplicationContext</code> ：从本地文件中加载配置文件，不是很常用，如果再到 Linux 环境中，还要改路径，不是很方便。</li></ul></li><li><p>通过对象的set方法注入的</p></li></ul><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/image-20240318205523668.png" alt="image-20240318205523668"></p><ul><li><p>如何实现一个IOC容器</p><p>1、先准备一个基本的容器对象，包含一些map结构的集合，用来方便后续过程中存储具体的对象</p><p>2、进行配置文件的读取工作或者注解的解析工作，将需要创建的bean对象都封装成BeanDefinition对象存储在容器中</p><p>3、容器将封装好的BeanDefinition对象通过反射的方式进行实例化，完成对象的实例化工作</p><p>4、进行对象的初始化操作，也就是给类中的对应属性值就行设置，也就是进行依赖注入，完成整个对象的创建，变成一个完整的bean对象，存储在容器的某个map结构中</p><p>5、通过容器对象来获取对象，进行对象的获取和逻辑处理工作</p><p>6、提供销毁操作，当对象不用或者容器关闭的时候，将无用的对象进行销毁</p></li></ul><p>注意：依赖注入是实现IOC的一个方法</p><hr><blockquote><p>bean生命周期</p></blockquote><ul><li>Bean容器找到配置文件中的bean，通过反射创建，用set()方法赋值</li><li>如果 Bean 实现了 <code>BeanNameAware</code> 接口，调用 <code>setBeanName()</code>方法，传入 Bean 的名字。</li><li>如果实现了 <code>*.Aware</code>接口，就调用相应的方法。<ul><li>如果 Bean 实现了 <code>BeanClassLoaderAware</code> 接口，调用 <code>setBeanClassLoader()</code>方法，传入 <code>ClassLoader</code>对象的实例。</li><li>如果 Bean 实现了 <code>BeanFactoryAware</code> 接口，调用 <code>setBeanFactory()</code>方法，传入 <code>BeanFactory</code>对象的实例。</li></ul></li><li>如果有和加载这个 Bean 的 Spring 容器相关的 <code>BeanPostProcessor</code> 对象，执行<code>postProcessBeforeInitialization()</code> 方法</li><li>如果 Bean 实现了<code>InitializingBean</code>接口，执行<code>afterPropertiesSet()</code>方法。</li><li>如果 Bean 在配置文件中的定义包含 init-method 属性，执行指定的方法。</li><li><p>如果有和加载这个 Bean 的 Spring 容器相关的 <code>BeanPostProcessor</code> 对象，执行<code>postProcessAfterInitialization()</code> 方法</p></li><li><p>使用</p></li><li>当要销毁 Bean 的时候，如果 Bean 实现了 <code>DisposableBean</code> 接口，执行 <code>destroy()</code> 方法。</li><li>当要销毁 Bean 的时候，如果 Bean 在配置文件中的定义包含 destroy-method 属性，执行指定的方法。</li></ul><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/image-20240318205941719.png" alt="image-20240318205941719"></p><hr><blockquote><p>spring中的设计模式</p></blockquote><ul><li>工厂模式<ul><li><code>BeanFactory</code></li><li><code>ApplicationContext</code></li></ul></li><li>单例模式<ul><li>bean的默认作用域就是单例</li></ul></li><li>代理模式<ul><li>AOP动态代理</li></ul></li><li>模板方法设计模式<ul><li>jdbcTemplate</li><li>redistemplate</li></ul></li><li>观察者设计模式</li><li>适配器设计模式<ul><li>在Spring MVC中，DispatcherServlet根据请求信息调用HandlerMapping，解析请求对应的Handler，解析到对应的Handler（也就是我们常说的Controller控制器）后，开始由HandlerAdapter适配器处理</li></ul></li><li>装饰者设计模式<ul><li>Spring 中配置DataSource的时候，DataSource可能是不同的数据库和数据源。我们能否根据客户的需求在少修改原有类的代码下切换不同的数据源？这个时候据需要用到装饰者模式。</li></ul></li></ul><hr><blockquote><p>Spring 依赖注入的方式</p></blockquote><ul><li>能注入的数据类型<ul><li>基本类型+String</li><li>其他的bean</li><li>复杂类型/集合类型</li></ul></li><li>注入方式<ul><li>使用构造函数</li><li>set方法</li><li>注解</li></ul></li></ul><hr><blockquote><p>自动装配 - SpringBoot约定大于配置的理念的产物</p></blockquote><ul><li><p>依赖注入的plus，简化了依赖注入的配置而生成的</p></li><li><p>主启动类上的注解<strong><code>@SpringbootApplication</code></strong>是一个复合注解，其中比较重要的</p><ul><li><code>@SpringbootConfiguration</code>：springboot的相关配置</li><li><code>@EnableAutoConfiguration</code></li><li><code>@ComponentScan</code>：扫描一些包并注入</li></ul></li><li>重点<strong><code>@EnableAutoConfiguration</code></strong>，也是一个复合注解<ul><li><code>@import(AutoConfigurationImportSelect.class)</code></li></ul></li><li><p><code>AutoConfigurationImportSelect</code> implements了<strong><code>DeferredImportSelector</code></strong></p><ul><li><p>因为是Deferred,所以自动配置类会放在最后加载,方便扩展和覆盖</p></li><li><p>其中重写了<strong><code>selectImports()</code></strong>方法：获取所有符合条件的类的全限定类名，加载到IOC容器中</p><ul><li><p>判断是否开启了自动装配：<code>spring.boot.enableautoconfiguration=true</code></p></li><li><p>获取<code>@EnableAutoConfiguration</code>中的<code>exclude</code>和<code>excludeName</code></p></li><li><p>读取所有spring boot start下面的classpath:/META-INF/spring.factories文件(key-value形式)</p></li><li><p>通过<code>@ConditionalOn</code>排除无效的自动配置类</p></li></ul></li></ul></li><li>配置文件的信息如何加载到bean中：classpath:/META-INF/spring.factories文件存储了一些键信息（<strong>SpringBoot约定大于配置的理念</strong>），然后加载的时候配置文件的值就被加载到这个文件中了</li><li>两种<ul><li><code>@Autowired</code>：根据类型自动注入<ul><li><code>@Qualifier</code>：格外指定bean的id（当IOC根据属性类型去容器中找找到多个相同类型的组件的时候需要使用）</li></ul></li><li><code>@Resource</code>：根据bean的名称自动注入<ul><li>这个是Java规范</li></ul></li></ul></li></ul><hr><blockquote><p>代理</p></blockquote><ul><li><p>不直接访问目标类,而是通过访问代理类来实现目标类方法,形成方法增强</p></li><li><p>静态代理</p><ul><li>预先编写,执行前有了编译好的字节码文件</li></ul></li><li>动态代理<ul><li>JDK动态代理：<ul><li><code>Proxy</code> 类的<code>newProxyInstance()</code>来生成代理对象</li><li>实现<code>invocationHandler</code>,重写<code>invoke()</code>方法实现代理类方法的增强</li><li>通过反射执行</li><li><code>getInstance()</code>传入代理对象 生成代理类</li></ul></li><li>CGLIB<strong>(Spring AOP默认)</strong><ul><li><code>Enhancer</code>类的<code>create()</code>方法创建代理类</li><li>实现<code>MethodInterceptor</code>，重写<code>intercept()</code>方法实现增强</li><li>why Spring AOP默认:非接口代理</li></ul></li></ul></li><li>对比jdk和cglib<ul><li>都是运行期间生成字节码，jdk直接生成class字节码，cglib使用ASM框架写的class字节码。后者更加复杂，代理类生成效率更低</li><li>jdk动态代理是通过反射机制来执行方法，cglib是通过FastClass机制（索引分配直接调用）直接调用方法，后者动态代理类执行效率更高</li></ul></li></ul><hr><blockquote><p>spring boot 常用注解</p></blockquote><ul><li><code>@RestController</code> &lt;==&gt; <code>@Controller</code> + <code>@ResponseBody</code> ：返回的是json，不能返回html页面</li><li><code>@ResquestMapping</code> ，<code>@PutMapping</code> ，<code>@PGetMapping</code> ，<code>@PostMapping</code> ，<code>@DeleteMapping</code> </li><li><code>@PathVarible</code> </li><li><p><code>@Value</code>，<code>@Autowired</code> ，<code>@Resource</code></p></li><li><p><code>@ControllerAdvice</code> ，<code>@ExceptionHandler</code></p></li><li><p><code>@Configuration</code>，<code>@Component</code> ， <code>@Service</code>，<code>@Mapper</code></p></li><li><code>@Transactional</code></li><li><code>@FeignClient</code></li></ul><hr><blockquote><p>Spring MVC 过程</p></blockquote><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/image-20240308102514363.png" alt="image-20240308102514363"></p><ul><li><code>filter</code>：在1和11过程中发挥作用</li><li><code>interceptor</code>：<ul><li><code>preHandle()</code>方法在4之前的时候执行</li><li><code>postHandle()</code>在9之前完成</li><li><code>afterCompletion()</code>在10渲染完成后执行</li></ul></li><li>过滤器和拦截器一般使用<ul><li>前者一般用于过滤敏感词汇（sql注入）、设置字符编码、URL权限访问控制、压缩响应信息</li><li>后者一般用于登录验证（JWT）、访问资源权限验证、日志记录、处理cookie、本地化/国际化/主题、性能监控：请求处理时长</li></ul></li></ul><hr><blockquote><p>spring 三级缓存</p></blockquote><ul><li><p>解决循环依赖</p><ul><li>前提：单例bean；依赖注入的方式不能全是构造器注入的方式</li></ul></li><li><p>一级缓存singletonObjects：已经初始化好的bean，即已经完成初始化好的注入对象的代理</p></li><li><p>二级缓存earlySingletonObjects：还没有完全被初始化好的中间对象代理</p></li><li><p>三级缓存singletonFactory：存放的是还未初始化完的bean，不是代理对象</p></li><li><p>过程：<a href="https://www.cnblogs.com/daimzh/p/13256413.html">https://www.cnblogs.com/daimzh/p/13256413.html</a></p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/image-20240321165705162.png" alt="image-20240321165705162" style="zoom: 50%;" /></p></li></ul><blockquote><p>spring的事务</p></blockquote><ul><li>编程式事务：通过 <code>TransactionTemplate</code>或者<code>TransactionManager</code>手动管理事务，少用</li><li>声明式事务：基于AOP实现，一般使用<code>@Transactional</code> 的注解</li></ul><blockquote><p>spring 事务失效</p></blockquote><ul><li>bean对象没有被容器管理</li><li>方法修饰符不是public</li><li>自身调用自身方法</li><li>数据源没有配置事务管理器</li><li>数据库不支持事务</li><li>异常被捕获</li><li>异常类型错误或配置错误</li></ul><h3 id="3-SpringCloud"><a href="#3-SpringCloud" class="headerlink" title="3 SpringCloud"></a>3 SpringCloud</h3><ul><li>配置中心与注册中心:Nacos<ul><li>eureka注册中心</li></ul></li><li>统一网关:Gateway</li><li>Feign的远程调用<ul><li>熔断处理</li></ul></li><li><p>CAP:</p><ul><li><strong>Consistency</strong>（一致性）：任意时刻都一致</li><li><strong>Availability</strong>（可用性）：任意时刻都可用</li><li><strong>Partition tolerance</strong>（分区容忍性）:由于分布式系统通过网络进行通信，网络是不可靠的。当任意数量的消息丢失或延迟到达时，系统仍会继续提供服务，不会挂掉</li><li>CP：秒杀</li><li>CA：银行</li></ul></li><li><p>BASE理论</p><ul><li><strong>Basically Available</strong>：基本可用</li><li><strong>Soft-state</strong>：软状态</li><li><strong>Eventually Consistent</strong>：最终一致</li></ul></li></ul><blockquote><p>事务一致性</p></blockquote><ul><li>事务四大特：原子性、一致性、隔离性、持久性</li><li>事务一致性是指数据库处理前后结果应与其所抽象的客观世界中真实状况保持一致。<ul><li>银行AB转账，总和为100(A50 B50)，转账后不可能为A-50 B150</li></ul></li></ul><blockquote><p>数据一致性</p></blockquote><ul><li>根本原因在于数据的复制</li><li>强一致性：CP<ul><li>主库更新后会一直等待所有从库更新再返回更新成功。保证了主从一直一致，保证了数据的完整性</li><li>银行</li></ul></li><li>弱一致性：AP： 最终一致性、读写一致性、单调读、因果一致性<ul><li>主库更新后就直接返回更新成功</li><li>互联网场景一般使用这个来保证高可用</li></ul></li></ul><h3 id="4-Git"><a href="#4-Git" class="headerlink" title="4 Git"></a>4 Git</h3><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/面试准备.assets/image-20240307145205270.png" alt="image-20240307145205270" style="zoom: 67%;" /></p><ul><li><p>rebase和merge</p><ul><li><p>merge就是直接合</p></li><li><p>rebase会分块</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/面试准备.assets/image-20240307145801991.png" alt="image-20240307145801991" style="zoom:50%;" /></p></li></ul></li></ul><h3 id="5-Linux"><a href="#5-Linux" class="headerlink" title="5 Linux"></a>5 Linux</h3><ul><li><p>切换用户</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">su yao               <span class="comment">#切换为用户&quot;yao&quot;,输入后回车需要输入该用户的密码</span></span><br><span class="line">  <span class="built_in">exit</span>               <span class="comment">#退出当前用户</span></span><br></pre></td></tr></table></figure></li><li><p>目录</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> <span class="comment"># 切换</span></span><br><span class="line"><span class="built_in">ls</span> <span class="comment"># 查看</span></span><br><span class="line">ll <span class="comment"># 查看详细信息</span></span><br><span class="line"><span class="built_in">mkdir</span> <span class="comment"># 创建</span></span><br><span class="line"><span class="built_in">rm</span> <span class="comment"># 删除remove</span></span><br><span class="line"><span class="built_in">mv</span> <span class="comment"># 移动move</span></span><br><span class="line"><span class="built_in">cp</span> <span class="comment"># 拷贝 copy</span></span><br><span class="line">find <span class="comment"># 搜索</span></span><br><span class="line"><span class="built_in">pwd</span> <span class="comment"># 显示当前路径</span></span><br></pre></td></tr></table></figure></li><li><p>文件</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">rm</span></span><br><span class="line"><span class="built_in">mv</span></span><br><span class="line">vi  <span class="comment"># 编辑</span></span><br><span class="line">vim <span class="comment"># 编辑 更高级</span></span><br><span class="line"><span class="built_in">chmod</span> <span class="comment"># 授权</span></span><br></pre></td></tr></table></figure></li><li><p>权限说明</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># &#x27;r&#x27; 代表可读（4），&#x27;w&#x27; 代表可写（2），&#x27;x&#x27; 代表执行权限</span></span><br></pre></td></tr></table></figure></li><li><p>压缩与解压</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#  .zip、.rar        //windows系统中压缩文件的扩展名</span></span><br><span class="line"><span class="comment">#  .tar              //Linux中打包文件的扩展名</span></span><br><span class="line"><span class="comment">#  .gz               //Linux中压缩文件的扩展名</span></span><br><span class="line"><span class="comment">#  .tar.gz           //Linux中打包并压缩文件的扩展名</span></span><br><span class="line">tar -zxvf a.tar                      <span class="comment">#解包至当前目录</span></span><br><span class="line">tar -zcvf a.tar file1 file2,...      <span class="comment">#多个文件压缩打包</span></span><br></pre></td></tr></table></figure></li><li><p>安装</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">rpm -ivh httpd-2.2.3-22.0.1.el5.i386.rpm    <span class="comment"># 使用rpm文件安装apache </span></span><br><span class="line">rpm -uvh httpd-2.2.3-22.0.1.el5.i386.rpm    <span class="comment"># 使用rpm更新apache </span></span><br><span class="line">rpm -ev httpd<span class="comment"># 卸载/删除apache </span></span><br><span class="line">yum install httpd      <span class="comment"># 使用yum安装apache   </span></span><br><span class="line">yum update httpd       <span class="comment"># 更新apache </span></span><br><span class="line">yum remove httpd       <span class="comment"># 卸载/删除apache </span></span><br></pre></td></tr></table></figure></li><li><p>运行docker</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl start docker</span><br></pre></td></tr></table></figure></li></ul><blockquote><p>文件描述符File descriptor（fd）</p></blockquote><ul><li>内核为了高效管理这些已经被打开的文件所创建的<strong>索引</strong></li><li>所有执行IO操作的系统调用都通过文件描述符来实现</li><li>0是标准输入，1是标准输出，2是标准错误</li><li>打开一个文件，它的文件描述符会是3，再打开一个文件文件描述符就是4…</li></ul><h3 id="6-Docker"><a href="#6-Docker" class="headerlink" title="6 Docker"></a>6 Docker</h3><ul><li><p>镜像（image）：Docker将应用程序及其所需的依赖、函数库、环境、配置等文件打包在一起，称为镜像。</p></li><li><p>容器（Container）：镜像中的应用程序运行后形成的进程就是<strong>容器</strong>，只是Docker会给容器做隔离，对外不可见。</p></li><li><p>通过命令启动docker：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">systemctl start docker  <span class="comment"># 启动docker服务</span></span><br><span class="line"></span><br><span class="line">systemctl stop docker  <span class="comment"># 停止docker服务</span></span><br><span class="line"></span><br><span class="line">systemctl restart docker  <span class="comment"># 重启docker服务</span></span><br></pre></td></tr></table></figure></li><li><p>镜像操作</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">docker push <span class="comment"># 推送镜像</span></span><br><span class="line">docker pull <span class="comment"># 从服务器拉取镜像</span></span><br><span class="line">docker build <span class="comment"># 构建镜像</span></span><br><span class="line">docker save <span class="comment"># 保存镜像为压缩包</span></span><br><span class="line">docker load <span class="comment"># 加载压缩的镜像</span></span><br></pre></td></tr></table></figure></li><li><p>容器操作</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">docker run <span class="comment"># 镜像加载为容器</span></span><br><span class="line">docker <span class="built_in">exec</span> <span class="comment"># 进入容器执行命令</span></span><br><span class="line">docker logs <span class="comment"># 查看日志</span></span><br><span class="line">docker ps <span class="comment"># 查看所有运行的容器</span></span><br><span class="line">docker pause <span class="comment"># 暂停</span></span><br><span class="line">docker stop <span class="comment"># 容器停止</span></span><br><span class="line">docker start <span class="comment"># 容器启动</span></span><br><span class="line">docker <span class="built_in">rm</span> <span class="comment"># 删除</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="7-Redis：NoSQL-数据库"><a href="#7-Redis：NoSQL-数据库" class="headerlink" title="7 Redis：NoSQL 数据库"></a>7 Redis：NoSQL 数据库</h3><ul><li>见苍穹和学成</li><li>主从和哨兵可以解决高可用、高并发读的问题</li></ul><blockquote><p>redis数据类型</p></blockquote><ul><li><p>5种基本数据类型：</p><ul><li><p>String</p></li><li><p>List：双向链表数据结构</p></li><li><p>Hash：类似于HashMap(数组+链表)还做了些优化，一个key下面有多个键值对</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/image-20240321105748037.png" alt="image-20240321105748037" style="zoom: 50%;" /></p></li><li><p>Set：类似于HashSet</p></li><li><p>Zset：有序的set</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SET、 MSET(批量) 、GET 、SETNX 、SETEX 、EXISTS 、DEL 、EXPIRE key seconds -- String</span><br><span class="line">RPUSH(尾部/右边添加元素)、LPUSH 、LSET key index value(设置值，指定了索引)、LPOP、RPOP(移除并获取)、LLEN(长度)  -- List</span><br><span class="line">HSET key field value、HMSET key field1 value1 field2 value2...、HGET key field、HEXISTS key field、     -- Hash</span><br><span class="line">SADD key member1 member2 ...、  -- Set</span><br><span class="line">SETBIT key offset value、GETBIT key offset、BITOP operation destkey key1 key2...(位运算，and or nor..)   -- Bitmap</span><br></pre></td></tr></table></figure></li><li><p>3种特殊数据类型：</p><ul><li><p>Bitmap(位图) <code>SETBIT</code>  <code>GETBIT</code>：就是一个01的数组</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/image-20240321113223104.png" alt="image-20240321113223104" style="zoom:50%;" /></p></li><li><p>HyperLogLog（基数统计）</p></li><li><p>Geospatial (地理位置)</p></li></ul></li></ul><blockquote><p>为什么快？</p></blockquote><ul><li>基于内存存储</li><li>单线程事件循环和 IO 多路复用</li><li>内置了多种优化过后的数据类型/结构实现，性能非常高</li></ul><blockquote><p>redis的IO多路复用</p></blockquote><ul><li>多路指多个网络连接客户端，复用指同一个进程/线程，redis的I/O 多路复用其实是使用一个线程来检查多个Socket的就绪状态，在单个线程中通过记录跟踪每一个socket（I/O流）的状态来管理处理多个I/O流</li><li>Reactor设计模式</li><li>当一个客户端建立连接的时候，会生成一个套接字描述符（是文件描述符fd的一种）</li><li>redis将这个fd注册到监听表中，监听多个fd的读写状态</li><li>当有事件产生的时候I/O 多路复用模块就会将那些产生了事件的套接字fd传送给文件事件分派器。</li><li>文件事件分派器接收到I/O多路复用程序传来的套接字fd后，并根据套接字产生的事件类型，将套接字派发给相应的事件处理器来进行处理相关命令操作</li></ul><blockquote><p>缓存读写策略</p></blockquote><ul><li>Cache Aside Pattern 旁路缓存模式：适合读比较多的情况<ul><li>写：先更新db后删除cache</li><li>读：先从cache读，没有数据再从db读，再写入数据到cache</li></ul></li><li>Read/Write Through Pattern 读写穿透 （减小db压力）<ul><li>写：先查cache，不存在则更新db；存在则更新cache，然后cache服务自己更新db（同步）</li><li>读：从cache读，读到则返回；没读到则从db加载到cache再返回</li></ul></li><li>Write Behind Pattern 异步缓存协议<ul><li>写：与上不同之处在于cache服务自己更新db是批量更新（异步）</li><li>读：同上</li></ul></li></ul><blockquote><p>redis的应用场景</p></blockquote><ul><li>缓存</li><li>分布式锁：互斥、高可用、可重入、高性能、非阻塞<ul><li><code>SETNX lockKey uniqueValue</code>  来获取锁； <code>DEL lockKey</code> 来释放锁</li><li>为了防止误删到其他锁，可以使用lua脚本通过key value来判断一下是不是这个锁</li><li>为了防止程序突然挂掉，需要给锁设置一个失效时间：<code>SET lockKey uniqueValue EX 3 NX</code>——3s过期，也可以用PX(单位是ms)</li></ul></li><li>限流<ul><li>redis+lua(为了保证操作的原子性)+AOP</li></ul></li><li>消息队列（没人用）<ul><li>List 数据类型</li></ul></li><li>延时队列<ul><li>Redisson 内置了延时队列，基于Sorted Set</li></ul></li><li>分布式session</li></ul><blockquote><p>常见实现</p></blockquote><ul><li><p>购物车用Hash：用户id位key，商品id为field，商品数量为value</p></li><li><p>排行榜用ZSet</p></li><li><p>抽奖用Set：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SADD key member1 member2 ...：向指定集合添加一个或多个元素。</span><br><span class="line">SPOP key count：随机移除并获取指定集合中一个或多个元素，适合不允许重复中奖的场景。</span><br><span class="line">SRANDMEMBER key count : 随机获取指定集合中指定数量的元素，适合允许重复中奖的场景。</span><br></pre></td></tr></table></figure></li><li><p>统计活跃用户：bitmap，日期作为key，用户id为offset(类似于数组下标)，活跃就设置为1，没活跃就设置为0</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">SETBIT 20210308 1 1</span><br><span class="line">SETBIT 20210308 2 1</span><br><span class="line">SETBIT 20210309 1 1</span><br><span class="line">// 用户1 两天都登录了， 用户2只在3.8登录</span><br><span class="line"></span><br><span class="line">BITOP and desk1 20210308 20210309</span><br><span class="line">BITCOUNT desk1 //总活跃人数：1(两天都登录)</span><br><span class="line"></span><br><span class="line">BITOP or desk2 20210308 20210309</span><br><span class="line">BITCOUNT desk2 // 在线活跃人数：2(只要登录就行)</span><br></pre></td></tr></table></figure></li></ul><blockquote><p>redis有序集合为什么用跳表不用平衡树、红黑树、B+树</p></blockquote><ul><li>平衡树的插入、删除和查询的时间复杂度和跳表一样都是 O(log n)，但是插入和删除都要额外的维护平衡而旋转(耗时)</li><li>红黑树需要通过旋转和染色（红黑变换）来保证黑平衡。并且，按照区间来查找数据这个操作，红黑树的效率没有跳表高。</li><li>B+树更适合作为数据库和文件系统中常用的索引结构之一，它核心是为了减少IO来快速定位到索引，但是redis并不需要这个</li></ul><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/image-20240321111144680.png" alt="image-20240321111144680" style="zoom:67%;" /></p><blockquote><p>redis持久化</p></blockquote><ul><li>AOF(append only file) ：<code>appendonly yes</code>开启 先写到AOF缓冲区 再写到系统内核缓冲区 最后写到AOF文件<ul><li><strong>命令追加（append）</strong>：所有的写命令会追加到 AOF 缓冲区。<ul><li>先执行命令后记录日志（mysql相反）<ul><li>避免额外的检查开销；不会阻塞当前的命令执行。</li><li>风险是可能会发送数据丢失</li></ul></li></ul></li><li><strong>文件写入（write）</strong>：将 AOF 缓冲区的数据写入到 AOF 文件中。这一步需要调用<code>write</code>函数（系统调用），<code>write</code>将数据写入到了系统内核缓冲区之后直接返回了（延迟写）。注意！！！此时并没有同步到磁盘。</li><li><strong>文件同步（fsync）</strong>：AOF 缓冲区根据对应的持久化方式（ <code>fsync</code> 策略）向硬盘做同步操作。这一步需要调用 <code>fsync</code> 函数（系统调用）， <code>fsync</code> 针对单个文件操作，对其进行强制硬盘同步，<code>fsync</code> 将阻塞直到写入磁盘完成后返回，保证了数据持久化。<ul><li>fsync：file synchronization</li><li>根据刷盘时机可以区分几种AOF方式：write后马上fsync，write后由后台线程fsync，write后由操作系统fsync(linux为30秒)</li></ul></li><li><strong>文件重写（rewrite）</strong>：随着 AOF 文件越来越大，需要定期对 AOF 文件进行重写，达到压缩的目的。</li><li><strong>重启加载（load）</strong>：当 Redis 重启时，可以加载 AOF 文件进行数据恢复。</li></ul></li><li>RDB(redis database)：快照（快速恢复）<ul><li>save： 同步保存操作，会阻塞 Redis 主线程；</li><li>bgsave：fork 出一个子进程，子进程执行，不会阻塞 Redis 主线程，默认选项。</li></ul></li></ul><blockquote><p>redis线程问题：</p></blockquote><ul><li>单线程：文件事件处理器使用 I/O 多路复用（multiplexing）程序来同时监听多个套接字，I/O 多路复用技术的使用让 Redis 不需要额外创建多余的线程来监听客户端的大量连接，降低了资源的消耗</li><li>4.0之后加入了多线程的支持，但是针对大键值对的删除操作</li><li>6.0之后就基本多线程了</li><li>为什么不使用多线程<ul><li>单线程编程容易并且更容易维护；</li><li>Redis 的性能瓶颈不在 CPU ，主要在内存和网络；</li><li>多线程就会存在死锁、线程上下文切换等问题，甚至会影响性能。</li></ul></li><li>redis后台线程<ul><li><code>bio_close_file</code>：释放 AOF / RDB 等过程中产生的临时文件资源。</li><li><code>bio_aof_fsync</code>：调用 <code>fsync</code> 函数将系统内核缓冲区还未同步到到磁盘的数据强制刷到磁盘（ AOF 文件）。</li><li><code>bio_lazy_free</code>：后台线程释放大对象（已删除）占用的内存空间</li></ul></li></ul><blockquote><p>redis的过期删除策略</p></blockquote><ul><li>惰性删除：取出key的时候删</li><li>定期删除：定期删</li></ul><blockquote><p>redis内存淘汰策略</p></blockquote><ul><li>LRU（最近最少使用）</li><li>LFU（最不经常使用）</li><li>Random</li><li>TTL（生存时间）</li><li>Maxmemory Policy（最大内存策略）</li></ul><blockquote><p>redis性能优化</p></blockquote><ul><li><p>使用批量操作减少网络传输 MSET MGET HMGET HMSET SADD</p></li><li><p>大量key的集中过期问题</p><ul><li>key随机过期时间</li><li>惰性删除</li></ul></li><li><p>避免使用bigkey（大key：value内存过大的key） <code>--bigkeys</code>查找</p></li><li><p>对于hotkey（热点key） <code>--hotkeys</code>查找</p><ul><li>读写分离：主节点写，从节点读</li><li>使用redis集群，将热点数据分散</li><li>采用二级缓存，将 hotkey 存放一份到 JVM 本地内存中</li></ul></li><li><p>内存碎片</p><ul><li><p>原因</p><ul><li>Redis 存储存储数据的时候向操作系统申请的内存空间可能会大于数据实际需要的存储空间</li><li>频繁的修改reids的数据</li></ul></li><li><p>怎么清理</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">config <span class="built_in">set</span> activedefrag <span class="built_in">yes</span></span><br><span class="line"><span class="comment"># 内存碎片占用空间达到 500mb 的时候开始清理</span></span><br><span class="line">config <span class="built_in">set</span> active-defrag-ignore-bytes 500mb</span><br><span class="line"><span class="comment"># 内存碎片率大于 1.5 的时候开始清理</span></span><br><span class="line">config <span class="built_in">set</span> active-defrag-threshold-lower 50</span><br></pre></td></tr></table></figure></li></ul></li></ul><blockquote><p>redis 生产问题</p></blockquote><ul><li>缓存穿透：大量请求打在不存在的key<ul><li>缓存无效的key，设置过期时间</li><li>布隆过滤器</li><li>接口限流</li></ul></li><li>缓存击穿：热点key失效导致大量请求打在db<ul><li>热点数据不过期或者过期时间长</li><li>针对热点数据提前预热，提前放到缓存</li><li>锁：请求数据库写数据到缓存之前，先获取互斥锁，保证只有一个请求落到数据库上，减少数据库压力</li></ul></li><li>缓存雪崩：大量key同时失效导致大量请求打在db<ul><li>针对redis服务器：集群；限流；多级缓存（本地+redis）</li><li>针对缓存失效：随机失效时间；缓存预热；</li></ul></li></ul><blockquote><p>缓存预热的方式</p></blockquote><ul><li>分布式任务调度系统：xxl-job</li><li>消息队列</li></ul><hr><blockquote><p>如何保证redis和数据库的同步</p></blockquote><ul><li><p><a href="https://itwanger.gitee.io/tobebetterjavaer/#/docs/mysql/redis-shuju-yizhixing">https://itwanger.gitee.io/tobebetterjavaer/#/docs/mysql/redis-shuju-yizhixing</a><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/image-20240311214614711.png" alt="image-20240311214614711" style="zoom:67%;" /></p></li><li><p>先写mysql再写redis为什么比先写mysql再删redis差？</p><ul><li><p>如果有多线程修改数据的时候，就可能出现写redis出错，所以直接删除比较好</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/面试准备.assets/image-20240311215337895.png" alt="image-20240311215337895" style="zoom:50%;" /></p></li></ul></li></ul><hr><h3 id="8-ES"><a href="#8-ES" class="headerlink" title="8 ES"></a>8 ES</h3><ul><li><p>Elasticsearch 是一个分布式、RESTful 风格的搜索和数据分析引擎，能够解决不断涌现出的各种用例</p></li><li><p>倒排索引过程</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/学成在线.assets/image-20240304153213090.png" alt="image-20240304153213090" style="zoom:67%;" /></p></li><li><p>概念</p><ul><li>文档：一条完整的数据，包括索引、名称等，以json方式存储</li><li>字段：文档中的具体字段，类似于表格的列</li><li>索引：就是相同类型的文档的集合，类似于表。eg：用户的索引、商品的索引、订单的索引…</li><li>映射(mapping)：索引中字段的约束信息，类似于表的结构约束。</li></ul></li><li><p>安装ik分词器</p></li><li><p>索引库的操作</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/学成在线.assets/image-20240304154138185.png" alt="image-20240304154138185" style="zoom:67%;" /></p></li><li><p>文档的操作</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/学成在线.assets/image-20240304154206085.png" alt="image-20240304154206085" style="zoom:67%;" /></p></li><li><p>搜索结果处理</p><ul><li>排序</li><li>分页</li><li>高亮<ul><li>给文档中的所有关键字都添加一个标签，例如<code>&lt;em&gt;</code>标签</li><li>页面给<code>&lt;em&gt;</code>标签编写CSS样式</li></ul></li></ul></li><li><p>demo</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testMatchAll</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">// 1. 准备Request对象，对应 GET /hotel/_search</span></span><br><span class="line">    <span class="type">SearchRequest</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SearchRequest</span>(<span class="string">&quot;hotel&quot;</span>);</span><br><span class="line">    <span class="comment">// 2. 组织DSL参数 对应 &quot;query&quot;: &#123;&quot;match_all&quot;: &#123;&#125;&#125;</span></span><br><span class="line">    request.source().query(QueryBuilders.matchAllQuery());</span><br><span class="line">    <span class="comment">// 3. 发送请求，得到相应结果</span></span><br><span class="line">    <span class="type">SearchResponse</span> <span class="variable">response</span> <span class="operator">=</span> client.search(request, RequestOptions.DEFAULT);</span><br><span class="line">    System.out.println(response);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    创建SearchRequest对象，指定索引库名</span></span><br><span class="line"><span class="comment">    利用request.source()构建DSL，DSL中可以包含查询、分页、排序、高亮等</span></span><br><span class="line"><span class="comment">    利用client.search()发送请求，得到响应</span></span><br><span class="line"><span class="comment">关键API：    </span></span><br><span class="line"><span class="comment">    一个是request.source()，其中包含了query、order、from、size、highlight等所有功能</span></span><br><span class="line"><span class="comment">    另一个是QueryBuilders，其中包含了match、term、function_score、bool等各种查询</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></li><li><p>数据聚合：用来实现对数据的统计分析计算等</p></li></ul><h3 id="9-RabbitMQ"><a href="#9-RabbitMQ" class="headerlink" title="9 RabbitMQ"></a>9 RabbitMQ</h3><ul><li>概念<ul><li>channel：操作MQ的工具</li><li>exchange：路由消息到队列中</li><li>queue：缓存消息</li><li>virtual host：虚拟主机，是对queue、exchange等资源的逻辑分组</li></ul></li><li>常见模型<ul><li>基本消息队列</li><li>工作消息队列</li><li>发布订阅:广播/路由/主题</li></ul></li><li>异步通讯</li></ul><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/面试准备.assets/image-20240306162652779.png" alt="image-20240306162652779" style="zoom:67%;" /></p><blockquote><p>死信队列？如何导致？</p></blockquote><ul><li>DLX，全称为 <code>Dead-Letter-Exchange</code>，死信交换器，死信邮箱。当消息在一个队列中变成死信 (<code>dead message</code>) 之后，它能被重新被发送到另一个交换器中，这个交换器就是 DLX，绑定 DLX 的队列就称之为死信队列。</li><li>死信的原因<ul><li>消息被拒</li><li>消息过期</li><li>队列满了无法添加</li></ul></li></ul><blockquote><p> 什么是延时队列</p></blockquote><ul><li>延迟队列指的是存储对应的延迟消息，消息被发送以后，并不想让消费者立刻拿到消息，而是等待特定时间后，消费者才能拿到这个消息进行消费。</li><li>实现<ul><li>使用死信交换机Exchange和设置消息的存活时间TTL</li><li>插件</li></ul></li><li>场景<ul><li>订单到期未支付</li></ul></li></ul><blockquote><p>如何确保消息100%不丢失？</p></blockquote><ul><li>消息丢失可能发生于：消息生产阶段(生产者 -&gt; MQ Broker)、消息存储阶段(MQ内部完成)、消息消费阶段(MQ Broker -&gt; 消费者)</li><li>解决：版本递增号校验(多生产端多消费端的时候失效)、全局唯一 ID </li><li>具体实现：<ul><li>生产者 -&gt; Broker：开启RabbitMQ事务，但是缺点是性能消耗大；<strong>使用confirm机制</strong>，这个是异步的<ul><li>代价比较大，需要在生产端额外写相关的确认代码，相对于消息丢失的概率来说代价昂贵</li><li><strong>消息入库</strong>：发送成功后生产端修改消息表的state为0，broker接收到后修改为1，生产端需要开一个定时器来检索消息表，确保发送成功</li></ul></li><li>Broker内部：开启rabbitMQ的持久化机制，将消息持久化到磁盘上；设置MQ集群的镜像模式</li><li>Broker -&gt; 消费者端：ACK确认机制</li></ul></li></ul><blockquote><p>如何保证消息的顺序性</p></blockquote><ul><li>拆分多个 queue(消息队列)，每个 queue(消息队列) 一个 consumer(消费者)，就是多一些 queue (消息队列)而已，确实是麻烦点；</li><li>或者就一个 queue (消息队列)但是对应一个 consumer(消费者)，然后这个 consumer(消费者)内部用内存队列做排队，然后分发给底层不同的 worker 来处理</li><li>用缓存来记录消息的消费情况</li></ul><blockquote><p> 如何确保消息只会被消费一次（任务幂等性的问题）？</p></blockquote><ul><li>建消息表（消息id，是否被消费）</li><li>或者利用redis存储</li><li><p>上述两个问题的关键在于<strong>消息全局id的唯一性</strong>：数据库自增主键、UUID、Redis，Twitter-Snowflake 算法等</p></li><li><p>如何处理消息积压问题？</p><ul><li><p>与生产端没关系，一般中间件的性能也很高，所以一般问题出现在<strong>消费端</strong></p></li><li><p>扩容、降级一些非核心的业务</p></li></ul></li></ul><blockquote><p>消息队列的作用</p></blockquote><ul><li>通过异步处理提高系统性能（减少响应所需时间）</li><li>削峰/限流：先将短时间高并发产生的事务消息存储在消息队列中，然后后端服务再慢慢根据自己的能力去消费这些消息，这样就避免直接把后端服务打垮掉。</li><li>降低系统耦合性。</li></ul><blockquote><p>消息队列带来的问题</p></blockquote><ul><li>系统可用性降低<ul><li>需要考虑消息丢失或者说 MQ 挂掉等等的情况</li></ul></li><li>系统复杂性提高<ul><li>需要保证消息没有被重复消费、处理消息丢失的情况、保证消息传递的顺序性等等问题</li></ul></li><li>一致性问题</li></ul><h3 id="10-Mybaits"><a href="#10-Mybaits" class="headerlink" title="10 Mybaits"></a>10 Mybaits</h3><blockquote><p>Mybatis设计模式</p></blockquote><ul><li>缓存模块:装饰器模式</li><li>日志模块:适配器模式</li><li>SqlSessionFactory:工厂模式</li><li>Mapper接口:代理模式</li><li>SqlssionFactoryBuiler:建造者模式</li></ul><blockquote><p>xml中的常见标签</p></blockquote><ul><li><code>select insert update delete</code></li><li><code>&lt;resultMap&gt;、 &lt;parameterMap&gt;、 &lt;sql&gt;、 &lt;include&gt;、 &lt;selectKey&gt;</code></li><li>动态sql <code>trim|where|set|foreach|if|choose|when|otherwise|bind</code></li></ul><blockquote><p>Executor执行器类别</p></blockquote><ul><li>SimpleExecutor：执行一次销毁</li><li>ReuseExecutor：重复执行</li><li>BatchExecutor：批处理</li></ul><blockquote><p>工作原理/过程</p></blockquote><ul><li>启动加载：SqlSessionFactory完成解析，保存相关配置</li><li>通过SqlSession对象处理请求，先走二级缓存，再一级缓存最后走数据库</li><li>交给StatementHandler来处理，通过ParameterHandler处理SQL中的占位符，通过ResultSetHandler处理结果集的映射</li></ul><blockquote><p>自定义sql的过程</p></blockquote><ul><li>首先在mapper中自定义一个方法以及参数，可以用<code>@Param</code>标注</li><li>在相应的xml中实现sql<ul><li>if标签，when标签等</li><li><code>#&#123;&#125;</code> 取参数</li></ul></li><li>四个一致：<ul><li>Mapper接口名和xml文件名一致</li><li>Mapper中的方法名和xml中对应的id一致</li><li>Mapper中的方法返回值类型和xml中的resultType一致</li><li>Mapper全路径名和xml中的namespace一致</li></ul></li></ul><hr><blockquote><p>分页查询</p></blockquote><ul><li><p><code>PageHelper</code>：原理是存储分页信息在<code>ThreadLocal</code>中，在执行sql前拦截器会读取到分页信息动态插入到sql中再执行</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/image-20240224180047211.png" alt="image-20240224180047211"></p></li></ul><hr><blockquote><p>批量插入</p></blockquote><ul><li>法一：<strong>循环插入</strong>：频繁建立和关闭连接，资源消耗大</li><li>法二：<strong>forEach标签</strong>，通过拼接SQL语句的方式完成批量操作的。但是当拼接的SQL过多，导致SQL大小超过了MySQL服务器中<strong>max_allowed_packet</strong>变量的值时，会导致操作失败</li><li>法三：<strong>批处理</strong>，效率最高，但是比较麻烦</li></ul><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/image-20240224182755036.png" alt="image-20240224182755036"></p><p>mapper：</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/image-20240224182807077.png" alt="image-20240224182807077"></p><hr><blockquote><p>参数传递</p></blockquote><ul><li><p><code>xxxMapper.java</code>中方法的形参名可以不与<code>.xml</code>一致，MyBatis 会按照参数的位置进行匹配而不是参数的名字，若有多个参数，则应该按顺序使用</p></li><li><p>也可以使用<code>@Param</code>：<code>List&lt;TeachplanDto&gt; selectTreeNodes(@Param(&quot;courseId&quot;) Long courseId, @Param(&quot;name&quot;) String name);</code>指定mapper中的名字</p></li></ul><hr><blockquote><p>多表联查</p></blockquote><ul><li><p>定义好实体类，接口等</p></li><li><p>在xml中定义resultMap的映射</p><ul><li><code>property</code>表示属性对应的是实体类的字段名称</li><li><code>column</code>表示的是自己定义的属性值，与sql语句定义的字段名称相同</li><li><code>association</code>和<code>javaType</code>在一对一关联查询的时候使用</li><li><code>association</code>里映射的是被关联查询的表和属性值</li></ul></li><li><p>编写主要的联查语句，<code>resultMap</code>中指定刚刚定义的id</p><ul><li>如果是一对多的话就用外连接 <code>left join</code></li><li>如果是多对多，需要一个中间表然后两个 <code>left join</code></li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;husbandAndWife&quot;</span> <span class="attr">type</span>=<span class="string">&quot;husband&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span> <span class="attr">column</span>=<span class="string">&quot;id&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;name&quot;</span> <span class="attr">column</span>=<span class="string">&quot;name&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">association</span> <span class="attr">property</span>=<span class="string">&quot;wife&quot;</span> <span class="attr">javaType</span>=<span class="string">&quot;wife&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span> <span class="attr">column</span>=<span class="string">&quot;wid&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;name&quot;</span> <span class="attr">column</span>=<span class="string">&quot;wname&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">association</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;findByName&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;string&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;husbandAndWife&quot;</span>&gt;</span></span><br><span class="line">    select h.id,h.name,w.id wid, w.name wname</span><br><span class="line">    from t_husband h,t_wife w </span><br><span class="line">    where h.id = w.id and h.name = #&#123;name&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="11-MySQL"><a href="#11-MySQL" class="headerlink" title="11 MySQL"></a>11 MySQL</h3><blockquote><p>SQL: 是一种结构化查询语言(Structured Query Language)，专门用来与数据库打交道，目的是提供一种从数据库中读写数据的简单有效的方法。</p><p>sql常用关键字：SELECT， INSERT，UPDATE，DELETE，BETWEEN，EXISTS，WHERE，FROM，AND，NOT，OR，LIKE，JOIN，ALTER </p><p>函数处理：AVG，COUNT，MAX，MIN，SUM</p><p>三种删除：Drop，Delete，Truncate(清空数据)</p><p>group by：分组</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> customer_id, <span class="built_in">SUM</span>(order_amount) <span class="keyword">AS</span> total_amount</span><br><span class="line"><span class="keyword">FROM</span> orders</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> customer_id;</span><br></pre></td></tr></table></figure><blockquote><p>子查询：用于嵌套查询，放在()里面</p><p>mysql索引：索引是一种用于快速查询和检索数据的数据结构，其本质可以看成是一种排序好的数据结构。</p></blockquote><ul><li><p>优点：可以快速检索，唯一性保证（唯一索引）缺点：创建和维护耗时，存储需要消耗物理空间</p><ul><li>为什么可以加快？<ul><li>索引会按照列的值建立一个有序的数据结构（B/B+树），这样查找的时候就不用线性扫描表了</li><li>由于只读取索引所在的数据页，大大减少了磁盘IO</li></ul></li></ul></li><li><p>分类</p><ul><li><p>按照数据结构划分：BTree索引、hash索引、RTree 索引、全文索引</p></li><li><p>按照底层存储方式划分：</p><ul><li><p>聚簇索引（聚集索引）：索引结构和数据一起存放的索引，InnoDB的主键索引就是</p><ul><li>默认是主键</li><li>如果表没有定义主键，但有唯一非空索引，那么第一个唯一非空索引会被用作聚集索引。</li><li>如果表既没有主键也没有唯一非空索引，InnoDB存储引擎会自动生成一个隐藏的聚集索引</li></ul></li><li><p>非聚簇索引（非聚集索引）：不存在一起的索引</p></li></ul><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/image-20240320172122032.png" alt="image-20240320172122032" style="zoom:50%;" /></p><ul><li>区别<ul><li>聚簇索引只能有一个，后者可以有多个</li><li>聚集索引存储记录是物理上连续存在</li><li>聚集索引在叶子节点上存储的是数据</li></ul></li></ul></li><li><p>按照引用维度划分</p><ul><li>主键索引：加速查询 + 列值唯一（不可以有 NULL）+ 表中只有一个<ul><li>除了这个其他的索引都是二级索引，二级索引数据位置存储的是主键</li></ul></li><li>普通索引：加速查询</li><li>唯一索引：加速查询 + 列值唯一（可以有 NULL）</li><li>覆盖索引：一个索引包含（或者说覆盖）所有需要查询的字段的值</li><li>联合索引：多列值组成一个索引，专门用于组合搜索，其效率大于索引合并</li><li>全文索引：对文本的内容进行分词，一般不会使用，效率较低，通常使用搜索引擎如 ElasticSearch 代替</li></ul></li></ul></li></ul>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> INDEX idx_name(索引名) <span class="keyword">ON</span> 表名 (字段名); # B<span class="operator">-</span>Tree 索引，默认索引</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">UNIQUE</span> INDEX idx_name <span class="keyword">ON</span> 表名 (字段名); # 唯一索引</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 表名 <span class="keyword">ADD</span> <span class="keyword">PRIMARY</span> KEY (字段名); # 主键索引</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 表名 <span class="keyword">ADD</span> FULLTEXT INDEX idx_name (字段名);<span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 表名 <span class="keyword">ADD</span> FULLTEXT INDEX idx_name (字段名); # 全文索引</span><br></pre></td></tr></table></figure><ul><li><p>索引的底层数据结构选型</p><ul><li>hash表：快，但是不支持范围查询</li><li>二叉查找树：性能很依赖其平衡性</li><li>AVL树(高度差不超过1)：需要频繁地进行旋转操作来保持平衡，且一个节点只存一个数据，磁盘IO性能开销大</li><li>红黑树：自平衡二叉查找树，平衡性稍弱（不追求完全的平衡）所以有些查询效率较低(多次IO)，但是增删效率高</li><li>B树：所有节点既存放key又存放date</li><li><strong>B+树</strong>：多路平衡查找树，更稳定快速。原因：数据存放在叶子节点，保证了其他节点能够存放更多的索引，大大压缩了树的高度，减少磁盘IO次数；且叶子节点之间用双向链表连接</li></ul></li></ul><blockquote><p>索引的设计原则</p></blockquote><ul><li>适合索引的列是出现在where字句中的列，或者连接子句中指定的列</li><li>定义有外键的数据列一定要创建索引</li><li>更新频繁的字段不要有索引</li><li>大文本、大对象不要创建索引</li></ul><blockquote><p>MYSQL字段类型：数值类型、字符串类型(char/varchar)、日期时间类型</p><p>mysql架构</p></blockquote><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/image-20240320164909208.png" alt="image-20240320164909208" style="zoom:50%;" /></p><ul><li><strong>    连接器：</strong> 身份认证和权限相关(登录 MySQL 的时候)。</li><li><strong>查询缓存：</strong> 执行查询语句的时候，会先查询缓存（MySQL 8.0 版本后移除，因为这个功能不太实用）。</li><li><strong>分析器：</strong> 没有命中缓存的话，SQL 语句就会经过分析器，分析器说白了就是要先看你的 SQL 语句要干嘛，再检查你的 SQL 语句语法是否正确。</li><li><strong>优化器：</strong> 按照 MySQL 认为最优的方案去执行。</li><li><strong>执行器：</strong> 执行语句，然后从存储引擎返回数据。 执行语句之前会先判断是否有权限，如果没有权限的话，就会报错。</li><li><strong>插件式存储引擎</strong>：主要负责数据的存储和读取，采用的是<strong>插件式架构</strong>，支持 <strong>InnoDB</strong>、MyISAM、Memory 等多种存储引擎。</li></ul><blockquote><p>InnoDB和MyISAM</p></blockquote><ul><li>MyISAM是表级锁、不支持MVCC、不支持事务、不支持外键且<strong>数据库崩溃后数据不可恢复</strong></li><li>MyISAM 引擎和 InnoDB 引擎都是使用 B+Tree 作为索引结构，但是两者的实现方式不太一样。</li></ul><blockquote><p>数据库事务</p></blockquote><ul><li>数据库事务是一个或一系列操作的最小逻辑单元</li><li>特性：原子性、一致性、隔离性、持久性</li></ul><blockquote><p>并发事务的带来的问题</p></blockquote><ul><li>读读：没有问题，不需要并发控制</li><li>读写：脏读、不可重复读、幻读</li><li>写写：丢失修改</li></ul><blockquote><p> 如何控制？</p></blockquote><ul><li>锁：<ul><li>共享锁(S锁)/读锁：读读并行</li><li>排他锁(X锁)/写锁：如果有写就禁止其他线程读写了</li></ul></li><li><p>MVCC：多版本并发控制方法，主要依赖的手段：三个隐藏字段、read view、undolog。</p><ul><li><p>三个隐藏字段：</p><ul><li>DB_TRX_ID：表示最后一次插入或更新该行的事务 id</li><li>DB_ROLL_PTR：回滚指针，指向该行的 <code>undolog</code></li><li>DB_ROW_ID：隐藏主键</li></ul></li><li><p>undolog 用于记录某行数据的多个版本的数据。</p></li><li>read view 和 三个隐藏字段 : 用来判断当前版本数据的可见性。</li></ul></li></ul><blockquote><p>InnoDB存储引擎实现MVCC</p></blockquote><ul><li>仅针对写操作</li><li>为要修改的数据行创建版本，将修改后的数据写入新版本，旧版本的数据仍然存在</li><li>事务的提交后所作的修改对所有事务可见；回滚后修改被撤销，其他事务不可见</li><li>版本的回收：MVCC 会定期进行版本的回收。回收机制会删除已经不再需要的旧版本数据，从而释放空间。</li></ul><blockquote><p>SQL定义的事务隔离级别：基于锁和MVCC实现</p></blockquote><p><a href="https://blog.csdn.net/baidu_40120883/article/details/118755990?utm_source=miniapp_weixin">https://blog.csdn.net/baidu_40120883/article/details/118755990?utm_source=miniapp_weixin</a></p><ul><li>读取未提交、读取已提交、<strong>可重复读</strong>(InnoDB默认)、可串行化<ul><li>读取未提交：不设任何限制 ==&gt; 问题<strong>脏读</strong>：直接读取到错误的数据</li><li>读取已提交：只能读取到别人提交/回滚的事务 ==&gt; 问题<strong>不可重复读</strong>：两次读取之间有别的事务提交导致读取到了不一样的数据</li><li>可重复读：在事务写数据的时候将数据加锁，其他事务无法读写该数据 ==&gt; 问题<strong>幻读</strong>：两次查询之间有别的事务提交导致读取到了行数不同的数据</li><li>可串行化：直接禁止事务的并发    </li></ul></li></ul><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/image-20240320173313410.png" alt="image-20240320173313410" style="zoom:67%;" /></p><blockquote><p>InnoDB如何解决幻读</p></blockquote><ul><li>间隙锁</li></ul><blockquote><p>mysql日志</p></blockquote><ul><li><p>二进制日志(归档日志)<code>binlog</code>：数据库的备份，同步</p><ul><li>写入时机：事务提交时从binlog cache中写入到binlog</li></ul></li><li><p>事务日志(重做日志)<code>redolog</code>：InnoDB独有，mysql崩溃恢复的能力</p><ul><li><p>记录的是物理级别的操作，比如页号xxx、偏移量yyy写入了’zzz’数据</p></li><li><p>刷盘时机(将用户在缓冲区的修改刷到磁盘上持久化)：事务提交、log buffer 空间不足、事务日志缓冲区满、定期检查刷盘、正常关闭服务器</p></li><li><p>两阶段提交：保证两个log的一致性，但是增加了磁盘IO和锁竞争</p><ul><li>若发生异常：判断 redolog 是否完整，如果判断是完整的，就立即提交。如果 redolog 只是预提交但不是 commit 状态，这个时候就会去判断 binlog 是否完整，如果完整就提交 redolog, 不完整就回滚事务。</li></ul><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/image-20240321095820154.png" alt="image-20240321095820154" style="zoom: 50%;" /></p></li></ul></li><li><p>回滚日志(回滚日志)<code>undolog</code>：保证事务</p><ul><li>记录的是逻辑操作：比如INSERT操作后，undolog就记录了DELETE</li><li>事务中会写到undolog buffer中，事务提交后写到undolog </li></ul></li></ul><blockquote><p>一个完整的mysql语句执行（写）</p></blockquote><ul><li>连接器：权限校验</li><li>查询缓存：命中则返回</li><li>分析器：sql语句的词法语法分析</li><li>优化器：优化执行顺序</li><li>执行器：调用存储引擎（InnoDB）执行sql<ul><li>开启事务，修改数据</li><li>写入redolog，状态为prepare</li><li>写入binlog</li><li>事务提交，redolog状态修改为commit</li></ul></li></ul><blockquote><p>mysql的锁有哪些</p></blockquote><ul><li><p>基于属性分：共享锁/S锁，排他锁/X锁</p></li><li><p>基于粒度：行级锁(innodb ) 、表级锁（ innodb、myisam)、页级锁（ innodb引擎)、记录锁、间隙锁、临键锁。</p></li><li>基于状态：意向共享锁、意向排它锁。</li></ul><blockquote><p>如何给字符串建立一个索引</p></blockquote><ul><li>使用前缀索引</li><li>需要定义好前缀的长度</li><li>必要的时候可以选择倒排存储，比如 422100200003018877 存储为 778810300002001224 这样前六位就很有辨识度了</li></ul><blockquote><p>分库分表</p></blockquote><ul><li>分库分表就是为了解决由于数据量过大而导致数据库性能降低的问题，将原来独立的数据库拆分成若干数据库组成 ，将数据大表拆分成若干数据表组成，使得单一数据库、单一数据表的数据量变小，从而达到提升数据库性能的目的。</li><li>垂直分表：将一个表按照字段分成多个表，每个表存储一部分字段<ul><li>不常用的字段放一张表</li><li>text，blob等大字段拆分出来放在附表</li><li>经常组合查询的列放在一张表</li></ul></li><li>垂直分库：按照业务分类，分布到不同数据库上，每个库可以放在不同的服务器<ul><li>解耦</li><li>高并发的场景可以提升IO</li></ul></li><li>水平分库：按照一定规则把同一个表中的数据拆到不同的数据库中<ul><li>比如单数在一个表，双数在另一个表</li><li>解决了单库大数据问题</li></ul></li><li>水平分表：是在同一个数据库内，把同一个表的数据按一定规则拆到多个表中</li></ul><blockquote><p>慢查询如何排查优化</p></blockquote><ul><li>sql语句：是否加载了不必要的字段</li><li>分析sql执行，是否命中的索引</li><li>看sql涉及到的表结构</li><li>可以考虑分表分库</li><li>利用缓存，减少查询</li></ul><blockquote><p>mysql索引失效</p></blockquote><ul><li>不合适的索引类型</li><li>索引列上使用了函数</li><li>使用了<code>or</code>操作符：当子条件中的列没有索引的时候，整个条件都无法使用索引</li><li>索引列存在<code>NULL</code></li><li>数据量小的时候索引查询可能比全表查询还慢</li></ul><h3 id="12-并发"><a href="#12-并发" class="headerlink" title="12 并发"></a>12 并发</h3><blockquote><p>线程和进程 并发和并行</p><p>开启线程</p></blockquote><ul><li>继承Thread类</li><li>实现Runnable接口（还是要通过Thread调用）</li><li>实现Callable接口（同上）</li><li>使用线程池</li></ul><blockquote><p>线程生命周期和状态</p></blockquote><ul><li>New</li><li>Runnable</li><li>Blocked</li><li>Waiting</li><li>TIME_WAITING：超时等待</li><li>TERMINATED</li></ul><blockquote><p>sleep和wait</p></blockquote><ul><li><code>sleep()</code> 方法没有释放锁，而 <code>wait()</code> 方法释放了锁 </li><li>后者常用于线程间的通信，需要别的线程在同一个对象上使用<code>notify()</code>或者<code>notifyAll()</code>唤醒，也可以用<code>wait(long timeout)</code>超时唤醒</li></ul><blockquote><p>volatile 关键字</p></blockquote><ul><li>指示 JVM，这个变量是共享且不稳定的，每次使用它都到主存中进行读取。</li><li>在编译的时候禁止指令重排</li></ul><blockquote><p>乐观锁和悲观锁</p></blockquote><ul><li><p>悲观锁总是假设最坏的情况，认为共享资源每次被访问的时候就会出现问题(比如共享数据被修改)，所以每次在获取资源操作的时候都会上锁</p><ul><li><code>synchronized</code>和<code>ReentrantLock</code></li></ul></li><li><p>乐观锁总是假设最好的情况，认为共享资源每次被访问的时候不会出现问题，线程可以不停地执行，无需加锁也无需等待，只是在提交修改的时候去验证对应的资源（也就是数据）是否被其它线程修改了</p><ul><li>版本号或者CAS算法</li><li><p>CAS算法三个参数：当仅当V==E的时候才会修改N</p><ul><li>V：要更新的变量值(Var)</li><li>E：预期值(Expected)</li><li>N：拟写入的新值(New)</li></ul></li><li><p>存在的问题：</p><ul><li>ABA问题：在变量前面加版本号</li><li>循环时间长开销大：</li><li>只能保证一个共享变量的原子操作</li></ul></li></ul></li></ul><blockquote><p>死锁的形成条件与解决</p></blockquote><ul><li><p>条件</p><ul><li><p>互斥条件：一个资源每次只能被一个进程使用。</p></li><li><p>请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。</p></li><li><p>不剥夺/非抢占条件:进程已获得的资源，在末使用完之前，不能强行剥夺。</p></li><li><p>循环等待条件:若干进程之间形成一种头尾相接的循环等待资源关系。</p></li></ul></li><li><p>解决：破坏四个条件之一</p><ul><li>破坏互斥：让资源可以同时访问（往往行不通）</li><li>破坏非抢占：剥夺式调度算法，但是会导致资源利用率低（不怎么用）</li><li>破坏请求与保持：静态分配策略：在进程执行之前先获取到他需要的所有资源，如果不满足就不开启（会导致资源利用率低，因为部分资源可能在进程后期才会用）</li><li>破坏循环等待：层次分配策略：将资源分层，先释放低层次的资源再获取高层次的资源</li></ul></li></ul><blockquote><p>synchronized </p></blockquote><ul><li>修饰实例方法：给对象加锁</li><li>修饰静态方法：给类加锁</li><li>修饰静态代码块：对括号里面的类/对象加锁</li><li>尽量不要使用 <code>synchronized(String a)</code> 因为 JVM 中，字符串常量池具有缓存功能</li><li>底层原理：使用的<code>monitorenter</code>锁住，使用<code>monitorexit</code>退出</li></ul><blockquote><p>线程池</p></blockquote><ul><li><p>创建</p><ul><li><code>ThreadPoolExecutor</code>创建（推荐）</li><li>通过<code>Executor</code>框架的工具类 <code>Executors</code> 来创建。</li></ul></li><li><p>线程池参数：</p><ul><li>corePoolSize : 任务队列未达到队列容量时，最大可以同时运行的线程数量。</li><li>maximumPoolSize : 任务队列中存放的任务达到队列容量的时候，当前可以同时运行的线程数量变为最大线程数。</li><li>workQueue: 新任务来的时候会先判断当前运行的线程数量是否达到核心线程数，如果达到的话，新任务就会被存放在队列中。</li><li>keepAliveTime：当线程数大于corePoolSize 且没有新的任务提交，多余的空闲线程的等待时间</li><li>unit : keepAliveTime 参数的时间单位。</li><li>threadFactory :executor 创建新线程的时候会用到。</li><li>handler :饱和策略<ul><li><code>ThreadPoolExecutor.AbortPolicy</code>： 抛出 <code>RejectedExecutionException</code>来拒绝新任务的处理。</li><li><code>ThreadPoolExecutor.DiscardPolicy</code>：不处理新任务，直接丢弃掉。</li><li><code>ThreadPoolExecutor.DiscardOldestPolicy</code>： 此策略将丢弃最早的未处理的任务请求。</li><li><code>ThreadPoolExecutor.CallerRunsPolicy</code>：由调用线程处理该任务。如果执行程序已关闭，则会丢弃该任务</li></ul></li></ul></li><li><p>参数设置原则</p><ul><li><p>最佳corePoolSize ，N为CPU的核数</p><ul><li><p>如果是IO密集型（CPU计算时间短，而等待IO操作（如读写文件、网络通信等）的时间长）的任务就设置为2N</p><ul><li>文件处理，数据库读写，网络操作等</li></ul></li><li><p>如果是CPU密集型（几乎没有IO等待）就设置为N+1</p><ul><li>数值计算、图像视频处理、加密解密、模型训练等</li></ul></li><li><p>还可以这样计算：<code>((线程等待时间+线程CPU时间) / 线程CPU时间)* CPU数目</code></p></li></ul></li></ul></li><li><p>执行过程</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/image-20240321213330649.png" alt="image-20240321213330649" style="zoom: 80%;" /></p></li></ul><blockquote><p>Java中的锁机制</p></blockquote><ul><li><strong>互斥锁</strong>：<code>synchronized</code>关键字：JVM底层实现，最基本的线程同步机制</li><li><strong>可重入锁</strong>：实现类<code>ReentrantLock</code>，允许更细粒度的锁控制</li><li><strong>读写锁</strong>：<code>ReadWriteLock</code></li><li><strong>乐观锁</strong>和<strong>悲观锁</strong></li><li>对<code>synchronized</code>性能的优化<ul><li>java对象头mark word存储了一些信息</li><li><strong>偏向锁</strong>：把线程ID放入对象的Mark Word字段中</li><li><strong>轻量级锁</strong>：采用CAS自旋锁的方式来完成加锁</li><li><strong>重量级锁</strong>：让抢占锁的线程从用户态转变为内核态，开销很大</li></ul></li><li><strong>自旋锁</strong>：让线程获取锁的时候不断的重试获取锁的操作，而不是立即进入阻塞状态</li><li><strong>分段锁</strong>：如<code>ConcurrentHashMap</code></li></ul><blockquote><p><code>synchronized</code>和<code>ReentrantLock</code></p></blockquote><ul><li>前者是JVM实现，后者是JDK实现</li><li>两者性能大致相同（因为新版本JVM对<code>synchronized</code>进行了优化，也支持了自旋锁等</li><li>前者不可中断，后者可以</li><li>优先使用前者，因为是JVM原生支持，且不用担心死锁问题，因为JVM会保证锁的释放</li></ul><blockquote><p>Java主流锁</p></blockquote><p><a href="https://pdai.tech/md/java/thread/java-thread-x-lock-all.html">https://pdai.tech/md/java/thread/java-thread-x-lock-all.html</a></p><ul><li>线程是否锁同步资源<ul><li>乐观锁：采用无锁编程实现，CAS算法常用</li><li>悲观锁：<code>synchronized</code>关键字和<code>Lock</code>的实现类实现<ul><li><code>ReentrantLock</code>、<code>ReadLock</code>、<code>WriteLock</code>（后两者是<code>ReentrantReadWriteLock</code>内部类）</li></ul></li></ul></li><li>锁住同步资源失败时，线程要不要阻塞<ul><li><strong>为什么要非阻塞</strong>：阻塞线程要切换CPU的状态，耗时，自旋就是不让线程阻塞（及不放弃CPU的时间片）</li><li>阻塞</li><li>非阻塞<ul><li>自旋锁</li><li>适应性自旋锁</li></ul></li></ul></li><li>多个线程竞争同步资源的流程细节<ul><li>这是针对<code>synchronized</code>的优化，表示锁的四个状态</li><li>无锁</li><li>偏向锁：同一个线程执行同步资源时自动获取资源</li><li>轻量级锁：多个线程竞争时，没获取资源的线程自旋等待所释放</li><li>重量级锁：多个线程竞争时，没获取资源的线程阻塞等待被唤醒</li></ul></li><li>多个线程竞争锁时要不要排队<ul><li>公平锁</li><li>非公平锁：先尝试插队，失败了再排队</li></ul></li><li>一个线程的多个流程能不能获取同一把锁（前提是锁的是同一个对象或者class）<ul><li>可重入锁：<code>ReentrantLock</code>和<code>synchronized</code></li><li>不可重入锁</li></ul></li><li>多个线程能否共享锁<ul><li>共享锁：<code>ReentrantReadWriteLock</code>，本质是里面的两把锁，读锁和写锁</li><li>排他锁：<code>synchronized</code>和JUC中<code>Lock</code>的实现类就是互斥锁。</li></ul></li></ul><h3 id="13-计网"><a href="#13-计网" class="headerlink" title="13 计网"></a>13 计网</h3><blockquote><p>七层模型</p></blockquote><ul><li>应用层：FTP、<strong>DNS</strong>、Telnet、SMTP、<strong>HTTP</strong>、WWW、NFS<ul><li>为计算机用户提供服务</li></ul></li><li>表示层：JPEG、MPEG、ASII<ul><li>数据处理（编解码、加密解密、压缩解压缩)</li></ul></li><li>会话层：NFS、SQL、NETBIOS、RPC<ul><li>管理(建立、维护、重连)应用程序之间的会话</li></ul></li><li>传输层：<strong>TCP</strong>、<strong>UDP</strong>、SPX<ul><li>为两台主机进程之间的通信提供通用的数据传输服务</li></ul></li><li>网络层：路由和寻址（决定数据在网络的游走路径)<ul><li><strong>IP</strong>：分为ipv4 和 ipv6，定义数据包格式，对数据包进行路由和寻址</li><li><strong>ARP</strong>：地址解析协议，用于解决网络层和数据链路层的地址的转换问题(IP地址转MAC地址)<ul><li>维护一个表：<code>&lt;IP, MAC, TTL&gt;</code>TTL为生存时间</li></ul></li><li><strong>ICMP</strong>：互联网控制报文协议，ping命令</li><li><strong>NAT</strong>：网络地址转换协议，内部网到外部网的转换</li><li>OSPF（Open Shortest Path First）：内部网关协议</li></ul></li><li>数据链路层：PPP、FR、HDLC、VLAN、MAC（网桥、交换机）<ul><li>帧编码和误差纠正控制</li></ul></li><li>物理层：RJ45、CLOCK、IEEE802.3（中继器、集线器）<ul><li>透明地传送比特流传输</li></ul></li></ul><blockquote><p>四层模型</p></blockquote><ul><li>应用层           1-3</li><li>传输层           4</li><li>网络层           5</li><li>网络接口层    6-7</li></ul><blockquote><p>三握四挥</p></blockquote><ul><li><p>名词解释</p><ul><li>seq：sequence ，序号，用于确认数据是否准确</li><li>ack：acknowledgement ，确认号，用于确认数据是否准确</li><li>flags：标志位，一共有6个，用于确认/更改连接状态<ul><li><strong>URG</strong>(ent)：紧急指针（urgent pointer）有效。</li><li><strong>ACK</strong>(nowledgment)：确认序号有效。（为了与确认号ack区分开，我们用大写表示）</li><li><strong>P</strong>(u)<strong>SH</strong>：接收方应该尽快将这个报文交给应用层。</li><li><strong>R</strong>(e)<strong>S</strong>(e)<strong>T</strong>：重置连接。</li><li><strong>SYN</strong>(chronization)：同步，发起一个新连接。</li><li><strong>FIN</strong>(ish)：释放一个连接</li></ul></li></ul></li><li><p>握手</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/image-20240322223936856.png" alt="image-20240322223936856"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sequenceDiagram</span><br><span class="line">    客户端 -&gt;&gt; + 服务器 : SYN(seq=x)</span><br><span class="line">    服务器 -&gt;&gt; 客户端 : ACK(ack=1)，SYN(seq=y)</span><br><span class="line">    客户端 -&gt;&gt; + 服务器 : ACK(ack=y+1) </span><br></pre></td></tr></table></figure></li><li><p>挥手</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/image-20240322223944455.png" alt="image-20240322223944455"></p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sequenceDiagram</span><br><span class="line">    客户端 -&gt;&gt; + 服务器 : FIN(seq=m)</span><br><span class="line">    服务器 -&gt;&gt; 客户端 : ACK(ack=m+1)</span><br><span class="line">    服务器 -&gt;&gt; 客户端 : FIN(seq=y)</span><br><span class="line">    客户端 -&gt;&gt; + 服务器 : ACK(ack=y+1) </span><br></pre></td></tr></table></figure><blockquote><p>TCP传输稳定性</p></blockquote><ul><li>数据传输之前会有三次握手来进行连接</li><li>在数据传输时：<ul><li>基于数据块（报文）</li><li>对数据包排序防丢失和重复</li><li>校验和：将保持它首部和数据的检验和</li><li>重传机制（直到收到ACK应答）</li><li>流量控制：控制发送的速率，保证能及时接收，利用滑动窗口<ul><li>发送窗口：四个部分 ==&gt; 已发送确认 + 已发送未确认 + 可以发送 + 不可发送</li><li>接收窗口：三个部分 ==&gt; 已发送确认 + 已接收未确认 + 不可接收</li></ul></li><li>拥塞控制：发送方维持一个拥塞窗口 ，四个算法 ==&gt; 慢开始，拥塞避免，快重传，快恢复</li><li>ARQ协议：自动重传请求（Automatic Repeat-reQuest），在数据链路层和传输层都有<ul><li>停止等待ARQ协议：每发送一个请求就等待对方确认ACK</li><li>连续ARQ协议：连续发送n个消息，接收方返回连续成功接收的第n个消息的序号，表示前n个消息都收到了<ul><li>优点：信道利用率高，容易实现，即使确认丢失，也不必重传。</li><li>缺点：如果发送了5条消息，第3条消息丢失了，那么接受方返回的是前两条的确认信息，发送方会重新发送345条消息</li></ul></li></ul></li></ul></li><li>数据传输之后会进行四次挥手断开连接来节约系统资源。</li></ul><blockquote><p>TCP和UDP</p></blockquote><ul><li><code>Transmission Control Protocol</code>传输控制协议</li><li><code>User Dategram Protocol</code>用户数据协议</li><li>TCP面向连接（传输之前需要建立连接）</li><li>TCP传输可靠</li><li>TCP传输有状态</li><li>TCP是面向字节传输，UDP面向报文<ul><li>面向字节出现粘包</li></ul></li><li>TCP 首部开销（20 ～ 60 字节）比 UDP 首部开销（8 字节）要大。</li><li>TCP点对点，UDP都支持</li></ul><blockquote><p>Http和Https</p></blockquote><ul><li><p>https协议要申请证书到ca，需要一定经济成本；</p></li><li><p>http是明文传输，https是加密的安全传输；  </p></li><li><p>连接的端口不一样，http是80，https是443；</p></li><li><p>http3.0之前是基于tcp连接的，https在此基础上还增加了SSL/TLS协议用作加密和安全认证</p><ul><li><p>SSL/TLS：TLS是SSL发展来的，一般就混在一起了，核心是用非对称加密传递对称加密的密钥，之后用对称加密来传输数据</p></li><li><p>https带证书的公钥传输机制：<a href="https://www.bilibili.com/video/BV1mj421d7VE/?spm_id_from=333.337.search-card.all.click&amp;vd_source=1a39594354c31d775ddc587407a55282">https://www.bilibili.com/video/BV1mj421d7VE/?spm_id_from=333.337.search-card.all.click&amp;vd_source=1a39594354c31d775ddc587407a55282</a></p><ul><li><p>设有服务器 Bob，客户端 Alice，和第三方信赖机构 CA。目的：让Alice知道Bob的公钥，且这个过程不会被别人篡改</p></li><li><p>Bob 信任 CA，CA 是知道 Bob 公钥的，CA 向 Bob  颁发证书。</p><ul><li>数字证书内容：Bob的公钥+Bob的身份+CA<strong>私钥</strong>对前两者hash运算结果的签名</li><li>签名是为了保证Bob公钥和身份没有被篡改，如果第三方修改了，那么两个部分就对不上了</li></ul></li><li><p>Bob 获得 CA 颁发的证书，将该证书传递给 Alice。</p></li><li><p>Alice 获得 Bob 的证书，并且还有CA的公钥（浏览器安装的时候会附带安装CA相关信息），</p><ul><li>使用 CA 公钥对证书上的签名解密，得到Bob的身份和Bob的公钥hash运算后的结果，也就是摘要</li><li>将证书的另一部分（Bob的公钥和身份）进行hash运算，对比两个摘要相同的话就说明证书是真实的</li></ul></li><li><p>如果 Alice 验证 Bob  证书是真实的，则信任 Bob  的公钥（在 S 证书中）。</p></li><li><p>注意：中间对文件hash运算一次的原因是为了压缩传输信息，加快传输速度(不可逆)</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/image-20240322205844944.png" alt="image-20240322205844944" style="zoom:67%;" /></p></li></ul></li></ul></li><li><p>http连接很简单，没有状态；</p></li><li><p>https是ssl加密的传输，身份认证的网络协议，相对http传输比较安全。</p></li></ul><blockquote><p>http常见的header</p></blockquote><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Accept   能够接受的回应内容类型</span><br><span class="line">Accept-Charset能够接受的字符集</span><br><span class="line">Accept-Encoding能够接受的编码方式列表</span><br><span class="line">Accept-Language能够接受的回应内容的自然语言列表。</span><br><span class="line">Authorization用于超文本传输协议的认证的认证信息</span><br><span class="line">Content-Type请求体的 多媒体类型 （用于 POST 和 PUT 请求中）</span><br><span class="line">Host服务器的域名以及服务器所监听的传输控制协议端口号</span><br><span class="line">Origin发起一个针对跨来源资源共享的请求。</span><br><span class="line">User-Agent浏览器的浏览器身份标识字符串</span><br></pre></td></tr></table></figure><blockquote><p>http1.0和http1.1</p></blockquote><ul><li><p>优化了缓存</p></li><li><p>tcp连接：1.0是短连接：每进行一次http操作就建立一次连接，1.1是长连接</p></li><li><p>host头处理：1.1在请求头中加入了Host字段，也就是主机名</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//请求http://example1.org/home.html</span><br><span class="line">GET /home.html HTTP/1.0</span><br><span class="line"></span><br><span class="line">GET /home.html HTTP/1.1</span><br><span class="line">Host: example1.org</span><br></pre></td></tr></table></figure></li><li><p>带宽优化及网络连接的使用：1.1请求头引入了 range 头域，它允许只请求资源的某个部分</p></li><li><p>状态响应码新增</p></li></ul><blockquote><p>http2.0和http1.1</p></blockquote><ul><li>多路复用：</li><li>2.0用二进制帧，1.1用文本传输</li><li>1.1支持body压缩，2.0额外支持了header压缩</li><li>服务器推送</li></ul><blockquote><p>浏览器输入url发生了什么</p></blockquote><ul><li><p>从事件来看</p><ul><li>DNS解析查询到对应的ip地址</li></ul></li></ul><ul><li>根据id地址和端口号，浏览器向服务器发送一个TCP连接请求（发送数据前客户端和服务队建立通道）</li></ul><ul><li>在TCP连接上，发送HTTP请求获取网页内容</li></ul><ul><li>服务器处理请求并返回HTTP报文</li></ul><ul><li>浏览器解析响应中的HTML，渲染结构和样式，同时根据HTML中的其他URL发送请求，获取资源直到网页完全加载</li></ul><ul><li><p>从4层来看</p><ul><li>应用层：<ul><li>浏览器先访问缓存的host，如果没有则使用DNS解析URL，最后得到IP地址</li><li>发送http报文，使用http或者https协议</li></ul></li><li>传输层：<ul><li>http基于tc协议</li></ul></li><li>网络层：核心：路由与转发<ul><li>转发：将分组从路由器的输入端口转移到合适的输出端口。</li><li>路由：确定分组从源到目的经过的路径。</li></ul></li></ul></li></ul><blockquote><p>一个URL的组成</p></blockquote><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/image-20240322202728626.png" alt=""></p><ul><li>协议：Http或者Https，也可能是ftp</li><li>域名</li><li>端口</li><li>资源路径</li><li>参数 ：?开始，&amp;隔开 ，采用k-v的形式</li><li>锚点：#开始，相当于一个小书签。并且不会作为请求的一部分发送给服务端。</li></ul><blockquote><p>DNS：Domain Name System 域名管理系统</p></blockquote><ul><li>基于UDP协议，端口53</li><li>跟DNS服务器</li><li>顶级域DNS服务器（TLD 服务器）：指域名的后缀，com org net edu</li><li>权威DNS服务器</li><li>本地DNS服务器</li><li>查询过程：<code>cis.poly.edu</code> 查询 <code>gaia.cs.umass.edu</code></li></ul><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/image-20240322204013957.png" alt="image-20240322204013957" style="zoom:50%;" /></p><blockquote><p>状态码</p></blockquote><ul><li>2xx：成功</li><li>3xx：重定向</li><li>4xx：客户端出错</li><li>5xx：服务器出错</li></ul><blockquote><p>websocket和http</p></blockquote><ul><li>WebSocket 和 HTTP 两者都是基于 TCP 的应用层协议，都可以在网络中传输数据。</li><li>区别<ul><li>WebSocket 是一种双向实时通信协议，而 HTTP 是一种单向通信协议。并且，HTTP 协议下的通信只能由客户端发起，服务器无法主动通知客户端。</li><li>WebSocket 使用 ws:// 或 wss://（使用 SSL/TLS 加密后的协议，类似于 HTTP 和 HTTPS 的关系） 作为协议前缀，HTTP 使用 http:// 或 https:// 作为协议前缀。</li><li>WebSocket 通信数据格式比较轻量，用于协议控制的数据包头部相对较小，网络开销小，而 HTTP 通信每次都要携带完整的头部，网络开销较大（HTTP/2.0 使用二进制帧进行数据传输，还支持头部压缩，减少了网络开销）</li></ul></li></ul><blockquote><p>ping</p></blockquote><ul><li>PING 基于网络层的 ICMP（Internet Control Message Protocol，互联网控制报文协议），其主要原理就是通过在网络上发送和接收 ICMP 报文实现的。</li></ul><h3 id="14-操作系统"><a href="#14-操作系统" class="headerlink" title="14 操作系统"></a>14 操作系统</h3><blockquote><p>操作系统的功能</p></blockquote><ul><li>进程和线程的管理：进程的创建、撤销、阻塞、唤醒，进程间的通信等。</li><li>存储管理：内存的分配和管理、外存（磁盘等）的分配和管理等。</li><li>文件管理：文件的读、写、创建及删除等。</li><li>设备管理：完成设备（输入输出设备和外部存储设备等）的请求或释放，以及设备启动等功能。</li><li>网络管理</li><li>安全管理：用户的身份认证、访问控制、文件加密等，以防止非法用户对系统资源的访问和操作。</li></ul><blockquote><p>内存管理</p></blockquote><ul><li>内存的分配和回收</li><li>地址转换：程序中的地址转为内存中的物理地址</li><li>内存扩充：虚拟内存技术</li><li>内存映射：将文件映射到内存，加快文件读取速度</li><li>内存优化</li><li>内存安全</li></ul><blockquote><p>内存碎片</p></blockquote><ul><li><p>内部内存碎片/内碎片：分配了但没使用的空间</p></li><li><p>外部内存碎片/外碎片：由于段式分配导致一些没有用的小间隙</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/image-20240323143949565.png" alt="image-20240323143949565" style="zoom:67%;" /></p></li></ul><blockquote><p>内存管理方法</p></blockquote><ul><li>连续内存管理：容易造成较多内存碎片，内存利用率不高</li><li>非连续内存管理<ul><li>段式管理：以段的形式存储，程序的内存被分为大小不等的段，每段有实际的逻辑含义：主程序段、子程序段、数据段、栈段<ul><li>优点：无内存碎片</li><li>缺点：段换入换出的时候会产生外碎片</li></ul></li><li>页式管理：把物理内存分为连续等长的物理页，应用程序的虚拟地址空间也被划分为连续等长的虚拟页，是现代操作系统广泛使用的一种内存管理方式。<ul><li>优点：无外碎片</li><li>缺点：可能有内碎片，因为页框可能填不满</li></ul></li><li>段页式管理：结合了段式管理和页式管理的一种内存管理机制，把物理内存先分成若干段，每个段又继续分成若干大小相等的页。</li></ul></li></ul><blockquote><p>用户态和内核态</p></blockquote><ul><li><p>两种形态是进程的运行级别（一个用了用户栈一个用了内核栈）</p></li><li><p>用户态： 用户态运行的进程可以直接读取用户程序的数据，拥有较低的权限。当需要进行磁盘读写的时候就会申请进入内核态</p></li><li><p>内核态：几乎可以访问系统的任何资源（不止一个）</p></li><li><p>用户态到内核态的三种方式</p><ul><li><p>系统调用</p><ul><li><p>用户态的进程发起系统调用，由于权限不足，因此会中断执行（trap）</p></li><li><p>发生中断后，当前CPU执行的程序中断，内核程序开始运行处理系统调用</p></li><li><p>内核处理完成后，主动触发trap，再次中断切换回用户态</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/image-20240323134044281.png" alt="image-20240323134044281"></p></li></ul></li><li><p>中断：外围设备完成请求后向CPU发送中断信号，这个时候如果进程是用户态就会被切换到运行态。比如比如硬盘读写操作完成，系统会切换到硬盘读写的中断处理程序中执行后续操作等</p></li><li><p>异常</p></li></ul></li></ul><blockquote><p>线程和进程</p></blockquote><ul><li>进程：计算机中运行的实例</li><li>线程：多个线程在一个进程中运行，共享进程中的资源（内存空间、文件句柄、网络连接等）</li><li>进程切换开销大，线程开销小</li><li>同一进程下的线程共享文件，因此他们之间的通信无需调用内核</li><li>多个线程可以并发处理不同任务，而进程只能在一个时间段干一件事，遇到阻塞如IO阻塞就会挂起</li></ul><blockquote><p>进程状态</p></blockquote><ul><li>与线程类似：创建、就绪、运行、阻塞、结束</li></ul><blockquote><p>进程间通信</p></blockquote><ul><li>管道/匿名管道(Pipes)：用于具有亲缘关系的父子进程间或者兄弟进程之间的通信。</li><li>有名管道(Named Pipes) </li><li>信号</li><li>消息队列</li><li>信号量</li><li>共享内存</li><li>套接字</li></ul><blockquote><p>进程调度算法</p></blockquote><ul><li>先到先服务</li><li>短作业优先</li><li>时间片轮转调度</li><li><strong>多级反馈队列调度</strong>：既能使高优先级的作业得到响应又能使短作业（进程）迅速完成best</li><li>优先级调度</li></ul><blockquote><p>僵尸进程和孤儿进程</p></blockquote><ul><li>僵尸进程：子进程已经终止，但是其父进程仍在运行</li><li>孤儿进程：一个进程的父进程已经终止或者不存在，但是该进程仍在运行</li></ul><blockquote><p>线程间的同步方式</p></blockquote><ul><li>互斥锁：比如java中的<code>synchronized</code>关键字和各种<code>lock</code></li><li>读写锁：只有一个线程可以写，可以多个线程同时读</li><li>信号量：允许同一时刻多个线程访问资源，但是需要控制线程数量</li><li>屏障：java中的<code>CyclicBarrier</code>：多个线程到了同一状态再一起行动</li><li>事件：<code>Wait/Notify</code>：通过通知操作的方式来保持多线程同步，还可以方便的实现多线程优先级的比较操作。</li></ul><blockquote><p>线程的上下文切换</p></blockquote><ul><li>CPU通过分配时间片来执行任务，一个任务从保存到加载的过程就是一次上下文切换</li><li>自发性的切换<ul><li><code>Thread.sleep()</code></li><li><code>Object.wait()</code></li><li><code>Thread.yeild()</code>：运行 ==&gt; 就绪</li><li><code>Thread.join()</code></li></ul></li><li>非自发性的切换<ul><li>时间片用完</li><li>更高优先级的线程需要运行</li><li>虚拟机的垃圾回收动作</li></ul></li></ul><h3 id="15-IO及IO模型"><a href="#15-IO及IO模型" class="headerlink" title="15 IO及IO模型"></a>15 IO及IO模型</h3><ul><li>应用程序发起IO调用，由内核来执行具体的IO操作：内核等待IO设备准备好数据 ==&gt; 内核将数据从内核空间拷贝到用户空间</li></ul><blockquote><p>Java常见IO类</p></blockquote><ul><li>磁盘操作：<code>File</code></li><li>字节操作：<code>InputStream</code>、<code>OutputStream</code></li><li>字符操作：<code>Reader</code>、<code>Writer</code></li><li>对象操作：<code>Serializable</code>、<code>transient</code><ul><li>只是一个标准，实现前者接口表示需要序列化，后者关键字标识表示不会被序列化</li></ul></li><li>网络操作：<code>Socket</code></li></ul><blockquote><p>UNIX系统下的IO模型</p></blockquote><ul><li><p>同步阻塞IO</p><ul><li><p>应用程序发起read调用，然后阻塞</p></li><li><p>内核空间准备数据，拷贝数据</p></li><li><p>直到拷贝数据结束的这段实际，线程处于阻塞</p></li><li><p>缺点：客户端连接数量多无法处理</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/image-20240323150836151.png" alt="image-20240323150836151" style="zoom: 80%;" /></p></li></ul></li><li><p>同步非阻塞IO</p><ul><li><p>应用程序发起read调用</p></li><li><p>内核空间准备数据，拷贝数据，在此期间应用程序不断的read轮询（polling），如果每准备好就会马上返回错误（所以这段时间可以视为没阻塞）</p></li><li><p>准备完毕，read调用然后内核拷贝数据到用户空间，此间线程阻塞，直到拷贝完毕</p></li><li><p>缺点：应用程序不断进行 I/O 系统调用轮询数据是否已经准备好的过程是十分消耗 CPU 资源的。</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/image-20240323150859310.png" alt="image-20240323150859310" style="zoom:80%;" /></p></li></ul></li><li><p>IO多路复用：</p><ul><li><p>多路：多个请求/网络连接</p></li><li><p>复用：同一个进程/线程</p></li><li><p>应用程序发起select/poll/epoll调用，询问内核数据是否准备就绪(读写就绪)，然后线程处于阻塞</p></li><li><p>内核空间准备数据，查询相关文件描述符的状态，准备完毕发送ready(可能是部分的文件描述符)</p></li><li><p>用户线程再发起 read 调用</p></li><li><p>read 调用的过程（数据从内核空间 -&gt; 用户空间），所有数据获取完毕则解除阻塞</p></li><li><p>优点：</p><ul><li>通过减少无效的系统调用，减少了对CPU的消耗</li><li><strong>一个线程可以检测多个文件描述符</strong>(linux中的文件索引)</li></ul></li><li><p>select几乎所用操作系统都支持，epoll是linux对select的升级，优化了IO执行效率</p></li><li><p>举例</p><ul><li>应用程序A使用select/poll/epoll等系统调用监控多个文件描述符(例如是ab两个文件)，随后处于阻塞</li><li>内核去查询文件描述符的状态，如果不可操作就进行数据准备</li><li>当文件描述符就绪(如b可读取)，内核就会通知应用程序A</li><li>A拿到通知后，会检查有哪些文件描述符就绪，并对就绪的文件描述符进行IO操作</li><li><strong>如果有多个应用程序都在等b，内核就会通知所有相关的程序，这也是IO多路复用的精髓</strong></li></ul><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/image-20240323150252477.png" alt="image-20240323150252477" style="zoom: 50%;" /></p></li><li><p><code>select/poll/epoll</code>区别</p><ul><li><code>select</code>：程序指定一组文件描述符，用<code>bitmap</code>存储，然后阻塞等待其中任何一个文件描述符就绪。<ul><li>不足：文件描述符数量有限(0-1023)，每次调用都需要将全部文件描述符集合从用户态拷贝到内核态，效率低</li></ul></li><li><code>poll</code>：使用了更灵活的链表来管理文件描述符集合，所以文件描述符数量没有限制，但本质上仍然是一种轮询机制。<ul><li>不足：在大量文件描述符的情况下需要线性循环扫描，效率依然不高。</li></ul></li><li><code>epoll</code>：linux内核提供，更高效，红黑树+链表</li></ul></li><li><p><code>select/poll</code>过程</p><ul><li>从<strong>用户空间拷贝fd集合到内核空间</strong>（这部分的开销很大，因为内核空间要修改里面的值，所以要拷贝）</li><li>注册回调函数<code>_pollwait</code></li><li><strong>遍历所有的fd</strong>，调用其<code>poll</code>方法</li><li><code>poll</code>方法返回时会返回一个描述读写操作是否就绪的<code>mask</code>掩码</li><li>遍历完所有的fd，还没有返回mask掩码，则使当前的进程进入睡眠状态，当资源可读写后再唤醒，如果长时间没有唤醒则调用<code>select/poll</code>的进程会重新唤醒获取CPU，进而重新遍历fd，判断有没有就绪</li><li>如果文件就绪，则将fd集合的引用返回给用户空间</li><li>用户再<strong>遍历fd集合</strong>，判断相应的文件描述符状态</li></ul></li><li><p><code>epoll</code>过程：event poll，复杂度降低到了<code>O(1)</code></p><ul><li>内核空间创建<code>epoll</code>结构体，即一个红黑树和一个就绪链表</li><li>用户线程调用<code>epoll_ctl</code>向内核空间注册文件描述符，内核空间会将文件描述符加入到epoll的红黑树中，并建立回调关系</li><li>当文件描述符状态发生变化的时候（可读、可写、异常），内核空间会将就绪事件加入到epoll链表中</li><li>用户空间调用<code>epoll_wait</code>等待就绪的事件，内核空间将就绪事件从就绪链表中返回给用户空间</li><li>用户空间线性扫描就绪链表，获取就绪文件描述符号，调用<code>read()</code>等方法进行IO操作</li></ul></li></ul></li><li><p>信号驱动IO</p></li><li><p>异步IO：基于事件和回调机制实现，应用系统不需要自己检查IO操作</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/image-20240323153018146.png" alt="image-20240323153018146" style="zoom:50%;" /></p></li></ul><blockquote><p>同步非阻塞和IO多路复用？</p></blockquote><ul><li>前者发送read后收到错误就解除阻塞了，如果是数据准备完成就直到获取完数据就解除阻塞，后者在发送系统调用后就一直阻塞，直到内核返回文件描述符就绪信息</li><li>并发请求比较少的情况下前者的效率更高，后者的优势在于一个线程监测多个文件描述符，可以实现文件描述符的复用，减少不必要的资源消耗</li></ul><blockquote><p>java中的三种IO模型</p></blockquote><ul><li><p>不同的是内核空间变成了服务端，用户空间变成了客户端</p></li><li><p>BIO(Blocking I/O)：同步阻塞IO</p></li><li>NIO(Non-blocking/New I/O)，可以看作是IO多路复用模型<ul><li>三个核心组件：<ul><li>Channel：通道，用于传递信息</li><li>Buffer：缓冲区，连接Channel和客户端/服务端的缓冲区</li><li>Selector：选择器，用于监控Channel中的IO事件的组件</li></ul></li></ul></li><li>AIO(Asynchronous I/O)：异步 IO 模型</li></ul><h3 id="16-JVM"><a href="#16-JVM" class="headerlink" title="16 JVM"></a>16 JVM</h3><blockquote><p>JVM 内存模型</p></blockquote><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/image-20240315171612257.png" alt="image-20240315171612257" style="zoom:33%;" /></p><p><img src="C:\Users\H\AppData\Roaming\Typora\typora-user-images\image-20240324104828501.png" alt="image-20240324104828031" style="zoom:67%;" /></p><ul><li>运行时内存<ul><li>线程私有：<ul><li><strong>程序计数器</strong>：不会产生<code>StackOverflowError</code>和<code>OutOfMemoryError</code>。</li><li><strong>Java虚拟机栈</strong>：可能出现<code>StackOverflowError</code>和<code>OutOfMemoryError</code>。<ul><li>栈帧：栈的小单元<ul><li>局部变量表</li><li>操作数栈</li><li>动态链接：一个方法调用另一个方法的情景</li><li>方法返回地址</li></ul></li></ul></li><li><strong>本地方法栈</strong></li></ul></li><li>线程共享：<ul><li><strong>方法区</strong>：存储编译器编译后的代码缓存数据：类信息、字段信息、方法信息、常量、静态变量<ul><li>JDK8之前用的<strong>永久代(JAVA堆的内存)</strong>，JDK8之后用的<strong>元空间(操作系统的内存)</strong></li><li>包含的的是整个程序唯一的元素：static，class变量</li><li>运行时常量池</li></ul></li><li><strong>java堆</strong>：内存最大的一块，存放实例对象<ul><li>结构：可以分为新生代和老年代，JDK8之前还有一个永久代区域用于方法区<ul><li>新生代：由Eden、S0(From Sruvivor)、S1(To Sruvivor)组成：8：1：1</li><li>老年代：</li></ul></li><li>字符串常量池</li></ul></li></ul></li></ul></li><li>本地内存<ul><li>元空间：也就是JDK8之后的方法区</li><li>直接内存</li></ul></li></ul><blockquote><p>为什么要分两个S区？</p></blockquote><ul><li>为了保证任何时候总有一个survivor是空的（幸存区），主要为了解决内存的碎片化问题，防止频繁触发GC,影响程序的性能和响应速度。</li><li>从Eden进入survivor时，如果S区不是空的，就会产生内存碎片，本来S区的内存就不大</li></ul><blockquote><p>垃圾回收</p></blockquote><ul><li><p>主要是对堆内存的垃圾回收</p></li><li><p>分类</p><ul><li><p>Partial GC</p><ul><li><p>young GC：只收集新生代</p></li><li><p>Old GC：只收集老年代</p></li><li><p>Mixed GC ：新生代+部分老年代</p></li></ul></li><li><p>Full GC：整个Java堆和方法区（不会影响元空间）</p></li></ul></li><li><p>内存分配</p><ul><li>优先在新生代的Eden区分配，空间不足就发起一次GC</li><li>大对象（需要大量连续内存空间的对象：字符串、数组等）直接进老年代</li><li>长期存活对象进老年代<ul><li>在Eden区第一次出生，经过一次 Minor GC 后存活则进入Survivor区（S0或者S1）</li><li>每熬过一次GC就加一岁，默认到15岁进入老年区</li></ul></li></ul></li><li><p>死亡对象判断（并不会马上宣判死亡）</p><ul><li><p>引用计数法：当被引用就+1，计数器为0就判断死亡</p></li><li><p>可达性分析算法：用一系列成为”GC Root“的对象作为起点，如果对象不在以这个Root为起点的链上，就死亡</p><ul><li><p>常见GC Root：</p><ul><li><p>虚拟机栈(栈帧中的局部变量表)中引用的对象</p></li><li><p>本地方法栈(Native 方法)中引用的对象</p></li><li><p>方法区中类静态属性引用的对象</p></li><li><p>方法区中常量引用的对象</p></li><li><p>所有被同步锁持有的对象</p></li><li><p>JNI（Java Native Interface）引用的对象</p></li></ul></li></ul></li></ul></li></ul><blockquote><p>四大引用</p></blockquote><ul><li>强引用：用的多，不会被回收</li><li>软引用：内存空间够就不会回收</li><li>弱引用：发现了就会被回收</li><li>虚引用：</li></ul><blockquote><p>如何判断废弃常量和无用的类</p></blockquote><ul><li>常量：没用引用</li><li>类：满足条件就“可以”被回收<ul><li>堆中没有实例</li><li>加载该类的<code>ClassLoader</code>被回收</li><li>该类对应的<code>java.lang.Class</code>没有被引用，也没有反射调用</li></ul></li></ul><blockquote><p>垃圾清除算法</p></blockquote><ul><li><p>标记-清除算法</p><ul><li>内存碎片问题；效率问题</li></ul><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/image-20240324113013046.png" alt="image-20240324113013046" style="zoom:67%;" /></p></li><li><p>标记-复制算法：内存切半，一次用一半</p><ul><li>可用内存变小；不适合老年代（对象数量大，复制性能差）</li></ul><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/image-20240324113118170.png" alt="image-20240324113118170" style="zoom: 67%;" /></p></li><li><p>标记-整理算法：</p><ul><li>多了整理这一步，效率不高。</li><li>适合老年代这种垃圾回收频率不是很高的场景。</li></ul><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/image-20240324113228667.png" alt="image-20240324113228667" style="zoom:67%;" /></p></li><li><p><strong>分代收集算法</strong></p><ul><li>分为新生代和老年代</li><li>新生代中每次收集都有很多对象死去，可用标记-复制算法</li><li>老年代中对象存活几率是比较高，必须选择“标记-清除”或“标记-整理”算法</li><li>这也是堆分代的原因</li></ul></li></ul><blockquote><p>垃圾收集器</p></blockquote><ul><li>Serial（串行）收集器：单线程</li></ul><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/image-20240324114051981.png" alt="image-20240324114051981"></p><ul><li>ParNew 收集器：多线程版本</li></ul><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/image-20240324114117775.png" alt="image-20240324114117775"></p><ul><li>Parallel Scavenge 收集器</li></ul><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/image-20240324114202214.png" alt="image-20240324114202214"></p><ul><li>Serial Old 收集器</li></ul><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/image-20240324114310340.png" alt="image-20240324114310340"></p><ul><li>Parallel Old 收集器：Parallel Scavenge 收集器的老年代版本</li></ul><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/image-20240324114336382.png" alt="image-20240324114336382"></p><ul><li>CMS收集器：注重用户的体验的应用上使用，实现用户线程和GC线程并发<ul><li>过程<ul><li>初始标记：暂停用户线程，标记与Root直连的对象</li><li>并发标记：开启用户线程，用一个闭包记录可达对象（是针对于上一个时刻的状态）</li><li>重新标记：暂停用户线程，再次标记并发标记过程中用户线程变动的标记情况（相当于一个同步）</li><li>并发清除：开启用户线程，GC线程清除未标记区域</li></ul></li><li>缺点：从 JDK9 开始，CMS 收集器已被弃用<ul><li>对 CPU 资源敏感；</li><li>无法处理浮动垃圾；</li><li>它使用的回收算法-“标记-清除”算法会导致收集结束时会有大量空间碎片产生。</li></ul></li></ul></li></ul><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/image-20240324114611636.png" alt="image-20240324114611636"></p><ul><li><p><strong>G1收集器</strong>：JDK就之后的默认收集器</p><ul><li>低延迟，高吞吐量</li><li>大内存，多核场景</li><li>标记整理</li></ul><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/image-20240324115056539.png" alt="image-20240324115056539"></p></li></ul><blockquote><p>类的生命周期</p></blockquote><ul><li>加载（Loading）<ul><li>类的加载是通过类加载器完成<code>ClassLoader</code></li><li>用哪个加载器是通过 <strong>双亲委派模型</strong> 决定</li></ul></li><li>验证（Verification）<ul><li>确保 Class 文件的字节流中包含的信息符合安全</li></ul></li><li>准备（Preparation）<ul><li>为类在方法区分配空间</li></ul></li><li>解析（Resolution）<ul><li>虚拟机将常量池内的符号引用替换为直接引用的过程</li></ul></li><li>初始化（Initialization）<ul><li>执行初始化方法 <code>&lt;clinit&gt;</code> ()方法</li></ul></li><li>使用（Using）</li><li>卸载（Unloading）<ul><li>三个条件<ul><li>该类的所有的实例对象都已被 GC，也就是说堆不存在该类的实例对象。</li><li>该类没有在其他任何地方被引用</li><li>该类的类加载器的实例已被 GC</li></ul></li><li>JDK 自带的 <code>BootstrapClassLoader</code>, <code>ExtClassLoader</code>, <code>AppClassLoader</code> 负责加载 JDK 提供的类，所以它们(类加载器的实例)肯定不会被回收。</li><li>自定义的类加载器的实例是可以被回收的</li></ul></li></ul><blockquote><p>类加载器</p></blockquote><ul><li><p>负责加载类的对象，<code>ClassLoader</code> 是一个抽象类</p></li><li><p>将<code>.class</code>文件加载到JVM中</p></li><li><p>每个 Java 类都有一个引用指向加载它的 <code>ClassLoader</code>。不过，数组类不是通过 <code>ClassLoader</code> 创建的，而是 JVM 在需要的时候自动创建的，数组类通过<code>getClassLoader()</code>方法获取 <code>ClassLoader</code> 的时候和该数组的元素类型的 <code>ClassLoader</code> 是一致的。</p></li><li><p>动态加载：要用的时候再加载</p></li><li>JVM内置类加载器<ul><li><code>BootstrapClassLoader</code>（启动类加载器）<ul><li>最顶层，C++实现，通常表示为 null<ul><li><code>getClassLoader()</code>得到的是null,因为C++实现，没有对应的Java类</li></ul></li><li>加载核心类库：<code>%JAVA_HOME%/lib</code>下的<code>rt.jar</code>、<code>resources.jar</code>、<code>charsets.jar</code>等 jar 包和类<ul><li><code>rt.jar</code>就是基础类库</li></ul></li><li>还有被<code>-Xbootclasspath</code>参数指定的路径下的所有类</li></ul></li><li><code>ExtensionClassLoader</code>（扩展类加载器）<ul><li><code>%JRE_HOME%/lib/ext</code>下的jar</li><li><code>java.ext.dirs</code> 系统变量所指定的路径下的所有类。</li></ul></li><li><code>AppClassLoader</code>（应用程序类加载器）<ul><li>加载当前classpath 下的类和jar包</li></ul></li></ul></li><li><p>自定义类加载器</p><ul><li><code>protected Class loadClass(String name, boolean resolve)</code>：加载指定二进制名称的类，实现了双亲委派机制 。</li><li><code>protected Class findClass(String name)</code>：根据类的二进制名称来查找类，默认实现是空方法。</li><li>区别：<ul><li>不想打破双亲委派，就重写<code>findClass</code>方法，无法被父类加载器加载的都过这个加载器加载</li><li>想打破双亲委派，就重写<code>loadClass</code></li></ul></li><li>Tomcat：自定义了<code>WebAppClassLoader</code>加载相关目录下的类</li><li>Spring：自定义了<code>ThreadContextClassLoader</code>线程上下文类加载器，</li></ul></li><li><p>双亲委派模型（就一个父类）</p><ul><li><p><code>ClassLoader</code> 类使用委托模型来搜索类和资源。</p></li><li><p>双亲委派模型要求除了顶层的启动类加载器外，其余的类加载器都应有自己的父类加载器。</p></li><li><p><code>ClassLoader</code> 实例会在试图亲自查找类或资源之前，将搜索类或资源的任务委托给其父类加载器。</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/image-20240324134630162.png" alt="image-20240324134630162" style="zoom: 33%;" /></p></li><li><p>注意：</p><ul><li>只是JDK的一种推荐，并不是强制的约束</li><li>类加载器之间的父子关系一般不是以继承的关系来实现的，而是通常使用组合关系来复用父加载器的代码。</li></ul></li><li><p>执行流程</p><ul><li>判断类有没有被加载过</li><li>没有被加载则先委托给父类加载(父类的<code>loadClass</code>)（也就是所有的请求都会从<code>BootstrapClassLoader</code>开始）</li><li>父类无法加载则子加载器再加载(<code>findClass</code>)</li><li>若还是无法加载，则抛出<code>ClassNotFoundException</code>异常</li></ul></li></ul></li></ul><blockquote><p>JVM 参数</p></blockquote><ul><li><p>堆内存相关</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 堆内存</span></span><br><span class="line">-Xms&lt;heap size&gt;[unit] <span class="comment"># 最小 unit：g,m,k</span></span><br><span class="line">-Xmx&lt;heap size&gt;[unit] <span class="comment"># 最大</span></span><br><span class="line">-----------------------------------</span><br><span class="line">-Xms2G -Xmx5G</span><br><span class="line">====================================</span><br><span class="line"><span class="comment"># 新生代</span></span><br><span class="line">-XX:NewSize=&lt;young size&gt;[unit]</span><br><span class="line">-XX:MaxNewSize=&lt;young size&gt;[unit]</span><br><span class="line">-----------------------------------</span><br><span class="line">-XX:NewSize=256m</span><br><span class="line">-XX:MaxNewSize=1024m</span><br><span class="line">====================================</span><br><span class="line"><span class="comment"># 新生代2</span></span><br><span class="line">-Xmn&lt;young size&gt;[unit]</span><br><span class="line">-----------------------------------</span><br><span class="line">-Xmn256m</span><br><span class="line">====================================</span><br><span class="line"><span class="comment"># 永久代</span></span><br><span class="line">-XX:PermSize=N <span class="comment"># 方法区 (永久代) 初始大小</span></span><br><span class="line">-XX:MaxPermSize=N <span class="comment"># 方法区 (永久代) 最大大小</span></span><br><span class="line">====================================</span><br><span class="line"><span class="comment">#元空间</span></span><br><span class="line">-XX:MetaspaceSize=N <span class="comment"># 设置 Metaspace 的初始大小</span></span><br><span class="line">-XX:MaxMetaspaceSize=N <span class="comment"># 设置 Metaspace 的最大大小</span></span><br><span class="line">====================================</span><br></pre></td></tr></table></figure></li><li><p>垃圾收集相关</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 选择垃圾回收器</span></span><br><span class="line">-XX:+UseSerialGC<span class="comment"># 串行垃圾收集器</span></span><br><span class="line">-XX:+UseParallelGC<span class="comment"># 并行垃圾收集器</span></span><br><span class="line">-XX:+UseParNewGC<span class="comment"># CMS 垃圾收集器</span></span><br><span class="line">-XX:+UseG1GC<span class="comment"># G1 垃圾收集器</span></span><br><span class="line">=====================================</span><br><span class="line"><span class="comment"># 日志</span></span><br><span class="line"><span class="comment"># 打印基本 GC 信息</span></span><br><span class="line">-XX:+PrintGCDetails</span><br><span class="line">-XX:+PrintGCDateStamps</span><br><span class="line"><span class="comment"># GC日志输出的文件路径</span></span><br><span class="line">-Xloggc:/path/to/gc-%t.log</span><br><span class="line"><span class="comment"># 每个文件上限大小，超过就触发分割</span></span><br><span class="line">-XX:GCLogFileSize=50M</span><br></pre></td></tr></table></figure></li></ul><h3 id="17-SQL"><a href="#17-SQL" class="headerlink" title="17 SQL"></a>17 SQL</h3><p><a href="https://sqlmother.solargod.cn/#/learn">https://sqlmother.solargod.cn/#/learn</a></p><blockquote><p>CRUD</p></blockquote><ul><li><p>增：<code>INSERT</code></p></li><li><p>删：<code>DELETE</code>（删除记录），<code>TRUNCATE</code>（清空表），<code>DROP</code>（删除表）</p></li><li><p>改：<code>UPDATE</code></p></li><li><p>查：</p><ul><li><p><code>SELECT</code>，<code>LIMIT</code>，<code>ORDER BY</code>，<code>ASC</code>，<code>DESC</code></p></li><li><p><code>IS NULL</code> 、<code>IS NOT NULL</code></p></li><li><p><code>GROUP BY</code></p><ul><li>分组之前过滤用<code>WHERE</code></li><li>分组之后用<code>HAVING</code></li></ul></li><li><p>子查询常用在 <code>WHERE</code> 子句和 <code>FROM</code> 子句后边，放在<code>()</code>里面，<code>EXISTS</code>、<code>NOT EXISTS</code></p></li><li><p><code>IN(XX,XX,XX...)</code></p></li><li><p><code>BETWEEN x AND y</code></p></li><li><p><code>AND</code> <code>OR</code> <code>NOT</code></p></li><li><p><code>DISTINCT</code>：去重，如果有多个字段就是组合去重</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select distinct class_id, exam_num from student;</span><br></pre></td></tr></table></figure></li><li><p>列操作</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> name, score, score <span class="operator">*</span> <span class="number">2</span> <span class="keyword">as</span> double_score <span class="keyword">from</span> student；</span><br></pre></td></tr></table></figure></li><li><p><code>LIKE</code> </p><ul><li><code>%</code>：任意字符出现任意次数</li><li><code>_</code>：任意字符出现一次</li><li>eg：<code>WHERE prod_name LIKE &#39;%bean bag%&#39;;</code></li></ul></li><li><p><code>JOIN</code> 用 <code>ON</code>表示连接条件</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> c.cust_name, o.order_num</span><br><span class="line"><span class="keyword">from</span> Customers c</span><br><span class="line"><span class="keyword">inner</span> <span class="keyword">join</span> Orders o</span><br><span class="line"><span class="keyword">on</span> c.cust_id <span class="operator">=</span> o.cust_id</span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> c.cust_name;</span><br></pre></td></tr></table></figure></li><li><p><code>UNION</code> <code>UNION ALL</code>连接两个表，后者不去重 </p></li><li><p>条件分支</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">-- 一个表有name和age列，返回name，age_level(age &gt; 60为老同学，&gt;=20为年轻，为空或者&lt;20为小同学)，最后结果用name升序排</span></span><br><span class="line"><span class="keyword">select</span></span><br><span class="line">  name,</span><br><span class="line">  <span class="keyword">case</span></span><br><span class="line">    <span class="keyword">when</span> (age <span class="operator">&gt;</span> <span class="number">60</span>) <span class="keyword">then</span> &quot;老同学&quot;</span><br><span class="line">    <span class="keyword">when</span> (age <span class="operator">&gt;=</span> <span class="number">20</span>) <span class="keyword">then</span> &quot;年轻&quot;</span><br><span class="line">    <span class="keyword">else</span> &quot;小同学&quot;</span><br><span class="line">  <span class="keyword">end</span> <span class="keyword">as</span> age_level</span><br><span class="line"><span class="keyword">from</span></span><br><span class="line">  student</span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span></span><br><span class="line">  name <span class="keyword">ASC</span>;</span><br></pre></td></tr></table></figure></li></ul></li></ul><blockquote><p>函数</p></blockquote><ul><li><p>开窗函数 <code>PARTITION BY xx</code>分组依据 <code>ORDER BY xx</code> 排序依据</p><ul><li><p><code>SUM(xx) OVER</code>：计算累计值，比如某个用户的累计消费</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">SUM</span>(计算字段名) <span class="keyword">OVER</span> (<span class="keyword">PARTITION</span> <span class="keyword">BY</span> 分组字段名)</span><br><span class="line"><span class="comment">-- 每个学生的详细信息，并且按照分数升序的方式累加计算每个班级的学生总分</span></span><br><span class="line"><span class="keyword">select</span> </span><br><span class="line">    id, name, age, score, class_id,</span><br><span class="line">    <span class="built_in">SUM</span>(score) <span class="keyword">OVER</span> (<span class="keyword">PARTITION</span> <span class="keyword">BY</span> class_id <span class="keyword">order</span> <span class="keyword">by</span> score <span class="keyword">asc</span>) <span class="keyword">as</span> class_sum_score</span><br><span class="line"><span class="keyword">from</span> student</span><br></pre></td></tr></table></figure></li><li><p><code>AVG(xx) OVER</code>：计算平均值，比如某个班的平均分，加在学生信息后面</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span></span><br><span class="line">    id, name, age, score, class_id,</span><br><span class="line">    <span class="built_in">AVG</span>(score) <span class="keyword">OVER</span> (<span class="keyword">PARTITION</span> <span class="keyword">BY</span> class_id) <span class="keyword">as</span> class_avg_score</span><br><span class="line"><span class="keyword">from</span> student</span><br></pre></td></tr></table></figure></li><li><p><code>RANK() OVER</code></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">  id,name,age,score,class_id,</span><br><span class="line">  <span class="built_in">RANK</span>() <span class="keyword">OVER</span> (<span class="keyword">PARTITION</span> <span class="keyword">BY</span> class_id <span class="keyword">ORDER</span> <span class="keyword">BY</span> score <span class="keyword">DESC</span>) <span class="keyword">as</span> ranking</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">  student;</span><br></pre></td></tr></table></figure></li><li><p><code>ROW_NUMBER() OVER</code>：和<code>RANK() OVER</code>不一样的地方在于这个得到的排序是唯一的</p></li><li><p><code>Lag() OVER</code> <code>Lead() OVER</code> </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- Lag 函数用于获取 当前行之前 的某一列的值 </span></span><br><span class="line"><span class="built_in">LAG</span>(column_name, <span class="keyword">offset</span>, default_value) <span class="keyword">OVER</span> (<span class="keyword">PARTITION</span> <span class="keyword">BY</span> partition_column <span class="keyword">ORDER</span> <span class="keyword">BY</span> sort_column);</span><br><span class="line"><span class="comment">-- Lead 函数用于获取 当前行之后 的某一列的值 </span></span><br><span class="line"><span class="built_in">LEAD</span>(column_name, <span class="keyword">offset</span>, default_value) <span class="keyword">OVER</span> (<span class="keyword">PARTITION</span> <span class="keyword">BY</span> partition_column <span class="keyword">ORDER</span> <span class="keyword">BY</span> sort_column)</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 以班级为单位按照分数降序的方式获取每个班级内的学生的前一名学生姓名（prev_name）、后一名学生姓名（next_name）。</span></span><br><span class="line"><span class="keyword">select</span> </span><br><span class="line">    id, name, age, score, class_id,</span><br><span class="line">    <span class="built_in">LAG</span>(name, <span class="number">1</span>, <span class="keyword">NULL</span>) <span class="keyword">OVER</span> (<span class="keyword">PARTITION</span> <span class="keyword">BY</span> class_id  <span class="keyword">ORDER</span> <span class="keyword">BY</span> score <span class="keyword">desc</span>) <span class="keyword">as</span> prev_name,</span><br><span class="line">    <span class="built_in">LEAD</span>(name, <span class="number">1</span>, <span class="keyword">NULL</span>) <span class="keyword">OVER</span> (<span class="keyword">PARTITION</span> <span class="keyword">BY</span> class_id  <span class="keyword">ORDER</span> <span class="keyword">BY</span> score <span class="keyword">desc</span>) <span class="keyword">as</span> next_name</span><br><span class="line"><span class="keyword">from</span> student</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="18-设计模式"><a href="#18-设计模式" class="headerlink" title="18 设计模式"></a>18 设计模式</h3><h4 id="装饰者模式"><a href="#装饰者模式" class="headerlink" title="装饰者模式"></a>装饰者模式</h4><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/image-20240508114653108.png" alt="image-20240508114653108" style="zoom: 80%;" /></p><ul><li><p>抽象组件：<code>Component</code></p></li><li><p>被装饰类：<code>ConcreteComponent</code></p></li><li><p>装饰者组件：<code>Decorator</code></p></li><li><p>具体装饰：<code>ConcreteDecoratorA</code>、<code>ConcreteDecoratorB</code></p></li><li><p>核心是<code>Decorator</code>内维护一个<code>Component</code>类型的变量</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Decorator</span> <span class="keyword">implements</span> <span class="title class_">Component</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> Component component;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">BitmapDecorator</span><span class="params">(Component component)</span> &#123;</span><br><span class="line">        component = component;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doOperation</span><span class="params">()</span> &#123;</span><br><span class="line">        component.component();<span class="comment">//可以做基础操作</span></span><br><span class="line">        <span class="comment">// 子类ConcreteDecoratorA、ConcreteDecoratorB再对这个方法进行装饰增强</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>使用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ConcreteComponent</span> <span class="variable">concreteComponent</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConcreteComponent</span>();<span class="comment">//创建被装饰者</span></span><br><span class="line"></span><br><span class="line">concreteComponent.doOperation();<span class="comment">//无任何装饰</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">ConcreteDecoratorA</span>(concreteComponent).doOperation();<span class="comment">//装饰器A增强</span></span><br></pre></td></tr></table></figure></li><li><p>具体使用，IO类</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/image-20240508115513966.png" alt="image-20240508115513966"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">FileInputStream</span> <span class="variable">fileInputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(filePath);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 两种不同的装饰</span></span><br><span class="line"><span class="type">BufferedInputStream</span> <span class="variable">bufferedInputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedInputStream</span>(fileInputStream);</span><br><span class="line"><span class="type">DataInputStream</span> <span class="variable">dataInputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DataInputStream</span>(fileInputStream);</span><br></pre></td></tr></table></figure></li></ul><h2 id="二-项目"><a href="#二-项目" class="headerlink" title="二 项目"></a>二 项目</h2><h3 id="1-FS开发"><a href="#1-FS开发" class="headerlink" title="1 FS开发"></a>1 FS开发</h3><ul><li>难点：高频次的呼叫+自定义的移库策略导致任务呼叫时与任务实际执行时库位的状态不一致，且无法通过设置库位预定占用量来确定，无法获取准确的库位信息进而无法确定空闲库位；</li><li>解决：自定义呼叫池，延后实际的呼叫事件触发时间，在池中维护一个队列，每次呼叫成功后再从池中获取任务，再根据当前的状态进行任务的调度。</li></ul><blockquote><p>涉及到的设计模式</p></blockquote><ul><li><h3 id="2-苍穹"><a href="#2-苍穹" class="headerlink" title="2 苍穹"></a>2 苍穹</h3></li></ul><h4 id="2-0-亮点"><a href="#2-0-亮点" class="headerlink" title="2.0 亮点"></a>2.0 亮点</h4><blockquote><p>使用AOP+自定义注解的方式实现业务的公共字段的自动插入/更新</p></blockquote><ul><li><p>定义<code>@AutoFill</code>注解，并定义<code>OperationType value();</code>属性是一个枚举类：更新和插入</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/image-20240319103405484.png" alt="image-20240319103405484" style="zoom: 67%;" /></p></li><li><p>标识切面类<code>AutoFillAspect</code>（<code>@Aspect</code>修饰）</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/image-20240319103353768.png" alt="image-20240319103353768" style="zoom:67%;" /></p></li><li><p>定义切入点<code>@PointCut</code>：限制扫描的包以及需要被<code>@AutoFill</code>修饰</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/image-20240319103343189.png" alt="image-20240319103343189"></p></li><li><p>定义前置通知<code>@Before(&quot;autoFillPointCut()&quot;)</code></p><ul><li>通过<code>JoinPoint</code>对象获取实体对象</li><li>通过反射来设置对象的值</li></ul></li></ul><blockquote><p>ThreadLocal对象</p></blockquote><ul><li>实现了线程之间的数据隔离</li><li>一个线程里面有一个ThreadLocalMap对象，里面维护了一个Entry数据，key就是Thread对象，value是保存的值</li><li>在本项目中实现：<ul><li>在拦截器中对JWT解析，解析通过后保存当前用户id</li><li>MyBatis中的分页插件Pagehelper底层使用的也是ThreadLocal来保存</li></ul></li><li>ThreadLocal内存泄漏：见java基础</li></ul><h4 id="2-1介绍"><a href="#2-1介绍" class="headerlink" title="2.1介绍"></a>2.1介绍</h4><ul><li>本项⽬包括管理端和小程序端两部分。其中管理端主要给内部员⼯使⽤，可以对菜品的分类、套餐、订单、员⼯信息进⾏管理维 护，对订单进⾏统计分析；小程序端主要给⽤⼾使⽤，可以在线浏览菜品、添加购物⻋、下单、⽀付等</li><li><code>SpringBoot+Mybatis+Redis+MySQL</code></li></ul><h4 id="2-2-数据表"><a href="#2-2-数据表" class="headerlink" title="2.2 数据表"></a>2.2 数据表</h4><ul><li><p>地址表 <code>address_book</code></p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/image-20240311162824258.png" alt="image-20240311162824258"></p></li><li><p>套餐分类表 <code>category</code></p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/image-20240311162842385.png" alt="image-20240311162842385"></p></li><li><p>菜品表 <code>dish</code></p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/image-20240311162908810.png" alt="image-20240311162908810"></p></li><li><p>菜品口味表 <code>dish_flavor</code></p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/image-20240311162923552.png" alt="image-20240311162923552"></p></li><li><p>员工表 <code>employee</code></p></li><li><p>用户表 <code>user</code></p></li><li><p>订单明细表 <code>order_detail</code></p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/image-20240311163113434.png" alt="image-20240311163113434"></p></li><li><p>订单表 <code>orders</code></p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/image-20240311163219518.png" alt="image-20240311163219518"></p></li><li><p>套餐表 setmeal</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/image-20240311163331594.png" alt="image-20240311163331594"></p></li><li><p>套餐明细表 setmeal_dish</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/面试准备.assets/image-20240311163313463.png" alt="image-20240311163313463" style="zoom:67%;" /></p></li><li><p>购物车表 shopping_cart</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/image-20240311163341344.png" alt="image-20240311163341344"></p></li></ul><h4 id="2-3-技术点"><a href="#2-3-技术点" class="headerlink" title="2.3 技术点"></a>2.3 技术点</h4><blockquote><p>JWT</p></blockquote><ul><li><p>三个部分，头部声明了加密算法HS256合加密类型JWT，载荷声明用户信息，尾部是前两部分的签名</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//头部</span></span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;alg&quot;</span><span class="punctuation">:</span> <span class="string">&quot;HS256&quot;</span><span class="punctuation">,</span>   <span class="comment">//第三段字符串的不可逆加密类型HS256，为什么不可逆？</span></span><br><span class="line">  <span class="attr">&quot;typ&quot;</span><span class="punctuation">:</span> <span class="string">&quot;JWT&quot;</span>   <span class="comment">//token类型JWT</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"><span class="comment">//载荷</span></span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;sub&quot;</span><span class="punctuation">:</span> <span class="string">&quot;1234567890&quot;</span><span class="punctuation">,</span>   <span class="comment">//用户id</span></span><br><span class="line">  <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;John Doe&quot;</span><span class="punctuation">,</span><span class="comment">//用户名</span></span><br><span class="line">  <span class="attr">&quot;exp&quot;</span><span class="punctuation">:</span> <span class="number">1516239022</span><span class="comment">//token过期时间</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure></li><li><p>生成过程</p><ul><li>首先将1、2部分进行<code>base64</code>加密(这个过程是可逆的，只要别人知道了使用base64加密就可以直接解析出来)<ul><li><code>base64</code>: ‘a’到 ‘z’ ‘A’ 到’Z’ ‘0’ 到 ‘9’ 再加上 ‘+’  ‘/‘一共64个字符</li><li>任何符号都可以转换成这个字符集中的字符，这个转换过程就叫做<strong>base64编码</strong></li></ul></li><li>然后使用第一部分声明的HS256和保存在服务器的自定义盐来进行加密得到第三部分</li></ul></li><li><p>解析过程</p><ul><li>服务端解析1、2部分得到加密类型和信息</li><li>根据签名及加密类型解密判断第三部分得到的信息是否与1、2部分一致来判断是否被篡改</li><li>进一步判断第2部分进行业务操作</li></ul></li></ul><hr><blockquote><p>HandlerInterceptor拦截器实现JWT校验</p></blockquote><ul><li>实现这个接口，里面有三个方法：<ul><li><code>preHandle</code>：Controller方法处理之前<ul><li>本项目中用于JWT令牌的校验</li></ul></li><li><code>postHandle</code>：Controller方法处理完之后，DispatcherServlet进行视图的渲染之前，也就是说在这个方法中你可以对ModelAndView进行操作</li><li><code>afterCompletion</code>：DispatcherServlet进行视图的渲染之后</li></ul></li></ul><hr><blockquote><p>微信登录</p></blockquote><ul><li>前端传入授权码发送至服务端</li><li><p>服务端携带授权码code + appid + secret 采用<code>HttpClient</code>发送请求到<a href="https://api.weixin.qq.com/sns/jscode2session">https://api.weixin.qq.com/sns/jscode2session</a></p></li><li><p>得到微信服务端返回的openid + session_key，其中openid也就是微信用户的唯一标识</p></li><li><p>根据openid查询数据库中是否存在此用户（openid不是主键），若不存在则自动创建，存在则返回该用户信息</p></li><li><p>为该用户生成jwt令牌（密钥+过期时间+信息）</p><ul><li>密钥用于加密解密jwt信息</li><li>信息claims是一个map，在本项目中只存储了userId这一个信息</li></ul></li><li><p>返回VO对象（token +用户id+微信openid）</p></li></ul><hr><blockquote><p>redis序列化的方式</p></blockquote><ul><li>JdkSerializationRedisSerializer：默认，将Java对象序列化为字节数组</li><li>StringRedisSerializer：默认，使用String类型作为Redis的key和value的序列化方式</li><li>GenericToStringSerializer：可以将任何对象泛化为字符串并序列化</li><li>Jackson2JsonRedisSerializer ：一种更加轻量级的序列化方式，它仅仅支持JSON格式的序列化和反序列化</li><li><strong>GenericJackson2JsonRedisSerializer</strong>：使用Jackson库将Java对象序列化为JSON格式的字符串，以便在Redis中存储和检索 — 常用</li></ul><blockquote><p> Reids与SpringCache</p></blockquote><ul><li><p><strong>key的命名:用户Id+业务名</strong>使用心得</p><ul><li>取key的时候通过定义工具类来取（输入用户id然后输出key）</li></ul></li><li><p>redis缓存菜品分类</p><ul><li><p>根据分类id查询菜品存储在List中，随后redis的key为dish_id号，value是list的内容     </p></li><li><p>当新增、修改、删除菜品的时候删除所有的dish_*的缓存（这里可以做的更细一点）</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/苍穹外卖.assets/image-20240224195415885.png" alt="image-20240224195415885" style="zoom:67%;" /></p></li></ul></li><li><p>SpringCache缓存套餐</p><ul><li><p>本质：SpringCache在JVM中，集群中不可用，当然也可以实现其整合redis等缓存中间件</p></li><li><p><code>application</code>类上添加<code>@EnableCaching</code></p></li><li><p>在根据分类id查询套餐前判断setmealCache这个缓存管理器中有没有指定的分类id的value，有则直接返回，没有则再执行方法，再将查询结果存储在缓存中</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/苍穹外卖.assets/image-20240224201425719.png" alt="image-20240224201425719" style="zoom:67%;" /></p></li><li><p>在批量删除套餐的时候清理所有缓存</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/苍穹外卖.assets/image-20240224201343039.png" alt="image-20240224201343039" style="zoom:67%;" /></p></li></ul></li></ul><hr><blockquote><p>定时任务</p></blockquote><ul><li>Spring Task和xxl-job区别：后者是分布式的，更稳定</li></ul><blockquote><p>微信支付</p></blockquote><ul><li>用户点击支付，向接口发送请求</li><li>服务端生成订单：获取到当前用户的id，采用JSAPI下单，传入appid、mchid（商户号）、description、out_trade_no、notify_url（回调地址）等信息，发送post请求给微信端（httpclient）<a href="https://api.mch.weixin.qq.com/v3/pay/transactions/jsapi">https://api.mch.weixin.qq.com/v3/pay/transactions/jsapi</a></li><li>微信端返回预支付订单信息返回给服务端</li><li>解析返回结果：<strong>prepay_id</strong>（关键，这个要给前端）： 预支付交易会话标识，根据prepay_id及appid、时间等信息生成二次签名（预支付交易单），生成vo对象给前端，前端生成支付二维码</li><li>支付成功请求回调地址：完成读取数据、解密数据、业务处理：修改订单状态、给微信响应</li></ul><hr><blockquote><p>百度地图和阿里云OSS</p></blockquote><ul><li>申请ak</li><li>请求的时候注意参数的顺序：address、output、ak</li><li>获取经纬度信息：<a href="https://api.map.baidu.com/geocoding/v3">https://api.map.baidu.com/geocoding/v3</a></li><li>获取路径规划信息：<a href="https://api.map.baidu.com/directionlite/v1/driving">https://api.map.baidu.com/directionlite/v1/driving</a></li></ul><hr><blockquote><p>来单提醒/用户催单</p></blockquote><ul><li><p>客户端通过<code>/ws/&#123;sid&#125;</code>与服务端建立websocket长连接，会话对象<code>Session</code>存储在map中，当需要发送消息的时候调用<code>session.getBasicRemote().sendText(message);</code>方法即可</p></li><li><p>在客户支付成功之后调用</p></li><li><p>websocket基于TCP连接</p><ul><li>TCP三次握手</li><li>四次挥手</li></ul></li></ul><blockquote><p>多用户抢单</p></blockquote><ul><li>乐观锁</li></ul><blockquote><p>订单超时未支付怎么处理</p></blockquote><ul><li>扫表轮询<ul><li>用一个定时任务获取数据库中的待支付状态数据，批量关闭超时订单</li><li>缺点：表的数据多的时候就会耗时</li></ul></li><li>懒删除<ul><li>用户查询订单的时候在业务逻辑中额外做一个判断</li><li>缺点：如果没有查询的话就会一直挂起，库存数据就一直被占用</li></ul></li><li>消息队列实现（多）<ul><li>下单的时候发送消息到延时队列，到期的时候检测支付状态，未支付就关闭</li></ul></li><li>redis实现<ul><li>发送一个redis消息，设置过期时间，然后设置过期回调，处理检测支付状态</li><li>缺点：redis 自动过期的实现方式是：定时任务离线扫描并删除<strong>部分</strong>过期键；在访问键时惰性检查是否过期并删除过期键。不能保证一到过期时间就删除</li></ul></li></ul><h3 id="3-学成"><a href="#3-学成" class="headerlink" title="3 学成"></a>3 学成</h3><ul><li>总结的不错:<a href="https://blog.csdn.net/qq_64948664/article/details/134403243">https://blog.csdn.net/qq_64948664/article/details/134403243</a></li></ul><h4 id="3-0-项目亮点"><a href="#3-0-项目亮点" class="headerlink" title="3.0 项目亮点"></a>3.0 项目亮点</h4><ul><li><p>Spring Security整合了OAuth2.0,JWT完成分布式的认证</p><ul><li>自定义继承<code>DaoAuthenticationProvider</code>,取消里面的密码校验,<code>checks()</code>方法直接返回null</li><li>在<code>WebSecurityConfig</code>配置类中注入刚刚的对象</li><li>自定义类继承<code>UserDetailService</code>接口,重写<code>loadUserByUsername()</code> 方法,根据登录方式在方法里面通过<code>ApplicationContext</code>容器找到对应的service bean,调用对应的方法(策略模式),最终返回<code>UserDetails</code>对象(username修改为用户信息,password随便写,但不能为空,authorities表示权限的数组)</li></ul></li><li><p>分布式事务控制的幂等性</p><ul><li>使用一个任务表记录任务的执行情况,保证了任务只会被执行一次</li></ul></li><li><p>使用redis对缓存进行优化，将课程的发布信息存入到redis中，减少对数据库的访问压力</p></li></ul><h4 id="3-1介绍"><a href="#3-1介绍" class="headerlink" title="3.1介绍"></a>3.1介绍</h4><ul><li><p>本项目是一个在线学习网站项目，采用SpringBoot、SpringCloud技术栈开发，划分的微服务包括网关服务、认证授权服务、注册中心服务、配置中心服务、内容管理服务、媒资管理服务、搜索服务、订单支付服务、学习中心服务、系统管理服务等，可以实现用户的网课在线学习等功能.</p></li><li><p><code>SpringBoot+SprintCloud Alibaba+Spring Security+ Mybatis-Plus+Redis+RabbitMQ+Elasticsearch+MinIO</code></p><ul><li><p>本项目包括两个端：用户端(学生端)、机构端</p><p>核心模块包括：内容管理、媒资管理、课程搜索、订单支付、选课管理、认证授权等，每个模块对应了一个微服务，</p><p>采用前后端分离架构，后端采用SpringBoot、SpringCloud技术栈开发，数据库使用了MySQL，还使用的Redis、消息队列、分布式文件系统、Elasticsearch等中间件系统。</p><p>我在这个项目中负责了课程内容管理、媒资管理、订单支付管理、搜索管理、认证授权管理模块的开发。</p></li><li><p>内容管理模块.是对平台上的课程进行管理，课程的相关信息比较多这里在数据库设计了课程基本信息表、课程营销表、课程计划、课程师资表进行存储 ，培训机构要发布一门课程需要填写课程基本信息、课程营销信息、课程计划信息、课程师资信息，填写完毕后需要提交审核，由运营人员进行课程信息的审核。课程审核通过即可选择发布课程，课程的相关信息会聚合到课程发布表中，这里不仅要将课程信息写到课程发布表还要将课程信息写到redis、课程索引写进ES索引库、课程内容静态页面上传分布式文件系统，所以这里存在分布式事务的问题，项目使用本地消息表加任务调度的方式去解决这里的分布式事务，保存数据的最终一致性。</p></li><li><p>媒资管理模块。对平台上的媒资信息进行管理,主要包括相关图片视频的分布式存储,采用的MINIO分布式文件系统，特别的，实现了对大文件的分块上传及校验；以及使用分布式任务调度平台xxl-job来实现视频转码的功能。</p></li><li><p>搜索模块。目前是完成了对课程的搜索，通过定义索引的操作接口（增删改查）及搜索接口，实现用户快速进行关键字索引课程的需求</p><ul><li><p><code>RestHighLevelClient</code>对象的<code>index</code>、<code>update</code>、<code>delete</code>方法进行索引的管理</p></li><li><p><code>RestHighLevelClient</code>对象的<code>search</code>进行搜索</p></li></ul></li><li><p>认证授权管理模块。在这个模块中主要是通过SpringSecurity实现了统一登录接口，具体的支持账号密码及微信扫码登录两种方式；此外也实现了基于角色的访问控制(RBAC)，通过定义不同类型的用户来实现角色的权限控制。</p></li><li><p>支付模块。目前是使用一个支付宝的沙箱环境完成了一个模拟在线支付的行为，了解到了支付宝的支付流程，在选课支付成功后通过向MQ中发送消息更新相关的用户课程信息来实现业务的解耦。</p></li></ul></li></ul><h4 id="3-2-数据表"><a href="#3-2-数据表" class="headerlink" title="3.2 数据表"></a>3.2 数据表</h4><ul><li>数据表</li></ul><h4 id="3-3-模块点"><a href="#3-3-模块点" class="headerlink" title="3.3 模块点"></a>3.3 模块点</h4><blockquote><p>内容管理服务</p></blockquote><ul><li>表：课程基本信息表、课程营销表、课程计划表、课程师资表、课程媒资表</li><li><p>为什么用多张表？方便不同的服务使用，比如课程媒资表</p></li><li><p>课程提交审核、课程发布、课程查看(Freemarker)</p><ul><li>为什么使用Freemarker？（FreeMarker、Velocity、Thymeleaf）<ul><li>页面静态化是指使用模板引擎技术将一个动态网页生成html静态页面，满足以下条件可以考虑使用静态化<ol><li>该页面被访问频率高，例如：商品信息展示、讲师介绍页面</li><li>页面上数据变化频率低，例如：商品发布后对商品信息的修改频率低、讲师介绍信息修改频率低</li></ol></li><li>静态化的技术很多，Freemarker是一个成熟的开源的模板引擎工具，简单易用，功能强大，本项目使用Freemarker将课程信息静态化<ol><li>使用Freemarker的标签编写课程信息的模板</li><li>调用接口获取模板上需要的模型数据</li><li>调用Freemarker的API生成静态页面</li><li>生成的静态页面最终会上传到文件系统方便访问</li></ol></li></ul></li></ul></li><li>师资的增删改查</li></ul><hr><blockquote><p>媒资管理服务</p></blockquote><ul><li><p>表：媒资信息表、视频任务处理表</p></li><li><p>云计算厂家：阿里云OSS、百度对象存储BOS，这里用的MINIO</p></li><li>上传图片/视频</li><li>断点续传(视频分块)</li><li>视频处理(分布式任务调度xxl-job，FFmpeg工具)</li><li>视频下载：FileOutputStream，InputStream</li><li>分块合并：<ul><li><code>MinioClient</code>的<code>composeObject()</code>方法</li><li>合并完成后下载，校验md5</li><li>信息入库并删除分块</li></ul></li></ul><hr><blockquote><p>认证授权服务</p></blockquote><ul><li>Spring Security：<a href="https://blog.csdn.net/justry_deng/article/details/103549894">https://blog.csdn.net/justry_deng/article/details/103549894</a></li></ul><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/image-20240318161649210.png" alt="image-20240318161649210"></p><ul><li><p>OAuth2.0的流程</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/image-20240318195542692.png" alt="image-20240318195542692"></p></li><li><p>JWT小工具：<a href="https://jwt.io/">https://jwt.io/</a> </p></li><li><p>微信登录</p></li></ul><hr><blockquote><p>订单服务</p></blockquote><ul><li>支付宝支付（订单表+消息通知表）<ul><li>请求学习中心服务创建选课记录</li><li>请求订单服务创建商品订单、生成支付二维码（<strong>存储到订单表数据库，payNo主键</strong>）</li><li>用户扫码请求订单支付服务，订单支付服务请求第三方支付平台生成支付订单（<strong>根据payNo，支付金额，订单名称，回调地址等信息，使用AlipayClient调用sdk请求下单</strong>）</li><li>前端唤起支付客户端（<strong>支付宝会返回一个表单数据，用户前端会生成支付宝支付的界面</strong>），用户输入密码完成支付</li><li>第三方支付平台支付完成后，发起支付通知</li><li>订单支付服务接收支付通知结果（<strong>支付宝在支付完成后会自动的请求这个回调通知接口</strong>）<ul><li>获取支付宝传来的DTO，然后根据payNo在数据库中找到订单，然后更新订单数据</li><li>向MQ中添加消息（<strong>解耦</strong>）</li></ul></li><li>用户在前端查询支付结果，请求订单支付服务查询支付结果，如果订单服务还没有收到支付结果，则请求学习中心查询支付结果</li><li>订单支付服务向学习中心通知支付结果</li><li>学习中心服务收到支付结果，如果支付成功则更新选课记录，并添加到我的课程表</li></ul></li></ul><hr><blockquote><p>搜索服务</p></blockquote><ul><li>本项目使用ElasticSearch开发搜索服务，步骤如下<ol><li>创建索引（相当于数据库表），将课程信息添加到索引库，对课程信息进行分词，存储到索引库</li><li>开发一个搜索服务，编写课程搜索接口，调用ElasticSearch的rest接口根据关键字、课程分类等信息进行搜索</li></ol></li><li>如何保证索引同步？<ul><li>本项目时使用本地任务表 + xxl-job任务调度进行索引同步，具体流程如下<ol><li>添加或修改或删除课程的同时，向任务表插入一条记录，这条记录就记录了是添加还是修改还是删除了哪个课程</li><li>任务调度定时扫描任务表，根据任务表的内容对课程信息进行同步<ul><li>如果添加了课程，将课程添加到索引库</li><li>如果修改了课程，就修改索引库的课程</li><li>如果是删除了课程，将课程信息从索引库删除</li></ul></li></ol></li></ul></li></ul><hr><h4 id="3-4-技术点"><a href="#3-4-技术点" class="headerlink" title="3.4 技术点"></a>3.4 技术点</h4><blockquote><p>异常处理</p></blockquote><ul><li><p><code>@ControllerAdvice</code>与<code>@ExceptionHandler</code>用来捕获异常</p><ul><li><code>@ControllerAdvice</code> 是一个特殊的 <code>@Component</code>（可以通过源码看得到），用于标识一个类，这个类中被以下三种注解标识的方法：<code>@ExceptionHandler</code>，<code>@InitBinder</code>，<code>@ModelAttribute</code>，将作用于所有<code>@Controller</code> 类的接口上。</li></ul></li><li><p><code>@ResponseStatus</code>用来确定响应数据</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/image-20240303152434784.png" alt="image-20240303152434784"></p></li></ul><hr><blockquote><p>传入数据是否为空的方法</p></blockquote><ul><li><p>在controller方法内部手动判断：<code>StringUtils.isNotEmpty</code></p></li><li><p>实体类的数据上标注<code>@NotNull</code>，然后在controller中的形参前面加上<code>@Valid</code>注解，再在全局异常中添加<code>BindException</code>异常类的捕获</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/面试准备.assets/image-20240303153429684.png" alt="image-20240303153429684" style="zoom:50%;" /></p></li></ul><hr><blockquote><p>controller与前端的数据传递</p></blockquote><ul><li>形参不带注解：此时参数名称一定要和请求参数的名称一致<ul><li>get方式提交，直接写参数</li><li>通过<code>HttpServletRequest</code>接收：<code>request.getParameter(&quot;username&quot;)</code></li><li>通过java类对象接收</li></ul></li><li>形参带注解<ul><li><code>@RequestParam</code>：有value、require、defaultValue字段可填充</li><li><code>@PathVariable</code>：支持类似于：<code>user/get/mac/&#123;macAddress&#125;</code>的请求</li><li><code>@ModelAttribute(&quot;user&quot;)</code>:会将客户端传递过来的参数按名称注入到指定对象中，并且会将这个对象自动加入ModelMap中，便于View层使用</li></ul></li></ul><hr><blockquote><p>树形查询</p></blockquote><ul><li><p><code>left join</code>连接表（可以是相同的表）</p></li><li><p>指定<code>resultMap</code>为一个值，然后再在指定的<code>resultMap</code>中设置映射关系并将结果返回。</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/image-20240303160733160.png" alt="image-20240303160733160"></p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/image-20240303160740937.png" alt="image-20240303160740937"></p></li></ul><hr><blockquote><p>视频分块上传</p></blockquote><ul><li><code>RandomAccessFile</code>实现文件的分块和合并</li><li>判断是否一致 ==&gt; <code>DigestUtils.md5Hex()</code></li></ul><hr><blockquote><p>@Transactional</p></blockquote><ul><li><p>自调用的时候需要声明一个代理对象来方便进行事务的管理</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/学成在线.assets/image-20240304110055984.png" alt="image-20240304110055984" style="zoom:67%;" /></p></li><li><p><code>@Transactional</code>即声明式事务管理， 建立在AOP之上的。其本质是对方法前后进行拦截，然后在目标方法开始之前创建或者加入一个事务，在执行完目标方法之后根据执行情况提交或者回滚事务。</p></li></ul><hr><blockquote><p>freemarker</p></blockquote><ul><li>controller中返回<code>ModelAndView</code>对象，在<code>setViewName</code>中设置重定向的页面文件，在<code>addObject</code>中传值</li></ul><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/面试准备.assets/image-20240304142757986.png" alt="image-20240304142757986" style="zoom:80%;" /></p><hr><blockquote><p>xxj-job</p></blockquote><ul><li>工作原理：xxl-job分布式任务调度服务由调度中心和执行器组成，调度中心负责按任务调度策略向执行器下发任务，执行器负责接收任务，执行任务</li><li>获取执行器序号、 执行器总数，然后用表的<code>id % 总数 == 序号</code>来保证一个任务只会被一个执行器执行，用字段标识来保证一个任务只会被执行一次(乐观锁)</li><li>用于视频转码作业</li><li>课程发布操作后，先更新数据库中的课程发布状态，更新后向Redis、ElasticSearch、MinIO写课程信息，只要在一定时间内最终成功写入数据即可<ul><li>这里使用了feign远程调用，在向MinIO写信息的时候调用了Media服务的相关接口<ul><li>熔断降级：返回null对象，然后再去判断是否为null来判断是否发生了故障</li><li>注意启动类开启注解<code>@EnableFeignClients</code></li></ul></li></ul></li><li>如何保证任务幂等性？<ul><li>数据库约束，例如：唯一索引、主键</li><li>乐观锁，长用户数据库，更新数据时根据乐观锁状态去更新</li><li>唯一序列号，操作传递一个唯一序列号，操作时判断与该序列号相等，则执行</li><li>在这里我们在数据库视频处理表中添加状态处理字段，视频处理完成更新状态为完成，执行视频前判断状态是否完成，如果完成则不再处理</li></ul></li></ul><hr><blockquote><p>ES</p></blockquote><ul><li>如何解决索引同步的问题？<ul><li>xxl-job 详见模块点中搜索模块</li></ul></li></ul><hr><blockquote><p>Spring Security</p></blockquote><ul><li><p>继承<code>UserDetailsService</code>接口，重写<code>loadUserByUsername()</code>方法</p><ul><li><p>返回<code>UserDetails</code>对象</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/image-20240305102255518.png" alt="image-20240305102255518"></p></li></ul></li><li><p><code>DaoAuthenticationProviderCustom extends DaoAuthenticationProvider</code></p><ul><li>刚刚我们重写的<code>loadUserByUsername()</code>方法是由<code>DaoAuthenticationProvider</code>调用的</li><li>重写<code>additionalAuthenticationChecks()</code>里面会比对密码，但不是所有的登录方式都有密码</li><li>然后在<code>WebSecurityConfig extends WebSecurityConfigurerAdapter</code>中配置刚刚定义的 <code>DaoAuthenticationProvider</code></li></ul></li></ul><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/image-20240318202120889.png" alt=""></p><ul><li><p>OAuth2.0</p><ul><li>客户端请求资源拥有者授权</li><li>资源拥有者授权客户端，即用户授权目标网站访问自己的用户信息</li><li>目标网站携带授权码请求认证</li><li>认证通过，颁发令牌</li><li>目标网站携带令牌请求资源服务器，获取资源</li><li>资源服务器校验令牌通过后，提供受保护的资源</li></ul></li><li><p>JWT：</p><ul><li>好处：在认证服务颁发令牌给客户端后，客户端携带令牌请求其他服务的资源时，其他服务可以直接校验令牌合法性，无需再经过认证服务。</li><li>缺点：JWT令牌占用空间较大</li><li>无状态认证：用户身份信息存储在令牌中，服务端从JWT解析出用户信息</li><li>有状态认证：用户信息通过session存储在服务端</li><li>组成<ul><li>头部Header：令牌类型及使用的哈希算法</li><li>负载Payload：用户信息</li><li>签名Sugbature：根据密钥进行加密前两部分，防止篡改</li></ul></li></ul></li><li><p><code>SecurityContextHolder</code>获取当前访问的用户信息：<code>Authentication</code>对象</p><ul><li>原理：<code>ThreadLocal</code></li></ul></li><li><p>用户授权</p><ul><li>授权认证服务器<code>@EnableAuthorizationServer</code> ==&gt; 配置资源列表：<code>xuecheng-plus</code></li><li>资源服务器<code>@EnableResourceServer</code> ==&gt; 定义资源id：<code>xuecheng-plus</code></li><li>接口添加<code>@PreAuthorize(&quot;hasAuthority(&#39;权限标识符&#39;)&quot;)</code>即可</li><li>授权定义在<code>loadUserByUsername</code>方法中返回的<code>UserDetails</code>中，是一个<code>String</code>类型的数组</li><li>没有权限抛出<code>AccessDeniedException</code>在全局异常处理器中捕获即可</li></ul></li></ul><hr><blockquote><p>验证码</p></blockquote><ul><li><code>Kaptcha</code></li></ul><hr><blockquote><p>RabbitMQ</p></blockquote><ul><li><h3 id="4-仿真项目"><a href="#4-仿真项目" class="headerlink" title="4 仿真项目"></a>4 仿真项目</h3></li></ul><h2 id="三-笔试"><a href="#三-笔试" class="headerlink" title="三 笔试"></a>三 笔试</h2><h3 id="3-13-携程"><a href="#3-13-携程" class="headerlink" title="3.13 携程"></a>3.13 携程</h3><ul><li>long </li></ul><h3 id="3-16-蚂蚁"><a href="#3-16-蚂蚁" class="headerlink" title="3.16 蚂蚁"></a>3.16 蚂蚁</h3><blockquote><p>数组每次可以变化ij下标的值（+2 和 -2），如果可以在有限次数让所有值的最大公因数为素数，则输出所有的可能</p></blockquote><ul><li>sum不变，分奇偶</li><li>讨论 [3, sum/n]区间内的所有素数</li><li>如果全是偶数(even个)，则只能是2</li><li>如果有奇数(odd个)<ul><li>记最大素数为i</li><li>先分配偶数，则一共分配 <code>2 * i * even</code></li><li>判断剩下 <code>sum - 2 * i * even</code> 能否恰好分配给odd个奇数  ==&gt; <code>(sum-2*i*even) % i == 0 &amp;&amp; (sum-2*i*even) / i &gt;= odd</code></li></ul></li></ul><h3 id="3-16-美团"><a href="#3-16-美团" class="headerlink" title="3.16 美团"></a>3.16 美团</h3><blockquote><p>小美拿到了一个数组，她每次操作会将除了第x个元素的其余元素翻倍，一共操作了q次。请你帮小美计算操作结束后所有元素之和。 由于答案过大，请对10^9+7取模。16%</p></blockquote><ul><li><p>快速幂法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="type">long</span> <span class="title function_">qpow</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> mod)</span> &#123;</span><br><span class="line">    <span class="comment">// 求a翻倍b次，结果取模mod</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">1</span>, t = a;</span><br><span class="line">    <span class="keyword">while</span> (b &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((b &amp; <span class="number">1</span>) == <span class="number">1</span>) &#123; <span class="comment">// 只计算末尾是1的指数，因为任何数的0次方=1，就没必要乘了</span></span><br><span class="line">        res = (res * t) % mod;</span><br><span class="line">        &#125;</span><br><span class="line">        b &gt;&gt;= <span class="number">1</span>;<span class="comment">// 指数位右移动：1011(2) -&gt; 101(2)</span></span><br><span class="line">        t = (t * t) % mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>调用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">res = (res + qpow(<span class="number">2</span>, s[i + <span class="number">1</span>], mod) * a[i] % mod) % mod;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>eg:比如求3^45</p><ul><li>指数位置 45(10) = 101101(2)</li><li>也就只要求 2^5 2^3 2^2 2^0这几个幂指数</li></ul></li></ul><hr><blockquote><p>小美拿到了一个数组只包含1和2，她希里你求出所有区间众数之和 70%</p></blockquote><ul><li><p><strong>树状数组/二叉索引树(Binary Indexed Tree)</strong>解决的问题：对于每个index，左边有多少数字小于等于它，有多少数字大于等于它</p><ul><li><p>O(logn)得到任意前缀和</p></li><li><p>由数组arr构建二叉索引数bit规则：</p><ul><li><p>bit[x] = arr[x]，当x为奇数</p></li><li><p>bit[x] = a[0] + a[1] + … + a[x]，当x为偶数且x为2的幂</p></li><li><p>bit[x] = a[x-2^k+1]+ … + a[x]，当x为偶数且不为2的幂，其中k = lowbit(x)</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/image-20240318135832990.png" alt="image-20240318135832990" style="zoom:50%;" /></p></li></ul></li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">from https://codefun2000.com/p/P1704 实战最重要 加了点注释</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> n;</span><br><span class="line">    <span class="comment">// 有效部分[n+1, :] tr[i]表示前缀和为i的出现次数</span></span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span>[] tr;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 返回一个整数在二进制表示中最低位的1及其后面的0构成的数 10(10) &lt;==&gt; 1010(2) -&gt; 10(2) &lt;==&gt; 2</span></span><br><span class="line">    <span class="comment">// 可以用这个方法获取一个数对应的所有二进制位为1对应的十进制数(递归) </span></span><br><span class="line">    <span class="comment">// 比如：lowbit(11)=1 然后 11-1=10；再lowbit(10)=2,然后10-2 = 8； 再lowbit(8)=8, 8-8 -= 0；结束</span></span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">lowbit</span><span class="params">(<span class="type">int</span> x)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x &amp; -x;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 在树状数组bit中的指定索引idx处增加1。这个操作相当于更新前缀和。</span></span><br><span class="line">    <span class="comment">// 比如：add(12)</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> idx)</span>&#123;</span><br><span class="line">        idx += n + <span class="number">1</span>; <span class="comment">// 这里的索引idx可能为负数(如果是2的情况是--1的)，然后是从bit[1]开始算的 所以 += n+1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span>idx;i&lt;tr.length;i += lowbit(i))&#123;</span><br><span class="line">            tr[i] += <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    <span class="comment">// 计算前缀和</span></span><br><span class="line">    <span class="comment">// 比如：pre(12) = Bit(12) + Bit(8) = a[12]+..+a[9] + a[8]+...a[1]</span></span><br><span class="line">    <span class="comment">// pre(13) = Bit[13] + Bit[12] + Bit[8]</span></span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">pre</span><span class="params">(<span class="type">int</span> idx)</span>&#123;</span><br><span class="line">        idx += n + <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> idx;i &gt; <span class="number">0</span>;i-=lowbit(i))&#123;</span><br><span class="line">            sum += tr[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        n = sc.nextInt();</span><br><span class="line">        <span class="type">int</span>[] A = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">2</span> * n + <span class="number">100</span>];</span><br><span class="line">        tr = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">2</span> * n + <span class="number">10</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n;i++) &#123;</span><br><span class="line">            A[i] = sc.nextInt();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">presum</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// A[0, index] 当前位置之前（包括当前位置）的前缀和。其中1对应-1 2对应1</span></span><br><span class="line">        add(presum);</span><br><span class="line">        <span class="type">long</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(A[i] == <span class="number">1</span>) &#123;</span><br><span class="line">                presum += <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                presum -= <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">           </span><br><span class="line">            <span class="comment">// pre(presum)：在当前位置之前，有多少个区间的众数是1</span></span><br><span class="line">            <span class="comment">// i - pre(presum)：在当前位置之前，有多少个区间的众数是2</span></span><br><span class="line">            ans += (<span class="type">long</span>) pre(presum) + <span class="number">2L</span> *(i - pre(presum));</span><br><span class="line">            add(presum);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(ans);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="3-29-小红书"><a href="#3-29-小红书" class="headerlink" title="3.29 小红书"></a>3.29 小红书</h3><ul><li><p>一个数组，一个目标值，每个元素至多用一次，并且可以变成自己的一半（向下取整），当取出的元素之和为目标值时，计算最小的元素个数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入： arr：1 2 3 4 11 target：8</span><br><span class="line">输出： 2</span><br><span class="line">解释：取3和11，其中11向下除以2取整变成5 则3+5=8</span><br></pre></td></tr></table></figure><ul><li>写了一个动态规划复杂度过高</li></ul></li></ul><h3 id="4-3-淘天"><a href="#4-3-淘天" class="headerlink" title="4.3 淘天"></a>4.3 淘天</h3><ul><li><p>给定一个长度为<code>n</code>的数组<code>arr</code>, 定义一个函数<code>f(l,r,x)</code>表示区间<code>[l,r]</code>内<code>x</code>出现的次数，现在给出数组<code>arr</code>,求所有的数对<code>(i,j)</code>满足<code>f(0,i,arr[i]) &gt; f(j, n-1, arr[j])</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">findPairs</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> arr.length;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 前缀map数组和后缀map数组</span></span><br><span class="line">    <span class="comment">// prefixCounts[i]存储了[0, i]所有元素出现的次数</span></span><br><span class="line">    <span class="comment">// suffixCounts[j]存储了[j, n]所有元素出现的次数</span></span><br><span class="line">    Map&lt;Integer, Integer&gt;[] prefixCounts = <span class="keyword">new</span> <span class="title class_">HashMap</span>[n];</span><br><span class="line">    Map&lt;Integer, Integer&gt;[] suffixCounts = <span class="keyword">new</span> <span class="title class_">HashMap</span>[n];</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 初始化map数组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        prefixCounts[i] = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        suffixCounts[i] = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 填充前缀map数组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 复制前一个map到当前map</span></span><br><span class="line">            prefixCounts[i].putAll(prefixCounts[i - <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        prefixCounts[i].put(arr[i], prefixCounts[i].getOrDefault(arr[i], <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 填充后缀map数组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i != n - <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// 复制后一个map到当前map</span></span><br><span class="line">            suffixCounts[i].putAll(suffixCounts[i + <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        suffixCounts[i].put(arr[i], suffixCounts[i].getOrDefault(arr[i], <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 遍历数组，寻找符合条件的数对(i, j)</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">prefixCount</span> <span class="operator">=</span> prefixCounts[i].getOrDefault(arr[i], <span class="number">0</span>);</span><br><span class="line">            <span class="type">int</span> <span class="variable">suffixCount</span> <span class="operator">=</span> suffixCounts[j].getOrDefault(arr[j], <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span> (prefixCount &gt; suffixCount) &#123;</span><br><span class="line">                <span class="comment">// 输出符合条件的数对(i, j)</span></span><br><span class="line">                System.out.println(<span class="string">&quot;(&quot;</span> + i + <span class="string">&quot;, &quot;</span> + j + <span class="string">&quot;)&quot;</span>);</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    System.out.println(<span class="string">&quot;Total pairs: &quot;</span> + count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="4-16-钉钉"><a href="#4-16-钉钉" class="headerlink" title="4.16 钉钉"></a>4.16 钉钉</h3><ul><li><p>输入一个十进制数x，数字n以及进制k，求反转后的数。反转的定义：x转为k进制后变为x’,将x’上的所有位上的数p变为k-p</p><ul><li>例：n=4,x=6,k=2 ，则k’=0110(需要保留高位的0) ,反转后k’’ = 2002 ,对应十进制为：18</li><li>思路：将所有位变为k比如n=4，k=2，就变为2222，对应的就是一个等比数列2 4 8 16的和，求这个和记为a，则结果就是a-x（过程中注意取模）</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CorrectKBaseToDecimal</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">MOD</span> <span class="operator">=</span> <span class="number">1_000_000_007L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 快速幂计算 (a^b) % mod，计算 a 的 b 次方对 mod 取模的结果。</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">long</span> <span class="title function_">powMod</span><span class="params">(<span class="type">long</span> a, <span class="type">long</span> b)</span> &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        a %= MOD;  <span class="comment">// 确保 a 在 MOD 下</span></span><br><span class="line">        <span class="keyword">while</span> (b &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((b &amp; <span class="number">1</span>) == <span class="number">1</span>) &#123;</span><br><span class="line">                result = (result * a) % MOD;</span><br><span class="line">            &#125;</span><br><span class="line">            a = (a * a) % MOD;</span><br><span class="line">            b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算所有位都是k的k进制数并减去x，然后取MOD</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">long</span> <span class="title function_">compute</span><span class="params">(<span class="type">long</span> n, <span class="type">long</span> k, <span class="type">long</span> x)</span> &#123;</span><br><span class="line">        <span class="comment">// 使用等比数列求和公式计算所有位都是k的k进制数的十进制表示</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">sum</span> <span class="operator">=</span> k * ((powMod(k, n) - <span class="number">1</span> + MOD) % MOD) % MOD;</span><br><span class="line">        <span class="comment">// 计算 (k-1) 的逆元</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">inverse</span> <span class="operator">=</span> powMod(k - <span class="number">1</span>, MOD - <span class="number">2</span>);</span><br><span class="line">        <span class="comment">// 计算公式结果</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">result</span> <span class="operator">=</span> (sum * inverse % MOD - x + MOD) % MOD;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 示例输入</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">3</span>, k = <span class="number">2</span>;</span><br><span class="line">        <span class="type">long</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">14</span>;</span><br><span class="line">        <span class="comment">// 计算并输出结果</span></span><br><span class="line">        System.out.println(compute(n, k, x));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="4-18-阿里云"><a href="#4-18-阿里云" class="headerlink" title="4.18 阿里云"></a>4.18 阿里云</h3><ul><li><p>给定一个字符串str，求他所有连续子串的权值之和，其中一个字符串权值的定义为：该字符串包含“a”, “li”，“yun”的数量，比如”ali”权值为2，”syuns”权值为1</p><ul><li>“aliyun”权值为18</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getTotalWeight</span><span class="params">(String str)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">re</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> str.length();</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span>[] chs = str.toCharArray();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(chs[i] == <span class="string">&#x27;a&#x27;</span>) &#123;</span><br><span class="line">        </span><br><span class="line">            <span class="comment">// 计算包含当前字符的所有子串数量</span></span><br><span class="line">            re += n;</span><br><span class="line"></span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(i &gt;= <span class="number">1</span> &amp;&amp; chs[i-<span class="number">1</span>] == <span class="string">&#x27;l&#x27;</span> &amp;&amp; chs[i] == <span class="string">&#x27;i&#x27;</span>) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//这个 li 字符串前面有 i-1 个字符 后面有 n-i-1 个字符</span></span><br><span class="line">            <span class="comment">// xxxlixxxx 那么含有li的子串数量为 3*4 + 3 + 4 + 1（这个1的意思是只包含li）</span></span><br><span class="line">            re += (i-<span class="number">1</span>) * (n-i-<span class="number">1</span>) + i-<span class="number">1</span> + n-i-<span class="number">1</span> + <span class="number">1</span>; </span><br><span class="line"></span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(i &gt;= <span class="number">2</span> &amp;&amp; chs[i-<span class="number">2</span>] == <span class="string">&#x27;y&#x27;</span> &amp;&amp; chs[i-<span class="number">1</span>] == <span class="string">&#x27;u&#x27;</span> &amp;&amp; chs[i] == <span class="string">&#x27;n&#x27;</span>) &#123;</span><br><span class="line">        </span><br><span class="line">            <span class="comment">// yun 前面有 i-2 后面有 n-i-1</span></span><br><span class="line">            re += (i-<span class="number">2</span>) * (n-i-<span class="number">1</span>) + i-<span class="number">2</span> + n-i-<span class="number">1</span> + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> re;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="4-26-小红书2"><a href="#4-26-小红书2" class="headerlink" title="4.26 小红书2"></a>4.26 小红书2</h3><ul><li><p>从<code>n</code>个粉丝中选<code>k</code>个最狂热的粉丝，给<code>n</code>行输入，每行有2列，第一列是粉丝<code>i</code>点赞数，第二列是粉丝<code>i</code>的收藏数。定义狂热度：点赞数是1分，收藏数是2分。如果两个粉丝狂热度一样就比较收藏数，如果收藏数也一样序号小的狂热度高</p><ul><li><p>优先级队列：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">solve</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> in.nextInt();</span><br><span class="line">    <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> in.nextInt();</span><br><span class="line">    <span class="type">int</span>[][] a = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>][<span class="number">3</span>];</span><br><span class="line">    </span><br><span class="line">    PriorityQueue&lt;<span class="type">int</span>[]&gt; pq = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;<span class="type">int</span>[]&gt;(<span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;<span class="type">int</span>[]&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(<span class="type">int</span>[] o1, <span class="type">int</span>[] o2)</span> &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">score1</span> <span class="operator">=</span> o1[<span class="number">1</span>] + o1[<span class="number">2</span>] * <span class="number">2</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">score2</span> <span class="operator">=</span> o2[<span class="number">1</span>] + o2[<span class="number">2</span>] * <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (score1 != score2) &#123;</span><br><span class="line">                <span class="keyword">return</span> score2 - score1;</span><br><span class="line">                </span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (o1[<span class="number">2</span>] != o2[<span class="number">2</span>]) &#123;</span><br><span class="line">                <span class="keyword">return</span> o2[<span class="number">2</span>] - o1[<span class="number">2</span>];</span><br><span class="line">                </span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> o1[<span class="number">0</span>] - o2[<span class="number">0</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        a[i][<span class="number">0</span>] = i;</span><br><span class="line">        a[i][<span class="number">1</span>] = in.nextInt();</span><br><span class="line">        a[i][<span class="number">2</span>] = in.nextInt();</span><br><span class="line">        pq.offer(a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span>[] ans = <span class="keyword">new</span> <span class="title class_">int</span>[k];</span><br><span class="line">    <span class="keyword">while</span> (k-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="type">int</span>[] p = pq.poll();</span><br><span class="line">        ans[k] = p[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    Arrays.sort(ans);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> id : ans) &#123;</span><br><span class="line">        out.print(Integer.toString(id) + <span class="string">&#x27; &#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>给一个数组<code>arr</code>以及一个目标数<code>x</code>，每个粉丝群可转移 <code>a[i]/2</code> 个粉丝，也可以选一个粉丝群转移 <code>a[i]</code> 个粉丝，求获得目标粉丝数所需的最少粉丝群数量。</p><ul><li><p>背包问题：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">solve</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> in.nextInt();</span><br><span class="line">    <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> in.nextInt();</span><br><span class="line">    <span class="type">int</span>[] a = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        a[i] = in.nextInt();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> func(a, -<span class="number">1</span>, x);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        ans = Math.min(ans, func(a, i, x) + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    out.println(ans == <span class="number">0x3f3f3f3f</span> ? -<span class="number">1</span> : ans);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="type">int</span> <span class="title function_">func</span><span class="params">(<span class="type">int</span>[] a, <span class="type">int</span> idx, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (idx != -<span class="number">1</span>) target -= a[idx];</span><br><span class="line">    <span class="keyword">if</span> (target &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0x3f3f3f3f</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> a.length;</span><br><span class="line">    <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[target + <span class="number">1</span>];</span><br><span class="line">    Arrays.fill(dp, <span class="number">0x3f3f3f3f</span>);</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i == idx + <span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">val</span> <span class="operator">=</span> a[i - <span class="number">1</span>] / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> target; j &gt;= val; j--) &#123;</span><br><span class="line">            dp[j] = Math.min(dp[j], dp[j - val] + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[target];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h2 id="四-面试"><a href="#四-面试" class="headerlink" title="四 面试"></a>四 面试</h2><h3 id="4-1-携程一面-3-20"><a href="#4-1-携程一面-3-20" class="headerlink" title="4.1 携程一面 3.20"></a>4.1 携程一面 3.20</h3><ul><li><p>自我介绍10min 有点多嗯</p></li><li><p>苍穹中担任什么职务，比较棘手的点？做学习用的，设计数据表，对相关业务的开发；用户高并发的情况</p></li><li><p>那多用户抢单的高并发过程怎么考虑？时间戳记录版本信息</p><ul><li>高并发：同一时刻有大量请求访问系统；大量请求并行访问系统。</li><li>提升机器的性能。</li><li>使用redis缓存数据，记录binlog日志信息，存入消息队列中，实现缓存的最终一致性。</li></ul></li><li><p>怎么理解任务幂等性？怎么实现？ 一个任务只会被执行一次；任务消息表</p><ul><li>一次和多次请求某一个资源对于资源本身应该具有同样的结果，任意多次执行对资源本身所产生的影响均与一次执行的影响相同</li><li>使用唯一索引防止新增脏数据</li><li>乐观锁：通过版本号来记录</li><li>分布式锁：redis，先获取锁再操作表再释放锁</li></ul></li><li><p>怎么理解AOP？定义+jdk/cglib 原理及区别</p></li><li><p>AOP的几个概念？切面+连接点+切入点+通知</p></li><li><p>AOP用什么捕获异常？@AfterThrowing</p></li><li><p>redis线程？之前是单线程，之后是多线程。提到了线程不是瓶颈及IO多路复用</p></li><li><p><strong>redis跳表？</strong>g</p></li><li><p><strong>setEx setNx，如何设置key过期时间？</strong>g</p><ul><li><code>set key value</code> ：将字符串值 value 关联到 key </li><li><p><code>setNX key value</code>： 将 key 的值设为 value ，当且仅当 key 不存在。</p><ul><li>setnx = SET if Not eXists</li></ul></li><li><p><code>setEX key seconds value</code>：将值 value 关联到 key ，并将 key 的生存时间设为 seconds (以秒为单位)。</p><ul><li>setex = set expire</li></ul></li></ul></li><li><p>基本数据类型和包装类型区别？在JVM存储区域</p></li><li><p>为什么静态方法不能调用非静态变量？</p><ul><li>在一个类的静态成员中去访问非静态成员之所以会出错是因为在类的非静态成员不存在的时候静态成员就已经存在了，访问一个内存中不存在的东西当然会出错。</li></ul></li><li><p>java三大特性？继承封装多态</p></li><li><p>HashMap底层原理？数组+链表/红黑树，然后讲了元素的插入过程，数组长度64 链表长度8</p></li><li><p><strong>乐观锁和悲观锁？</strong>g</p><ul><li>悲观锁假设冲突会发生，在访问共享资源之前先锁定资源，确保数据的一致性。悲观锁的特点是在访问共享资源之前会先锁定资源，确保其他线程无法修改该资源，直到当前线程完成操作。常见互斥锁和读写锁</li><li>乐观锁假设冲突较少，允许多个线程同时读取和操作共享资源，只在更新时进行冲突检查和处理。当要更新共享资源时，乐观锁会检查在操作期间是否有其他线程修改了该资源。如果没有冲突发生，操作继续进行；如果发现冲突，乐观锁会回滚操作并重新尝试。用版本号和时间戳来记录。</li></ul></li><li><p><strong>线程池常用参数</strong>？提高了最大连接数和线程数量</p><ul><li>核心线程数：corePoolSize</li><li>最大连接数：maximumPoolSize</li><li>空闲线程存货时间：keepAliveTime</li><li>时间单位：unit</li><li>工作队列：workQueue：存放待执行任务的队列</li><li>线程工厂：threadFactory</li><li>拒绝策略：handler</li></ul></li><li><p><strong>线程池策略？</strong>g</p><ul><li><code>AbortPolicy</code>：丢弃任务并抛出RejectedExecutionException异常。</li><li><code>DiscardPolicy</code>：丢弃任务，但是不抛出异常。可能导致无法发现系统的异常状态。</li><li><code>DiscardOldestPolicy</code>：丢弃队列最前面的任务，然后重新提交被拒绝的任务。</li><li><code>CallerRunsPolicy</code>：由调用线程处理该任务。</li></ul></li><li><p>JVM内存区域？java堆，方法区+java栈，本地方法栈，线程计数器</p></li><li><p><strong>mysql索引类型？</strong>g</p><ul><li>主键索引</li><li>普通索引</li><li>唯一索引</li><li>全文索引</li><li>前缀索引</li><li>组合索引</li><li>空间索引</li></ul></li><li><p><strong>序数索引和非序数索引？</strong>g</p><ul><li><p>聚簇索引和非聚簇索引？</p><ul><li>聚簇索引（聚集索引）：索引结构和数据一起存放的索引，InnoDB的主键索引就是</li><li>非聚簇索引（非聚集索引）：不存在一起的索引</li></ul><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/image-20240320172122032.png" alt="image-20240320172122032" style="zoom:50%;" /></p></li></ul></li></ul><h3 id="4-2-美团一面-3-22-外卖平台"><a href="#4-2-美团一面-3-22-外卖平台" class="headerlink" title="4.2 美团一面 3.22 外卖平台"></a>4.2 美团一面 3.22 外卖平台</h3><ul><li>自我介绍3min 然后</li><li>问了项目什么时候做的，有无团队一起做</li><li>问了一下FS立库的算法还有引擎的优化 15min 讲的不太清除</li><li>苍穹的表结构 菜品表和套餐表</li><li>两个表的关系 多对多 </li><li>怎么管理套餐的 增删改查</li><li>怎么做套餐的修改的，提供了哪些修改</li><li>库存怎么存储的 redis+mysql</li><li>redis还存了什么 购物车和菜品</li><li>redis和mysql一致性？ 先修改mysql再删除redis</li><li>为什么这样做？高并发带来的数据不一致</li><li>为什么不先更新redis后更新mysql？举了一个例子</li><li>redis是什么时候更新？查询的时候更新</li><li>数据修改频繁呢？异步缓存，以redis缓存为主，先修改redis，由后台修改mysql</li><li><p>为什么用redis？内存 + IO多路复用</p></li><li><p>IO多路复用？ 单线程处理多个并发，提到了同步IO 异步IO（应该是阻塞IO和非阻塞IO）</p></li><li>mysql B+树的优点？对比了hash表、二叉搜索树、平衡树、红黑表、B树</li><li>AOP底层原理？JDK cglib，原理，生成字节码，执行效率的对比</li><li><p><strong>java多态解决了什么问题？</strong></p><ul><li>简化对应用软件的代码编写和修改过程</li></ul></li><li><p>进程和线程的区别？进程是操作系统的最小单位由多个线程组成，线程可以上下文切换</p></li><li><p>线程调度过程，上下文切换</p><ul><li>线程上下文切换是指操作系统为了能够让多个线程并发执行，在运行一个线程前，需要保存当前线程的 CPU 寄存器、程序计数器、栈指针和其他硬件上下文信息，以便于在恢复该线程时还原到之前的状态。而将这些信息保存起来、加载其他线程运行所需的上下文信息，然后再切换到该线程继续执行的过程就被称为线程上下文切换</li></ul></li><li><p>MQ解决了什么问题？业务解耦，服务的通讯</p><ul><li>业务解耦</li><li><strong>流量削峰</strong></li></ul></li><li><strong>TCP为什么是可靠的</strong>？三挥四握，传输过程中，全双工<ul><li>数据传输之前会有三次握手来进行连接</li><li>在数据传输时候，有确认、滑动窗口、超时重传、拥塞控制之类机制</li><li>数据传输之后会进行四次挥手断开连接来节约系统资源。</li></ul></li><li>算法：二叉树最长路径和 20min</li></ul><h3 id="4-3-饿了么一面-3-25"><a href="#4-3-饿了么一面-3-25" class="headerlink" title="4.3 饿了么一面 3.25"></a>4.3 饿了么一面 3.25</h3><ul><li><p>一直问fs，然后问了毕业情况，能不能出来</p></li><li><p>fs中的设计模式？</p><ul><li>单例设计模式。图标</li><li>代理模式。堆垛机</li></ul></li></ul><h3 id="4-4-美团二面-3-26"><a href="#4-4-美团二面-3-26" class="headerlink" title="4.4 美团二面 3.26"></a>4.4 美团二面 3.26</h3><ul><li>介绍自己 5min</li><li>主要在第一个项目<ul><li>是怎么做优化的，有什么对比，用什么方式评估达到了要求</li><li>开发团队是怎么配合的</li><li>你们的软件的主要用途</li><li>这个过程中挑战比较大的地方  代码上手+立库</li><li>这个过程中收获了什么 了解了java，开发的规范性</li><li>是怎么沟通的</li></ul></li><li>你是怎么看java后端开发的</li><li>为什么选择做外卖项目 学习，和生活贴近</li><li>后端都是自己搭的吗？中间有什么问题？ 版本的改动，自己的解决办法</li><li>redis怎么用的？购物车，菜品数据</li><li>并发量不这么大为什么要用redis？学习</li><li>redis为什么这么快？内存IO+IO多路复用</li><li>讲一下IO多路复用。 讲了同步阻塞模型、同步非阻塞模型、IO多路复用（文件描述符）</li><li>有什么想问的<ul><li>做的商家事业部：商家线上注册、外卖、帮助线上商家能卖更多的东西</li><li>关于结果：一周内</li></ul></li><li>闲聊时间 10min<ul><li>对面试的过程有什么感想</li><li>有什么职业规划</li><li>怎么看java后端的</li><li>什么时候可以实习，实习时间段，准备在北京发展吗</li><li>怎么看互联网这个行业</li><li>怎么看很多人去选择进入体制内</li><li>为什么还在机械学院读研不去计算机学院</li></ul></li></ul><h3 id="4-5-腾讯一面-3-27"><a href="#4-5-腾讯一面-3-27" class="headerlink" title="4.5 腾讯一面 3.27"></a>4.5 腾讯一面 3.27</h3><ul><li><p>如何解决多个恶意请求（黑名单多到缓存放不下）</p><ul><li><p>用布隆过滤器，缺点是有可能会造成白名单误被认为是黑名单的情况</p></li><li><p>如何优化：可以加大哈希函数的数量</p></li></ul></li><li><p>输入一个url到完成请求的过程</p></li><li><p>在使用DNS解析的过程，使用了什么连接</p><ul><li>本地查询、递归查询、最后向下返回ip地址</li><li>UDP（一开始说的TCP，但是又说TCP比较慢，应该用的UDP）</li></ul></li><li><p>TCP和UDP区别</p><ul><li>面向连接</li><li>可靠</li><li>数据量</li><li>头部开销</li></ul></li></ul><ul><li>TCP如何确保传输的稳定的<ul><li>对数据包有一个排序校验</li><li>重传机制</li><li>滑动窗口的流量控制：保证发送方不会发过多数据导致接收方处理不过来或者缓冲区溢出</li><li>拥塞控制：保证网络中的传输速率不超过网络容量</li></ul></li><li><p>TCP三次握手时，在收到客户端的SYN包后一定会返回ACK吗？如果服务端建立了过多的连接可能不返回（不确定）</p><ul><li>防火墙导致入站连接被过滤了</li><li>网络出现拥塞或者故障</li><li>为了防止TCP SYN 攻击，某些服务器可能会配置特殊的防护机制，例如 SYN 队列限制或 SYN cookie，这可能会导致服务端不返回 SYN+ACK 包。</li><li>如果服务端的资源（如内存、CPU）不足，可能会导致服务端无法处理新的连接请求，从而不返回 SYN+ACK 包。</li></ul></li><li><p>mysql慢查询是怎么发现的，用什么命令</p><ul><li><p>启用慢查询日志，在配置文件中</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">slow_query_log = 1 -- 启动</span><br><span class="line">slow_query_log_file = /path/to/slow-query.log -- 指定慢查询日志文件的路径和名称。</span><br><span class="line">long_query_time = 1 -- 定义执行时间超过多少秒的查询被认为是慢查询</span><br></pre></td></tr></table></figure></li><li><p>重启</p></li><li><p>查看日志</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> /path/to/slow-query.log</span><br></pre></td></tr></table></figure></li></ul></li></ul><ul><li><p>那是如何优化一个sql的</p><ul><li>优化sql语句<ul><li>尽量避免<code>SELECT *</code></li><li>尽量减少<code>JOIN</code>，考虑使用子查询或者临时表</li><li>避免在<code>WHERE</code>子句中使用函数，因为这可能会导致索引失效。<ul><li><code>where</code>中使用了函数</li><li><code>where</code>中发生了类型的转换</li><li><code>where</code>中使用了模糊查询</li><li><code>where</code>中使用了非索引列</li></ul></li></ul></li><li>索引</li><li>优化表的设计：分表分库</li></ul></li><li><p>在采用水平分表的时候，如果是用数据id取模确定数据库的情况下，假如出现了某个数据库的突然宕机该怎么办</p><ul><li>方案一：修改id取模值，但是这种方式代价相对大，因为他需要将所有的数据进行重新的备份</li><li>方案二：对于新插入的数据，当其取模后得到的值对应的是宕机的数据库后，将其id增加一位，保证数据插入到正常数据库中。优点是对于原有的数据可以不用修改</li></ul></li><li><p>linux中如何查看某个端口的使用情况</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">netstat -tuln | grep &lt;端口号&gt;  <span class="comment"># t表示tcp u表示udp l表示仅显示监听状态 n表示直接显示IP地址和端口号而不进行反向解析(根据IP查域名)</span></span><br><span class="line">ss -tuln | grep &lt;端口号&gt;</span><br><span class="line">lsof -i :&lt;端口号&gt;</span><br></pre></td></tr></table></figure></li><li><p>了解kafka吗 没用过</p></li><li><p>手撕：一个字符串数组，然后一个字符串，问匹配的最长字符串是什么</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">数组：ABC abs ASs ABCD</span><br><span class="line">字符串：ABCssadoasosahfeiowhoawjsdohABCDasfdhw</span><br><span class="line">输出：ABCD</span><br></pre></td></tr></table></figure><ul><li>想了一个暴力，面试官说优化一下，没想出来，然后提示说字典树会不会，不会</li></ul><p>字典树，本质就是维护一个路径</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">class TrieNode &#123;</span><br><span class="line">    TrieNode[] children;</span><br><span class="line">    boolean isEnd;</span><br><span class="line"></span><br><span class="line">    public TrieNode() &#123;</span><br><span class="line">        children = new TrieNode[52]; // 考虑大小写字母，总共52个字符</span><br><span class="line">        isEnd = false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class LongestSubstringMatching &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        String[] arr = &#123;&quot;AB&quot;, &quot;ABC&quot;, &quot;ABCD&quot;, &quot;asbasd&quot;, &quot;asfa&quot;&#125;;</span><br><span class="line">        String str = &quot;asfhsadfhiABasdoiahABCDasdhooABC&quot;;</span><br><span class="line"></span><br><span class="line">        String longestMatchingSubstring = findLongestMatchingSubstring(arr, str);</span><br><span class="line">        System.out.println(&quot;Longest matching substring: &quot; + longestMatchingSubstring);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static String findLongestMatchingSubstring(String[] arr, String str) &#123;</span><br><span class="line">        TrieNode root = new TrieNode();</span><br><span class="line">        String longestMatchingSubstring = &quot;&quot;;</span><br><span class="line"></span><br><span class="line">        // 构建字典树</span><br><span class="line">        for (String s : arr) &#123;</span><br><span class="line">            insert(root, s);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        int n = str.length();</span><br><span class="line">        for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">            TrieNode node = root;</span><br><span class="line">            for (int j = i; j &lt; n; j++) &#123;</span><br><span class="line">                char c = str.charAt(j);</span><br><span class="line">                int index = getIndex(c);</span><br><span class="line">                if (node.children[index] == null) &#123;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">                node = node.children[index];</span><br><span class="line">                if (node.isEnd &amp;&amp; j - i + 1 &gt; longestMatchingSubstring.length()) &#123;</span><br><span class="line">                    longestMatchingSubstring = str.substring(i, j + 1);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return longestMatchingSubstring;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static void insert(TrieNode root, String word) &#123;</span><br><span class="line">        TrieNode node = root;</span><br><span class="line">        for (char c : word.toCharArray()) &#123;</span><br><span class="line">            int index = getIndex(c);</span><br><span class="line">            if (node.children[index] == null) &#123;</span><br><span class="line">                node.children[index] = new TrieNode();</span><br><span class="line">            &#125;</span><br><span class="line">            node = node.children[index];</span><br><span class="line">        &#125;</span><br><span class="line">        node.isEnd = true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static int getIndex(char c) &#123;</span><br><span class="line">        if (c &gt;= &#x27;a&#x27; &amp;&amp; c &lt;= &#x27;z&#x27;) &#123;</span><br><span class="line">            return c - &#x27;a&#x27;;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return c - &#x27;A&#x27; + 26;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>又给了一次机会，手写一个LRU数据结构，轻松拿下</p></li></ul><h3 id="4-6-腾讯二面-3-29"><a href="#4-6-腾讯二面-3-29" class="headerlink" title="4.6 腾讯二面 3.29"></a>4.6 腾讯二面 3.29</h3><ul><li>自我介绍3min</li><li>你不是计算机专业的</li><li>网络五层结构</li><li>网络如何定位一个进程：端口+IP</li><li>TCP为什么要三次握手？而不是两次</li><li><strong>linux五种IO</strong>？BIO NIO IO多路复用 AIO<ul><li>同步阻塞IO</li><li>同步非阻塞IO</li><li>IO多路复用</li><li>信号驱动IO</li><li>异步IO</li></ul></li><li>说一下IO多路复用</li><li>双向链表中放的是什么？文件描述符及状态</li><li>数组和链表查删综合复杂度</li><li>手撕算法：一个乱序数组，输出超过1/2的众数（一定存在），5min<ul><li>用的map，时间复杂度O(n)</li><li>面试官问快排然后返回中间的那个 O(logn)</li></ul></li><li><p>手撕算法：LRU结构</p></li><li><p>说一说mysql为什么用B+树</p></li><li><strong>联合索引</strong></li><li>问项目，亮点是什么 redis</li><li>缓存穿透？怎么解决<ul><li>布隆过滤器</li><li>缓存那个不存在的key</li><li><strong>接口限流</strong></li></ul></li><li>怎么学习的</li><li>看过什么java的书 — java核心技术卷<ul><li>还有阿里巴巴开发手册，面试官说那个没用</li></ul></li><li>组织活动的时候怎么解决人与人之间的冲突</li><li>怎么解决别人对你的冲突</li><li>你是不是一个有责任心的人 举例</li><li>反问<ul><li>是不是用java</li><li>对我的面试评价（不能说）</li><li>多久出结果（1周内）</li></ul></li><li>总结：感觉十分看重是不是科班</li></ul><h3 id="4-7-蚂蚁一面-4-2-做中间件架构"><a href="#4-7-蚂蚁一面-4-2-做中间件架构" class="headerlink" title="4.7 蚂蚁一面 4.2 做中间件架构"></a>4.7 蚂蚁一面 4.2 做中间件架构</h3><ul><li><p>自我简单介绍，没说项目</p></li><li><p>手撕算法：给一个图，从源节点广播，多久能够广播所有的节点，如果不能则返回-1</p><ul><li>用的dfs，结构出来了，貌似没通过</li></ul></li><li><p>在校成绩、在校比赛、论文情况</p></li><li><p>在校的课程 c++ java</p></li><li><p>fs团队分工</p></li><li><p>TCP四次挥手过程</p></li><li><p>如何在linux上查询TCP的过程 netstat -nat</p></li><li><p>如果是time wait状态是哪个？</p><ul><li>主动断开方（蒙对了）</li></ul></li><li><p>乐观锁和悲观锁</p></li><li><p>mysql怎么用行级锁</p><ul><li><p>共享锁</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM table_name WHERE condition LOCK IN SHARE MODE</span><br></pre></td></tr></table></figure></li><li><p>排他锁</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM table_name WHERE condition FOR UPDATE;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>java进程内存占用高 jvm堆空间</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pgrep -lf java   <span class="comment"># 查看当前java进程的pid</span></span><br><span class="line">jmap -heap PID   <span class="comment"># 查看java堆的详细信息</span></span><br><span class="line">jmap -histo PID  <span class="comment"># 查看java堆中对象的相关信息，包含数量以及占用的空间大小</span></span><br></pre></td></tr></table></figure></li><li><p>线程池核心参数，corePoolSize 和 maximumPoolSize 区别</p></li><li><p>主要做的是中间件架构的设计</p></li></ul><h3 id="4-8-蚂蚁二面-4-9"><a href="#4-8-蚂蚁二面-4-9" class="headerlink" title="4.8 蚂蚁二面 4.9"></a>4.8 蚂蚁二面 4.9</h3><ul><li>问了好多微服务相关</li><li>自我介绍 4min</li><li>实习的软件和专业的关系</li><li>hashcode和equals区别 </li><li>三次握手四次挥手</li><li><p>怎么理解注册中心</p><ul><li>注册中心是服务实例信息的存储仓库，也是服务提供者和服务消费者进行交互的桥梁。它主要提供了服务注册和服务发现这两大核心功能。</li></ul></li><li><p>nacos上注册中心的信息，存储的信息</p><ul><li>服务名</li><li>分组名</li><li>集群数</li><li>实例数</li><li>健康实例数</li><li>触发保护阈值</li></ul></li><li><p>怎么理解CAP，怎么实现</p><ul><li>CA</li><li>CP</li></ul></li><li><p>Seata 有没有了解 无</p></li><li>分布式事务</li><li>有什么技术难点？学成在线的同意登录接口</li><li><p>微服务性能瓶颈怎么处理</p><ul><li>请求：恶意请求过滤</li><li>硬件：实例扩容</li><li>业务：服务熔断降级</li></ul></li><li><p>怎么理解AOP</p></li><li><p>redis怎么用的</p><ul><li>购物车</li><li>课程/菜品信息</li></ul></li><li><p>redis和数据库的同步</p><ul><li>数据更新不频繁：先更新数据库后删除redis</li><li>数据更新频繁：先更新redis，后台线程同步到数据库</li></ul></li><li><p>怎么理解微服务？ 网关、注册中心、配置中心、feign远程调用</p></li><li>地点：北京、上海、杭州、成都</li><li>语言转换？java 会 golang最好</li></ul><link rel="stylesheet" href="https://cdn1.tianli0.top/gh/zhheo/Post-Abstract-AI@0.15.2/tianli_gpt.css"><script>let tianliGPT_postSelector = '#post #article-container';let tianliGPT_key = 'c9b7741d290063ab872e';</script><script src="https://cdn1.tianli0.top/gh/zhheo/Post-Abstract-AI@0.15.2/tianli_gpt.js"></script>]]></content>
      
      
      <categories>
          
          <category> study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 搬砖 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM</title>
      <link href="/posts/17374.html"/>
      <url>/posts/17374.html</url>
      
        <content type="html"><![CDATA[<h2 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h2><h3 id="0-引言"><a href="#0-引言" class="headerlink" title="0 引言"></a>0 引言</h3><h4 id="什么是-JVM"><a href="#什么是-JVM" class="headerlink" title="什么是 JVM ?"></a>什么是 JVM ?</h4><p>定义：</p><p>Java Virtual Machine - java 程序的运行环境（java 二进制字节码的运行环境）</p><p>好处：</p><p>一次编写，到处运行</p><p>自动内存管理，垃圾回收功能</p><p>数组下标越界检查</p><p>多态</p><p>比较：</p><p>jvm jre jdk</p><h4 id="常见的-JVM"><a href="#常见的-JVM" class="headerlink" title="常见的 JVM"></a>常见的 JVM</h4><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/JVM.assets/image-20230320105212686.png" alt="image-20230320105212686"></p><h4 id="路线"><a href="#路线" class="headerlink" title="路线"></a>路线</h4><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/JVM.assets/image-20230320105426694.png" alt="image-20230320105426694"></p><h3 id="1-内存结构"><a href="#1-内存结构" class="headerlink" title="1 内存结构"></a>1 内存结构</h3><h4 id="1-1-程序计数器"><a href="#1-1-程序计数器" class="headerlink" title="1.1 程序计数器"></a>1.1 程序计数器</h4><ul><li>Program Counter Register 程序计数器（寄存器） </li><li>作用：是记住下一条jvm指令的执行地址 </li><li>特点 <ul><li>是线程私有的 </li><li>不会存在内存溢出</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>: getstatic #<span class="number">20</span>                       <span class="comment">// PrintStream out = System.out;</span></span><br><span class="line"><span class="number">3</span>: astore_1    <span class="comment">// --</span></span><br><span class="line"><span class="number">4</span>: aload_1    <span class="comment">// out.println(1);</span></span><br><span class="line"><span class="number">5</span>: iconst_1    <span class="comment">// --</span></span><br><span class="line"><span class="number">6</span>: invokevirtual #<span class="number">26</span>    <span class="comment">// --</span></span><br><span class="line"><span class="number">9</span>: aload_1                             <span class="comment">// out.println(2);</span></span><br><span class="line"><span class="number">10</span>: iconst_2                           <span class="comment">// --</span></span><br><span class="line"><span class="number">11</span>: invokevirtual #<span class="number">26</span>                  <span class="comment">// --</span></span><br><span class="line"><span class="number">14</span>: aload_1                            <span class="comment">// out.println(3);</span></span><br><span class="line"><span class="number">15</span>: iconst_3                           <span class="comment">// --</span></span><br><span class="line"><span class="number">16</span>: invokevirtual #<span class="number">26</span>                  <span class="comment">// --</span></span><br><span class="line"><span class="number">19</span>: aload_1                            <span class="comment">// out.println(4);</span></span><br><span class="line"><span class="number">20</span>: iconst_4                           <span class="comment">// --</span></span><br><span class="line"><span class="number">21</span>: invokevirtual #<span class="number">26</span>                  <span class="comment">// --</span></span><br><span class="line"><span class="number">24</span>: aload_1                            <span class="comment">// out.println(5);</span></span><br><span class="line"><span class="number">25</span>: iconst_5                           <span class="comment">// --</span></span><br><span class="line"><span class="number">26</span>: invokevirtual #<span class="number">26</span>                  <span class="comment">// --</span></span><br><span class="line"><span class="number">29</span>: <span class="keyword">return</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="1-2-虚拟机栈"><a href="#1-2-虚拟机栈" class="headerlink" title="1.2 虚拟机栈"></a>1.2 虚拟机栈</h4><ul><li><p>Java Virtual Machine Stacks （Java 虚拟机栈）</p><ul><li>每个线程运行时所需要的内存，称为虚拟机栈 </li><li>每个栈由多个栈帧（Frame）组成，对应着每次方法调用时所占用的内存 </li><li>每个线程只能有一个活动栈帧，对应着当前正在执行的那个方法</li></ul></li><li><p>栈内存溢出</p><ul><li>栈帧过多导致栈内存溢出 </li><li>栈帧过大导致栈内存溢出</li></ul></li><li><p>线程诊断</p><ul><li></li></ul></li></ul><h4 id="1-3-本地方法栈"><a href="#1-3-本地方法栈" class="headerlink" title="1.3 本地方法栈"></a>1.3 本地方法栈</h4><h4 id="1-4-堆"><a href="#1-4-堆" class="headerlink" title="1.4 堆"></a>1.4 堆</h4><ul><li>Heap 堆<ul><li>通过 new 关键字，创建对象都会使用堆内存 </li></ul></li><li>特点 <ul><li>它是线程共享的，堆中对象都需要考虑线程安全的问题</li><li>有垃圾回收机制</li></ul></li><li>堆内存溢出</li><li>堆内存诊断<ul><li>jps 工具 查看当前系统中有哪些 java 进程 </li><li>jmap 工具 查看堆内存占用情况 jmap - heap 进程id （某一时刻，要连续得使用jconsole）</li><li>jconsole 工具 图形界面的，多功能的监测工具，可以连续监测</li></ul></li></ul><h4 id="1-5-方法区"><a href="#1-5-方法区" class="headerlink" title="1.5 方法区"></a>1.5 方法区</h4><ul><li>方法区内存溢出<ul><li>1.8以前会导致永久代内存溢出</li><li>1.8 之后会导致元空间内存溢出</li></ul></li><li>运行时常量池<ul><li>常量池，就是一张表，虚拟机指令根据这张常量表找到要执行的类名、方法名、参数类型、字面量 等信息 </li><li>运行时常量池，常量池是 *.class 文件中的，当该类被加载，它的常量池信息就会放入运行时常量池，并把里面的符号地址变为真实地址</li></ul></li><li>StringTable<ul><li>特性<ul><li>常量池中的字符串仅是符号，第一次用到时才变为对象 </li><li>利用串池的机制，来避免重复创建字符串对象 </li><li>字符串变量拼接的原理是 StringBuilder （1.8） </li><li>字符串常量拼接的原理是编译期优化 </li><li>可以使用 intern 方法，主动将串池中还没有的字符串对象放入串池 <ul><li>1.8 将这个字符串对象尝试放入串池，如果有则并不会放入，如果没有则放入串池， 会把串池中的对象返回 </li><li>1.6 将这个字符串对象尝试放入串池，如果有则并不会放入，如果没有会把此对象复制一份，放入串池，会把串池中的对象返回</li></ul></li></ul></li><li>性能调优<ul><li>调整 -XX:StringTableSize=桶个数<ul><li>字符常量种类多则调整大一些</li></ul></li><li>考虑将字符串对象是否入池</li></ul></li></ul></li></ul><h4 id="1-6-直接内存"><a href="#1-6-直接内存" class="headerlink" title="1.6 直接内存"></a>1.6 直接内存</h4><ul><li>Direct Memory <ul><li>常见于 NIO 操作时，用于数据缓冲区 </li><li>分配回收成本较高，但读写性能高 </li><li>不受 JVM 内存回收管理</li></ul></li><li>分配和回收原理 <ul><li>使用了 Unsafe 对象完成直接内存的分配回收，并且回收需要主动调用 freeMemory 方法 </li><li>ByteBuffer 的实现类内部，使用了 Cleaner （虚引用）来监测 ByteBuffer 对象，一旦 ByteBuffer 对象被垃圾回收，那么就会由 ReferenceHandler 线程通过 Cleaner 的 clean 方法调 用 freeMemory 来释放直接内存</li></ul></li></ul><h3 id="2-垃圾回收"><a href="#2-垃圾回收" class="headerlink" title="2 垃圾回收"></a>2 垃圾回收</h3><h4 id="2-1-如何判断对象可以回收"><a href="#2-1-如何判断对象可以回收" class="headerlink" title="2.1 如何判断对象可以回收"></a>2.1 如何判断对象可以回收</h4><ul><li><p>引用计数法</p><ul><li>A引用B B引用A会造成循环引用，出问题（故Java不使用）</li><li>可达性分析算法<ul><li>Java 虚拟机中的垃圾回收器采用可达性分析来探索所有存活的对象 </li><li>扫描堆中的对象，看是否能够沿着 GC Root对象 为起点的引用链找到该对象，找不到，表示可以回收 </li><li>哪些对象可以作为 GC Root ?</li></ul></li></ul></li><li><p>四种引用</p><ul><li>强引用 <ul><li>只有所有 GC Roots 对象都不通过【强引用】引用该对象，该对象才能被垃圾回收  </li></ul></li><li>软引用（SoftReference） <ul><li>仅有软引用引用该对象时，在垃圾回收后，内存仍不足时会再次出发垃圾回收，回收软引用对象 </li><li>可以配合引用队列来释放软引用自身 </li></ul></li><li>弱引用（WeakReference） <ul><li>仅有弱引用引用该对象时，在垃圾回收时，无论内存是否充足，都会回收弱引用对象 </li><li>可以配合引用队列来释放弱引用自身 </li></ul></li><li>虚引用（PhantomReference） <ul><li>必须配合引用队列使用，主要配合 ByteBuffer 使用，被引用对象回收时，会将虚引用入队， 由 Reference Handler 线程调用虚引用相关方法释放直接内存 </li></ul></li><li>终结器引用（FinalReference） <ul><li>无需手动编码，但其内部配合引用队列使用，在垃圾回收时，终结器引用入队（被引用对象 暂时没有被回收），再由 Finalizer 线程通过终结器引用找到被引用对象并调用它的 finalize 方法，第二次 GC 时才能回收被引用对象</li></ul></li></ul><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/JVM.assets/image-20230320190113297.png" alt="image-20230320190113297"></p></li></ul><h4 id="2-2-垃圾回收算法"><a href="#2-2-垃圾回收算法" class="headerlink" title="2.2 垃圾回收算法"></a>2.2 垃圾回收算法</h4><ul><li>标记清除算法<ul><li>速度快但是会造成内存碎片</li><li><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/JVM.assets/image-20230321143736610.png" alt="image-20230321143736610"></li></ul></li><li>标记整理算法<ul><li>没有内存碎片但是速度慢</li><li><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/JVM.assets/image-20230321143833384.png" alt="image-20230321143833384"></li></ul></li><li>复制算法<ul><li>不会有内存碎片但是需要双倍的空间</li><li><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/JVM.assets/image-20230321143908721.png" alt="image-20230321143908721"></li></ul></li></ul><h4 id="2-3-分代垃圾回收"><a href="#2-3-分代垃圾回收" class="headerlink" title="2.3 分代垃圾回收"></a>2.3 分代垃圾回收</h4><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/JVM.assets/image-20230321151452214.png" alt="image-20230321151452214"></p><ul><li>对象首先分配在伊甸园区域 </li><li>新生代空间不足时，触发 minor gc，伊甸园和 from 存活的对象使用 copy 复制到 to 中，存活的 对象年龄加 1并且交换 from to </li><li>minor gc 会引发 stop the world，暂停其它用户的线程，等垃圾回收结束，用户线程才恢复运行 </li><li>当对象寿命超过阈值时，会晋升至老年代，最大寿命是15（4bit） </li><li>当老年代空间不足，会先尝试触发 minor gc，如果之后空间仍不足，那么触发 full gc，STW的时间更长</li></ul><div class="table-container"><table><thead><tr><th style="text-align:center">表头</th><th style="text-align:center">表头</th></tr></thead><tbody><tr><td style="text-align:center">堆初始大小</td><td style="text-align:center">-Xms</td></tr><tr><td style="text-align:center">堆最大大小</td><td style="text-align:center">Xmx 或 -XX:MaxHeapSize=size</td></tr><tr><td style="text-align:center">新生代大小</td><td style="text-align:center">-Xmn 或 (-XX:NewSize=size + -XX:MaxNewSize=size )</td></tr><tr><td style="text-align:center">幸存区比例（动态）</td><td style="text-align:center">-XX:InitialSurvivorRatio=ratio 和 -XX:+UseAdaptiveSizePolicy</td></tr><tr><td style="text-align:center">幸存区比例</td><td style="text-align:center">-XX:SurvivorRatio=ratio</td></tr><tr><td style="text-align:center">晋升阈值</td><td style="text-align:center">-XX:MaxTenuringThreshold=threshold</td></tr><tr><td style="text-align:center">晋升详情</td><td style="text-align:center">-XX:+PrintTenuringDistribution</td></tr><tr><td style="text-align:center">GC详情</td><td style="text-align:center">-XX:+PrintGCDetails -verbose:gc</td></tr><tr><td style="text-align:center">FullGC 前 MinorGC</td><td style="text-align:center">-XX:+ScavengeBeforeFullGC</td></tr></tbody></table></div><h4 id="2-4-垃圾回收器"><a href="#2-4-垃圾回收器" class="headerlink" title="2.4 垃圾回收器"></a>2.4 垃圾回收器</h4><ul><li><p>串行  <code>-XX:+UseSerialGC = Serial + SerialOld</code></p><ul><li>单线程 </li><li>堆内存较小，适合个人电脑 </li><li><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/JVM.assets/image-20230321154846388.png" alt="image-20230321154846388"></li></ul></li><li><p>吞吐量优先 </p><ul><li><p>多线程 </p></li><li><p>堆内存较大，多核 cpu </p></li><li><p>让单位时间内，STW 的时间最短 0.2 0.2 = 0.4，垃圾回收时间占比最低，这样就称吞吐量高 </p></li><li><p>```java<br>-XX:+UseParallelGC ~ -XX:+UseParallelOldGC<br>-XX:+UseAdaptiveSizePolicy<br>-XX:GCTimeRatio=ratio<br>-XX:MaxGCPauseMillis=ms<br>-XX:ParallelGCThreads=n</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  - ![image-20230321154900987](https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/JVM.assets/image-20230321154900987.png)</span><br><span class="line"></span><br><span class="line">- 响应时间优先 </span><br><span class="line"></span><br><span class="line">  - 多线程 </span><br><span class="line"></span><br><span class="line">  - 堆内存较大，多核 cpu</span><br><span class="line"></span><br><span class="line">  -  尽可能让单次 STW 的时间最短 0.1 0.1 0.1 0.1 0.1 = 0.</span><br><span class="line"></span><br><span class="line">  - ```java</span><br><span class="line">    -XX:+UseConcMarkSweepGC ~ -XX:+UseParNewGC ~ SerialOld</span><br><span class="line">    -XX:ParallelGCThreads=n ~ -XX:ConcGCThreads=threads</span><br><span class="line">    -XX:CMSInitiatingOccupancyFraction=percent</span><br><span class="line">    -XX:+CMSScavengeBeforeRemark</span><br></pre></td></tr></table></figure></li><li><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/JVM.assets/image-20230321154909859.png" alt="image-20230321154909859"></p></li></ul></li></ul><h4 id="2-5-G1垃圾回收器"><a href="#2-5-G1垃圾回收器" class="headerlink" title="2.5 G1垃圾回收器"></a>2.5 G1垃圾回收器</h4><ul><li><p>定义：Garbage First</p><ul><li>2004 论文发布</li><li>2009 JDK 6u14 体验 </li><li>2012 JDK 7u4 官方支持 </li><li>2017 JDK 9 默认</li></ul></li><li><p>适用场景</p><ul><li>同时注重吞吐量（Throughput）和低延迟（Low latency），默认的暂停目标是 200 ms </li><li>超大堆内存，会将堆划分为多个大小相等的 Region </li><li>整体上是 <code>标记+整理</code> 算法，两个区域之间是 <code>复制</code> 算法</li></ul></li><li><p>相关 JVM 参数</p><ul><li><code>-XX:+UseG1GC</code></li><li><code>-XX:G1HeapRegionSize=size</code></li><li><code>-XX:MaxGCPauseMillis=time</code></li></ul></li><li><p>垃圾回收阶段</p><ul><li><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/JVM.assets/image-20230321160301405.png" alt="image-20230321160301405"></p></li><li><p>Young Collection</p><ul><li><p>会stw（stop the work）</p><ul><li><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/JVM.assets/image-20230321160440625.png" alt="image-20230321160440625"></p><p>新生代</p></li><li><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/JVM.assets/image-20230321160447582.png" alt="image-20230321160447582"></p><p>新生代到幸存区</p></li><li><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/JVM.assets/image-20230321160534802.png" alt="image-20230321160534802"></p><p>进入老年代</p></li></ul></li></ul></li><li><p>Young Collection + CM</p><ul><li>在 Young GC 时会进行 GC Root 的初始标记 </li><li>老年代占用堆空间比例达到阈值时，进行并发标记（不会 STW），由下面的 JVM 参数决定<ul><li><code>-XX:InitiatingHeapOccupancyPercent=percent</code> （默认45%）</li></ul></li></ul></li><li><p>Mixed Collection（优先收集垃圾最多的以达到暂停时间最短的）</p><ul><li><p>会对 E、S、O 进行全面垃圾回收 </p><ul><li>最终标记（Remark）会 STW </li><li>拷贝存活（Evacuation）会 STW</li></ul></li><li><p><code>-XX:MaxGCPauseMillis=ms</code></p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/JVM.assets/image-20230321160831105.png" alt="image-20230321160831105"></p></li></ul></li></ul></li></ul><h4 id="2-6-垃圾回收调优"><a href="#2-6-垃圾回收调优" class="headerlink" title="2.6 垃圾回收调优"></a>2.6 垃圾回收调优</h4><ul><li>调优领域<ul><li>内存 </li><li>锁竞争 </li><li>cpu </li><li>占用 io</li></ul></li><li>确定目标<ul><li>【低延迟】还是【高吞吐量】，选择合适的回收器 </li><li>CMS，G1，ZGC </li><li>ParallelGC </li><li>Zing</li></ul></li><li>最快的GC<ul><li>查看 FullGC 前后的内存占用，考虑下面几个问题 <ul><li>数据是不是太多？<ul><li>resultSet = statement.executeQuery(“select * from 大表 limit n”) </li></ul></li><li>数据表示是否太臃肿？<ul><li>对象图 </li><li>对象大小 16 Integer 24 int 4 </li></ul></li><li>是否存在内存泄漏？ <ul><li>static Map map = </li><li>软 </li><li>弱</li><li>第三方缓存实现</li></ul></li></ul></li></ul></li><li>新生代调优<ul><li>新生代的特点 <ul><li>所有的 new 操作的内存分配非常廉价<ul><li>TLAB thread-local allocation buffer </li></ul></li><li>死亡对象的回收代价是零 </li><li>大部分对象用过即死</li><li>Minor GC 的时间远远低于 Full GC</li></ul></li></ul></li><li>老年代调优<ul><li>CMS 的老年代内存越大越好 </li><li>先尝试不做调优，如果没有 Full GC 那么已经…，否则先尝试调优新生代 </li><li>观察发生 Full GC 时老年代内存占用，将老年代内存预设调大 1/4 ~ 1/3<ul><li><code>-XX:CMSInitiatingOccupancyFraction=percent</code></li></ul></li></ul></li></ul><h3 id="3-类加载与字节码技术"><a href="#3-类加载与字节码技术" class="headerlink" title="3 类加载与字节码技术"></a>3 类加载与字节码技术</h3><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/JVM.assets/image-20230322101115226.png" alt="image-20230322101115226"></p><h4 id="3-1-类文件结构"><a href="#3-1-类文件结构" class="headerlink" title="3.1  类文件结构"></a>3.1  类文件结构</h4><ul><li><p>根据jvm规范，类文件结构</p></li><li><p>```java<br>ClassFile {</p><pre><code>u4 magic;//前四个字节表示：魔数（ca fe ba be）u2 minor_version;//小版本u2 major_version;//大版本u2 constant_pool_count;//常量池（占主要）cp_info constant_pool[constant_pool_count-1];//访问标识与继承信息u2 access_flags;u2 this_class;u2 super_class;u2 interfaces_count;u2 interfaces[interfaces_count];u2 fields_count;// Field 信息，表示成员变量的数量field_info fields[fields_count];u2 methods_count;//方法信息method_info methods[methods_count];u2 attributes_count;//附加属性attribute_info attributes[attributes_count];</code></pre><p>}</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#### 3.2 字节码指令</span><br><span class="line"></span><br><span class="line">- javap工具</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>[root@localhost ~]# javap -v HelloWorld.class<br>Classfile /root/HelloWorld.class</p><pre><code>Last modified Jul 7, 2019; size 597 bytesMD5 checksum 361dca1c3f4ae38644a9cd5060ac6dbcCompiled from &quot;HelloWorld.java&quot;</code></pre><p>public class cn.itcast.jvm.t5.HelloWorld</p><pre><code>minor version: 0major version: 52flags: ACC_PUBLIC, ACC_SUPER</code></pre><p>Constant pool:</p><pre><code>#1 = Methodref #6.#21 // java/lang/Object.&quot;&lt;init&gt;&quot;:()V#2 = Fieldref #22.#23 //</code></pre><p>java/lang/System.out:Ljava/io/PrintStream;</p><pre><code>#3 = String #24 // hello world#4 = Methodref #25.#26 // java/io/PrintStream.println:</code></pre><p>(Ljava/lang/String;)V</p><pre><code>#5 = Class #27 // cn/itcast/jvm/t5/HelloWorld#6 = Class #28 // java/lang/Object#7 = Utf8 &lt;init&gt;#8 = Utf8 ()V#9 = Utf8 Code#10 = Utf8 LineNumberTable#11 = Utf8 LocalVariableTable#12 = Utf8 this#13 = Utf8 Lcn/itcast/jvm/t5/HelloWorld;#14 = Utf8 main#15 = Utf8 ([Ljava/lang/String;)V#16 = Utf8 args#17 = Utf8 [Ljava/lang/String;#18 = Utf8 MethodParameters#19 = Utf8 SourceFile#20 = Utf8 HelloWorld.java#21 = NameAndType #7:#8 // &quot;&lt;init&gt;&quot;:()V#22 = Class #29 // java/lang/System#23 = NameAndType #30:#31 // out:Ljava/io/PrintStream;#24 = Utf8 hello world#25 = Class #32 // java/io/PrintStream#26 = NameAndType #33:#34 // println:(Ljava/lang/String;)V#27 = Utf8 cn/itcast/jvm/t5/HelloWorld#28 = Utf8 java/lang/Object#29 = Utf8 java/lang/System#30 = Utf8 out#31 = Utf8 Ljava/io/PrintStream;#32 = Utf8 java/io/PrintStream#33 = Utf8 println#34 = Utf8 (Ljava/lang/String;)V</code></pre><p>{</p><pre><code>public cn.itcast.jvm.t5.HelloWorld();    descriptor: ()V    flags: ACC_PUBLIC    Code:        stack=1, locals=1, args_size=1            0: aload_0            1: invokespecial #1 // Method java/lang/Object.&quot;</code></pre><p><init>“:()V</p><pre><code>            4: return        LineNumberTable:            line 4: 0        LocalVariableTable:            Start Length Slot Name Signature                0 5 0 this Lcn/itcast/jvm/t5/HelloWorld;public static void main(java.lang.String[]);    descriptor: ([Ljava/lang/String;)V    flags: ACC_PUBLIC, ACC_STATIC    Code:        stack=2, locals=1, args_size=1            0: getstatic #2 // Fieldjava/lang/System.out:Ljava/io/PrintStream;            3: ldc #3 // String hello world            5: invokevirtual #4 // Methodjava/io/PrintStream.println:(Ljava/lang/String;)V            8: return        LineNumberTable:            line 6: 0            line 7: 8        LocalVariableTable:            Start Length Slot Name Signature                0 9 0 args [Ljava/lang/String;    MethodParameters:        Name Flags        args</code></pre><p>}</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 过程</span><br><span class="line"></span><br><span class="line">  - 原始java代码</span><br><span class="line"></span><br><span class="line">  - 编译后的字节码文件</span><br><span class="line"></span><br><span class="line">  - 常量池载入运行时常量池</span><br><span class="line"></span><br><span class="line">    ![image-20230322104419079](https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/JVM.assets/image-20230322104419079.png)</span><br><span class="line"></span><br><span class="line">  - 方法字节码载入方法区</span><br><span class="line"></span><br><span class="line">    ![image-20230322104440580](https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/JVM.assets/image-20230322104440580.png)</span><br><span class="line"></span><br><span class="line">  - main线程开始运行，分配栈帧内存</span><br><span class="line"></span><br><span class="line">    ![image-20230322104528061](https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/JVM.assets/image-20230322104528061.png)</span><br><span class="line"></span><br><span class="line">  - 执行引擎开始执行字节码</span><br><span class="line"></span><br><span class="line">#### 3.3  编译期处理</span><br><span class="line"></span><br><span class="line">- 所谓的 `语法糖` ，其实就是指 java 编译器把 *.java 源码编译为 *.class 字节码的过程中，自动生成 和转换的一些代码，主要是为了减轻程序员的负担，算是 java 编译器给我们的一个额外福利</span><br><span class="line"></span><br><span class="line">- 默认的构造器</span><br><span class="line"></span><br><span class="line">  - ```java</span><br><span class="line">    public class Candy1 &#123;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ul><li><p>编译成.class后的代码</p></li><li><p>```java<br>public class Candy1 {</p><pre><code>// 这个无参构造是编译器帮助我们加上的public Candy1() &#123;    super(); // 即调用父类 Object 的无参构造方法，即调用 java/lang/Object.&quot;    &lt;init&gt;&quot;:()V&#125;</code></pre><p>}</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 自动拆装箱</span><br><span class="line"></span><br><span class="line">  - JDK5以后引用</span><br><span class="line"></span><br><span class="line">  - ```java</span><br><span class="line">    public class Candy2 &#123;</span><br><span class="line">        public static void main(String[] args) &#123;</span><br><span class="line">            Integer x = 1;</span><br><span class="line">            int y = x;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li><p>```java<br>public class Candy2 {</p><pre><code>public static void main(String[] args) &#123;    Integer x = Integer.valueOf(1);    int y = x.intValue();&#125;</code></pre><p>}</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 泛型集合取值</span><br><span class="line"></span><br><span class="line">  - 泛型也是在 JDK 5 开始加入的特性，但 java 在编译泛型代码后会执行 泛型擦除 的动作，即泛型信息</span><br><span class="line">    在编译为字节码之后就丢失了，实际的类型都当做了 Object 类型来处理</span><br><span class="line"></span><br><span class="line">  - ```java</span><br><span class="line">    public class Candy3 &#123;</span><br><span class="line">        public static void main(String[] args) &#123;</span><br><span class="line">            List&lt;Integer&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line">            list.add(10); // 实际调用的是 List.add(Object e)</span><br><span class="line">            Integer x = list.get(0); // 实际调用的是 Object obj = List.get(int index);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li><p>所以取值的时候，编译器真正生成的字节码中，还要额外做一个类型转换的操作</p></li><li><p>```java<br>// 需要将 Object 转为 Integer<br>Integer x = (Integer)list.get(0);<br>// 需要将 Object 转为 Integer, 并执行拆箱操作<br>int x = ((Integer)list.get(0)).intValue();</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 可变参数</span><br><span class="line"></span><br><span class="line">  - JDK5引入新特性</span><br><span class="line"></span><br><span class="line">  - ```java</span><br><span class="line">    public class Candy4 &#123;</span><br><span class="line">        public static void foo(String... args) &#123;</span><br><span class="line">            String[] array = args; // 直接赋值</span><br><span class="line">            System.out.println(array);</span><br><span class="line">        &#125;</span><br><span class="line">        public static void main(String[] args) &#123;</span><br><span class="line">            foo(&quot;hello&quot;, &quot;world&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li><p>转为了</p></li><li><p>```java<br>public class Candy4 {</p><pre><code>public static void foo(String[] args) &#123;    String[] array = args; // 直接赋值    System.out.println(array);&#125;public static void main(String[] args) &#123;    foo(new String[]&#123;&quot;hello&quot;, &quot;world&quot;&#125;);&#125;</code></pre><p>}</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- foreach循环</span><br><span class="line"></span><br><span class="line">  - jdk5引入</span><br><span class="line"></span><br><span class="line">  - ```java</span><br><span class="line">    public class Candy5_1 &#123;</span><br><span class="line">        public static void main(String[] args) &#123;</span><br><span class="line">        int[] array = &#123;1, 2, 3, 4, 5&#125;; // 数组赋初值的简化写法也是语法糖哦</span><br><span class="line">            for (int e : array) &#123;</span><br><span class="line">           System.out.println(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br></pre></td></tr></table></figure></li><li><p>```java<br>public class Candy5_1 {</p><pre><code>public Candy5_1() &#123;&#125;public static void main(String[] args) &#123;    int[] array = new int[]&#123;1, 2, 3, 4, 5&#125;;    for(int i = 0; i &lt; array.length; ++i) &#123;          int e = array[i];        System.out.println(e);    &#125;&#125;</code></pre><p>}</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- switch字符串</span><br><span class="line"></span><br><span class="line">  - jdk7开始switch 可以作用于字符串和枚举类，这个功能其实也是语法糖</span><br><span class="line"></span><br><span class="line">  - ```java</span><br><span class="line">    public class Candy6_1 &#123;</span><br><span class="line">        public static void choose(String str) &#123;</span><br><span class="line">        switch (str) &#123;</span><br><span class="line">        case &quot;hello&quot;: &#123;</span><br><span class="line">        System.out.println(&quot;h&quot;);</span><br><span class="line">        break;</span><br><span class="line">        &#125;</span><br><span class="line">        case &quot;world&quot;: &#123;</span><br><span class="line">                    System.out.println(&quot;w&quot;);</span><br><span class="line">                    break;</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li><p>变编译器转换为</p></li><li><p>```java<br>public class Candy6_1 {</p><pre><code>public Candy6_1() &#123;&#125;public static void choose(String str) &#123;    byte x = -1;    switch(str.hashCode()) &#123;    case 99162322: // hello 的 hashCode        if (str.equals(&quot;hello&quot;)) &#123;            x = 0;        &#125;        break;    case 113318802: // world 的 hashCode        if (str.equals(&quot;world&quot;)) &#123;            x = 1;        &#125;    &#125;    switch(x) &#123;    case 0:        System.out.println(&quot;h&quot;);        break;    case 1:        System.out.println(&quot;w&quot;);    &#125;&#125;</code></pre><p>}</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- switch枚举</span><br><span class="line"></span><br><span class="line">- 枚举类</span><br><span class="line"></span><br><span class="line">  - jdk7引入</span><br><span class="line"></span><br><span class="line">  - ```java</span><br><span class="line">    enum Sex &#123;</span><br><span class="line">    MALE, FEMALE</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li><p>```java<br>public final class Sex extends Enum<Sex> {</p><pre><code>public static final Sex MALE;public static final Sex FEMALE;private static final Sex[] $VALUES;static &#123;    MALE = new Sex(&quot;MALE&quot;, 0);    FEMALE = new Sex(&quot;FEMALE&quot;, 1);    $VALUES = new Sex[]&#123;MALE, FEMALE&#125;;&#125;/*** Sole constructor. Programmers cannot invoke this constructor.* It is for use by code emitted by the compiler in response to* enum type declarations.** @param name - The name of this enum constant, which is the identifier* used to declare it.* @param ordinal - The ordinal of this enumeration constant (its position* in the enum declaration, where the initial constant isassigned*/private Sex(String name, int ordinal) &#123;    super(name, ordinal);&#125;public static Sex[] values() &#123;    return $VALUES.clone();&#125;public static Sex valueOf(String name) &#123;    return Enum.valueOf(Sex.class, name);&#125;</code></pre><p>}</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- try-with-resources</span><br><span class="line"></span><br><span class="line">  - JDK 7 开始新增了对需要关闭的资源处理的特殊语法 try-with-resources`</span><br><span class="line"></span><br><span class="line">  - ```java</span><br><span class="line">    try(资源变量 = 创建资源对象)&#123;</span><br><span class="line">        </span><br><span class="line">    &#125; catch( ) &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li><p>略</p></li></ul></li><li><p>方法重写时的桥接方法</p><ul><li>```java<br>class A {<pre><code>public Number m() &#123;    return 1;&#125;</code></pre>}<br>class B extends A {<pre><code>@Override// 子类 m 方法的返回值是 Integer 是父类 m 方法返回值 Number 的子类public Integer m() &#123;    return 2;&#125;</code></pre>}<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- ```java</span><br><span class="line">  class B extends A &#123;</span><br><span class="line">      public Integer m() &#123;</span><br><span class="line">      return 2;</span><br><span class="line">  &#125;</span><br><span class="line">  // 此方法才是真正重写了父类 public Number m() 方法</span><br><span class="line">      public synthetic bridge Number m() &#123;</span><br><span class="line">      // 调用 public Integer m()</span><br><span class="line">      return m();</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>匿名内部类</p></li></ul><h4 id="3-4-类加载阶段"><a href="#3-4-类加载阶段" class="headerlink" title="3.4 类加载阶段"></a>3.4 类加载阶段</h4><ul><li>加载<ul><li>将类的字节码载入方法区中，内部采用 C++ 的 instanceKlass 描述 java 类，它的重要 field 有：<ul><li>_java_mirror 即 java 的类镜像，例如对 String 来说，就是 String.class，作用是把 klass 暴 露给 java 使用 </li><li>_super 即父类 </li><li>_fields 即成员变量 </li><li>_methods 即方法 </li><li>_constants 即常量池 </li><li>_class_loader 即类加载器 </li><li>_vtable 虚方法表 </li><li>_itable 接口方法表</li></ul></li><li>如果这个类还有父类没有加载，先加载父类</li><li>加载和链接可能是交替运行的</li></ul></li><li>链接<ul><li>验证：验证类是否符合JVM规范，安全性检查</li><li>准备：为 static 变量分配空间，设置默认值</li><li>解析：将常量池中的符号引用解析为直接引用</li></ul></li><li>初始化<ul><li>初始化即调用 <code>&lt;cinit&gt;()V</code> ，虚拟机会保证这个类的『构造方法』的线程安全    </li></ul></li></ul><h4 id="3-5-类加载器"><a href="#3-5-类加载器" class="headerlink" title="3.5 类加载器"></a>3.5 类加载器</h4><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/JVM.assets/image-20230322153720740.png" alt="image-20230322153720740"></p><ul><li><p>启动类加载器</p><ul><li><p>用 Bootstrap 类加载器加载类：</p></li><li><p>```java<br>package cn.itcast.jvm.t3.load;</p><pre><code>public class F &#123;    static &#123;        System.out.println(&quot;bootstrap F init&quot;);    &#125;</code></pre><p>}</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 执行</span><br><span class="line"></span><br><span class="line">- ```java</span><br><span class="line">  package cn.itcast.jvm.t3.load;</span><br><span class="line">      public class Load5_1 &#123;</span><br><span class="line">          public static void main(String[] args) throws ClassNotFoundException &#123;</span><br><span class="line">              Class&lt;?&gt; aClass = Class.forName(&quot;cn.itcast.jvm.t3.load.F&quot;);</span><br><span class="line">              System.out.println(aClass.getClassLoader());</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li><li><p>输出</p></li><li><pre><code class="lang-java">E:/git/jvm/out/production/jvm&gt;java -Xbootclasspath/a:.cn.itcast.jvm.t3.load.Load5bootstrap F initnull</code></pre><ul><li>-Xbootclasspath 表示设置 bootclasspath</li><li>其中 /a:. 表示将当前目录追加至 bootclasspath 之后</li><li>可以用这个办法替换核心类<ul><li><code>java -Xbootclasspath:&lt;new bootclasspath&gt;</code></li><li><code>java -Xbootclasspath/a:&lt;追加路径&gt;</code> </li><li><code>java -Xbootclasspath/p:&lt;追加路径&gt;</code></li></ul></li></ul></li></ul></li><li><p>扩展类加载器</p></li><li><p>双亲委派模式</p><ul><li>所谓的双亲委派，就是指调用类加载器的 loadClass 方法时，查找类的规则</li></ul></li><li><p>线程上下文类加载器</p></li><li><p>自定义类加载器</p></li></ul><h4 id="3-6-运行期优化"><a href="#3-6-运行期优化" class="headerlink" title="3.6 运行期优化"></a>3.6 运行期优化</h4><link rel="stylesheet" href="https://cdn1.tianli0.top/gh/zhheo/Post-Abstract-AI@0.15.2/tianli_gpt.css"><script>let tianliGPT_postSelector = '#post #article-container';let tianliGPT_key = 'c9b7741d290063ab872e';</script><script src="https://cdn1.tianli0.top/gh/zhheo/Post-Abstract-AI@0.15.2/tianli_gpt.js"></script>]]></content>
      
      
      <categories>
          
          <category> study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java高级 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>学成在线</title>
      <link href="/posts/50254.html"/>
      <url>/posts/50254.html</url>
      
        <content type="html"><![CDATA[<h1 id="学成在线"><a href="#学成在线" class="headerlink" title="学成在线"></a>学成在线</h1><p>视频：<a href="https://www.bilibili.com/video/BV1j8411N7Bm?p=1&amp;vd_source=1a39594354c31d775ddc587407a55282">https://www.bilibili.com/video/BV1j8411N7Bm?p=1&amp;vd_source=1a39594354c31d775ddc587407a55282</a></p><p>文档：<a href="https://cyborg2077.github.io/2023/02/10/XuechengOnlinePart3/#%E8%A7%86%E9%A2%91%E5%A4%84%E7%90%86">https://cyborg2077.github.io/2023/02/10/XuechengOnlinePart3/#%E8%A7%86%E9%A2%91%E5%A4%84%E7%90%86</a></p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/学成在线.assets/image-20240109141122521.png" alt="image-20240109141122521"></p><ul><li><p>用户层：描述了本系统所支持的用户类型包括：pc用户、app用户、h5用户。pc用户通过浏览器访问系统、app用户通过android、ios手机访问系统，H5用户通过h5页面访问系统。</p></li><li><p>CDN：全称Content Delivery Network，即内容分发网络，本系统所有静态资源全部通过CDN加速来提高访问速度。系统静态资源包括：html页面、js文件、css文件、image图片、pdf和ppt及doc教学文档、video视频等。</p></li><li>系统的CDN层、UI层、服务层及数据层均设置了负载均衡服务，上图仅在UI层前边标注了负载均衡。 每一层的负载均衡会根据系统的需求来确定负载均衡器的类型，系统支持4层负载均衡+7层负载均衡结合的方式，4层负载均衡是指在网络传输层进行流程转发，根据IP和端口进行转发，7层负载均衡完成HTTP协议负载均衡及反向代理的功能，根据url进行请求转发</li><li>UI层：描述了系统向pc用户、app用户、h5用户提供的产品界面。根据系统功能模块特点确定了UI层包括如下产品界面类型： 1）面向pc用户的门户系统、学习中心系统、教学管理系统、系统管理中心。 2）面向h5用户的门户系统、学习中心系统。 3）面向app用户的门户系统、学习中心系统。</li><li>微服务层将系统服务分类三类：业务服务、基础服务、第三方代理服务。 业务服务：主要为学成在线核心业务提供服务，并与数据层进行交互获得数据。 基础服务：主要管理学成在线系统运行所需的配置、日志、任务调度、短信等系统级别的服务。 第三方代理服务：系统接入第三方服务完成业务的对接，例如认证、支付、视频点播/直播、用户认证和授权。</li><li>数据层描述了系统的数据存储的内容类型，关系性数据库：持久化的业务数据使用MySQL。 消息队列：存储系统服务间通信的消息，本身提供消息存取服务，与微服务层的系统服务连接。 索引库：存储课程信息的索引信息，本身提供索引维护及搜索的服务，与微服务层的系统服务连接。 缓存：作为系统的缓存服务，作为微服务的缓存数据便于查询。 文件存储：提供系统静态资源文件的分布式存储服务，文件存储服务器作为CDN服务器的数据来源，CDN上的静态资源将最终在文件存储服务器上保存多份。</li></ul><ul><li><p>工程结构</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/学成在线.assets/image-20240109142156626.png" alt="image-20240109142156626"></p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/学成在线.assets/image-20240109143211283.png" alt="image-20240109143211283"></p></li><li><p>数据模型</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/学成在线.assets/image-20240109142833380.png" alt="image-20240109142833380"></p></li><li><p>什么时候用vo什么时候用dto</p><ul><li><p>多个前端调用接口的时候</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/学成在线.assets/image-20240109151832346.png" alt="image-20240109151832346"></p></li><li><p>前端调接口 ：VO/DTO</p></li><li><p>接口调业务：DTO</p></li><li><p>业务调数据：PO</p></li></ul></li><li><p>swagger</p><ul><li><p>xuecheng-plus-content-api导入依赖</p></li><li><p>bootstrap.yml</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">swagger:</span></span><br><span class="line">  <span class="attr">title:</span> <span class="string">&quot;学成在线内容管理系统&quot;</span></span><br><span class="line">  <span class="attr">description:</span> <span class="string">&quot;内容系统管理系统对课程相关信息进行管理&quot;</span></span><br><span class="line">  <span class="attr">base-package:</span> <span class="string">com.xuecheng.content</span></span><br><span class="line">  <span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">version:</span> <span class="number">1.0</span><span class="number">.0</span></span><br></pre></td></tr></table></figure></li><li><p>启动类开启注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableSwagger2Doc</span></span><br></pre></td></tr></table></figure></li><li><p>访问:<a href="http://localhost:63040/content/swagger-ui.html">http://localhost:63040/content/swagger-ui.html</a></p></li><li><p>升级为knife4j</p><p>访问：<a href="http://localhost:63040/content/doc.html">http://localhost:63040/content/doc.html</a></p></li></ul></li><li><p>数据字典表：用于对应前端的响应</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/学成在线.assets/image-20240110151549125.png" alt="image-20240110151549125"></p></li><li><p>httpclient</p><ul><li><p><code>.http文件</code>，类似于postman，swagger，但是可以保存测试数据且是idea自带</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/学成在线.assets/image-20240110160051703.png" alt="image-20240110160051703"></p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/学成在线.assets/image-20240110160107352.png" alt="image-20240110160107352"></p></li></ul></li><li><p>前端工程运行：看readme文件</p></li><li><p>JRS303校验</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-validation&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><ul><li>然后在po、dto等类的字段上加注解如 <code>@NotEmpty</code></li><li>最后在controller调用的时候给形参加注解<code>@validated</code></li></ul></li></ul><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/学成在线.assets/image-20240111093212987.png" alt="image-20240111093212987"></p><ul><li>JRS303分组校验<ul><li>多个接口用一个模型类</li></ul></li></ul><h3 id="0-总结"><a href="#0-总结" class="headerlink" title="0 总结"></a>0 总结</h3><h4 id="1-异常处理"><a href="#1-异常处理" class="headerlink" title="1 异常处理"></a>1 异常处理</h4><ul><li><p><code>@ControllerAdvice</code>与<code>@ExceptionHandler</code>用来捕获异常</p></li><li><p><code>@ResponseStatus</code>用来确定响应数据</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/学成在线.assets/image-20240303152434784.png" alt="image-20240303152434784"></p></li></ul><h4 id="2-传入数据判断是否为空方法"><a href="#2-传入数据判断是否为空方法" class="headerlink" title="2 传入数据判断是否为空方法"></a>2 传入数据判断是否为空方法</h4><ul><li><p>在controller方法内部手动判断：<code>StringUtils.isNotEmpty</code></p></li><li><p>实体类的数据上标注<code>@NotNull</code>，然后在controller中的形参前面加上<code>@Valid</code>注解，再在全局异常中添加<code>BindException</code>异常类的捕获</p><p>&lt;img src=(<a href="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/学成在线.assets/image-20240303153429684.png">https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/学成在线.assets/image-20240303153429684.png</a>“ alt=”image-20240303153429684” style=”zoom:50%;” /&gt;</p></li></ul><h4 id="3-controller与前端的数据传递"><a href="#3-controller与前端的数据传递" class="headerlink" title="3 controller与前端的数据传递"></a>3 controller与前端的数据传递</h4><ul><li>形参不带注解：此时参数名称一定要和请求参数的名称一致<ul><li>get方式提交，直接写参数</li><li>通过<code>HttpServletRequest</code>接收：<code>request.getParameter(&quot;username&quot;)</code></li><li>通过java类对象接收</li></ul></li><li>形参带注解<ul><li><code>@RequestParam</code>：有value、require、defaultValue字段可填充</li><li><code>@PathVariable</code>：支持类似于：<code>user/get/mac/&#123;macAddress&#125;</code>的请求</li><li><code>@ModelAttribute(&quot;user&quot;)</code>:会将客户端传递过来的参数按名称注入到指定对象中，并且会将这个对象自动加入ModelMap中，便于View层使用</li></ul></li></ul><h4 id="4-树形查询"><a href="#4-树形查询" class="headerlink" title="4 树形查询"></a>4 树形查询</h4><ul><li><p><code>left join</code>连接表（可以是相同的表）</p></li><li><p>指定<code>resultMap</code>为一个值，然后再在指定的<code>resultMap</code>中设置映射关系并将结果返回。</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/学成在线.assets/image-20240303160733160.png" alt="image-20240303160733160"></p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/学成在线.assets/image-20240303160740937.png" alt="image-20240303160740937"></p></li></ul><h4 id="5-视频分块上传"><a href="#5-视频分块上传" class="headerlink" title="5 视频分块上传"></a>5 视频分块上传</h4><ul><li><code>RandomAccessFile</code>实现文件的分块和合并</li><li>判断是否一致 ==&gt; <code>DigestUtils.md5Hex()</code></li></ul><h4 id="6-Transactional"><a href="#6-Transactional" class="headerlink" title="6 @Transactional"></a>6 @Transactional</h4><ul><li><p>自调用的时候需要声明一个代理对象来方便进行事务的管理</p><p>&lt;img src=(<a href="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/学成在线.assets/image-20240304110055984.png">https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/学成在线.assets/image-20240304110055984.png</a>“ alt=”image-20240304110055984” style=”zoom:67%;” /&gt;</p></li><li><p><code>@Transactional</code>即声明式事务管理， 建立在AOP之上的。其本质是对方法前后进行拦截，然后在目标方法开始之前创建或者加入一个事务，在执行完目标方法之后根据执行情况提交或者回滚事务。</p></li></ul><h4 id="7-freemarker"><a href="#7-freemarker" class="headerlink" title="7 freemarker"></a>7 freemarker</h4><ul><li><p>controller中返回<code>ModelAndView</code>对象，在<code>setViewName</code>中设置重定向的页面文件，在<code>addObject</code>中传值</p><p>&lt;img src=(<a href="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/学成在线.assets/image-20240304142757986.png">https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/学成在线.assets/image-20240304142757986.png</a>“ alt=”image-20240304142757986” style=”zoom:80%;” /&gt;</p></li></ul><h4 id="8-xxj-job"><a href="#8-xxj-job" class="headerlink" title="8 xxj-job"></a>8 xxj-job</h4><ul><li>获取执行器序号、 执行器总数，然后用表的<code>id % 总数 == 序号</code>来保证一个任务只会被一个执行器执行，用字段标识来保证一个任务只会被执行一次(乐观锁)</li><li>用于视频转码作业</li><li>课程发布操作后，先更新数据库中的课程发布状态，更新后向Redis、ElasticSearch、MinIO写课程信息，只要在一定时间内最终成功写入数据即可<ul><li>这里使用了feign远程调用，在向MinIO写信息的时候调用了Media服务的相关接口<ul><li>熔断降级：返回null对象，然后再去判断是否为null来判断是否发生了故障</li><li>注意启动类开启注解<code>@EnableFeignClients</code></li></ul></li></ul></li></ul><h4 id="9-ES"><a href="#9-ES" class="headerlink" title="9 ES"></a>9 ES</h4><ul><li><p>倒排索引过程</p><p>&lt;img src=(<a href="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/学成在线.assets/image-20240304153213090.png">https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/学成在线.assets/image-20240304153213090.png</a>“ alt=”image-20240304153213090” style=”zoom:67%;” /&gt;</p></li><li><p>概念</p><ul><li>文档：一条完整的数据，包括索引、名称等，以json方式存储</li><li>字段：文档中的具体字段，类似于表格的列</li><li>索引：就是相同类型的文档的集合，类似于表。eg：用户的索引、商品的索引、订单的索引…</li><li>映射(mapping)：索引中字段的约束信息，类似于表的结构约束。</li></ul></li><li><p>安装ik分词器</p></li><li><p>索引库的操作</p><p>&lt;img src=(<a href="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/学成在线.assets/image-20240304154138185.png">https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/学成在线.assets/image-20240304154138185.png</a>“ alt=”image-20240304154138185” style=”zoom:67%;” /&gt;</p></li><li><p>文档的操作</p><p>&lt;img src=(<a href="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/学成在线.assets/image-20240304154206085.png">https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/学成在线.assets/image-20240304154206085.png</a>“ alt=”image-20240304154206085” style=”zoom:67%;” /&gt;</p></li><li><p>搜索结果处理</p><ul><li>排序</li><li>分页</li><li>高亮<ul><li>给文档中的所有关键字都添加一个标签，例如<code>&lt;em&gt;</code>标签</li><li>页面给<code>&lt;em&gt;</code>标签编写CSS样式</li></ul></li></ul></li><li><p>demo</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testMatchAll</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">// 1. 准备Request对象，对应 GET /hotel/_search</span></span><br><span class="line">    <span class="type">SearchRequest</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SearchRequest</span>(<span class="string">&quot;hotel&quot;</span>);</span><br><span class="line">    <span class="comment">// 2. 组织DSL参数 对应 &quot;query&quot;: &#123;&quot;match_all&quot;: &#123;&#125;&#125;</span></span><br><span class="line">    request.source().query(QueryBuilders.matchAllQuery());</span><br><span class="line">    <span class="comment">// 3. 发送请求，得到相应结果</span></span><br><span class="line">    <span class="type">SearchResponse</span> <span class="variable">response</span> <span class="operator">=</span> client.search(request, RequestOptions.DEFAULT);</span><br><span class="line">    System.out.println(response);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    创建SearchRequest对象，指定索引库名</span></span><br><span class="line"><span class="comment">    利用request.source()构建DSL，DSL中可以包含查询、分页、排序、高亮等</span></span><br><span class="line"><span class="comment">    利用client.search()发送请求，得到响应</span></span><br><span class="line"><span class="comment">关键API：    </span></span><br><span class="line"><span class="comment">    一个是request.source()，其中包含了query、order、from、size、highlight等所有功能</span></span><br><span class="line"><span class="comment">    另一个是QueryBuilders，其中包含了match、term、function_score、bool等各种查询</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></li><li><p>数据聚合：用来实现对数据的统计分析计算等</p></li></ul><h4 id="10-Spring-Security"><a href="#10-Spring-Security" class="headerlink" title="10 Spring Security"></a>10 Spring Security</h4><ul><li><p>继承<code>UserDetailsService</code>接口，重写<code>loadUserByUsername()</code>方法</p><ul><li><p>返回<code>UserDetails</code>对象</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/学成在线.assets/image-20240305102255518.png" alt="image-20240305102255518"></p></li></ul></li><li><p><code>DaoAuthenticationProviderCustom extends DaoAuthenticationProvider</code></p><ul><li>刚刚我们重写的<code>loadUserByUsername()</code>方法是由<code>DaoAuthenticationProvider</code>调用的</li><li>重写<code>additionalAuthenticationChecks()</code>里面会比对密码，但不是所有的登录方式都有密码</li><li>然后在<code>WebSecurityConfig extends WebSecurityConfigurerAdapter</code>中配置刚刚定义的 <code>DaoAuthenticationProvider</code></li></ul></li><li><p>OAuth2.0</p><ul><li>客户端请求资源拥有者授权</li><li>资源拥有者授权客户端，即用户授权目标网站访问自己的用户信息</li><li>目标网站携带授权码请求认证</li><li>认证通过，颁发令牌</li><li>目标网站携带令牌请求资源服务器，获取资源</li><li>资源服务器校验令牌通过后，提供受保护的资源</li></ul></li><li><p>JWT：</p><ul><li>好处：在认证服务颁发令牌给客户端后，客户端携带令牌请求其他服务的资源时，其他服务可以直接校验令牌合法性，无需再经过认证服务。</li><li>缺点：JWT令牌占用空间较大</li><li>无状态认证：用户身份信息存储在令牌中，服务端从JWT解析出用户信息</li><li>有状态认证：用户信息通过session存储在服务端</li><li>组成<ul><li>头部Header：令牌类型及使用的哈希算法</li><li>负载Payload：用户信息</li><li>签名Sugbature：根据密钥进行加密前两部分，防止篡改</li></ul></li></ul></li><li><p><code>SecurityContextHolder</code>获取当前访问的用户信息：<code>Authentication</code>对象</p><ul><li>原理：<code>ThreadLocal</code></li></ul></li><li><p>用户授权</p><ul><li>授权认证服务器<code>@EnableAuthorizationServer</code> ==&gt; 配置资源列表：<code>xuecheng-plus</code></li><li>资源服务器<code>@EnableResourceServer</code> ==&gt; 定义资源id：<code>xuecheng-plus</code></li><li>接口添加<code>@PreAuthorize(&quot;hasAuthority(&#39;权限标识符&#39;)&quot;)</code>即可</li><li>授权定义在<code>loadUserByUsername</code>方法中返回的<code>UserDetails</code>中，是一个<code>String</code>类型的数组</li><li>没有权限抛出<code>AccessDeniedException</code>在全局异常处理器中捕获即可</li></ul></li></ul><h4 id="11-验证码"><a href="#11-验证码" class="headerlink" title="11 验证码"></a>11 验证码</h4><ul><li><code>Kaptcha</code> </li></ul><h4 id="12-RabbitMQ"><a href="#12-RabbitMQ" class="headerlink" title="12 RabbitMQ"></a>12 RabbitMQ</h4><ul><li><p>异步通讯</p><p>&lt;img src=(<a href="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/学成在线.assets/image-20240306162652779.png">https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/学成在线.assets/image-20240306162652779.png</a>“ alt=”image-20240306162652779” style=”zoom:67%;” /&gt;</p></li><li></li></ul><h2 id="0-坑"><a href="#0-坑" class="headerlink" title="0 坑"></a>0 坑</h2><h4 id="1-StringUtils"><a href="#1-StringUtils" class="headerlink" title="1 StringUtils"></a>1 <code>StringUtils</code></h4><ul><li>StringUtils.isNotEmpty</li></ul><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/学成在线.assets/image-20240110155057659.png" alt="image-20240110155057659"></p><ul><li>会去掉<code>null</code>和<code>&quot;&quot;</code>两种情况，所以比 <code>... != null</code>好</li></ul><h4 id="2-跨域请求问题"><a href="#2-跨域请求问题" class="headerlink" title="2 跨域请求问题"></a>2 跨域请求问题</h4><ul><li><p>从一个地址请求到另一个地址：协议、端口、主机三者有一个不一致就属于跨域</p><ul><li>端口的跨域</li><li>主机的跨域</li><li>协议的跨域：<code>http</code>和<code>https</code></li></ul></li><li><p>解决一：利用script跨域跨域的特性解决</p></li><li><p>解决二：服务端添加响应头</p><ul><li><p>服务端收到请求判断这个origin是否允许跨域，如果允许则在响应头中说明允许该来源的跨域请求：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Access-Control-Allow-Origin:http//localhost:8601</span><br></pre></td></tr></table></figure></li><li><p>允许任何域名来源跨域</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Access-Control-Allow-Origin:*</span><br></pre></td></tr></table></figure></li><li><p>定义一个<code>GlobalCorsConfig</code>类</p></li></ul></li><li><p>解决三：通过nginx代理跨域</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/学成在线.assets/image-20240110165247455.png" alt="image-20240110165247455"></p></li></ul><h4 id="3-开热点会占用端口！"><a href="#3-开热点会占用端口！" class="headerlink" title="3 开热点会占用端口！"></a>3 开热点会占用端口！</h4><h4 id="4-maven-3-6-1"><a href="#4-maven-3-6-1" class="headerlink" title="4 maven 3.6.1"></a>4 maven 3.6.1</h4><ul><li>maven版本对项目也是有影响的</li></ul><h4 id="5-nginx"><a href="#5-nginx" class="headerlink" title="5 nginx"></a>5 nginx</h4><ul><li><p>设置最大上传文件大小，默认是1M</p><p>&lt;img src=(<a href="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/学成在线.assets/image-20240304144704820.png">https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/学成在线.assets/image-20240304144704820.png</a>“ alt=”image-20240304144704820” style=”zoom:67%;” /&gt;</p></li></ul><h2 id="1-nacos"><a href="#1-nacos" class="headerlink" title="1 nacos"></a>1 nacos</h2><ul><li>Spring Cloud：一套规范</li><li>Spring Cloud alibaba：nacos服务注册中心、配置中心</li></ul><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><ul><li>namespace：用于区分环境，比如开发环境、测试环境、生产环境</li><li>group：用于区分项目</li></ul><h3 id="实现nacos上报服务步骤"><a href="#实现nacos上报服务步骤" class="headerlink" title="实现nacos上报服务步骤"></a>实现nacos上报服务步骤</h3><ul><li><p>启动虚拟机，然后启动docker容器</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl start docker</span><br></pre></td></tr></table></figure><p>随后访问<a href="http://192.168.71.22:8848即可">http://192.168.71.22:8848即可</a></p></li><li><p>在父工程上添加<code>spring-cloud-alibaba-dependencies</code>依赖</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/学成在线.assets/image-20240114103338764.png" alt="image-20240114103338764"></p></li><li><p>在子模块上添加依赖用于上报信息（谁需要启动就上报谁）</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/学成在线.assets/image-20240114103739675.png" alt="image-20240114103739675"></p></li><li><p>在子模块的配置文件中配置nacos信息</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/学成在线.assets/image-20240114104508191.png" alt="image-20240114104508191"></p></li><li><p>坑</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/学成在线.assets/image-20240114125029189.png" alt="image-20240114125029189"></p></li></ul><h3 id="实现nacos配置中心"><a href="#实现nacos配置中心" class="headerlink" title="实现nacos配置中心"></a>实现nacos配置中心</h3><ul><li><p>好处：不用重启就可以修改配置、多服务的时候配置集中</p></li><li><p>配置分类</p><ul><li>项目特有的配置</li><li>公共的配置</li></ul></li><li><p>nacos如何定位一个具体的配置文件</p><ul><li><p>通过namespace、group找到具体的环境和具体的项目</p></li><li><p>通过dataid找到具体的配置文件，dataid组成</p><ul><li><p><code>(content-setrvice)-(dev).(yaml)</code>：<code>服务名-环境名.yaml</code></p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/学成在线.assets/image-20240114125655369.png" alt="image-20240114125655369"></p></li></ul></li></ul></li><li><p>在nacos中创建好配置</p><ul><li><p>根据上述起：dataid，以及group</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/学成在线.assets/image-20240114131013547.png" alt="image-20240114131013547"></p></li><li><p>随后写入配置并发布</p></li></ul></li><li><p>服务中引入依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-config<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><p>坑</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--不引入这个依赖会报错找不到类：com.alibaba.nacos.client.logging.NacosLogging--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.nacos<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>nacos-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.4.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--不引入这个依赖会报错找不到类：com/alibaba/spring/util/PropertySourcesUtils--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.spring<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context-support<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>配置扩展：读取别的配置信息</p><ul><li>在content-api中配置引入content-service的配置</li></ul><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/学成在线.assets/image-20240114135844607.png" alt="image-20240114135844607"></p></li><li><p>公共配置：读取公共配置信息</p><ul><li>在nacos中分别创建<code>swagger-dev.yaml</code>与<code>loggin-dev.yaml</code>均属于<code>xuecheng-plus-common</code>组</li></ul><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/学成在线.assets/image-20240114140720353.png" alt="image-20240114140720353"></p></li><li><p>优先级</p><ul><li>项目应用名配置文件&gt;扩展配置文件&gt;共享配置文件&gt;本地配置文件 </li></ul></li><li><p>如何让本地优先？（场景：本地想多端口启动同一个服务）</p><ul><li><p>修改远程配置文件</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/学成在线.assets/image-20240114141638717.png" alt="image-20240114141638717"></p></li><li><p>然后启动的时候添加VM参数：</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/学成在线.assets/image-20240114141706783.png" alt="image-20240114141706783"></p></li></ul></li></ul><h2 id="2-分布式文件系统"><a href="#2-分布式文件系统" class="headerlink" title="2 分布式文件系统"></a>2 分布式文件系统</h2><ul><li><p>将若干计算机通过网络连接共同提供文件存储服务</p></li><li><p>NFS</p></li><li>GFS</li><li>HDFS</li><li><p>云计算厂家</p><ul><li>阿里云对象存储服务(OSS)</li></ul></li><li><p>MinIO</p><ul><li>使用了纠删码技术</li><li><a href="https://www.minio.org.cn/">https://www.minio.org.cn/</a> </li><li><a href="https://www.minio.org.cn/docs/">https://www.minio.org.cn/docs/</a> </li></ul></li></ul><h2 id="3-媒资管理服务"><a href="#3-媒资管理服务" class="headerlink" title="3 媒资管理服务"></a>3 媒资管理服务</h2><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/学成在线.assets/image-20240115131858362.png" alt="image-20240115131858362"></p><h3 id="3-1-上传图片（MinIO）"><a href="#3-1-上传图片（MinIO）" class="headerlink" title="3.1 上传图片（MinIO）"></a>3.1 上传图片（MinIO）</h3><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/学成在线.assets/image-20240115132057535.png" alt="image-20240115132057535"></p><ul><li>前端进入上传图片界面</li><li>上传图片，请求媒资管理服务</li><li>媒资管理服务将图片文件存储在MinIO</li><li>媒资管理记录文件信息到数据库</li><li>保存课程信息，在内容管理数据库保存图片地址</li></ul><h3 id="3-2-上传视频（断点续传）"><a href="#3-2-上传视频（断点续传）" class="headerlink" title="3.2 上传视频（断点续传）"></a>3.2 上传视频（断点续传）</h3><ul><li><p>断点续传：将上传和下载功能分为多个部分，防止中途断网导致的重新下载和上传文件</p></li><li><p>实现：文件分块</p><ul><li><p>前端上传前先把文件分成块</p></li><li><p>一块一块的上传，上传中断后重新上传。已上传的分块则不用再上传</p></li><li><p>各分块上传完成后，在服务端合并文件</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/学成在线.assets/image-20240115152036661.png" alt="image-20240115152036661"></p></li></ul></li><li><p>具体流程</p><ol><li>前端上传文件前，请求媒资接口层检查文件是否存在<ul><li>若存在，则不再上传</li><li>若不存在，则开始上传，首先对视频文件进行分块</li></ul></li><li>前端分块进行上传，上传前首先检查分块是否已经存在<ul><li>若分块已存在，则不再上传</li><li>若分块不存在，则开始上传分块</li></ul></li><li>前端请求媒资管理接口层，请求上传分块</li><li>接口层请求服务层上传分块</li><li>服务端将分块信息上传到MinIO</li><li>前端将分块上传完毕，请求接口层合并分块</li><li>接口层请求服务层合并分块</li><li>服务层根据文件信息找到MinIO中的分块文件，下载到本地临时目录，将所有分块下载完毕后开始合并</li><li>合并完成后，将合并后的文件上传至MinIO</li></ol></li><li><p>相关问题</p></li></ul><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/学成在线.assets/image-20240115211313009.png" alt="image-20240115211313009"></p><h3 id="3-3-视频转码（XXL-JOB）"><a href="#3-3-视频转码（XXL-JOB）" class="headerlink" title="3.3 视频转码（XXL-JOB）"></a>3.3 视频转码（XXL-JOB）</h3><ul><li><p>转换视频编码</p><ul><li><p>ffmpeg：转码工具</p></li><li><p>目标：<code>.avi</code>转<code>.mp4</code></p></li></ul></li></ul><h4 id="分布式任务处理"><a href="#分布式任务处理" class="headerlink" title="分布式任务处理"></a>分布式任务处理</h4><ul><li>视频上传成功需要对视频格式进行处理，如何用Java程序对视频进行处理呢？<ul><li>这里有一个关键的需求就是：当视频比较多的时候，我们如何高效的处理</li></ul></li><li>如何去高效的处理一批任务呢？<ul><li>多线程<ul><li>多线程是充分利用单机的资源</li></ul></li><li>分布式+多线程<ul><li>充分利用多台计算机，每台计算机使用多线程处理</li></ul></li></ul></li><li>方案2的可扩展性更强，同时方案二也是一种分布式任务调度的处理方案</li></ul><ul><li>JDK也为我们提供了相关支持，如Timer、ScheduledExecutor<ul><li>缺点是不能胜任复杂的任务</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Timer</span> <span class="variable">timer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Timer</span>();</span><br><span class="line">    timer.schedule(<span class="keyword">new</span> <span class="title class_">TimerTask</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="comment">//<span class="doctag">TODO:</span> something</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, <span class="number">1000</span>, <span class="number">2000</span>); <span class="comment">// 1秒后开始调度，每2秒执行一次</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">ScheduledExecutorService</span> <span class="variable">service</span> <span class="operator">=</span> Executors.newScheduledThreadPool(<span class="number">10</span>);</span><br><span class="line">    service.scheduleAtFixedRate(</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="comment">//<span class="doctag">TODO:</span> something</span></span><br><span class="line">                System.out.println(<span class="string">&quot;todo something&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="number">1</span>, <span class="number">2</span>, TimeUnit.SECONDS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p><code>Quartz</code>: Quartz设计的核心类包括Job，Trigger以及Scheduler。</p><ul><li>Job负责定义需要执行的任务</li><li>Trigger负责设置调度策略</li><li>Scheduler将二者组装在一起，并触发任务开始执行</li></ul></li></ul><h4 id="XXL-Job"><a href="#XXL-Job" class="headerlink" title="XXL-Job"></a>XXL-Job</h4><ul><li><p><code>XXL-JOB</code>:是一个轻量级分布式任务调度平台，其核心设计是开发迅速、学习简单、轻量级、易扩展，现已开放源代码并接入多家公司线上产品线，开箱即用</p></li><li><p>官网：<a href="https://www.xuxueli.com/xxl-job/">https://www.xuxueli.com/xxl-job/</a></p></li><li><p>组成：调度中心、执行器、任务</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/学成在线.assets/image-20240115213145999.png" alt="image-20240115213145999"></p><ul><li>调度中心<ul><li>负责管理调度信息，按照调度配置发出调度请求，自身不承担业务代码</li><li>主要职责为执行器管理、任务管理、监控运维、日志管理等</li></ul></li><li>任务执行器<ul><li>负责接收调度请求并执行任务逻辑</li><li>主要职责是注册服务、任务执行服务（接收到任务后会放入线程池中的任务队列）、执行结果上报、日志服务等</li></ul></li><li>任务<ul><li>负责执行具体的业务逻辑</li></ul></li></ul></li><li><p>执行流程</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/学成在线.assets/image-20240115213223020.png" alt="image-20240115213223020"></p><ol><li>任务执行器根据配置的调度中心的地址，自动注册到调度中心</li><li>达到任务出发条件，调度中心下发任务</li><li>执行器基于线程池执行任务，并把执行结果放入内存队列、把执行日志写入日志文件中</li><li>执行器消费内存队列中的执行结果，主动上报给调度中心</li><li>当用户在调度中心查看任务日志，调度中心请求任务执行器，任务执行器读取任务日志文件并返回日志详情</li></ol></li><li><p>XXL-job部署</p><ul><li><p>首先下载XXL-JOB</p><ul><li>GitHub：<a href="https://github.com/xuxueli/xxl-job">https://github.com/xuxueli/xxl-job</a></li><li>GitEE：<a href="https://gitee.com/xuxueli0323/xxl-job">https://gitee.com/xuxueli0323/xxl-job</a></li><li>项目使用2.3.1版本： <a href="https://github.com/xuxueli/xxl-job/releases/tag/2.3.1">https://github.com/xuxueli/xxl-job/releases/tag/2.3.1</a></li></ul></li><li><p>使用IDEA打开项目</p><ul><li>xxl-job-admin：调度中心</li><li>xxl-job-core：公共依赖</li><li>xxj-job-executor-samples：执行器Sample示例<ul><li>xxl-job-executor-sample-springboot：SpringBoot版本，通过SpringBoot管理执行器</li><li>xxl-job-executor-sample-frameless：无框架版本</li></ul></li></ul></li><li><p>根据数据库脚本创建数据库，修改数据库连接信息和端口，启动xxl-job-admin，访问<a href="http://localhost:8080/xxl-job-admin/toLogin">http://localhost:8080/xxl-job-admin/toLogin</a></p><ul><li>账号密码：admin/123456</li></ul></li><li><p>启动成功之后，可以选择在Linux上运行</p><ul><li><p>使用maven命令，将xxl-job-admin打包，然后将其上传至Linux中，使用命令启动</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nohup java -jar /绝对路径/xxl-job-admin-2.3.1.jar &amp;</span><br></pre></td></tr></table></figure></li></ul></li></ul></li><li><p>执行器注册</p><ul><li><p>在网页上新建一个执行器</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/学成在线.assets/image-20240115214339070.png" alt="image-20240115214339070"></p></li><li><p>在媒资服务中添加依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.xuxueli<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>xxl-job-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>在nacos中配置</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/学成在线.assets/image-20240115214547214.png" alt="image-20240115214547214"></p></li><li><p>将示例工程下的配置类<code>XxlJobConfig</code> 拷贝到media-service工程下，该类中的属性就是获取配置文件中的配置得到的，同时提供了一个执行器的Bean</p></li></ul></li><li><p>执行任务</p><ul><li><p>拷贝<code>SampleXxlJob</code>到media-service项目的service/jobhandler包中</p></li><li><p>在调度中心注册任务</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/学成在线.assets/image-20240115220351208.png" alt="image-20240115220351208"></p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/学成在线.assets/image-20240115220414563.png" alt="image-20240115220414563"></p></li><li><p>最后在调度中心开启任务</p></li><li>调度中心的高级配置说明<ul><li>路由策略:有多个执行器的时候，选择让谁来执行，<ul><li>```<ul><li>FIRST（第一个）：固定选择第一个机器；<pre><code>  - LAST（最后一个）：固定选择最后一个机器；  - ROUND（轮询）：；  - RANDOM（随机）：随机选择在线的机器；  - CONSISTENT_HASH（一致性HASH）：每个任务按照Hash算法固定选择某一台机器，且所有任务均匀散列在不同机器上。  - LEAST_FREQUENTLY_USED（最不经常使用）：使用频率最低的机器优先被选举；  - LEAST_RECENTLY_USED（最近最久未使用）：最久未使用的机器优先被选举；  - FAILOVER（故障转移）：按照顺序依次进行心跳检测，第一个心跳检测成功的机器选定为目标执行器并发起调度；  - BUSYOVER（忙碌转移）：按照顺序依次进行空闲检测，第一个空闲检测成功的机器选定为目标执行器并发起调度；  - SHARDING_BROADCAST(分片广播)：广播触发对应集群中所有机器执行一次任务，同时系统自动传递分片参数；可根据分片参数开发分片任务；</code></pre><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br></pre></td><td class="code"><pre><span class="line">    - 子任务id：执行完这个任务后再执行的任务id</span><br><span class="line">    - 调度过期策略：</span><br><span class="line">    - 阻塞过期策略：</span><br><span class="line">    - 任务超时时间</span><br><span class="line">    - 失败重试次数</span><br><span class="line"></span><br><span class="line">- 分片广播</span><br><span class="line"></span><br><span class="line">  ![image-20240115221446082](https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/学成在线.assets/image-20240115221446082.png)</span><br><span class="line"></span><br><span class="line">  - 场景：</span><br><span class="line">    - 分片任务场景：10个执行器的集群来处理10w条数据，每台机器只需要处理1w条数据，耗时降低10倍</span><br><span class="line">    - 广播任务场景：广播执行器同时运行shell脚本、广播集群节点进行缓存更新等</span><br><span class="line">  - 所以广播分片方式不仅可以充分发挥每个执行器的能力，并且根据分片参数可以控制任务是否执行，最终灵活控制了执行器集群的分布式处理任务</span><br><span class="line"></span><br><span class="line">#### 作业分片方案</span><br><span class="line"></span><br><span class="line">- 任务添加成功后，对于要处理的任务，会添加到待处理任务表中，现在启动多个执行器实例去查询这些待处理任务，此时如何保证多个执行器不会重复执行任务？</span><br><span class="line"></span><br><span class="line">  - 每个执行器收到广播任务有两个参数，**分片序号**和**分片总数**。每个执行器从数据表取任务时，可以用`任务id`对`分片总数`取`模`，如果等于该执行器的分片序号，则执行此任务</span><br><span class="line"></span><br><span class="line">  ![image-20240116094226494](https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/学成在线.assets/image-20240116094226494.png)</span><br><span class="line"></span><br><span class="line">#### 保证任务不重复执行</span><br><span class="line"></span><br><span class="line">- 通过作业分片方案，保证了执行器之间分配的任务不重复执行</span><br><span class="line"></span><br><span class="line">  - 但是如果同一个执行器，在处理一个视频的时候，还没有处理完，此时调度中心又来了一次请求调度，为了不重复处理同一个视频，该怎么办？</span><br><span class="line"></span><br><span class="line">- 配置调度过期策略</span><br><span class="line"></span><br><span class="line">  ![image-20240116094341299](https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/学成在线.assets/image-20240116094341299.png)</span><br><span class="line"></span><br><span class="line">  - 选择忽略</span><br><span class="line"></span><br><span class="line">- 配置阻塞处理策略：就是当前执行器正在执行任务还没有结束时，调度中心又请求调度，此时该如何处理</span><br><span class="line"></span><br><span class="line">  ![image-20240116094429676](https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/学成在线.assets/image-20240116094429676.png)</span><br><span class="line"></span><br><span class="line">  - 选择`丢弃后续调度`，避免重复调度</span><br><span class="line"></span><br><span class="line">- 最后是保证任务的幂等性：对于数据的操作不论多少次，操作的结果始终是一致的。</span><br><span class="line">  - 执行器接收调度请求去执行任务，要有办法去判断该任务是否处理完成，如果处理完则不再处理，即使重复调度处理相同的任务也不能重复处理相同的视频。</span><br><span class="line">  - 幂等性的常用方案</span><br><span class="line">    - 数据库约束，例如：唯一索引、主键</span><br><span class="line">    - 乐观锁，长用户数据库，更新数据时根据乐观锁状态去更新</span><br><span class="line">    - 唯一序列号，操作传递一个唯一序列号，操作时判断与该序列号相等，则执行</span><br><span class="line">  - 这里我们在数据库视频处理表中**添加状态处理字段**，视频处理完成**更新状态为完成**，执行视频前判断状态是否完成，如果完成则不再处理</span><br><span class="line"></span><br><span class="line">#### 业务流程</span><br><span class="line"></span><br><span class="line">- 确定了分片方案，下面梳理视频上传以及处理的业务流程</span><br><span class="line"></span><br><span class="line">  ![image-20240116095127790](https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/学成在线.assets/image-20240116095127790.png)</span><br><span class="line"></span><br><span class="line">- 上传视频成功，向视频待处理表中添加记录，视频处理的详细流程如下</span><br><span class="line"></span><br><span class="line">  ![image-20240116094658382](https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/学成在线.assets/image-20240116094658382.png)</span><br><span class="line"></span><br><span class="line">  - 任务调度中心广播作业分片</span><br><span class="line"></span><br><span class="line">  - 执行器收到广播作业分片，从数据库读取待处理任务</span><br><span class="line"></span><br><span class="line">    ![image-20240116094821777](https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/学成在线.assets/image-20240116094821777.png)</span><br><span class="line"></span><br><span class="line">  - 执行器根据任务内容MinIO下载要处理的文件</span><br><span class="line"></span><br><span class="line">  - 执行器启动多线程去处理任务</span><br><span class="line"></span><br><span class="line">  - 任务处理完成，上传处理后的视频到MinIO</span><br><span class="line"></span><br><span class="line">  - 将更新任务处理结果，如果视频处理完成，除了更新任务处理结果之外，还要将文件的访问地址更新至任务处理表及文件中，最后将任务完成记录写入历史表</span><br><span class="line"></span><br><span class="line">#### 分布式锁</span><br><span class="line"></span><br><span class="line">- 为了保证任务不重复执行，需要加锁</span><br><span class="line"></span><br><span class="line">- 如果是多个执行器分布式部署，不能保证同一个视频只有一个执行器处理。现在要实现分布式环境下所有虚拟机中的线程去同步执行就需要让多个虚拟机去共用一个锁，虚拟机可以分布式部署，锁也可以分布式部署，如下图:</span><br><span class="line"></span><br><span class="line">  ![image-20240116104845403](https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/学成在线.assets/image-20240116104845403.png)</span><br><span class="line"></span><br><span class="line">- 虚拟机都去抢占同一个锁，锁是一个单独的程序提供加锁、解锁服务</span><br><span class="line">- 该锁不属于某个虚拟机，而是分布式部署，由多个虚拟机共享，这种锁叫**分布式锁**</span><br><span class="line">- 实现</span><br><span class="line">  - 基于数据库：利用数据库主键唯一的特点（**本次实现**）</span><br><span class="line">  - 基于redis：redis提供了分布式锁的实现方案，比如SETNX </span><br><span class="line">    - SETNX是去set一个不存在的key。多个线程设置同一个key只会有一个线程设置成功，设置成功的拿到锁</span><br><span class="line">  - 基于zookeeper：多线程向zookeeper创建一个子目录，只会有一个创建成功，谁创建成功谁拿到锁</span><br><span class="line"></span><br><span class="line">#### 面试tip</span><br><span class="line"></span><br><span class="line">- ![image-20240116142001860](https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/学成在线.assets/image-20240116142001860.png)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- ![image-20240116142334028](https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/学成在线.assets/image-20240116142334028.png)</span><br><span class="line"></span><br><span class="line">- ![image-20240116142518301](https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/学成在线.assets/image-20240116142518301.png)</span><br><span class="line"></span><br><span class="line">### 3.4 绑定媒资</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## 4 课程发布模块</span><br><span class="line"></span><br><span class="line">![image-20240116145059489](https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/学成在线.assets/image-20240116145059489.png)</span><br><span class="line"></span><br><span class="line">### 4.1 课程预览</span><br><span class="line"></span><br><span class="line">1. 教学机构用户在课程管理中可对该机构所管理的课程进行检索</span><br><span class="line">2. 点击某课程数据后的预览链接，即可对该课程进行预览，可以看到发布后的详情页面</span><br><span class="line">3. 点即课程目录中的具体章节，查看视频是否正常播放</span><br><span class="line"></span><br><span class="line">#### java模板引擎</span><br><span class="line"></span><br><span class="line">- 根据前面的数据模型分析，课程预览就是把课程的相关信息进行整合，在课程预览界面进行展示，课程预览界面与课程发布的课程详情界面一致，保证了教学机构人员发布前看到的是什么样，发布后也会看到什么样</span><br><span class="line"></span><br><span class="line">- 所以模板引擎就是`模板 + 数据 = 输出`。JSP页面就是模板，页面中嵌入的JSP标签就是数据，两者相结合输出HTML网页</span><br><span class="line">- 常用的Java模板引擎还有那些？</span><br><span class="line">  - JSP</span><br><span class="line">  - **Freemarker**:本项目采用</span><br><span class="line">  - Thymeleaf</span><br><span class="line">  - Velocity</span><br><span class="line"></span><br><span class="line">#### Freemarker</span><br><span class="line"></span><br><span class="line">- 引入依赖</span><br><span class="line"></span><br><span class="line">  ```xml</span><br><span class="line">  &lt;!-- Spring Boot 对结果视图 Freemarker 集成 --&gt;</span><br><span class="line">  &lt;dependency&gt;</span><br><span class="line">      &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;spring-boot-starter-freemarker&lt;/artifactId&gt;</span><br><span class="line">  &lt;/dependency&gt;</span><br></pre></td></tr></table></figure></li></ul></li></ul></li></ul></li></ul></li><li><p>nacos中的配置</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">freemarker:</span></span><br><span class="line">    <span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">cache:</span> <span class="literal">false</span>   <span class="comment">#关闭模板缓存，方便测试</span></span><br><span class="line">    <span class="attr">settings:</span></span><br><span class="line">      <span class="attr">template_update_delay:</span> <span class="number">0</span></span><br><span class="line">    <span class="attr">suffix:</span> <span class="string">.ftl</span>   <span class="comment">#页面模板后缀名</span></span><br><span class="line">    <span class="attr">charset:</span> <span class="string">UTF-8</span></span><br><span class="line">    <span class="attr">template-loader-path:</span> <span class="string">classpath:/templates/</span>   <span class="comment">#页面模板位置(默认为 classpath:/templates/)</span></span><br><span class="line">    <span class="attr">resources:</span></span><br><span class="line">      <span class="attr">add-mappings:</span> <span class="literal">false</span>   <span class="comment">#关闭项目中的静态资源映射(static、resources文件夹下的资源)</span></span><br></pre></td></tr></table></figure><ul><li>并在contente-api的resource目录下创建templates目录</li></ul></li><li><p>在contente-api的配置文件中引入nacos中远程配置</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/学成在线.assets/image-20240116145803347.png" alt="image-20240116145803347"></p></li><li><p>添加模板,在resource下创建templates目录（与配置文件中一致），添加test.ftl模板文件</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Hello World!<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">Hello $&#123;broski&#125;!</span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>Controller中添加方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/testfreemaker&quot;)</span></span><br><span class="line"><span class="keyword">public</span> ModelAndView <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">ModelAndView</span> <span class="variable">modelAndView</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ModelAndView</span>();</span><br><span class="line">    modelAndView.setViewName(<span class="string">&quot;test&quot;</span>);</span><br><span class="line">    modelAndView.addObject(<span class="string">&quot;broski&quot;</span>, <span class="string">&quot;Kyle&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> modelAndView;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>启动内容管理服务，访问<a href="http://localhost:53040/content/testfreemaker">http://localhost:53040/content/testfreemaker</a> ，屏幕输出<code>Hello Kyle!</code></p></li></ul><h4 id="部署门户网站"><a href="#部署门户网站" class="headerlink" title="部署门户网站"></a>部署门户网站</h4><h4 id="文件服务及视频播放"><a href="#文件服务及视频播放" class="headerlink" title="文件服务及视频播放"></a>文件服务及视频播放</h4><ul><li>见<a href="https://cyborg2077.github.io/2023/02/28/XuechengOnlinePart4/#%E6%96%87%E4%BB%B6%E6%9C%8D%E5%8A%A1%E5%99%A8">https://cyborg2077.github.io/2023/02/28/XuechengOnlinePart4/#%E6%96%87%E4%BB%B6%E6%9C%8D%E5%8A%A1%E5%99%A8</a></li></ul><h4 id="加入nginx"><a href="#加入nginx" class="headerlink" title="加入nginx"></a>加入nginx</h4><p>&lt;img src=(<a href="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/学成在线.assets/image-20240116203422988.png">https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/学成在线.assets/image-20240116203422988.png</a>“ alt=”image-20240116203422988” style=”zoom:50%;” /&gt;</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/学成在线.assets/image-20240116200235703.png" alt="image-20240116200235703"></p><h4 id="修改host"><a href="#修改host" class="headerlink" title="修改host"></a>修改host</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1 www.51xuecheng.cn 51xuecheng.cn ucenter.51xuecheng.cn teacher.51xuecheng.cn file.51xuecheng.cn group.51xuecheng.cn group1.xuecheng.com localhost</span><br></pre></td></tr></table></figure><h4 id="编写freemarker模板"><a href="#编写freemarker模板" class="headerlink" title="编写freemarker模板"></a>编写freemarker模板</h4><ul><li>文档：<a href="http://freemarker.foofun.cn/ref_directives.html">http://freemarker.foofun.cn/ref_directives.html</a></li></ul><h3 id="4-2-课程审核"><a href="#4-2-课程审核" class="headerlink" title="4.2 课程审核"></a>4.2 课程审核</h3><ol><li>学机构提交课程审核后，平台运营人员登录运营平台查询待审核的记录</li><li>具体审核的过程与课程预览的过程类似，运营人员查看课程信息、课程视频等内容</li><li>如果存在问题，则审核不通过，并附上审核不通过的原因供教学机构人员查看</li><li>如果课程内容没有违规信息且课程内容全面，则审核通过</li><li><p>课程审核通过后，教学机构发布课程成功</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/学成在线.assets/image-20240117100848288.png" alt="image-20240117100848288"></p></li></ol><ul><li><p>课程状态转移</p><p>&lt;img src=(<a href="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/学成在线.assets/image-20240117101213845.png">https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/学成在线.assets/image-20240117101213845.png</a>“ alt=”image-20240117101213845” style=”zoom:67%;” /&gt;</p></li></ul><ul><li>状态说明<ul><li>一门课程新增后，它的审核状态为<code>未提交</code>，发布状态为<code>未发布</code></li><li>课程信息编辑完成，教学机构人员进行<code>提交审核</code>操作，此时课程的审核状态为<code>已提交</code></li><li>当课程状态为<code>已提交</code>时，运营平台人员对课程进行审核</li><li>运营平台人员审核课程，结果有两个：审核通过、审核不通过</li><li>课程审核后不管状态是否通过，教学机构都可以再次修改课程并提交审核，此时课程状态为<code>已提交</code>，运营平台人员再次审核课程</li><li>课程审核通过，教学机构人员可以发布课程，发布成功后，课程的发布状态为<code>已发布</code></li><li>课程发布后，通过<code>下架</code>操作可以更改课程发布状态为<code>下架</code></li><li>课程下架后，通过<code>上架</code>操作可以再次发布课程，上架后课程发布状态为<code>发布</code></li></ul></li></ul><ul><li><p>问题：课程审核通过后再修改，运营人员审核课程和教学机构编辑课程操作的数据是同一份，此时就可能产生冲突，例如：运营人员正在审核时，教学机构把数据修改了</p><ul><li>为了解决这个问题，我们专门设计了一张课程与发布表<ul><li>提交课程审核，将课程基本信息、营销信息、课程计划汇总后，写入该表中。</li><li>课程审核人员从预发布表查询信息</li><li>课程审核通过执行课程发布，将课程预发布的信息写入课程发布表</li><li>提交审核课程后，必须等待课程审核完毕后，才可以再次提交课程（无论审核通过/不通过）</li></ul></li></ul></li><li><p>业务中的数据转移</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/学成在线.assets/image-20240117103008531.png" alt="image-20240117103008531"></p></li></ul><h3 id="4-3-课程发布"><a href="#4-3-课程发布" class="headerlink" title="4.3 课程发布"></a>4.3 课程发布</h3><ol><li>教学机构用户在课程管理中可对机构内课程进行检索</li><li>点击某课程数据后的发布连接，即可对该课程进行发布</li><li>课程发布后可通过课程搜索查询到的课程信息，查看课程的详细信息</li><li>点击课程搜索页中课程列表的某个课程，可以进入课程详情页</li></ol><ul><li><p>教学机构人员在课程审核通过后，即可发布课程，课程发布后会公开展示在网站上供学生查看、选课、学习</p><ul><li>如何去快速搜索课程？打开课程详情页面仍然去查询数据库可行吗？</li></ul></li><li><p>为了提高网站的速度需要将课程信息进行缓存，并且要将课程信息加入索引库方便搜索，下图显示了课程发布后课程信息的流转情况</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/学成在线.assets/image-20240117110214188.png" alt="image-20240117110214188"></p></li><li><p>操作</p><ul><li>向内容管理数据库的课程发布并存储课程发布信息</li><li>向Redis存储课程缓存信息</li><li>向Elasticsearch存储课程索引信息</li><li>请求分布式文件系统存储存储课程静态化页面（即htm页面），实现快速浏览课程详情页面</li></ul></li><li><p>问题：一次课程发布操作需要向数据库、Redis、Elasticsearch、MinIO写四份数据，这里存在<strong>分布式事务问题</strong></p></li></ul><h4 id="分布式事务"><a href="#分布式事务" class="headerlink" title="分布式事务"></a>分布式事务</h4><ul><li>本地事务：平时我们在程序中通过Spring去控制事务是利用数据库本身的事务特性来实现的，因此叫<code>数据库事务</code>，由于应用主要靠关系数据库来控制事务，而数据库通常和应用在同一个服务器，所以基于关系型数据库的事务又被称为<strong>本地事务</strong>。<ul><li>本地事务具有ACID四大特性<ul><li>原子性（Atomicity）：事务是一个不可分割的工作单位，事务中的操作要么全部成功，要么全部失败。</li><li>一致性（Consistency）：事务在执行前后必须保持数据的一致性，即满足业务逻辑和约束条件。</li><li>隔离性（Isolation）：事务之间不应相互干扰，每个事务都应该在独立的环境中执行，不受其他事务的影响。</li><li>持久性（Durability）：事务一旦提交，其对数据的修改就应该永久保存在数据库中，即使发生系统故障或崩溃也不会丢失。</li></ul></li></ul></li><li><p>现在的需求是：课程发布操作后，将数据写入数据库、Redis、ElasticSearch、MinIO四个地方，这四个地方已经不限制在一个数据库内，而是由四个分散的服务去提供，与这四个服务去通信需要网络通信，而网络存在不可到达性（例如突然断网），在这种分布式系统环境下，通过与不同的服务进行网络通信去完成事务，称之为<strong>分布式事务</strong></p></li><li><p><strong>CAP理论</strong>是一个分布式系统设计的重要理论，它指出一个分布式系统最多只能同时满足一致性（Consistency）、可用性（Availability）和分区容忍性（Partition tolerance）这三项中的两项。</p><ul><li>一致性是指所有节点访问同一份最新的数据副本</li><li>可用性是指每个请求都能得到响应</li><li>分区容忍性是指系统能够在网络分区的情况下继续运行。</li></ul></li><li>所以CAP中要么保证CP要么保证AP</li><li>CP的场景：满足C舍弃A，强调一致性<ul><li>跨行转账：一次转账请求要等待双方银行系统都完成整个事务才算完成，只要其中一个失败，另一方执行回滚操作</li><li>开户操作：在业务系统开户同时要在运营商开户，任何一方开户失败，该用户都不可使用新开账户，要满足一致性</li></ul></li><li>AP的场景：满足A舍弃C，强调可用性(<strong>较多</strong>)<ul><li>订单退款，今日退款成功，明日账户到账，只要用户可以接受在一定时间内到账即可</li><li>注册送积分，注册成功，积分在24小时内到账</li><li>支付短信通信，支付成功发短信，短信发送可以有延迟</li></ul></li><li><strong>BASE理论</strong>：基于AP，是Basically Available(基本可用)、Soft state(软状态)和 Eventually consistent (最终一致性)三个短语的缩写<ul><li>基本可用：当系统无法满足全部可用时，保证核心业务可用即可，比如一个外卖系统，到了饭点的时候系统并发量很高，此时要保证下单流程涉及的服务可用，其他服务暂不可用</li><li>软状态：可以存在中间状态，例如：微博的评论功能。当用户发表一条评论时，这条评论并不会立即同步到所有关注者的页面上，而是会先存储在缓存中，并逐渐传播到其他节点。这样就存在了一个中间状态，即某些用户可以看到这条评论，而某些用户还不能看到。</li><li>最终一致性：前面的软状态并不影响微博的整体可用性，用户仍然可以正常浏览和发表微博。最终，在一定时间内，所有关注者都能看到这条评论，达到了最终一致性。</li></ul></li></ul><h4 id="课程发布"><a href="#课程发布" class="headerlink" title="课程发布"></a>课程发布</h4><ul><li><p>课程发布的分布式事务控制：使用AP</p><ul><li><p>课程发布操作后，先更新数据库中的课程发布状态，更新后向Redis、ElasticSearch、MinIO写课程信息，只要在一定时间内最终成功写入数据即可</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/学成在线.assets/image-20240117113008428.png" alt="image-20240117113008428"></p><ol><li>在内容管理服务的数据库添加一个消息表（mq_message），消息表和课程发布表在同一个数据库</li><li>点击课程发布，通过本地事务向课程发布表写入课程发布信息，同时向消息表写入课程发布的信息，这两条记录需保证同时存在或者同时不存在</li><li>启动任务调度系统的定时调度，内容管理服务去定时扫描消息表的记录</li><li>当扫描到课程发布的消息时，即开始向Redis、ElasticSearch、MinIO完成同步数据的操作</li><li>同步数据的任务完成后删除消息表记录，并插入历史消息表</li></ol></li></ul></li><li><p>时序图</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/学成在线.assets/image-20240117113120291.png" alt="image-20240117113120291"></p></li></ul><h4 id="消息处理SDK"><a href="#消息处理SDK" class="headerlink" title="消息处理SDK"></a>消息处理SDK</h4><ul><li>课程发布操作执行后需要扫描消息表的记录，有关消息表处理的有哪些？<ul><li>增删改查</li></ul></li><li>&lt;img src=(<a href="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/学成在线.assets/image-20240117120836198.png">https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/学成在线.assets/image-20240117120836198.png</a>“ alt=”image-20240117120836198” style=”zoom:60%;” /&gt;</li></ul><ul><li><p>问题：如果在每个地方都实现一套针对消息定时扫描、处理的逻辑，基本上都是重复的，软件的复用性太低、成本太高</p></li><li><p>解决：将消息处理相关的逻辑做成一个通用的东西，将消息处理做成一个SDK工具包，相比较通用服务，不仅可以解决将消息处理通用化的需求，还可以降低成本</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/学成在线.assets/image-20240117120935111.png" alt="image-20240117120935111"></p></li><li><blockquote><p> 执行任务应该是SDK包含的功能吗？</p></blockquote><ul><li>拿课程发布任务举例，执行课程发布任务是要向Redis、索引库等同步数据，其他任务的执行逻辑是不同的，所以执行任务在SDK中不用实现，只需要提供一个抽象方法由具体的执行任务方去实现</li></ul></li><li><blockquote><p>如何保证任务的幂等性？</p></blockquote><ul><li>在视频处理章节介绍的视频处理的幂等性方案，这里可以采用类似方案<ul><li>任务执行完成后，从消息表删除</li><li>如果消息表的状态是完成或不存在，则无需执行</li></ul></li></ul></li><li><blockquote><p>如何保证任务不重复执行？</p></blockquote><ul><li>任务调度采用分片广播，根据分片参数去获取处理任务，配置调度过期策略为<code>忽略</code>，配置任务阻塞处理策略为<code>丢弃后续调度</code></li></ul></li><li><blockquote><p>根据消息表记录是否存在或消息表中的任务状态去保证任务的幂等性，但是如果一个任务旗下又分为好几个小任务，例如课程发布任务需要执行3个同步操作：存储课程到Redis、存储课程到索引库、存储课程页面到MinIO。如果其中一个小任务已经完成，也不应该去重复执行这个小任务，那么该如何设计呢？</p></blockquote><ul><li>将小任务作为任务的不同阶段，在消息表中设立阶段状态</li><li>每完成一个阶段，就在对应的阶段状态字段打上标记，即使大任务还没有完成，重新执行大任务时，也会跳过执行完毕了的小任务</li><li>这里设立更多个小任务阶段状态字段为冗余字段，以备不时之需（万一你一个大任务下有10个小任务呢）</li><li>不过这里4个小任务状态字段就够了</li></ul></li></ul><h4 id="页面静态化"><a href="#页面静态化" class="headerlink" title="页面静态化"></a>页面静态化</h4><ul><li>根据课程发布的操作流程，执行课程发布后要将课程详情信息页面静态化，生成html页面上传至文件系统</li></ul><blockquote><p>什么是页面静态化？</p></blockquote><ul><li>课程预览功能通过模板引擎技术在页面模板中填充数据，生成html页面。这个过程是当客户端请求服务器时，服务器才开始渲染生成html页面，最终响应给浏览器，这个过程支持并发是有限的</li><li>页面静态化则强调将生成的html页面的过程提前，提前使用模板引擎技术生成html页面，当客户端请求时，直接请求html页面，由于是静态页面，可以使用nginx、apache等高性能web服务器，并发性能高</li></ul><blockquote><p>什么时候能用页面静态化技术？</p></blockquote><ul><li>当数据变化不频繁，一旦生成静态页面很长一段时间内很少变化，此时可以使用页面静态化。</li><li>因为如果数据变化频繁，一旦改变就需要重新生成静态页面，导致维护静态页面的工作量很大</li><li>根据课程发布的也无需求，虽然课程发布后仍可以修改课程信息，但是需要经过课程审核，且修改频率不高，所以适合使用页面静态化</li></ul><h4 id="feign远程调用"><a href="#feign远程调用" class="headerlink" title="feign远程调用"></a>feign远程调用</h4><ul><li><p>content-service添加feign依赖</p></li><li><p>nacos中配置feign并在content-service配置文件中引入</p></li><li><p>编写<code>MultipartSupportConfig</code>类使feign支持<code>Mulipart</code></p></li><li><p>编写feign接口</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/学成在线.assets/image-20240117165530100.png" alt="image-20240117165530100"></p></li><li><p>启动类添加<code>@EnableFeignClients</code>注解</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/学成在线.assets/image-20240117165545746.png" alt="image-20240117165545746"></p></li><li><p>测试</p></li></ul><h4 id="熔断降级"><a href="#熔断降级" class="headerlink" title="熔断降级"></a>熔断降级</h4><ul><li><p>当微服务运行不正常，会导致无法正常调用微服务，此时会出现异常，如果这种异常不去处理，可能会导致雪崩效应</p></li><li><p>微服务的雪崩效应表现在服务与服务之间调用，当其中一个服务无法提供服务时，可能导致其他服务也挂掉。</p><ul><li><p>例如服务C调用服务B，服务B调用服务A，由于服务A异常导致服务B响应缓慢，最终导致服务A和服务B都不可用，而服务B不可用又导致服务C也不可用。</p></li><li><p>像这样由一个服务所引起的一连串的服务都无法提供服务，就是微服务的雪崩效应</p><p>&lt;img src=(<a href="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/学成在线.assets/image-20240117165655380.png">https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/学成在线.assets/image-20240117165655380.png</a>“ alt=”image-20240117165655380” style=”zoom:50%;” /&gt;</p></li></ul></li><li><blockquote><p>如何解决由于微服务异常所引起的雪崩效应呢？</p></blockquote><ul><li>采用<strong>熔断、降级</strong>的方法去解决</li></ul></li><li><p>熔断降级的相同点都是为了解决微服务系统崩溃的问题，但它们是两个不同的技术手段，两者又存在联系</p><ul><li><p><strong>熔断</strong>：当下游服务异常时，断开与上游服务的交互。它就相当于保险丝，下游服务异常触发了熔断，从而保证上游服务不受影响</p></li><li><p><strong>降级</strong>：当下游服务异常触发熔断后，上游服务就不再去调用异常的服务，而是执行降级处理逻辑，这个降级处理逻辑可以是本地的一个单独的方法</p><p>&lt;img src=(<a href="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/学成在线.assets/image-20240117165816743.png">https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/学成在线.assets/image-20240117165816743.png</a>“ alt=”image-20240117165816743” style=”zoom: 50%;” /&gt;</p></li><li><p>而这都是为了保护系统，熔断是当下服务异常时一种保护系统的手段，<strong>降级是熔断后上游服务处理熔断的方法</strong></p></li></ul></li><li><p>具体处理</p><ol><li><p>开启feign熔断保护，在feign-dev.yaml中配置</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/学成在线.assets/image-20240117165914647.png" alt="image-20240117165914647"></p></li><li><p>定义降级逻辑</p><ul><li>方式一：<strong>fallback</strong>。定义一个fallback类<code>MediaServiceClientFallback</code>，此类实现了<code>MediaServiceClient</code>接口</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 媒资管理服务远程调用接口</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@FeignClient(value = &quot;media-api&quot;, configuration = MultipartSupportConfig.class, fallback = MediaServiceClientFallback.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">MediaServiceClient</span> &#123;</span><br><span class="line">    <span class="meta">@RequestMapping(value = &quot;/media/upload/coursefile&quot;, consumes = MediaType.MULTIPART_FORM_DATA_VALUE)</span></span><br><span class="line">    String <span class="title function_">upload</span><span class="params">(<span class="meta">@RequestPart(&quot;filedata&quot;)</span> MultipartFile upload,</span></span><br><span class="line"><span class="params">                <span class="meta">@RequestParam(value = &quot;folder&quot;, required = false)</span> String folder,</span></span><br><span class="line"><span class="params">                <span class="meta">@RequestParam(value = &quot;objectName&quot;, required = false)</span> String objectName)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MediaServiceClientFallback</span> <span class="keyword">implements</span> <span class="title class_">MediaServiceClient</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">upload</span><span class="params">(MultipartFile upload, String folder, String objectName)</span> &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;方式一：熔断处理，无法获取异常&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>缺点：无法获取熔断的异常信息</p><ul><li>方式二：<strong>fallbackFactory</strong>。由于方式一无法取出熔断所抛出的异常，而方式二定义MediaServiceClientFallbackFactory可以解决这个问题</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 媒资管理服务远程调用接口</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@FeignClient(value = &quot;media-api&quot;, configuration = MultipartSupportConfig.class, fallbackFactory = MediaServiceClientFallbackFactory.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">MediaServiceClient</span> &#123;</span><br><span class="line">    <span class="meta">@RequestMapping(value = &quot;/media/upload/coursefile&quot;, consumes = MediaType.MULTIPART_FORM_DATA_VALUE)</span></span><br><span class="line">    String <span class="title function_">upload</span><span class="params">(<span class="meta">@RequestPart(&quot;filedata&quot;)</span> MultipartFile upload,</span></span><br><span class="line"><span class="params">                <span class="meta">@RequestParam(value = &quot;folder&quot;, required = false)</span> String folder,</span></span><br><span class="line"><span class="params">                <span class="meta">@RequestParam(value = &quot;objectName&quot;, required = false)</span> String objectName)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MediaServiceClientFallbackFactory</span> <span class="keyword">implements</span> <span class="title class_">FallbackFactory</span>&lt;MediaServiceClient&gt; &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> MediaServiceClient <span class="title function_">create</span><span class="params">(Throwable throwable)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MediaServiceClient</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> String <span class="title function_">upload</span><span class="params">(MultipartFile upload, String folder, String objectName)</span> &#123;</span><br><span class="line">                log.debug(<span class="string">&quot;方式二：熔断处理，熔断异常：&#123;&#125;&quot;</span>, throwable.getMessage());</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>定义降级逻辑</p><ul><li>返回一个null对象，上游服务请求接口得到一个null，说明执行了降级处理</li></ul></li></ol></li></ul><h3 id="4-4-课程搜索"><a href="#4-4-课程搜索" class="headerlink" title="4.4 课程搜索"></a>4.4 课程搜索</h3><h4 id="es"><a href="#es" class="headerlink" title="es"></a>es</h4><p>参考文档：<a href="https://cyborg2077.github.io/2022/12/24/ElasticSearch/#RestAPI">https://cyborg2077.github.io/2022/12/24/ElasticSearch/#RestAPI</a></p><p>主要过程</p><ul><li><p>linux启动es，kibana（可视化管理）</p></li><li><p>创建mapping（类似于一个表，声明了有哪些列及属性）</p></li><li>转移到java项目中</li><li>初始化<code>RestHighLevelClient</code><ul><li>引入依赖</li><li>初始化RestHighLevelClient的Bean</li><li>使用</li></ul></li></ul><blockquote><p> RestHighLevelClient</p><ul><li>文档操作：<code>XxxIndexRequest</code>，Xxx是<code>Create、Get、Delete</code></li><li>文档搜索：Search API</li><li><code>QueryBuilder</code>用于构造搜索条件</li></ul></blockquote><h4 id="课程信息索引同步"><a href="#课程信息索引同步" class="headerlink" title="课程信息索引同步"></a>课程信息索引同步</h4><ul><li>方案<ul><li>Canal（实时性高）</li><li>消息队列（实时性不高）</li><li><strong>定时任务调度（xxlJob）</strong></li></ul></li><li>流程<ul><li>课程发布向消息表中插入记录</li><li>由任务调度程序通过消息处理SDK对消息记录进行处理</li><li>向es索引中保存课程信息</li></ul></li></ul><h2 id="5-认证授权模块"><a href="#5-认证授权模块" class="headerlink" title="5 认证授权模块"></a>5 认证授权模块</h2><h3 id="5-1-准备"><a href="#5-1-准备" class="headerlink" title="5.1 准备"></a>5.1 准备</h3><ul><li>认证授权模块实现平台所有用户的身份认证和用户授权功能</li></ul><blockquote><p>什么是用户身份认证？</p><ul><li>用户身份认证即当用户访问系统资源时，系统要求验证用户的身份信息，身份合法方可继续访问</li><li>常见的用户身份认证表现形式有<ul><li>用户名密码登录</li><li>微信扫码登录等</li></ul></li></ul><p>什么是用户授权？</p><ul><li>用户认证通过后去访问系统的资源，系统会判断用户是否拥有访问资源的权限，只允许访问有权限的系统资源，没有权限的资源将无法访问，这个过程叫用户授权。</li><li>例如用户去发布课程，系统首先进行用户身份认证，认证通过后继续判断用户是否有发布课程的权限<ul><li>如果没有权限，则拒绝继续访问系统</li><li>如果有权限，则继续发布课程</li></ul></li></ul></blockquote><ul><li><p>统一认证</p><ul><li><p>包括学生、学习机构的老师、平台运营人员三类用户，三类用户将使用统一的认证入口</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/学成在线.assets/image-20240118153738021.png" alt="image-20240118153738021"></p></li><li><p>认证通过由认证服务想用户颁发令牌，相当于访问系统的通行证，用户拿着令牌去访问系统的资源</p></li></ul></li><li><p>单点登录</p><ul><li>本项目基于微服务架构构建，微服务包括：内容管理服务、媒资管理服务、系统管理服务等。</li><li>为了提高用户的体验性，用户只需要依次认证，便可以在多个拥有访问权限的系统中访问，这个功能叫<strong>单点登录</strong></li><li>单点登录（Single Sign On），简称为 SSO，是目前比较流行的企业业务整合的解决方案之一。SSO的定义是在多个应用系统中，用户只需要登录一次就可以访问所有相互信任的应用系统。</li></ul></li><li><p>第三方认证</p><ul><li><p>为了提高用户体验，很多网站都具有扫码登录的功能，例如微信扫码登录、QQ扫码登录等</p></li><li><p>扫码登录的好处是用户不用输入账号密码，操作简便，而且有利于用户信息的共享。</p></li><li><p>互联网的优势就是资源共享，用户也是一种资源，对于一个新网站，如果让用户去注册是很困难的，如果提供了微信扫码登录，将省去用户的注册成本，是一种非常有效的推广方式。</p></li><li><p>微信扫码登录其中的原理正是使用了第三方认证，如下图</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/学成在线.assets/image-20240118153940987.png" alt="image-20240118153940987"></p></li></ul></li></ul><h4 id="Spring-Security认证"><a href="#Spring-Security认证" class="headerlink" title="Spring Security认证"></a>Spring Security认证</h4><ul><li><p>认证功能几乎是每个项目都要具备的功能，并且它与业务无关，市面上有很多认证框架，如Apache Shiro、CAS、<strong>Spring Security</strong>等</p></li><li><p>本项目是基于Spring Cloud技术构建，Spring Security是spring家族的一份子，且和Spring Cloud集成的很好，所以本项目采用Spring Security作为认证服务的技术框架</p></li><li><p>项目主页：<a href="https://spring.io/projects/spring-security">https://spring.io/projects/spring-security</a></p></li><li><p>SpringCloud Security：<a href="https://spring.io/projects/spring-cloud-security">https://spring.io/projects/spring-cloud-security</a></p></li><li><p><code>Spring Security</code>功能的实现主要是由一系列过滤器链相互配合完成的</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/学成在线.assets/image-20240118165200653.png" alt="image-20240118165200653"></p><ul><li><code>SecurityContextPresistenceFilter</code>：这个Filter是整个拦截过程的入口和出口（也就是第一个和最后一个拦截器），会在请求开始时从配置好的SecurityContextRepository中获取SecurityContext，然后把它设置给SecurityContextHolder，在请求完成后，将SecurityContextRepository持有的SecurityContext再保存到配置好的SecurityContextRepository，同时清楚SecurityContextHolder所持有的SecurityContext</li><li><code>UsernamePasswordAuthenticationFilter</code>：用于处理来自表单提交的认证，该表单必须提供对应的用户名和密码，其内部还有登录成功或失败后进行处理的AuthenticationSuccessHandler和AuthenticationFailureHandler，这些都可以根据需求做相关改变</li><li><code>FilterSecurityInterceptor</code>是用于保护web资源的，使用<code>AccessDecisionManager</code>对当前用户进行授权访问</li><li><code>ExeptionTranslationFilter</code>能够捕获来自<code>FilterChain</code>所有的异常，并进行处理。但是他只会处理两类异常：<code>AuthenticationException</code>和<code>AccessDeniedException</code>，其他的异常它会继续抛出</li></ul></li><li><p>执行流程</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/学成在线.assets/image-20240118164818741.png" alt="image-20240118164818741"></p></li></ul><h4 id="OAuth2协议"><a href="#OAuth2协议" class="headerlink" title="OAuth2协议"></a>OAuth2协议</h4><ul><li><p>前面我们提到的微信扫码认证，是一种第三方认证方式，这种认证方式是基于OAuth2协议实现的</p></li><li><p>OAuth2认证微信扫码登录的过程</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/学成在线.assets/image-20240118165833884.png" alt="image-20240118165833884"></p></li><li><p>具体流程如下</p><ul><li>用户点击微信扫码登录，微信扫码的目的是通过微信认证登录目标网站，目标网站需要从微信获取当前用户的身份信息才会让当前用户在目标网站登录成功<ul><li>首先搞清楚几个概念<ul><li><code>资源</code>：用户信息，在微信中存储</li><li><code>资源拥有者</code>：用户是用户信息资源的拥有者</li><li><code>认证服务</code>：微信负责认证当前用户的身份，负责为客户端颁发令牌</li><li><code>客户端</code>：客户端会携带令牌请求微信获取用户信息</li></ul></li></ul></li><li>用户授权网站访问用户信息<ul><li>资源拥有者扫描二维码，表示资源拥有者请求微信进行认证，微信认证通过向用户手机返回授权页面（让你确认登录）</li><li>询问用户是否授权目标网站访问自己在微信的用户信息，用户点击（确认登录）表示同意授权，微信认证服务器会颁发一个授权码给目标网站</li><li>只有资源拥有者同意，微信才允许目标网站访问资源</li></ul></li><li>目标网站获取到授权码</li><li>携带授权码请求微信认证服务器，申请令牌（此交互过程用户看不到）</li><li>微信认证服务器想目标网站响应令牌（此交互过程用户看不到）</li><li>目标网站携带令牌请求微信服务器获取用户的基本信息</li><li>资源服务器返回受保护资源，即用户信息</li><li>目标网站接收到用户信息，此时用户在目标网站登录成功</li></ul></li><li><p>OAuth2.0认证流程</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/学成在线.assets/image-20240118172128265.png" alt="image-20240118172128265"></p><ul><li><code>A</code>表示：客户端请求资源拥有者授权</li><li><code>B</code>表示：资源拥有者授权客户端，即用户授权目标网站访问自己的用户信息</li><li><code>C</code>表示：目标网站携带授权码请求认证</li><li><code>D</code>表示：认证通过，颁发令牌</li><li><code>E</code>表示：目标网站携带令牌请求资源服务器，获取资源</li><li><code>F</code>表示：资源服务器校验令牌通过后，提供受保护的资源</li></ul></li><li><p>OAuth 2.0包括以下角色</p><ol><li><p><code>客户端</code>：本身不存储资源，需要通过资源拥有者的授权去请求资源服务器的资源，例如：手机客户端、浏览器等</p></li><li><p><code>资源拥有者</code>：通常为用户，也可以是应用程序，即该资源的拥有者</p></li><li><p><code>授权服务器（认证服务器）</code>：认证服务器对资源拥有者进行认证，还会对客户端进行认证并颁发令牌</p></li><li><p><code>资源服务器</code>：存储资源的服务器</p></li></ol></li><li><p>在本项目的应用</p><ul><li>学成在线访问第三方系统的资源<ul><li>本项目要接入微信扫码登录，所以本项目要是用OAuth2协议访问微信中的用户信息</li></ul></li><li>外部系统访问学成在线的资源<ul><li>同样当第三方系统想要访问学成在线网站的资源，也可以基于OAuth2协议来访问用户信息</li></ul></li><li>学成在线前端（客户端）访问学成在线微服务的资源<ul><li>本项目是前后端分离架构，前端访问微服务资源也可以基于OAuth2协议</li></ul></li></ul></li><li><p>四种模式</p><ul><li><p>授权码模式（微信扫码）</p><p>&lt;img src=(<a href="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/学成在线.assets/image-20240118172500362.png">https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/学成在线.assets/image-20240118172500362.png</a>“ alt=”image-20240118172500362” style=”zoom:67%;” /&gt;</p></li><li><p>密码模式（也应用的多）</p><p>&lt;img src=(<a href="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/学成在线.assets/image-20240118172522851.png">https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/学成在线.assets/image-20240118172522851.png</a>“ alt=”image-20240118172522851” style=”zoom:67%;” /&gt;</p></li><li><p>简化模式</p></li><li><p>客户端模式</p></li></ul></li></ul><h4 id="JWT"><a href="#JWT" class="headerlink" title="JWT"></a>JWT</h4><ul><li><p>普通令牌问题</p><ul><li><p>客户端申请到令牌，接下来客户端携带令牌去访问资源，到资源服务器会校验令牌的合法性。<br>资源服务器如何校验令牌的合法性？这里以OAuth2的密码模式为例进行说明</p><p>&lt;img src=(<a href="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/学成在线.assets/image-20240119094718731.png">https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/学成在线.assets/image-20240119094718731.png</a>“ alt=”image-20240119094718731” style=”zoom:50%;” /&gt;</p></li><li><p>问题：校验令牌需要远程请求认证服务，客户端每次访问都会远程校验，<strong>执行性能低</strong></p></li><li><p>改进：</p><p>&lt;img src=(<a href="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/学成在线.assets/image-20240119094817784.png">https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/学成在线.assets/image-20240119094817784.png</a>“ alt=”image-20240119094817784” style=”zoom:50%;” /&gt;</p></li><li><p>如何解决上面的问题，实现资源服务自行校验令牌呢？</p><ul><li>令牌采用JWT格式即可解决上面的问题，用户认证后会得到一个JWT令牌，JWT令牌中已经包括了用户相关的信息，客户端只需要携带JWT访问资源服务，资源服务根据事先约定的算法自行完成令牌校验，无需每次都请求认证服务完成授权</li></ul></li></ul></li><li><p>Json Web Token（JWT）是一种使用Json格式传递数据的网络令牌技术，它是一个开放的行业标准（RFC 7519），它定义了一种简介的、自包含的协议格式，用于在通信双方传递Json对象，传递的对象经过数字签名可以被验证和信任，它可以是应用HMAC算法或使用RSA的公钥/私钥来签名，防止内容篡改<a href="https://jwt.io/">https://jwt.io/</a></p><ul><li>使用JWT可以实现无状态认证。什么是<code>无状态认证</code>？</li><li>传统的基于Session的方式是<code>有状态认证</code>，用户登录成功，将用户的身份信息存储在服务端，这样加大了服务端的存储压力，并且这种方式不适合在分布式系统中应用<ul><li>当用户访问应用服务，每个应用服务都会去服务器查看Session信息，如果没有Session，则认证用户没有登录，此时会重新认证，而解决这个问题的颁发是Session复制黏贴</li></ul></li><li>如果是基于令牌技术，用户，用户将令牌存储在客户端，去访问应用服务时携带令牌去访问，服务端从JWT解析出用户信息，这个过程就是无状态认证</li></ul></li></ul><ul><li>JWT令牌的优点<ul><li>JWT基于JSON，非常方便解析</li><li>可以在令牌中自定义丰富的内容，易扩展</li><li>通过非对称加密算法及数字签名技术，JWT防篡改，安全性高</li><li>资源服务使用JWT可不依赖认证服务即可完成授权</li></ul></li><li><p>缺点</p><ul><li>JWT令牌较长，占存储空间比较大</li></ul></li><li><p>JWT内容：有三部分，每部分中间使用点（.）分隔，例如xxxx.yyyyyy.zzzzzzz</p><ul><li><p>第一部分Header：头部包括令牌的类型（即JWT）及使用的哈希算法（如HMAC、SHA256或RSA），一个例子如下</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;alg&quot;</span><span class="punctuation">:</span> <span class="string">&quot;HS256&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;typ&quot;</span><span class="punctuation">:</span> <span class="string">&quot;JWT&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><ul><li>将上面的内容使用Base64Url编码，得到一个字符串就是JWT令牌的第一部分</li></ul></li><li><p>第二部分Payload：内容也是一个Json对象</p><ul><li><p>它是存放有效信息的地方，它可以存放JWT提供的现成字段，如iss（签发者）、exp（过期时间戳）、sub（面向的用户）等，也可以自定义字段</p></li><li><p>此部分不建议存放敏感信息，因为此部分可以解码还原原始内容</p></li><li><p>最后将第二部分负载使用Base64Url编码，得到一个字符串就是JWT令牌的第二部分</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;sub&quot;</span><span class="punctuation">:</span> <span class="string">&quot;1234567890&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;456&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;admin&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>第三部分：Sugbature：第三部分是签名，此部分用于防止JWT内容被篡改。</p><ul><li><p>这个部分使用Base64Url将前两部分进行编码，编码后使用点（.）连接组成字符串，最后使用Header中声明的签名算法进行签名</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">HMACSHA256(</span><br><span class="line">    base64UrlEncode(header) + <span class="string">&quot;.&quot;</span> +</span><br><span class="line">    base64UrlEncode(payload)<span class="punctuation">,</span></span><br><span class="line">    secret)</span><br></pre></td></tr></table></figure></li></ul></li></ul><blockquote><p>为什么JWT可以防止篡改？</p><ul><li>第三部分使用签名算法对第一部分和第二部分的内容进行签名，常见的签名算法是HS526，常见的还有MD5、SHA等，签名算法需要使用密钥进行签名，密钥不对外公开，并且签名是不可逆的，如果第三方更改了内容，那么服务器验证前面就会失败，要想保证签名正确，必须保证内容、密钥与签名前一致</li></ul></blockquote></li><li><p>JWT认证过程</p><p>&lt;img src=(<a href="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/学成在线.assets/image-20240119095547079.png">https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/学成在线.assets/image-20240119095547079.png</a>“ alt=”image-20240119095547079” style=”zoom:67%;” /&gt;</p><ul><li>从上图中可以看出，认证服务和资源服务使用相同的密钥，这叫对称加密，对称加密效率高，如果一旦密钥泄露可以伪造JWT令牌</li><li>JWT还可以使用非对称加密，认证服务自己保留私钥，将公钥下发给受信任的客户端、资源服务，公钥和私钥是配对的，成对的公钥和私钥才可以正常加密、解密，非对称加密效率低，但相比较于对称加密更加安全</li></ul></li></ul><h4 id="网关鉴定"><a href="#网关鉴定" class="headerlink" title="网关鉴定"></a>网关鉴定</h4><ul><li><p>加上网关后的过程</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/学成在线.assets/image-20240119105355848.png" alt="image-20240119105355848"></p></li><li><p>所有访问微服务的请求都要经过网关，在网关进行用户身份的认证，可以将很多非法的请求拦截到微服务以外，这叫做<strong>网关鉴权</strong></p></li><li><p>网关鉴权的职责</p><ul><li>网站白名单维护：针对不用认证的URL全部放行</li><li><p>校验JWT的合法性：除了白名单剩下的就是需要认证的请求，网关需要验证JWT的合法性，JWT合法则说明用户身份合法，否则说明身份不合法，拒绝继续访问</p></li><li><p>注意：<strong>网关不负责授权</strong>，对请求的授权操作在各个微服务进行，因为微服务最清楚用户有哪些权限访问哪些接口</p></li></ul></li><li><p>步骤</p><ul><li>在网关服务中引入依赖</li><li>网关过滤器</li><li>配置白名单</li><li>在微服务中放行所有请求</li></ul></li></ul><h3 id="5-2-用户认证"><a href="#5-2-用户认证" class="headerlink" title="5.2 用户认证"></a>5.2 用户认证</h3><ul><li><p>到目前为止，我们的用户认证流程如下</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/学成在线.assets/image-20240119110656791.png" alt="image-20240119110656791"></p></li><li><p>自定义<code>UserDetailsImpl implements UserDetailsService</code>读取数据库用户信息</p><ul><li>重写<code>loadUserByUsername()</code>方法</li></ul></li><li><p>扩展用户身份信息，在JWT令牌中存储用户的昵称、头像、QQ等信息</p><ul><li>说明：在认证阶段DaoAuthenticationProvider会调用UserDetailsService查询用户的信息，这里是可以获取到齐全的用户信息，由于JWT令牌中用户身份信息来源于UserDetails，UserDetails中仅定义了username为用户的身份信息，这里有两个思路</li><li>方法一：自定义<code>UserDetails</code> ，让它包括更多的自定义属性</li><li>方法二：扩展username的内容，例如存入Json数据作为username的内容</li></ul></li><li><p>资源服务获取用户身份</p><ul><li>根据返回的json内容转为一个java对象</li><li>在content-api中定义一个工具类来处理</li></ul></li></ul><h3 id="5-3-统一认证服务"><a href="#5-3-统一认证服务" class="headerlink" title="5.3 统一认证服务"></a>5.3 统一认证服务</h3><blockquote><p>基于当前研究的Spring Security认证流程如何支持多样化的认证方案呢？</p><ol><li>支持账号和密码认证<ul><li>采用OAuth2协议的密码模式即可实现</li></ul></li><li>支持手机号加验证码认证<ul><li>用户认证提交的是手机号和验证码，并不是账号和密码</li></ul></li><li>微信扫码认证<ul><li>基于OAuth2协议与微信交互，学成在线网站会向微信服务器申请一个令牌，然后携带令牌去微信查询用户信息，查询成功则用户在学成在线项目认证通过</li></ul></li></ol></blockquote><ul><li><p>而不同的认证提交方式的数据不一样，例如</p><ul><li>手机加验证码方式：会提交手机号和验证码</li><li>账号密码方式：会提交账号、密码、验证码</li></ul></li><li><p>解决：我们可以在<code>loadUserByUsername()</code>方法上做文章，将用户原来提交的账号数据改为提交一个JSON数据，JSON数据可以扩展不同的认证方式所提交的各种参数</p></li><li><p>步骤</p><ul><li><p>定义<code>AuthParamsDto</code>来接收认证参数（统一接收参数）</p></li><li><p>修改<code>UserDetailsImpl</code>的 <code>loadUserByUsername()</code>方法，让它解析接收的字符串为<code>AuthParamsDto</code>对象（之前就只是一个密码）</p></li><li>继承<code>DaoAuthenticationProvider</code>并重写<code>additionalAuthenticationChecks</code>方法</li><li>在<code>WebSecurityConfig</code>中注入</li><li>定义<code>AuthService</code>接口，不同的登录方式分别继承这个接口，重写<code>execute</code>方法（<strong>策略模式</strong>）</li><li>修改<code>UserDetailsImpl</code>的<code>loadUserByUsername</code>，根据输入参数转换的<code>AuthParamsDto</code>对象的<code>authType</code>方法来获取到spring容器的<code>AuthService</code>继承类的<code>bean</code>，调用<code>bean</code>的<code>execute</code>方法得到<code>XcUserExt</code>对象，随后转为Json返回（主要要把敏感信息置null，比如密码）</li></ul></li><li><p>总结：</p><ul><li>统一在一个地方登录</li><li>统一请求数据/认证参数</li><li>统一了认证接口</li></ul></li></ul><h3 id="5-4-验证码服务"><a href="#5-4-验证码服务" class="headerlink" title="5.4 验证码服务"></a>5.4 验证码服务</h3><ul><li>步骤<ul><li>请求生成验证码：<code>POST &#123;&#123;checkcode_host&#125;&#125;/checkcode/pic</code></li><li>返回一个json 包含<code>key</code>和<code>aliasing</code>两个字段，key表示验证码的key，aliasing是对应的图片，与此同时将key和对应的验证码字符串存入redis中，其中键就是key，值就是字符串</li><li>当用户进行验证码验证的时候，根据key向redis中取出字符串进行对比</li></ul></li></ul><h3 id="5-5-账号密码登录完善"><a href="#5-5-账号密码登录完善" class="headerlink" title="5.5 账号密码登录完善"></a>5.5 账号密码登录完善</h3><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/学成在线.assets/image-20240119144944164.png" alt="image-20240119144944164"></p><ul><li>前期准备完成</li><li>步骤<ul><li>定义远程调用验证码服务的接口</li><li>启动类添加开启Feign的注解</li><li>完善<code>PasswordAuthServiceImpl</code></li></ul></li></ul><h3 id="5-6-微信登录（与第三方接口对接）"><a href="#5-6-微信登录（与第三方接口对接）" class="headerlink" title="5.6 微信登录（与第三方接口对接）"></a>5.6 微信登录（与第三方接口对接）</h3><ul><li><p>接口文档：<a href="https://developers.weixin.qq.com/doc/oplatform/Website_App/WeChat_Login/Wechat_Login.html">https://developers.weixin.qq.com/doc/oplatform/Website_App/WeChat_Login/Wechat_Login.html</a></p></li><li><p>整体流程：</p><ol><li><p>第三方发起微信授权登录请求，微信用户允许授权第三方应用后，微信会拉起应用或重定向到第三方网站，并且带上授权临时票据 code 参数；</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/学成在线.assets/image-20240127154915000.png" alt="image-20240127154915000"></p></li><li><p>通过 code 参数加上 AppID 和AppSecret等，通过 API 换取access_token(令牌)；</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/学成在线.assets/image-20240127154903134.png" alt="image-20240127154903134"></p></li><li><p>通过access_token进行接口调用，获取用户基本数据资源或帮助用户实现基本操作。</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/学成在线.assets/image-20240127154843269.png" alt="image-20240127154843269"></p><p>&lt;img src=(<a href="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/学成在线.assets/image-20240119151437866.png">https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/学成在线.assets/image-20240119151437866.png</a>“ alt=”image-20240119151437866” style=”zoom:67%;” /&gt;</p></li></ol></li><li><p>结合本项目流程</p><p>&lt;img src=(<a href="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/学成在线.assets/image-20240119152008978.png">https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/学成在线.assets/image-20240119152008978.png</a>“ alt=”image-20240119152008978” style=”zoom:67%;” /&gt;</p></li></ul><blockquote><p>本项目认证服务需要做哪些事？</p><ol><li>需要定义接口接收微信下发的授权码</li><li>收到授权码调用微信接口申请令牌</li><li>申请到令牌后，调用微信获取用户信息</li><li>获取用户信息成功，将其写入本项目的用户信息数据库</li><li>重定向到浏览器自动登录</li></ol></blockquote><ul><li>需要一个内网穿透工具，不然微信服务无法找到本机的认证服务</li></ul><h3 id="5-7-授权"><a href="#5-7-授权" class="headerlink" title="5.7 授权"></a>5.7 授权</h3><ul><li>如何实现授权？业界通常基于RBAC实现授权</li></ul><h4 id="RBAC"><a href="#RBAC" class="headerlink" title="RBAC"></a>RBAC</h4><ul><li>两种方式<ul><li>基于角色的访问控制（Role-Based Access Control）：按角色进行授权<ul><li>缺点：当需要修改角色权限时，就需要修改授权相关的代码，系统可扩展性差</li></ul></li><li><strong>基于资源的访问控制</strong>（Resource-Based Access Control）：按资源/权限授权<ul><li>系统设计时定义好权限标识，修改角色的权限信息即可完成角色权限</li></ul></li></ul></li></ul><h4 id="资源服务授权流程"><a href="#资源服务授权流程" class="headerlink" title="资源服务授权流程"></a>资源服务授权流程</h4><ul><li><p>本项目在资源服务内部进行授权，基于资源的授权方式，因为接口在资源服务，通过在接口处添加授权注解实现授权</p></li><li><p>配置nginx</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">#前端开发服务</span><br><span class="line">upstream uidevserver&#123;</span><br><span class="line">    server 127.0.0.1:8601 weight=10;</span><br><span class="line">&#125; </span><br><span class="line">server &#123;</span><br><span class="line">    listen       80;</span><br><span class="line">    server_name  teacher.localhost;</span><br><span class="line">    ssi on;</span><br><span class="line">    ssi_silent_errors on;</span><br><span class="line">    location / &#123;</span><br><span class="line">        proxy_pass   http://uidevserver;</span><br><span class="line">        proxy_cookie_path / &quot;/; HTTPOnly; SameSite=strict&quot;;</span><br><span class="line">        proxy_cookie_domain uidevserver teacher.localhost;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    location /api/ &#123;</span><br><span class="line">        proxy_pass http://gatewayserver/;</span><br><span class="line"></span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>接口中使用：<code>@PreAuthorize(&quot;hasAuthority(&#39;权限标识符&#39;)&quot;)</code></p></li><li><p>原理：在令牌中有一个<code>authorities</code>字段表示用户的权限信息，然后去和<code>@PreAuthorize</code>注解中的权限进行对比，在权限范围则通过，否则拒绝</p></li></ul><h4 id="数据模型"><a href="#数据模型" class="headerlink" title="数据模型"></a>数据模型</h4><ul><li>如何给用户分配权限呢？查看数据库中的表结构<ul><li><code>xc_user</code>：用户表，存储了系统用户信息</li><li><code>xc_user_role</code>：用户角色表，一个用户可拥有多个角色，一个角色可被多个用户拥有<ul><li>关系表，用于连接<code>xc_user</code>和<code>xc_role</code></li></ul></li><li><code>xc_role</code>：角色表，存储了系统的角色类型，角色类型包括：学生、老师、管理员、教学管理员、超级管理员</li><li><code>xc_permission</code>：角色权限表，一个角色可拥有多个权限，一个权限可被多个角色拥有<ul><li>关系表，用于连接<code>xc_role</code>和<code>xc_menu</code>表</li></ul></li><li><code>xc_menu</code>：权限菜单表，里面记录了各种操作的权限code</li></ul></li></ul><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/学成在线.assets/image-20240122154644485.png" alt="image-20240122154644485"></p><ul><li>如何将用户的权限返回？<ul><li>UserDetails构建的时候加入<code>authorities</code>的修饰    </li></ul></li><li>查询用户权限</li></ul><h3 id="5-8-细粒度授权"><a href="#5-8-细粒度授权" class="headerlink" title="5.8 细粒度授权"></a>5.8 细粒度授权</h3><blockquote><p>什么叫细粒度授权？</p><ul><li>细粒度授权也叫数据范围授权，即不同的用户所拥有的的操作权限相同，但是能够操作的数据范围是不一样的。</li><li>例如：用户A和网易的，用户B是字节的，他们都拥有<code>我的课程</code>的权限，但他们查询到的数据是不一样的，因为不能查询别的机构的课程</li></ul><p>本项目有哪些细粒度授权？</p><ul><li>我的课程：教学机构只允许查询本机构下的课程信息</li><li>我的选课：学生只允许查询自己所选的课</li></ul><p>如何实现细粒度授权？</p><ul><li>细粒度授权涉及到不同的业务逻辑，通常在service层实现，根据不同的用户进行校验，根据不同的参数查询不同的数据，或操作不同的数据</li></ul></blockquote><p>实现</p><ul><li>教学机构在维护课程时，只允许维护本机构的课程，教学机构细粒度授权过程如下<ol><li>获取当前登录的用户身份</li><li>得到用户所属教育机构的id</li><li>查询该教学机构下的课程信息</li></ol></li><li>最终实现了用户只允许查询自己机构的课程信息</li><li>在之前的做法，我们是模拟了一个假数据，用的是一个写死的companyId</li><li>根据companyId查询课程，流程如下<ol><li>教学机构用户登录系统，从用户身份中取出所属机构的id</li><li>接口层取出当前登录用户的身份，取出机构id</li><li>将机构id传入service方法</li><li>service方法将机构id传入dao方法，作为SQL查询参数（where companyId = ${companyId}），最终查询出本机构的课程信息</li></ol></li></ul><h2 id="6-选课模块"><a href="#6-选课模块" class="headerlink" title="6 选课模块"></a>6 选课模块</h2><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/学成在线.assets/image-20240123091506763.png" alt="image-20240123091506763"></p><h3 id="6-1-学生选课"><a href="#6-1-学生选课" class="headerlink" title="6.1 学生选课"></a>6.1 学生选课</h3><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/学成在线.assets/image-20240123091707512.png" alt="image-20240123091707512"></p><ul><li><p>选课信息存入选课记录表</p><ul><li>如果选的是免费课程，除了要将信息存入选课记录表，同时也要存入我的课程表</li><li>如果选的是收费课程，将信息存入选课信息表后，要经过下单、支付成功后，才可以存入我的课程表</li></ul></li><li><p>选课记录表</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/学成在线.assets/image-20240123092901604.png" alt="image-20240123092901604"></p><ul><li>选课类型：免费课程、收费课程</li><li>选课状态：选课成功、待支付、选课删除</li><li>对于免费课程：课程价格为0，默认有效期为365天，开始服务时间为选课时间，结束服务时间为选课时间加一年后的时间，选课状态为选课成功</li><li>对于收费课程：按课程的现价、有效期确定开始服务时间、结束服务时间、选课状态为待支付</li><li>收费课程的选课记录需要支付成功后，选课状态为选课成功</li></ul></li><li><p>我的课程表</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/学成在线.assets/image-20240123092927497.png" alt="image-20240123092927497"></p><ul><li>对于免费课程：创建选课记录时，同时向我的课程表添加记录</li><li>对于收费课程：创建选课记录后，需要下单支付成功后，自动向我的课程表添加记录</li></ul></li><li><p>具体流程</p><p>&lt;img src=(<a href="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/学成在线.assets/image-20240123092958882.png">https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/学成在线.assets/image-20240123092958882.png</a>“ alt=”image-20240123092958882” style=”zoom:67%;” /&gt;</p></li></ul><h3 id="6-2-下单支付"><a href="#6-2-下单支付" class="headerlink" title="6.2 下单支付"></a>6.2 下单支付</h3><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/学成在线.assets/image-20240123091717092.png" alt="image-20240123091717092"></p><ul><li>流程（红色部分是订单支付模块完成）<ul><li>请求学习中心服务创建选课记录</li><li>请求订单服务创建商品订单、生成支付二维码</li><li>用户扫码请求订单支付服务，订单支付服务请求第三方支付平台生成支付订单</li><li>前端唤起支付客户端，用户输入密码完成支付</li><li>第三方支付平台支付完成后，发起支付通知</li><li>订单支付服务接收支付通知结果</li><li>用户在前端查询支付结果，请求订单支付服务查询支付结果，如果订单服务还没有收到支付结果，则请求学习中心查询支付结果</li><li>订单支付服务向学习中心通知支付结果</li><li>学习中心服务收到支付结果，如果支付成功则更新选课记录，并添加到我的课程表</li></ul></li></ul><h3 id="6-3-支付通知"><a href="#6-3-支付通知" class="headerlink" title="6.3 支付通知"></a>6.3 支付通知</h3><ul><li>支付服务通过消息队列将支付消息给学习服务</li></ul><blockquote><p>为什么不用feign？</p><ul><li>减少耦合</li></ul></blockquote><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/学成在线.assets/image-20240124095859634.png" alt="image-20240124095859634"></p><ul><li>订单服务作为通用服务，在订单支付成功后，需要将支付结果异步通知给其他微服务<ul><li>学习中心服务：对于收费课程，选课需要支付，与订单服务对接完成支付</li><li>学习资源服务：对于收费的学习资料，需要购买后才能下载，与订单服务对接完成支付</li></ul></li><li>本项目使用RabbitMQ，可以通过以下几个方面保证消息的可靠性<ol><li>生产者确认机制<ul><li>发送消息前，使用数据库事务将消息保证到数据库表中</li><li>成功发送到交换机，将消息从数据库中删除</li></ul></li><li>MQ持久化<ul><li>MQ收到消息会持久化，当MQ重启，即使消息没有消费完，也不会丢失</li><li>需要配置交换机持久化、队列持久化、发送消息时设置持久化</li></ul></li><li>消费者确认机制<ul><li>消费者消费成功，自动发送ACK，负责重试消费</li></ul></li></ol></li></ul><h3 id="6-4-学生学习"><a href="#6-4-学生学习" class="headerlink" title="6.4 学生学习"></a>6.4 学生学习</h3><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/学成在线.assets/image-20240123091726920.png" alt="image-20240123091726920"></p><ul><li>用户通过课程详情界面点击<code>马上学习</code>，进入视频播放页面进行视频点播</li><li>获取视频资源时，进行学习资格校验</li><li>拥有学习资格则继续播放视频，不具有学习资格，则引导其去购买、续期等操作</li></ul><blockquote><p>如何判断是否拥有学习资格?</p><ul><li>首先判断是否为试学视频，如果为试学视频，则可以正常学习</li><li>如果为非试学视频，则先判断用户是否登录，如果已经登录则判断是否选课，如果已经选课，且没有过期则可以正常学习</li></ul></blockquote><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/学成在线.assets/image-20240124111308158.png" alt="image-20240124111308158"></p><h3 id="6-5-我的课程表"><a href="#6-5-我的课程表" class="headerlink" title="6.5 我的课程表"></a>6.5 我的课程表</h3><h3 id="6-6-免费课程续期"><a href="#6-6-免费课程续期" class="headerlink" title="6.6 免费课程续期"></a>6.6 免费课程续期</h3><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/学成在线.assets/image-20240123091805261.png" alt="image-20240123091805261"></p><h2 id="7-支付模块"><a href="#7-支付模块" class="headerlink" title="7 支付模块"></a>7 支付模块</h2><ul><li><p>支付宝官方文档：<a href="https://opendocs.alipay.com/open/203/105285/">https://opendocs.alipay.com/open/203/105285/</a></p></li><li><p>配置沙箱环境</p></li><li><p>接口交互流程</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/学成在线.assets/image-20240123142722275.png" alt="image-20240123142722275"></p></li></ul><h3 id="7-1-接口测试"><a href="#7-1-接口测试" class="headerlink" title="7.1 接口测试"></a>7.1 接口测试</h3><p>查文档</p><h3 id="7-2-生成二维码"><a href="#7-2-生成二维码" class="headerlink" title="7.2 生成二维码"></a>7.2 生成二维码</h3><p>&lt;img src=(<a href="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/学成在线.assets/image-20240123162041937.png">https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/学成在线.assets/image-20240123162041937.png</a>“ alt=”image-20240123162041937” style=”zoom: 67%;” /&gt;</p><ul><li>流程<ul><li>前端调用学习中心服务的添加选课接口</li><li>添加选课成功，请求订单服务生成支付二维码接口</li><li>生成二维码接口：创建商品订单、生成支付交易记录、生成二维码</li><li>将二维码返回到前端，用户扫码</li></ul></li><li><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/学成在线.assets/image-20240123162549494.png" alt="image-20240123162549494"><ul><li>其中支付记录表的pay_no才是传给支付平台的订单号</li></ul></li></ul><blockquote><p>为什么创建支付交易记录？</p><ul><li><p>在请求微信或支付宝下单接口时，需要传入<code>商品订单号</code>，在与第三方交付平台对接时发现，当用户支付失败或因为其他原因导致该订单没有支付成功，此时再次调用第三方支付平台的下单接口就会报错<code>订单号已存在</code>。</p></li><li><p>但如果我们此时传入一个新的订单号就可以解决问题，但是商品订单已经创建，因此没有支付成功重新创建一个新订单是不合理的</p></li><li><p>解决以上问题的方案是</p><ol><li><p>用户每次发起都创建一个新的支付交易记录，此交易记录与商品订单关联</p></li><li><p>将支付交易记录的流水号传给第三方支付系统的下单接口，这样即使没有支付成功，也不会出现上面的问题</p></li><li><p>判断订单支付状态，提醒用户不要重复支付</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/学成在线.assets/image-20240123165044814.png" alt="image-20240123165044814"></p></li></ol></li></ul></blockquote><h2 id="8-项目部署"><a href="#8-项目部署" class="headerlink" title="8 项目部署"></a>8 项目部署</h2><ul><li><p><strong>DevOps</strong>（Development 和 Operations）</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/学成在线.assets/image-20240124154335446.png" alt="image-20240124154335446"></p></li><li><p><strong>CI/CD</strong>包含两个CI和两个CD</p><ul><li>持续集成</li><li>持续交付</li><li>持续部署</li></ul></li><li><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/学成在线.assets/image-20240124155500369.png" alt="image-20240124155500369"></p><ul><li>Kubernetes：k8s（中间有8个字母）</li><li>Jenkins</li></ul></li><li><p>环境准备</p><ul><li><p>Centos7虚拟机，安装docker、jdk、maven，通过docker容器安装jenkins、docker私服软件及其他软件</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/学成在线.assets/image-20240124160024156.png" alt="image-20240124160024156"></p></li></ul></li></ul><h3 id="手动部署"><a href="#手动部署" class="headerlink" title="手动部署"></a>手动部署</h3><ul><li><p>项目打包</p><ul><li><p>在parent项目的pom中聚合各个模块</p><p>&lt;img src=(<a href="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/学成在线.assets/image-20240124161607063.png">https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/学成在线.assets/image-20240124161607063.png</a>“ alt=”image-20240124161607063” style=”zoom:67%;” /&gt;</p></li><li><p>这样做的好处是之后编译的时候maven会自动识别依赖关系然后自动确定各个模块的打包顺序</p></li></ul></li><li><p>配置打包插件</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/学成在线.assets/image-20240124161810725.png" alt="image-20240124161810725"></p><ul><li><p>在要打可执行jar包的工程中配置该插件</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/学成在线.assets/image-20240124162321041.png" alt="image-20240124162321041"></p></li><li><p>说明</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/学成在线.assets/image-20240124162310357.png" alt="image-20240124162310357"></p></li></ul></li><li><p>package生成jar包，使用<code>java -jar</code>可以正常启动运行</p></li><li><p>然后传到linux中，并在文件夹中创建dockerfile文件用于构建镜像</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/学成在线.assets/image-20240124164245696.png" alt="image-20240124164245696"></p></li><li><p>使用docker build创建镜像</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build -t checkcode:<span class="number">1.0</span> .</span><br></pre></td></tr></table></figure><ul><li><code>-t checkcode:1.0</code>是指构建后的镜像名称</li><li>最后的 <code>.</code> 表示dockerfile文件在当前目录</li></ul></li><li><p>创建并启动容器</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="keyword">run</span><span class="language-bash"> --name xuecheng-plus-checkcode -p 63075:63075 -idt checkcode:1.0</span></span><br></pre></td></tr></table></figure></li><li><p>查看运行日志</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker logs -f xuecheng-plus-checkcode</span><br></pre></td></tr></table></figure></li></ul><h3 id="自动部署Jenkins"><a href="#自动部署Jenkins" class="headerlink" title="自动部署Jenkins"></a>自动部署Jenkins</h3><ul><li>修改需要启动的服务的pom文件</li><li>代码提交到git</li></ul><h2 id="9-项目优化"><a href="#9-项目优化" class="headerlink" title="9 项目优化"></a>9 项目优化</h2><ul><li><p>压力测试</p><ul><li><p>主要是测试需要直接查询数据库的地方，比如课程信息中的视频就是直接查数据库来的</p></li><li><p>吞吐量(TBS)：系统每秒可以处理的事务数</p></li><li>响应时间：指客户端请求数据，请求从系统到客户端的时间</li><li>每秒查询数(QPS)：一秒可以请求该接口查询商品信息的次数</li><li>错误率</li></ul></li><li><p>Jmeter软件</p></li></ul><h3 id="9-1-redis缓存优化"><a href="#9-1-redis缓存优化" class="headerlink" title="9.1 redis缓存优化"></a>9.1 redis缓存优化</h3><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/学成在线.assets/image-20240125104439596.png" alt="image-20240125104439596"></p><ul><li><p>实现</p><p>&lt;img src=(<a href="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/学成在线.assets/image-20240125104730079.png">https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/学成在线.assets/image-20240125104730079.png</a>“ alt=”image-20240125104730079” style=”zoom:67%;” /&gt;</p></li><li><p>缓存穿透问题</p><blockquote><p>使用缓存后，码的性能有了很大的提升，但是控制台还是打出了很多从数据库查询的日志，明明已经判断了如果缓存存在，课程信息就从缓存中查询，那为什么还有这么多从数据库查询的请求呢？</p><ul><li>因为并发数很高，很多线程会同时到达查询数据库代码处去执行</li><li>如果存在恶意攻击的可能，大量并发去查询一个不存在的课程信息会出现什么问题呢？</li></ul></blockquote><ul><li>大量并发去访问一个数据库不存在的数据，由于缓存中没有该数据，就会导致大量并发查询数据库，这个现象叫<strong>缓存穿透</strong></li><li>缓存穿透可以造成数据库瞬间压力过大，连接数等资源耗尽，最终数据库拒绝连接，不可用</li></ul></li><li><p>缓存穿透解决</p><ul><li>方式一：对请求增加校验极致</li><li>方式二：使用布隆过滤器</li><li>方式三：缓存空值或特殊值<ul><li>请求通过了第一步校验，查询数据库得到的数据不存在，此时我们仍然去缓存数据，缓存一个空值或一个特殊值的数据</li><li>注意：如果缓存了空值或特殊值，要设置一个短暂的过期时间</li></ul></li></ul></li><li><p>缓存雪崩</p><ul><li>缓存雪崩是缓存中大量key失效后，当高并发到来时导致大量请求到数据库，瞬间耗尽数据库资源，导致数据库无法使用</li><li>造成缓存雪崩问题的原因是大量key拥有了相同的过期时间<ul><li>例如：对课程信息设置缓存过期时间为10分钟，当大量请求同时查询大量课程信息时，由于大量课程拥有相同的过期时间，所以大量课程的缓存信息也会同时失效，出现缓存雪崩问题</li></ul></li></ul></li><li><p>解决缓存雪崩</p><ul><li><p>方法一：使用同步锁控制数据库的线程（性能不高）</p><ul><li><p>使用同步锁控制查询数据库的线程，只允许有一个线程去查询数据库，查询得到数据后存入缓存</p><p>&lt;img src=(<a href="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/学成在线.assets/image-20240125111225625.png">https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/学成在线.assets/image-20240125111225625.png</a>“ alt=”image-20240125111225625” style=”zoom:67%;” /&gt;</p></li></ul></li><li><p>方式二：对同一类型信息的key设置不同的过期时间</p><ul><li>通常对一类信息的key设置的过期时间是相同的，这里可以在原有的固定时间基础上，加上一个随机时间，从而使他们的过期时间不相同</li></ul></li><li><p>方式三：缓存预热</p><ul><li>不用等到请求到来再去查询数据库存入缓存，可以写一个定时任务，提前将数据存入缓存。使用缓存预热机制，通常有专门的后台程序去将数据库的数据同步到缓存中</li></ul></li></ul></li><li><p>缓存击穿</p><ul><li>缓存击穿是指大量并发访问同一个热点数据，当单例数据失效后，同时去请求数据库，瞬间耗尽数据库资源，导致数据库无法使用<ul><li>例如：某手机新品发布，此时手机数据存在缓存中，如果在秒杀的时候，缓存刚好失效，那么此时就会有大量请求直接访问数据库</li></ul></li></ul></li><li><p>如何解决</p><ul><li><p>方式一：使用同步锁控制查询数据库的线程，只允许有一个线程去查询数据库，查询得到的数据存入缓存</p></li><li><p>方式二：热点数据不过期</p><ul><li>可以由后台程序提前将热点数据加入缓存，缓存时间设置不过期，由后台程序做好缓存同步</li></ul></li></ul></li><li><p>总结：</p><ul><li><strong>缓存穿透</strong><ul><li>去访问一个<strong>数据库不存在</strong>的数据，无法将数据进行缓存，导致直接查询数据库，当并发较大时，就会对数据库产生压力。</li><li>缓存穿透可以造成数据库压力增大，连接数等资源用完，最终数据库拒绝连接不可用</li><li>解决方案<ol><li>缓存一个null值</li><li>布隆过滤器</li></ol></li></ul></li><li><strong>缓存雪崩</strong><ul><li>缓存中<strong>大量key失效</strong>后，当高并发到来时，导致大量请求到数据库，瞬间耗尽数据库资源，导致数据库无法使用</li><li>造成缓存雪崩问题的原因是大量key拥有了相同的过期时间</li><li>解决方案：<ol><li>使用同步锁控制</li><li>设置不同的过期时间，例如：使用固定数+随机数作为过期时间</li></ol></li></ul></li><li><strong>缓存击穿</strong><ul><li>大量并发<strong>访问同一个热点数据</strong>，当热点数据失效后，同时去请求数据库，瞬间耗尽数据库资源，导致数据库无法使用</li><li>解决方案<ol><li>使用同步锁控制</li><li>设置key永不过期</li></ol></li></ul></li></ul></li></ul><h3 id="9-2-分布式锁"><a href="#9-2-分布式锁" class="headerlink" title="9.2 分布式锁"></a>9.2 分布式锁</h3><ul><li>本地锁的问题<ul><li>上面的程序中使用了同步锁来解决缓存击穿、缓存雪崩的问题，保证同一个key过期后，只会查询一次数据库，但如果将同步锁的程序，分布式部署在多个jvm上，则无法保证同一个key只会查询一次数据库</li></ul></li></ul><blockquote><p>什么是分布式锁?</p><p>本地锁只能控制所在JVM中的线程同步执行，现在要实现分布式环境下所有虚拟机中的线程去同步执行，就需要让多个JVM使用同一把锁，JVM可以分布式部署，锁也可以分布式部署</p><ul><li>该锁不属于某个虚拟机，而是分布式部署，由多个虚拟机共享，这种锁叫<strong>分布式锁</strong></li></ul></blockquote><ul><li><p>分布式锁的实现方案</p><ul><li>基于数据库实现分布式锁<ul><li>利用数据库主键唯一的特性，或利用数据库唯一索引的特点，多个线程同时去插入相同的记录，谁插入成功谁就抢到锁</li></ul></li><li>基于Redis实现分布式锁<ul><li>Redis提供了分布式锁的实现方案，例如：SETNX、Redisson等</li><li>拿SETNX举例，SETNX是set一个不存在的key（set if not exists），多个线程去设置同一个key，只会有一个线程设置成功，设置成功的线程拿到锁</li></ul></li><li>使用zookeeper实现<ul><li>zookeeper是一个分布式协调事务，主要解决分布式程序之间的同步问题</li><li>zookeeper的结构类似文件目录，多线程向zookeeper创建一个子目录（节点）只会有一个创建成功，可以利用此特点实现分布式锁，谁创建该节点成功，谁就获得锁</li></ul></li></ul></li><li><p>SETNX实现分布式锁</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/学成在线.assets/image-20240125112747380.png" alt="image-20240125112747380"></p><ul><li><p>如何释放锁</p><ol><li><p>key到期自动释放</p><ul><li>因为锁设置了过期时间，key到期会自动释放，但是会存在一个问题：查询数据库时，还没操作完，key就到期了</li><li>由于key到期了，就会导致其他线程也拿到了锁，最终重复查询数据库，执行了重复的业务操作</li><li>怎么解决这个问题？可以将key的到期时间设置的长一些，足以完成查询数据库并设置缓存等相关操作。但是这个效率会低一些，而且到期时间也不好把握</li></ul></li><li><p>手动删除锁</p><ul><li><p>如果是采用手动删除锁，可能和key到期自动删除有冲突，造成删除了别人的锁</p></li><li><p>例如：查询数据库等业务还没执行完，此时key过期了，别的线程又拿到锁进来了，当上一个线程执行完查询数据库业务之后，手动删除锁，把新进来的线程的锁给删了</p></li><li><p>要解决这个问题，可以在删除锁之前，判断这个锁是不是自己的，伪代码如下</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/学成在线.assets/image-20240125112949438.png" alt="image-20240125112949438"></p><ul><li>上述代码10~13行非原子性，也会导致删除其他线程的锁</li><li>想实现原子性，需要让redis去执行Lua脚本的方式去实现，这样就具有原子性，但是过期时间的值设置还存在不精准的问题</li></ul></li></ul></li></ol></li></ul></li><li><p>Redisson实现分布式锁(碾压setnx)</p><ul><li><p>Redisson相比SETNX实现分布式锁要简单的多，其工作原理如下</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/学成在线.assets/image-20240125115024195.png" alt="image-20240125115024195"></p></li><li><p>加锁机制</p><ul><li>线程去获取锁，获取成功：执行lua脚本，保存数据到redis</li><li>线程去获取锁，获取失败：一致通过while循环常事获取锁，获取成功后，执行lua脚本，保存数据到redis</li></ul></li><li>WatchDog自动延期<ul><li>第一种情况：在一个分布式环境下，假如一个线程获得锁后，突然服务器宕机了，那么这个时候在一定时间后这个锁会自动释放，你也可以设置锁的有效时间(当不设置默认30秒时），这样的目的主要是防止死锁的发生</li><li>第二种情况：线程A业务还没有执行完，时间就过了，线程A 还想持有锁的话，就会启动一个watch dog后台线程，不断的延长锁key的生存时间。</li></ul></li><li>Lua脚本保证原子性操作<ul><li>主要是如果你的业务逻辑复杂的话，通过封装在lua脚本中发送给redis，而且redis是单线程的，这样就保证这段复杂业务逻辑执行的原子性</li></ul></li><li>具体使用RLock操作分布式锁，RLock继承了JDK的Lock接口，所以他有Lock接口的所有特性，例如：lock、unlock、tryLock等特性，同时它还有很多新特性：强制锁释放、带有效期的锁</li></ul></li></ul><h2 id="10-项目总结"><a href="#10-项目总结" class="headerlink" title="10 项目总结"></a>10 项目总结</h2><h3 id="10-1-项目开发技术点"><a href="#10-1-项目开发技术点" class="headerlink" title="10.1 项目开发技术点"></a>10.1 项目开发技术点</h3><h4 id="1-接口开发"><a href="#1-接口开发" class="headerlink" title="1 接口开发"></a>1 接口开发</h4><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/学成在线.assets/image-20240125122018593.png" alt="image-20240125122018593"></p><h4 id="2-异常处理"><a href="#2-异常处理" class="headerlink" title="2 异常处理"></a>2 异常处理</h4><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/学成在线.assets/image-20240125122006876.png" alt="image-20240125122006876"></p><h4 id="3-前后端联调"><a href="#3-前后端联调" class="headerlink" title="3 前后端联调"></a>3 前后端联调</h4><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/学成在线.assets/image-20240125122048035.png" alt="image-20240125122048035"></p><h4 id="4-解决接口跨域问题"><a href="#4-解决接口跨域问题" class="headerlink" title="4 解决接口跨域问题"></a>4 解决接口跨域问题</h4><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/学成在线.assets/image-20240125122201913.png" alt="image-20240125122201913"></p><ul><li><p>解决</p><ul><li><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/学成在线.assets/image-20240125122215575.png" alt="image-20240125122215575"></p></li><li><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/学成在线.assets/image-20240125122229930.png" alt="image-20240125122229930"></p></li><li><p>nginx代理</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/学成在线.assets/image-20240125122359139.png" alt="image-20240125122359139"></p></li></ul></li></ul><h4 id="5-微服务之间的接口调用"><a href="#5-微服务之间的接口调用" class="headerlink" title="5 微服务之间的接口调用"></a>5 微服务之间的接口调用</h4><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/学成在线.assets/image-20240125122422531.png" alt="image-20240125122422531"></p><ul><li><p>熔断降级</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/学成在线.assets/image-20240125122435089.png" alt="image-20240125122435089"></p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/学成在线.assets/image-20240125122442244.png" alt="image-20240125122442244"></p><h4 id="6-微服务雪崩"><a href="#6-微服务雪崩" class="headerlink" title="6 微服务雪崩"></a>6 微服务雪崩</h4></li></ul><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/学成在线.assets/image-20240125122513252.png" alt="image-20240125122513252"></p><ul><li>解决<ul><li>熔断</li><li>降级</li><li>限流</li></ul></li></ul><h3 id="10-2-模块"><a href="#10-2-模块" class="headerlink" title="10.2 模块"></a>10.2 模块</h3><h4 id="1-内容管理"><a href="#1-内容管理" class="headerlink" title="1 内容管理"></a>1 内容管理</h4><ul><li>流程控制</li><li>课程审核</li><li>课程发布分布式事务方案</li><li>课程发布任务调度方案</li><li>页面静态化方案</li><li>课程搜索方案</li></ul><h4 id="2-媒资管理"><a href="#2-媒资管理" class="headerlink" title="2 媒资管理"></a>2 媒资管理</h4><ul><li>断点续传</li><li>任务调度视频处理流程</li><li>文件服务访问方案</li></ul><h4 id="3-认证授权"><a href="#3-认证授权" class="headerlink" title="3 认证授权"></a>3 认证授权</h4><ul><li>认证流程</li><li>网关统一鉴权</li><li>OAuth2</li><li>微信扫码流程</li><li>授权相关数据模型</li><li>验证码校验流程</li><li>JWT令牌</li><li>spring security工作原理<ul><li><code>UserDetails</code>和<code>DaoAuthentication</code></li></ul></li></ul><h4 id="4-选课学习"><a href="#4-选课学习" class="headerlink" title="4 选课学习"></a>4 选课学习</h4><ul><li>选课流程</li><li>在线学习流程</li><li>免费课程续期流程</li></ul><h4 id="5-订单支付"><a href="#5-订单支付" class="headerlink" title="5 订单支付"></a>5 订单支付</h4><ul><li>支付流程</li><li>生成二维码执行流程</li><li>用户扫码支付流程</li><li>支付结果通知流程</li><li>支付结果通知分布式事务</li></ul><link rel="stylesheet" href="https://cdn1.tianli0.top/gh/zhheo/Post-Abstract-AI@0.15.2/tianli_gpt.css"><script>let tianliGPT_postSelector = '#post #article-container';let tianliGPT_key = 'c9b7741d290063ab872e';</script><script src="https://cdn1.tianli0.top/gh/zhheo/Post-Abstract-AI@0.15.2/tianli_gpt.js"></script>]]></content>
      
      
      <categories>
          
          <category> 实战 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 项目 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>苍穹外卖</title>
      <link href="/posts/21962.html"/>
      <url>/posts/21962.html</url>
      
        <content type="html"><![CDATA[<h1 id="苍穹外卖"><a href="#苍穹外卖" class="headerlink" title="苍穹外卖"></a>苍穹外卖</h1><p><a href="https://www.bilibili.com/video/BV1TP411v7v6/?spm_id_from=333.788.video.desc.click&amp;vd_source=1a39594354c31d775ddc587407a55282">https://www.bilibili.com/video/BV1TP411v7v6/?spm_id_from=333.788.video.desc.click&amp;vd_source=1a39594354c31d775ddc587407a55282</a></p><h2 id="〇-经验总结"><a href="#〇-经验总结" class="headerlink" title="〇 经验总结"></a>〇 经验总结</h2><h3 id="0-自动装配"><a href="#0-自动装配" class="headerlink" title="0 自动装配"></a>0 自动装配</h3><ul><li>主启动类上的注解<code>@SpringbootApplication</code>是一个复合注解，其中比较重要的<ul><li><code>@SpringbootConfiguration</code>：springboot的相关配置</li><li><code>@EnableAutoConfiguration</code></li><li><code>@ComponentScan</code>：扫描一些包并注入</li></ul></li><li>重点<code>@EnableAutoConfiguration</code>，也是一个复合注解<ul><li><code>@import(AutoConfigurationImportSelect.class)</code></li></ul></li><li><p><code>AutoConfigurationImportSelect</code>中一个重要的方法：<code>importSelect()</code>作用是选取一些类，注入到IOC容器中</p></li><li><p>配置文件的信息如何加载到bean中：spring.factories文件存储了一些键信息，然后加载的时候配置文件的值就被加载到这个文件中了</p></li><li><p>两种</p><ul><li><code>@Autowired</code>：根据类型自动注入</li><li><code>@Resource</code>：根据bean的名称自动注入</li></ul></li></ul><h3 id="1-Mybatis"><a href="#1-Mybatis" class="headerlink" title="1 Mybatis"></a>1 Mybatis</h3><ul><li><p>分页查询</p><ul><li><p><code>PageHelper</code>：原理是存储分页信息在<code>ThreadLocal</code>中，在执行sql前拦截器会读取到分页信息动态插入到sql中再执行</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/苍穹外卖.assets/image-20240224180047211.png" alt="image-20240224180047211"></p></li></ul></li><li><p>批量插入</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/苍穹外卖.assets/image-20240224182755036.png" alt="image-20240224182755036"></p><p>mapper：</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/苍穹外卖.assets/image-20240224182807077.png" alt="image-20240224182807077"></p></li><li><p>参数传递<code>xxxMapper.java</code>中方法的形参名可以不与<code>.xml</code>一致，MyBatis 会按照参数的位置进行匹配而不是参数的名字，若有多个参数，则应该按顺序使用</p><ul><li>也可以使用<code>@Param</code>：<code>List&lt;TeachplanDto&gt; selectTreeNodes(@Param(&quot;courseId&quot;) Long courseId, @Param(&quot;name&quot;) String name);</code>指定mapper中的名字</li></ul></li></ul><h3 id="2-微信登录"><a href="#2-微信登录" class="headerlink" title="2 微信登录"></a>2 微信登录</h3><ul><li><p>过程</p><ul><li><p>前端传入授权码发送至服务端</p></li><li><p>服务端携带授权码code + appid + secret 采用<code>HttpClient</code>发送请求到<a href="https://api.weixin.qq.com/sns/jscode2session">https://api.weixin.qq.com/sns/jscode2session</a></p></li><li><p>得到微信服务端返回的openid + session_key，其中openid也就是微信用户的唯一标识</p></li><li><p>根据openid查询数据库中是否存在此用户（openid不是主键），若不存在则自动创建，存在则返回该用户信息</p></li><li><p>为该用户生成jwt令牌（密钥+过期时间+信息）</p><ul><li>密钥用于加密解密jwt信息</li><li>信息claims是一个map，在本项目中只存储了userId这一个信息</li></ul></li><li><p>返回VO对象</p><p>&lt;img src=(<a href="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/苍穹外卖.assets/image-20240224190705160.png">https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/苍穹外卖.assets/image-20240224190705160.png</a>“ alt=”image-20240224190705160” style=”zoom: 67%;” /&gt;</p></li></ul></li></ul><h3 id="3-redis和SpringCache"><a href="#3-redis和SpringCache" class="headerlink" title="3 redis和SpringCache"></a>3 redis和SpringCache</h3><ul><li><p>redis缓存菜品分类</p><ul><li><p>根据分类id查询菜品存储在List中，随后redis的key为dish_id号，value是list的内容     </p></li><li><p>当新增、修改、删除菜品的时候删除所有的dish_*的缓存（这里可以做的更细一点）</p><p>&lt;img src=(<a href="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/苍穹外卖.assets/image-20240224195415885.png">https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/苍穹外卖.assets/image-20240224195415885.png</a>“ alt=”image-20240224195415885” style=”zoom:67%;” /&gt;</p></li></ul></li><li><p>SpringCache缓存套餐</p><ul><li><p>本质：SpringCache在JVM中，集群中不可用</p></li><li><p><code>application</code>类上添加<code>@EnableCaching</code></p></li><li><p>在根据分类id查询套餐前判断setmealCache这个缓存管理器中有没有指定的分类id的value，有则直接返回，没有则再执行方法，再将查询结果存储在缓存中</p><p>&lt;img src=(<a href="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/苍穹外卖.assets/image-20240224201425719.png">https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/苍穹外卖.assets/image-20240224201425719.png</a>“ alt=”image-20240224201425719” style=”zoom:67%;” /&gt;</p></li><li><p>在批量删除套餐的时候清理所有缓存</p><p>&lt;img src=(<a href="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/苍穹外卖.assets/image-20240224201343039.png">https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/苍穹外卖.assets/image-20240224201343039.png</a>“ alt=”image-20240224201343039” style=”zoom:67%;” /&gt;</p></li></ul></li></ul><h3 id="4-微信支付"><a href="#4-微信支付" class="headerlink" title="4 微信支付"></a>4 微信支付</h3><ul><li>用户点击支付，向接口发送请求，传入订单号及付款方式（微信）</li><li>服务端获取到当前用户的id，采用JSAPI下单，传入appid、mchid（商户号）、description、out_trade_no、notify_url（回调地址）等信息，发送post请求（httpclient）<a href="https://api.mch.weixin.qq.com/v3/pay/transactions/jsapi">https://api.mch.weixin.qq.com/v3/pay/transactions/jsapi</a></li><li>解析返回结果：<strong>prepay_id</strong>（关键，这个要给前端）： 预支付交易会话标识，根据prepay_id及appid、时间等信息生成二次签名（预支付交易单）</li><li>支付结果异步通知：读取数据、解密数据、业务处理：修改订单状态、给微信响应</li></ul><h3 id="5-百度地图"><a href="#5-百度地图" class="headerlink" title="5 百度地图"></a>5 百度地图</h3><ul><li>申请ak</li><li>请求的时候注意参数的顺序：address、output、ak</li><li>获取经纬度信息：<a href="https://api.map.baidu.com/geocoding/v3">https://api.map.baidu.com/geocoding/v3</a></li><li>获取路径规划信息：<a href="https://api.map.baidu.com/directionlite/v1/driving">https://api.map.baidu.com/directionlite/v1/driving</a></li></ul><h3 id="6-来单提醒-用户催单"><a href="#6-来单提醒-用户催单" class="headerlink" title="6 来单提醒/用户催单"></a>6 来单提醒/用户催单</h3><ul><li><p>客户端通过<code>/ws/&#123;sid&#125;</code>与服务端建立websocket长连接，会话对象<code>Session</code>存储在map中，当需要发送消息的时候调用<code>session.getBasicRemote().sendText(message);</code>方法即可</p></li><li><p>在客户支付成功之后调用</p></li></ul><h2 id="Ⅰ-整体介绍"><a href="#Ⅰ-整体介绍" class="headerlink" title="Ⅰ 整体介绍"></a>Ⅰ 整体介绍</h2><h3 id="一-软件开发整体介绍"><a href="#一-软件开发整体介绍" class="headerlink" title="一 软件开发整体介绍"></a>一 软件开发整体介绍</h3><h4 id="1-1-流程"><a href="#1-1-流程" class="headerlink" title="1.1 流程"></a>1.1 流程</h4><ul><li>需求分析：需求规格说明书、产品原型</li><li>设计：UI设计、数据库设计、接口设计</li><li>编码：项目代码、单元测试</li><li>测试：测试用例、测试报告</li><li>上线运维：软件环境安装、配置</li></ul><h4 id="1-2-角色分工"><a href="#1-2-角色分工" class="headerlink" title="1.2 角色分工"></a>1.2 角色分工</h4><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/苍穹外卖.assets/image-20231112215647568.png" alt="image-20231112215647568"></p><h4 id="1-3-软件环境"><a href="#1-3-软件环境" class="headerlink" title="1.3 软件环境"></a>1.3 软件环境</h4><ul><li>开发环境：开发阶段环境，一般外部用户无法访问</li><li>测试环境：测试人员使用，一般外部用户无法访问</li><li>生产环境：线上环境，正式提供对外服务的环境</li></ul><h3 id="二-苍穹外卖项目介绍"><a href="#二-苍穹外卖项目介绍" class="headerlink" title="二 苍穹外卖项目介绍"></a>二 苍穹外卖项目介绍</h3><h4 id="2-1-项目介绍"><a href="#2-1-项目介绍" class="headerlink" title="2.1 项目介绍"></a>2.1 项目介绍</h4><ul><li><p>定位：专门为餐饮企业（餐厅、饭店）定制的一款软件产品</p></li><li><p>功能架构</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/苍穹外卖.assets/image-20231112215927930.png" alt="image-20231112215927930"></p></li></ul><h4 id="2-2-产品原型"><a href="#2-2-产品原型" class="headerlink" title="2.2 产品原型"></a>2.2 产品原型</h4><ul><li>产品原型：用于展示项目的业务功能，一般由产品经理进行设计</li></ul><h4 id="2-3-技术选型"><a href="#2-3-技术选型" class="headerlink" title="2.3 技术选型"></a>2.3 技术选型</h4><ul><li><p>技术选型：展示项目中使用到的技术框架和中间件等</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/苍穹外卖.assets/image-20231112220002355.png" alt="image-20231112220002355"></p></li></ul><h3 id="三-开发环境搭建"><a href="#三-开发环境搭建" class="headerlink" title="三 开发环境搭建"></a>三 开发环境搭建</h3><ul><li>整体结构<ul><li>前端<ul><li>管理端：Web</li><li>用户端：小程序</li></ul></li><li>后端<ul><li>后端服务：Java</li></ul></li></ul></li></ul><h4 id="3-1-前端环境搭建"><a href="#3-1-前端环境搭建" class="headerlink" title="3.1 前端环境搭建"></a>3.1 前端环境搭建</h4><ul><li>前端工程基于nginx运行</li><li>双击项目目录下的nginx.exe即可启动服务，端口号为80</li></ul><h4 id="3-2-后端环境搭建"><a href="#3-2-后端环境搭建" class="headerlink" title="3.2 后端环境搭建"></a>3.2 后端环境搭建</h4><ul><li><p>后端工程基于maven进行项目构建，并且进行分模块开发</p></li><li><p>sky-take-out：maven父工程，统一管理依赖版本，聚合其他子模块</p><ul><li>sky-common：子模块，存放公共类，例如：工具类、常量类、异常类等</li><li>sky-pojo：子模块，存放实体类、VO、DTO等<ul><li>entity：实体，通常与数据库的表对应</li><li>DTO：数据传输对象，通常于程序中各层之间传递数据</li><li>VO：视图对象，为前端展示数据提供的对象</li><li>POJO：普通Java对象，只有属性和对应的getter和setter</li></ul></li><li>sky-server：子模块，后端服务，存放配置文件、Controller、Service、Mapper等</li></ul></li><li><p>使用Git进行版本控制</p></li><li><p>数据库环境搭建</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/苍穹外卖.assets/image-20231112220832816.png" alt="image-20231112220832816"></p></li><li><p>前后端联调</p><ul><li>前端请求地址：<a href="http://localhost/api/employee/login">http://localhost/api/employee/login</a></li><li>后端接口地址：<a href="http://localhost:8080/admin/employee/login">http://localhost:8080/admin/employee/login</a></li><li>nginx 反向代理，就是将前端发送的动态请求由 nginx 转发到后端服务器<ul><li>提高访问速度</li><li>进行负载均衡</li><li>保证后端服务安全</li></ul></li></ul></li></ul><h4 id="3-3-完善登录功能"><a href="#3-3-完善登录功能" class="headerlink" title="3.3 完善登录功能"></a>3.3 完善登录功能</h4><ul><li>问题：员工表中的密码是明文存储，安全性低</li><li>思路：将密码加密后存储，提高安全性，使用MD5加密方式对明文密码加密</li></ul><h3 id="四-接入接口文档"><a href="#四-接入接口文档" class="headerlink" title="四 接入接口文档"></a>四 接入接口文档</h3><h4 id="4-1-前后端分离开发流程"><a href="#4-1-前后端分离开发流程" class="headerlink" title="4.1 前后端分离开发流程"></a>4.1 前后端分离开发流程</h4><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/苍穹外卖.assets/image-20231112221529341.png" alt="image-20231112221529341"></p><ul><li>在YApi中管理接口</li></ul><h3 id="五-Swagger"><a href="#五-Swagger" class="headerlink" title="五 Swagger"></a>五 Swagger</h3><ul><li>类似于postman 但是postman一个一个测试比较麻烦</li></ul><h4 id="5-1-介绍"><a href="#5-1-介绍" class="headerlink" title="5.1 介绍"></a>5.1 介绍</h4><ul><li><p>使用Swagger你只需要按照它的规范去定义接口及接口相关的信息，就可以做到生成接口文档，以及在线接口调试页面。</p><p>官网：<a href="https://swagger.io/">https://swagger.io/</a></p></li><li><p><a href="https://doc.xiaominfo.com/">K</a><a href="https://doc.xiaominfo.com/">nife4j</a><a href="https://doc.xiaominfo.com/"> </a>是为Java MVC框架集成Swagger生成Api文档的增强解决方案。</p></li></ul><h4 id="5-2-使用方式"><a href="#5-2-使用方式" class="headerlink" title="5.2 使用方式"></a>5.2 使用方式</h4><ul><li>导入坐标</li><li>配置类中加入配置</li><li>设置静态资源映射，否则接口文档页面无法访问</li></ul><h4 id="5-3-常用注解"><a href="#5-3-常用注解" class="headerlink" title="5.3 常用注解"></a>5.3 常用注解</h4><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/苍穹外卖.assets/image-20231112221816822.png" alt="image-20231112221816822"></p><ul><li><p>在com.sky.config.WebMvcConfiguration.java中定义</p></li><li><p>启动后端项目后：<a href="http://localhost:8080/doc.html">http://localhost:8080/doc.html</a> 可访问生成的文档</p></li></ul><h2 id="Ⅱ-员工管理、分类管理"><a href="#Ⅱ-员工管理、分类管理" class="headerlink" title="Ⅱ 员工管理、分类管理"></a>Ⅱ 员工管理、分类管理</h2><h3 id="一-新增员工"><a href="#一-新增员工" class="headerlink" title="一 新增员工"></a>一 新增员工</h3><h4 id="1-1-需求分析和设计"><a href="#1-1-需求分析和设计" class="headerlink" title="1.1 需求分析和设计"></a>1.1 需求分析和设计</h4><ul><li><p>产品原型</p><ul><li>账号唯一</li><li>手机号合法的</li><li>身份证合法</li><li>密码默认123456</li></ul></li><li><p>接口设计</p><ul><li><p>请求参数</p><ul><li>Path：/admin/employee</li><li>Method：POST</li></ul><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/苍穹外卖.assets/image-20231113202940688.png" alt="image-20231113202940688"></p></li><li><p>返回数据</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/苍穹外卖.assets/image-20231113202956877.png" alt="image-20231113202956877"></p></li><li><p>约定</p><ul><li>管理端的请求，/admin作为前缀</li><li>用户端的请求，/user作为前缀</li></ul></li></ul></li><li><p>数据库设计（employee表）</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/苍穹外卖.assets/image-20231113203143786.png" alt="image-20231113203143786"></p></li></ul><h4 id="1-2-代码开发"><a href="#1-2-代码开发" class="headerlink" title="1.2 代码开发"></a>1.2 代码开发</h4><ul><li><p>根据新增员工接口设计对应的DTO</p><ul><li><p>注意：当前端提交的数据和实体类中对应的属性差别比较大时，建议使用DTO来封装数据</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EmployeeDTO</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String phone;</span><br><span class="line">    <span class="keyword">private</span> String sex;</span><br><span class="line">    <span class="keyword">private</span> String idNumber;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h4 id="1-3-功能测试"><a href="#1-3-功能测试" class="headerlink" title="1.3 功能测试"></a>1.3 功能测试</h4><ul><li><p>通过接口文档测试（多用这种）</p></li><li><p>通过前后端联调测试</p></li><li><p>由于开发阶段前端和后端是并行开发的，后端完成某个功能后，此时前端对应的功能可能还没有开发完成，</p><p>导致无法进行前后端联调测试。所以在开发阶段，后端测试主要以接口文档测试为主。</p></li><li><p>注意配置token，在接口文档中定义一个全局变量，key为token(有时效的)</p></li></ul><h4 id="1-3-代码完善"><a href="#1-3-代码完善" class="headerlink" title="1.3 代码完善"></a>1.3 代码完善</h4><ul><li><p>录入的用户名已存在，抛出异常后没有处理</p><ul><li><p>全局异常处理器处理</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/苍穹外卖.assets/image-20231113205617529.png" alt="image-20231113205617529"></p></li></ul></li><li><p>新增员工时，创建人id和修改人id设置为了固定值</p><ul><li><p>通过某种方式动态获取当前登录员工的id</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/苍穹外卖.assets/image-20231113210316469.png" alt="image-20231113210316469"></p><ul><li>员工登录成功后会生成JWT令牌并响应给前端</li><li>后续请求中，前端会携带JWT令牌，通过JWT令牌可以解析出当前登录员工id</li><li>解析出登录员工id后，如何传递给Service的save方法？</li></ul></li></ul></li><li><p>ThreadLocal </p><ul><li>并不是一个Thread，而是Thread的局部变量。</li><li>ThreadLocal为每个线程提供单独一份存储空间，具有线程隔离的效果，只有在线程内才能获取到对应的值，线程外则不能访问。<ul><li><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/苍穹外卖.assets/image-20231113210620803.png" alt="image-20231113210620803"></li></ul></li><li>客户端发送的每次请求，后端的Tomcat服务器都会分配一个单独的线程来处理请求</li><li>在拦截器中解析出当前登录的员工的id，并放入的线程局部变量中，随后在保存的时候读取这个id</li></ul></li></ul><h3 id="二-员工分页查询"><a href="#二-员工分页查询" class="headerlink" title="二 员工分页查询"></a>二 员工分页查询</h3><h4 id="2-1-需求分析和设计"><a href="#2-1-需求分析和设计" class="headerlink" title="2.1 需求分析和设计"></a>2.1 需求分析和设计</h4><ul><li><p>业务规则</p><ul><li>根据页码展示员工信息</li><li>每页10条数据</li><li>分页查询时可以根据需要，输入员工姓名进行查询</li></ul></li><li><p>接口设计</p><ul><li><p>请求参数</p><ul><li>Path：/admin/employee/page</li><li>Method:GET</li><li><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/苍穹外卖.assets/image-20231113211539458.png" alt="image-20231113211539458"></li></ul></li><li><p>返回数据</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/苍穹外卖.assets/image-20231113211520807.png" alt="image-20231113211520807"></p></li></ul></li></ul><h4 id="2-2-代码开发"><a href="#2-2-代码开发" class="headerlink" title="2.2 代码开发"></a>2.2 代码开发</h4><ul><li><p>根据接口设计对应的DTO</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/苍穹外卖.assets/image-20231113211659677.png" alt="image-20231113211659677"></p></li><li><p>后面所有的分页查询，统一都封装成PageResult对象：</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/苍穹外卖.assets/image-20231113211718332.png" alt="image-20231113211718332"></p></li><li><p>员工信息分页查询后返回的对象类型为：<code>Result&lt;PageResult&gt;</code></p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/苍穹外卖.assets/image-20231113211815663.png" alt="image-20231113211815663"></p></li></ul><h4 id="2-3-功能测试"><a href="#2-3-功能测试" class="headerlink" title="2.3 功能测试"></a>2.3 功能测试</h4><h4 id="2-4-代码完善"><a href="#2-4-代码完善" class="headerlink" title="2.4 代码完善"></a>2.4 代码完善</h4><ul><li><p>方式一：在属性上加入注解，对日期进行格式化</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/苍穹外卖.assets/image-20231113215900420.png" alt="image-20231113215900420"></p></li><li><p>方式二：在 WebMvcConfiguration 中扩展Spring MVC的消息转换器，统一对日期类型进行格式化处理</p></li></ul><h3 id="三-启用禁用员工账号"><a href="#三-启用禁用员工账号" class="headerlink" title="三 启用禁用员工账号"></a>三 启用禁用员工账号</h3><h4 id="3-1-需求分析与设计"><a href="#3-1-需求分析与设计" class="headerlink" title="3.1 需求分析与设计"></a>3.1 需求分析与设计</h4><ul><li><p>业务规则</p><ul><li>可以对状态为“启用” 的员工账号进行“禁用”操作</li><li>可以对状态为“禁用”的员工账号进行“启用”操作</li><li>状态为“禁用”的员工账号不能登录系统</li></ul></li><li><p>接口设计</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/苍穹外卖.assets/image-20231113220915625.png" alt="image-20231113220915625"></p></li></ul><h4 id="3-2-代码开发"><a href="#3-2-代码开发" class="headerlink" title="3.2 代码开发"></a>3.2 代码开发</h4><h4 id="3-3-功能测试"><a href="#3-3-功能测试" class="headerlink" title="3.3 功能测试"></a>3.3 功能测试</h4><h3 id="四-编辑员工"><a href="#四-编辑员工" class="headerlink" title="四 编辑员工"></a>四 编辑员工</h3><h4 id="4-1-需求分析与设计"><a href="#4-1-需求分析与设计" class="headerlink" title="4.1 需求分析与设计"></a>4.1 需求分析与设计</h4><ul><li><p>业务规则</p><ul><li>根据id查询员工信息</li><li>编辑员工信息</li></ul></li><li><p>接口设计</p><ul><li><p>根据id查询员工信息</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/苍穹外卖.assets/image-20231113222420681.png" alt="image-20231113222420681"></p></li><li><p>编辑员工信息</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/苍穹外卖.assets/image-20231113222441435.png" alt="image-20231113222441435"></p></li></ul></li></ul><h4 id="4-2-代码开发"><a href="#4-2-代码开发" class="headerlink" title="4.2 代码开发"></a>4.2 代码开发</h4><h4 id="4-3-功能测试"><a href="#4-3-功能测试" class="headerlink" title="4.3 功能测试"></a>4.3 功能测试</h4><h3 id="五-导入分类模块功能代码"><a href="#五-导入分类模块功能代码" class="headerlink" title="五 导入分类模块功能代码"></a>五 导入分类模块功能代码</h3><ul><li>与员工管理类似</li></ul><h4 id="5-1-需求分析与设计"><a href="#5-1-需求分析与设计" class="headerlink" title="5.1 需求分析与设计"></a>5.1 需求分析与设计</h4><ul><li><p>业务规则</p><ul><li>分类名称必须是<strong>唯一</strong>的</li><li>分类按照类型可以分为<strong>菜品分类</strong>和<strong>套餐分类</strong></li><li>新添加的分类状态默认为<strong>“禁用”</strong></li></ul></li><li><p>接口设计</p><ul><li>新增分类</li><li>分类分页查询</li><li>根据id删除分类</li><li>修改分类</li><li>启用禁用分类</li><li>根据类型查询分类</li></ul></li><li><p>数据库设计（category表）</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/苍穹外卖.assets/image-20231113223801771.png" alt="image-20231113223801771"></p></li></ul><h4 id="5-2-代码开发"><a href="#5-2-代码开发" class="headerlink" title="5.2 代码开发"></a>5.2 代码开发</h4><h4 id="5-3-功能测试"><a href="#5-3-功能测试" class="headerlink" title="5.3 功能测试"></a>5.3 功能测试</h4><h2 id="Ⅲ-菜品管理"><a href="#Ⅲ-菜品管理" class="headerlink" title="Ⅲ 菜品管理"></a>Ⅲ 菜品管理</h2><h3 id="一-公共字段自动填充"><a href="#一-公共字段自动填充" class="headerlink" title="一 公共字段自动填充"></a>一 公共字段自动填充</h3><h4 id="1-1-问题分析"><a href="#1-1-问题分析" class="headerlink" title="1.1 问题分析"></a>1.1 问题分析</h4><ul><li><p>业务表中的公共字段重复，导致代码冗余、不便于后期维护</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/苍穹外卖.assets/image-20231116224758489.png" alt="image-20231116224758489"></p></li></ul><h4 id="1-2-实现思路"><a href="#1-2-实现思路" class="headerlink" title="1.2 实现思路"></a>1.2 实现思路</h4><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/苍穹外卖.assets/image-20231116224942816.png" alt="image-20231116224942816"></p><ul><li>自定义注解AutoFill，用于标识需要进行公共字段自动填充的方法</li><li>自定义切面类 AutoFillAspect，统一拦截加入了 AutoFill 注解的方法，通过反射为公共字段赋值</li><li>在 Mapper 的方法上加入 AutoFill 注解</li><li>技术点：枚举、注解、AOP、反射</li></ul><h4 id="1-3-代码开发"><a href="#1-3-代码开发" class="headerlink" title="1.3 代码开发"></a>1.3 代码开发</h4><ul><li>自定义注解AutoFill</li><li>自定义切面 AutoFillAspect</li><li>完善自定义切面 AutoFillAspect 的 autoFill 方法</li><li>在Mapper接口的方法上加入 AutoFill 注解</li><li>将业务层为公共字段赋值的代码注释掉</li></ul><h4 id="1-4-功能测试"><a href="#1-4-功能测试" class="headerlink" title="1.4 功能测试"></a>1.4 功能测试</h4><h3 id="二-新增菜品"><a href="#二-新增菜品" class="headerlink" title="二 新增菜品"></a>二 新增菜品</h3><h4 id="2-1-需求分析和设计-1"><a href="#2-1-需求分析和设计-1" class="headerlink" title="2.1 需求分析和设计"></a>2.1 需求分析和设计</h4><ul><li><p>业务规则</p><ul><li>菜品名称必须是唯一的</li><li>菜品必须属于某个分类下，不能单独存在</li><li>新增菜品时可以根据情况选择菜品的口味</li><li>每个菜品必须对应一张图片</li></ul></li><li><p>接口设计</p><ul><li><p>根据类型查询分类（已完成）</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/苍穹外卖.assets/image-20231116232910259.png" alt="image-20231116232910259"></p></li><li><p>文件上传</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/苍穹外卖.assets/image-20231116233003532.png" alt="image-20231116233003532"></p></li><li><p>新增菜品</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/苍穹外卖.assets/image-20231116233013731.png" alt="image-20231116233013731"></p></li></ul></li><li><p>数据库设计（dish菜品表和dish_flavor口味表）</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/苍穹外卖.assets/image-20231116233046342.png" alt="image-20231116233046342"></p></li></ul><h4 id="2-2-代码开发-1"><a href="#2-2-代码开发-1" class="headerlink" title="2.2 代码开发"></a>2.2 代码开发</h4><h4 id="2-3-功能测试-1"><a href="#2-3-功能测试-1" class="headerlink" title="2.3 功能测试"></a>2.3 功能测试</h4><h3 id="三-菜品分页查询"><a href="#三-菜品分页查询" class="headerlink" title="三 菜品分页查询"></a>三 菜品分页查询</h3><h4 id="3-1-需求分析和设计"><a href="#3-1-需求分析和设计" class="headerlink" title="3.1 需求分析和设计"></a>3.1 需求分析和设计</h4><ul><li><p>业务规则</p><ul><li>根据页码展示菜品信息</li><li>每页展示10条数据</li><li>分页查询时可以根据需要输入菜品名称、菜品分类、菜品状态进行查询</li></ul></li><li><p>接口设计</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/苍穹外卖.assets/image-20231117153112174.png" alt="image-20231117153112174"></p></li></ul><h4 id="3-2-代码开发-1"><a href="#3-2-代码开发-1" class="headerlink" title="3.2 代码开发"></a>3.2 代码开发</h4><h4 id="3-3-功能测试-1"><a href="#3-3-功能测试-1" class="headerlink" title="3.3 功能测试"></a>3.3 功能测试</h4><h3 id="四-删除菜品"><a href="#四-删除菜品" class="headerlink" title="四 删除菜品"></a>四 删除菜品</h3><h4 id="4-1-需求分析和设计"><a href="#4-1-需求分析和设计" class="headerlink" title="4.1 需求分析和设计"></a>4.1 需求分析和设计</h4><ul><li><p>业务规则</p><ul><li>可以一次删除一个菜品，也可以批量删除菜品</li><li>起售中的菜品不能删除</li><li>被套餐关联的菜品不能删除</li><li>删除菜品后，关联的口味数据也需要删除掉</li></ul></li><li><p>接口设计</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/苍穹外卖.assets/image-20231117211019552.png" alt="image-20231117211019552"></p></li><li><p>数据库设计</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/苍穹外卖.assets/image-20231117211032524.png" alt="image-20231117211032524"></p></li></ul><h4 id="4-2-代码开发-1"><a href="#4-2-代码开发-1" class="headerlink" title="4.2 代码开发"></a>4.2 代码开发</h4><h4 id="4-3-功能测试-1"><a href="#4-3-功能测试-1" class="headerlink" title="4.3 功能测试"></a>4.3 功能测试</h4><h3 id="五-修改菜品"><a href="#五-修改菜品" class="headerlink" title="五 修改菜品"></a>五 修改菜品</h3><h4 id="5-1-需求分析和设计"><a href="#5-1-需求分析和设计" class="headerlink" title="5.1 需求分析和设计"></a>5.1 需求分析和设计</h4><ul><li><p>接口设计</p><ul><li><p>根据id查询菜品</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/苍穹外卖.assets/image-20231117215618556.png" alt="image-20231117215618556"></p></li><li><p>根据类型查询分类（已实现）</p></li><li><p>文件上传（已实现）</p></li><li><p>修改菜品</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/苍穹外卖.assets/image-20231117215636319.png" alt="image-20231117215636319"></p></li></ul></li></ul><h4 id="5-2-代码开发-1"><a href="#5-2-代码开发-1" class="headerlink" title="5.2 代码开发"></a>5.2 代码开发</h4><h4 id="5-3-功能测试-1"><a href="#5-3-功能测试-1" class="headerlink" title="5.3 功能测试"></a>5.3 功能测试</h4><h2 id="Ⅳ-店铺状态"><a href="#Ⅳ-店铺状态" class="headerlink" title="Ⅳ 店铺状态"></a>Ⅳ 店铺状态</h2><h3 id="一-Redis"><a href="#一-Redis" class="headerlink" title="一 Redis"></a>一 Redis</h3><h4 id="1-1-简介"><a href="#1-1-简介" class="headerlink" title="1.1 简介"></a>1.1 简介</h4><ul><li>Redis是一个基于<strong>内存</strong>的 key-value 结构数据库<ul><li>基于内存存储，读写性能高</li><li>适合存储热点数据（热点商品、资讯、新闻）</li><li>企 业应用广泛</li></ul></li><li>网站<ul><li>官网：<a href="https://redis.io/">https://redis.io</a></li><li>中文网：<a href="https://www.redis.net.cn/">https://www.redis.net.cn/</a></li></ul></li><li>下载与安装<ul><li>win：<a href="https://github.com/microsoftarchive/redis/releases">https://github.com/microsoftarchive/redis/releases</a></li><li>Linux：<a href="https://download.redis.io/releases/">https://download.redis.io/releases/</a> 、</li></ul></li></ul><h4 id="1-2-Redis服务启动与停止"><a href="#1-2-Redis服务启动与停止" class="headerlink" title="1.2 Redis服务启动与停止"></a>1.2 Redis服务启动与停止</h4><ul><li><p>服务端</p><ul><li>服务启动命令cmd：<code>redis-server.exe redis.windows.conf</code></li><li>Redis服务默认端口号为 6379 ，通过快捷键Ctrl + C 即可停止Redis服务</li></ul></li><li><p>客户端</p><ul><li><p>客户端连接命令cmd：<code>redis-cli.exe</code></p></li><li><p>通过redis-cli.exe命令默认连接的是本地的redis服务，并且使用默认6379端口。也可以通过指定如下参数连接：</p><ul><li><p>-h ip地址</p></li><li><p>-p 端口号</p></li><li><p>-a 密码（如果需要）</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/苍穹外卖.assets/image-20231120095709243.png" alt="image-20231120095709243"></p></li></ul></li></ul></li><li><p>设置Redis服务密码</p><ul><li><p>修改redis.windows.conf</p></li><li><p>requirepass 123456</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/苍穹外卖.assets/image-20231120095546630.png" alt="image-20231120095546630"></p></li></ul></li><li><p>客户端图形工具</p><ul><li>Another-Redis-Desktop-</li></ul></li></ul><h3 id="二-Redis数据类型"><a href="#二-Redis数据类型" class="headerlink" title="二 Redis数据类型"></a>二 Redis数据类型</h3><h4 id="2-1-5种常用数据类型"><a href="#2-1-5种常用数据类型" class="headerlink" title="2.1 5种常用数据类型"></a>2.1 5种常用数据类型</h4><ul><li>字符串 <code>String</code><ul><li>普通字符串，Redis中最简单的数据类型</li></ul></li><li>哈希 <code>hash</code><ul><li>也叫散列，类似于Java中的HashMap结构</li></ul></li><li>列表 <code>list</code><ul><li>按照插入顺序排序，可以有重复元素，类似于Java中的LinkedList</li></ul></li><li>集合 <code>set</code><ul><li>无序集合，没有重复元素，类似于Java中的HashSet</li></ul></li><li>有序集合 <code>sorted set/zset</code><ul><li>集合中每个元素关联一个分数（score），根据分数升序排序，没有重复元素</li></ul></li></ul><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/苍穹外卖.assets/image-20231120100715094.png" alt="image-20231120100715094"></p><h3 id="三-Redis常用命令"><a href="#三-Redis常用命令" class="headerlink" title="三 Redis常用命令"></a>三 Redis常用命令</h3><ul><li><p>字符串操作命令</p><ul><li><code>SET key value</code></li><li><code>GET key</code></li><li><code>SETEX key seconds value</code>：设置指定key的值，并将 key 的过期时间设为 seconds 秒</li><li><code>SETNX key value</code> ：只有在 key 不存在时设置 key 的值</li></ul></li><li><p>哈希操作命令</p><ul><li><p><code>HSET key field value</code> ：将哈希表 key 中的字段 field 的值设为 value</p></li><li><p><code>HGET key field</code> ：获取存储在哈希表中指定字段的值</p></li><li><p><code>HDEL key field</code> ：删除存储在哈希表中的指定字段</p></li><li><p><code>HKEYS key</code> ：获取哈希表中所有字段</p></li><li><p><code>HVALS key</code> ：获取哈希表中所有值</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/苍穹外卖.assets/image-20231120101206111.png" alt="image-20231120101206111"></p></li></ul></li><li><p>列表操作命令</p><ul><li><p><code>LPUSH key value1 [value2]</code> ：将一个或多个值插入到列表头部(左边)</p></li><li><p><code>LRANGE key start stop</code> ：获取列表指定范围内的元素</p></li><li><p><code>RPOP key</code> ：移除并获取列表最后一个元素(右边)</p></li><li><p><code>LLEN key</code>  ：获取列表长度</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/苍穹外卖.assets/image-20231120101217359.png" alt="image-20231120101217359"></p></li></ul></li><li><p>集合操作命令</p><ul><li><p><code>SADD key member1 [member2]</code> ：向集合添加一个或多个成员</p></li><li><p><code>SMEMBERS key</code> ：返回集合中的所有成员</p></li><li><p><code>SCARD key</code>  ：获取集合的成员数</p></li><li><p><code>SINTER key1 [key2]</code>：返回给定所有集合的交集</p></li><li><p><code>SUNION key1 [key2]</code> ：返回所有给定集合的并集</p></li><li><p><code>SREM key member1 [member2]</code>：删除集合中一个或多个成员</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/苍穹外卖.assets/image-20231120101505467.png" alt="image-20231120101505467"></p></li></ul></li><li><p>有序集合操作命令</p><ul><li><p><code>ZADD key score1 member1 [score2 member2]</code> ：向有序集合添加一个或多个成员</p></li><li><p><code>ZRANGE key start stop [WITHSCORES]</code> ：通过索引区间返回有序集合中指定区间内的成员</p></li><li><p><code>ZINCRBY key increment member</code>  ：有序集合中对指定成员的分数加上增量 increment</p></li><li><p><code>ZREM key member [member ...]</code>  ：移除有序集合中的一个或多个成员</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/苍穹外卖.assets/image-20231120101738061.png" alt="image-20231120101738061"></p></li></ul></li><li><p>通用命令</p><ul><li><code>KEYS pattern</code> ：查找所有符合给定模式( pattern)的 key </li><li><code>EXISTS key</code> ：检查给定 key 是否存在</li><li><code>TYPE key</code> ：返回 key 所储存的值的类型</li><li><code>DEL key</code> ：该命令用于在 key 存在是删除 key</li></ul></li></ul><h3 id="四-java中操作Redis"><a href="#四-java中操作Redis" class="headerlink" title="四 java中操作Redis"></a>四 java中操作Redis</h3><ul><li><p>Redis的java客户端很多，常用的几种</p><ul><li><p>Jedis</p></li><li><p>Lettuce</p></li><li><p>Spring Data Redis ：是 Spring 的一部分，对 Redis 底层开发包进行了高度封装。</p><p>在 Spring 项目中，可以使用Spring Data Redis来简化操作。</p></li></ul></li><li><p>步骤</p><ul><li><p>导入Spring Data Redis坐标</p></li><li><p>配置数据源</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/苍穹外卖.assets/image-20231120103809024.png" alt="image-20231120103809024"></p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/苍穹外卖.assets/image-20231120103824045.png" alt="image-20231120103824045"></p></li><li><p>编写配置类，创建Redis Template对象</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/苍穹外卖.assets/image-20231120104116616.png" alt="image-20231120104116616"></p></li><li><p>通过Redis Template对象操作Redis</p></li></ul></li><li><p><code>RedisTemplate</code>：针对大量api进行了归类封装,将同一数据类型的操作封装为对应的Operation接口，具体分类如下：</p><ul><li>ValueOperations：string数据操作</li><li>SetOperations：set类型数据操作</li><li>ZSetOperations：zset类型数据操作</li><li>HashOperations：hash类型的数据操作</li><li>ListOperations：list类型的数据操作</li></ul></li></ul><h3 id="五-店铺营业状态设置"><a href="#五-店铺营业状态设置" class="headerlink" title="五 店铺营业状态设置"></a>五 店铺营业状态设置</h3><h4 id="5-1-需求分析和设置"><a href="#5-1-需求分析和设置" class="headerlink" title="5.1 需求分析和设置"></a>5.1 需求分析和设置</h4><ul><li><p>接口设计</p><ul><li><p>设置营业状态</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/苍穹外卖.assets/image-20231120114209815.png" alt="image-20231120114209815"></p></li><li><p>管理端查询营业状态</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/苍穹外卖.assets/image-20231120114236302.png" alt="image-20231120114236302"></p></li><li><p>用户端查询营业状态</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/苍穹外卖.assets/image-20231120114251878.png" alt="image-20231120114251878"></p></li></ul></li><li><p>数据存储方式：基于Redis的字符串来进行存储</p><ul><li>约定：1表示营业。0表示打烊</li></ul></li></ul><h4 id="5-2-代码开发-2"><a href="#5-2-代码开发-2" class="headerlink" title="5.2 代码开发"></a>5.2 代码开发</h4><h4 id="5-3-功能测试-2"><a href="#5-3-功能测试-2" class="headerlink" title="5.3 功能测试"></a>5.3 功能测试</h4><h2 id="Ⅴ-微信登录-商品浏览"><a href="#Ⅴ-微信登录-商品浏览" class="headerlink" title="Ⅴ 微信登录 商品浏览"></a>Ⅴ 微信登录 商品浏览</h2><h3 id="一-HttpClient"><a href="#一-HttpClient" class="headerlink" title="一 HttpClient"></a>一 HttpClient</h3><h4 id="1-1-介绍"><a href="#1-1-介绍" class="headerlink" title="1.1 介绍"></a>1.1 介绍</h4><ul><li><p>HttpClient是Apache的一个子项目，是高效的、功能丰富的支持HTTP协议的客户端编程工具包。</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/苍穹外卖.assets/image-20231120142148489.png" alt="image-20231120142148489"></p></li><li><p>作用</p><ul><li>发送HTTP请求</li><li>接收响应数据</li></ul></li><li><p>核心API</p><ul><li>HttpClient</li><li>HttpClients</li><li>CloseableHttpClient</li><li>HttpGet</li><li>HttpPost</li></ul></li><li><p>发送请求步骤</p><ul><li>创建HttpClient对象</li><li>创建Http请求对象</li><li>调用HttpClient的execute方法发送请求</li></ul></li></ul><h4 id="1-2-入门案例"><a href="#1-2-入门案例" class="headerlink" title="1.2 入门案例"></a>1.2 入门案例</h4><h3 id="二-微信小程序开发"><a href="#二-微信小程序开发" class="headerlink" title="二 微信小程序开发"></a>二 微信小程序开发</h3><h4 id="2-1-介绍"><a href="#2-1-介绍" class="headerlink" title="2.1 介绍"></a>2.1 介绍</h4><h4 id="2-2-准备工作"><a href="#2-2-准备工作" class="headerlink" title="2.2 准备工作"></a>2.2 准备工作</h4><ul><li>创建完善信息</li><li>获取APPID以及密钥<ul><li>ID：wx51bff83287f6cf1e</li><li>密钥：8d1d0cba4123d1b03f772b50f0266abc</li></ul></li></ul><h4 id="2-3-入门案例"><a href="#2-3-入门案例" class="headerlink" title="2.3 入门案例"></a>2.3 入门案例</h4><ul><li><p>了解小程序的目录结构</p><ul><li><p>小程序包含一个描述整体程序的 app 和多个描述各自页面的 page。一个小程序主体部分由三个文件组成，必须放在项目的根目录，如下：</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/苍穹外卖.assets/image-20231120151300404.png" alt="image-20231120151300404"></p></li><li><p>一个小程序页面由四个文件组成：</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/苍穹外卖.assets/image-20231120151330404.png" alt="image-20231120151330404"></p></li><li></li></ul></li><li><p>编写小程序代码</p></li><li><p>编译小程序</p></li></ul><h3 id="三-微信登录"><a href="#三-微信登录" class="headerlink" title="三 微信登录"></a>三 微信登录</h3><h4 id="3-1-微信登录流程"><a href="#3-1-微信登录流程" class="headerlink" title="3.1 微信登录流程"></a>3.1 微信登录流程</h4><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/苍穹外卖.assets/image-20231120170720902.png" alt="image-20231120170720902"></p><h4 id="3-2-需求分析和设计"><a href="#3-2-需求分析和设计" class="headerlink" title="3.2 需求分析和设计"></a>3.2 需求分析和设计</h4><ul><li><p>业务规则</p><ul><li><p>基于微信登录实现小程序的登录功能</p></li><li><p>如果是新用户需要自动完成注册</p></li></ul></li><li><p>接口设计</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/苍穹外卖.assets/image-20231120171640916.png" alt="image-20231120171640916"></p></li><li><p>数据表设计（user表）</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/苍穹外卖.assets/image-20231120171713035.png" alt="image-20231120171713035"></p></li></ul><h4 id="3-3-代码开发"><a href="#3-3-代码开发" class="headerlink" title="3.3 代码开发"></a>3.3 代码开发</h4><ul><li>配置微信登录所需配置项：</li><li>配置为微信用户生成jwt令牌时使用的配置项：</li><li>DTO设计：</li><li>VO设计：</li><li>Controller、service、Mapper的编写</li></ul><h4 id="3-4-功能测试"><a href="#3-4-功能测试" class="headerlink" title="3.4 功能测试"></a>3.4 功能测试</h4><h3 id="四-导入商品浏览功能代码"><a href="#四-导入商品浏览功能代码" class="headerlink" title="四 导入商品浏览功能代码"></a>四 导入商品浏览功能代码</h3><h4 id="4-1-需求分析和设计-1"><a href="#4-1-需求分析和设计-1" class="headerlink" title="4.1 需求分析和设计"></a>4.1 需求分析和设计</h4><ul><li><p>查询分类</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/苍穹外卖.assets/image-20231120194321065.png" alt="image-20231120194321065"></p></li><li><p>根据分类id查询菜品</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/苍穹外卖.assets/image-20231120194340174.png" alt="image-20231120194340174"></p></li><li><p>根据分类id查询套餐</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/苍穹外卖.assets/image-20231120194355621.png" alt="image-20231120194355621"></p></li><li><p>根据套餐id查询包含的菜品</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/苍穹外卖.assets/image-20231120194409786.png" alt="image-20231120194409786"></p></li></ul><h2 id="Ⅵ-缓存商品、购物车"><a href="#Ⅵ-缓存商品、购物车" class="headerlink" title="Ⅵ 缓存商品、购物车"></a>Ⅵ 缓存商品、购物车</h2><h3 id="一-缓存菜品"><a href="#一-缓存菜品" class="headerlink" title="一 缓存菜品"></a>一 缓存菜品</h3><h4 id="1-1-问题说明"><a href="#1-1-问题说明" class="headerlink" title="1.1 问题说明"></a>1.1 问题说明</h4><ul><li><p>用户端小程序展示的菜品数据都是通过查询数据库获得，如果用户端访问量比较大，数据库访问压力随之增大。</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/苍穹外卖.assets/image-20231121151948735.png" alt="image-20231121151948735"></p></li></ul><h4 id="1-2-实现思路-1"><a href="#1-2-实现思路-1" class="headerlink" title="1.2 实现思路"></a>1.2 实现思路</h4><ul><li><p>通过Redis来缓存菜品数据，减少数据库查询操作。</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/苍穹外卖.assets/image-20231121152017276.png" alt="image-20231121152017276"></p></li><li><p>缓存逻辑分析</p><ul><li>每个分类下的菜品保存一份缓存数据</li><li>数据库中的菜品数据有变更时清理缓存数据</li></ul></li></ul><h4 id="1-3-代码开发-1"><a href="#1-3-代码开发-1" class="headerlink" title="1.3 代码开发"></a>1.3 代码开发</h4><ul><li>修改管理端接口 DishController 的相关方法，加入清理缓存的逻辑，需要改造的方法：<ul><li>新增菜品</li><li>修改菜品</li><li>批量删除菜品</li><li>起售、停售菜品</li></ul></li></ul><h4 id="1-4-功能测试-1"><a href="#1-4-功能测试-1" class="headerlink" title="1.4 功能测试"></a>1.4 功能测试</h4><h3 id="二-缓存套餐"><a href="#二-缓存套餐" class="headerlink" title="二 缓存套餐"></a>二 缓存套餐</h3><h4 id="2-1-Spring-Cache"><a href="#2-1-Spring-Cache" class="headerlink" title="2.1 Spring Cache"></a>2.1 Spring Cache</h4><ul><li><p>Spring Cache 是一个框架，实现了基于注解的缓存功能，只需要简单地加一个注解，就能实现缓存功能</p></li><li><p>Spring Cache 提供了一层抽象，底层可以切换不同的缓存实现，例如：</p><ul><li>EHCache</li><li>Caffeine</li><li>Redis</li></ul></li><li><p>常用注解</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/苍穹外卖.assets/image-20231121171344515.png" alt="image-20231121171344515"></p></li></ul><h4 id="2-2-实现思路"><a href="#2-2-实现思路" class="headerlink" title="2.2 实现思路"></a>2.2 实现思路</h4><ul><li>导入坐标</li><li>在启动类上加入@EnableCaching注解，开启缓存注解功能</li><li>在用户端接口SetmealController的 list 方法上加入@Cacheable注解</li><li>在管理端接口SetmealController的 save、delete、update、startOrStop等方法上加入CacheEvict注解</li></ul><h4 id="2-3-代码开发与功能测试"><a href="#2-3-代码开发与功能测试" class="headerlink" title="2.3 代码开发与功能测试"></a>2.3 代码开发与功能测试</h4><h3 id="三-添加购物车"><a href="#三-添加购物车" class="headerlink" title="三 添加购物车"></a>三 添加购物车</h3><h4 id="3-1-需求分析和设计-1"><a href="#3-1-需求分析和设计-1" class="headerlink" title="3.1 需求分析和设计"></a>3.1 需求分析和设计</h4><ul><li><p>接口设计</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/苍穹外卖.assets/image-20231121224256927.png" alt="image-20231121224256927"></p></li><li><p>数据库设计</p><ul><li><p>作用：暂时存放所选商品的地方</p><ul><li>选的什么商品，每个商品买了几个，不同的用户的购物车需要分开</li></ul><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/苍穹外卖.assets/image-20231121224403598.png" alt="image-20231121224403598"></p></li></ul></li></ul><h3 id="四-查看购物车"><a href="#四-查看购物车" class="headerlink" title="四 查看购物车"></a>四 查看购物车</h3><h4 id="4-1-需求分析和设计-2"><a href="#4-1-需求分析和设计-2" class="headerlink" title="4.1 需求分析和设计"></a>4.1 需求分析和设计</h4><ul><li><p>接口设计</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/苍穹外卖.assets/image-20231122141933057.png" alt="image-20231122141933057"></p></li></ul><h3 id="五-清空购物车"><a href="#五-清空购物车" class="headerlink" title="五 清空购物车"></a>五 清空购物车</h3><ul><li><p>需求分析和设计</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/苍穹外卖.assets/image-20231122142543137.png" alt="image-20231122142543137"></p></li></ul><h2 id="Ⅶ-用户下单-订单支付"><a href="#Ⅶ-用户下单-订单支付" class="headerlink" title="Ⅶ 用户下单 订单支付"></a>Ⅶ 用户下单 订单支付</h2><h3 id="一-导入地址簿功能"><a href="#一-导入地址簿功能" class="headerlink" title="一 导入地址簿功能"></a>一 导入地址簿功能</h3><h4 id="1-1-查询地址列表"><a href="#1-1-查询地址列表" class="headerlink" title="1.1 查询地址列表"></a>1.1 查询地址列表</h4><ul><li><p>查询登录用户所有地址</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/苍穹外卖.assets/image-20231122193352335.png" alt="image-20231122193352335"></p></li><li><p>查询默认地址</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/苍穹外卖.assets/image-20231122193416024.png" alt="image-20231122193416024"></p></li></ul><h4 id="1-2-新增地址"><a href="#1-2-新增地址" class="headerlink" title="1.2 新增地址"></a>1.2 新增地址</h4><ul><li><p>接口</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/苍穹外卖.assets/image-20231122193334415.png" alt="image-20231122193334415"></p></li></ul><h4 id="1-3-修改地址"><a href="#1-3-修改地址" class="headerlink" title="1.3 修改地址"></a>1.3 修改地址</h4><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/苍穹外卖.assets/image-20231122193425846.png" alt="image-20231122193425846"></p><h4 id="1-4-删除地址"><a href="#1-4-删除地址" class="headerlink" title="1.4 删除地址"></a>1.4 删除地址</h4><ul><li><p>根据id删除地址</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/苍穹外卖.assets/image-20231122193445677.png" alt="image-20231122193445677"></p></li></ul><h4 id="1-5-设置默认地址"><a href="#1-5-设置默认地址" class="headerlink" title="1.5 设置默认地址"></a>1.5 设置默认地址</h4><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/苍穹外卖.assets/image-20231122193529096.png" alt="image-20231122193529096"></p><h4 id="1-6-查询默认地址"><a href="#1-6-查询默认地址" class="headerlink" title="1.6 查询默认地址"></a>1.6 查询默认地址</h4><ul><li><p>根据id查询地址</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/苍穹外卖.assets/image-20231122193516107.png" alt="image-20231122193516107"></p></li></ul><h4 id="1-7-数据表（address-book）"><a href="#1-7-数据表（address-book）" class="headerlink" title="1.7 数据表（address_book）"></a>1.7 数据表（address_book）</h4><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/苍穹外卖.assets/image-20231122193553555.png" alt="image-20231122193553555"></p><h3 id="二-用户下单"><a href="#二-用户下单" class="headerlink" title="二 用户下单"></a>二 用户下单</h3><h4 id="2-1-需求分析和设计-2"><a href="#2-1-需求分析和设计-2" class="headerlink" title="2.1 需求分析和设计"></a>2.1 需求分析和设计</h4><ul><li><p>业务说明</p><ul><li>电商系统中，用户是通过下单的方式通知商家，用户已经购买了商品，需要商家进行备货和发货。</li><li>用户下单后会产生订单相关数据，订单数据需要能够体现如下信息：<ul><li>总金额</li><li>用户</li><li>商品种类及数量</li><li>收获地址</li><li>手机号码</li></ul></li></ul></li><li><p>业务流程</p><ul><li>购物车页面</li><li>订单提交页面</li><li>订单支付页面</li><li>下单成功页面</li></ul></li><li><p>接口分析</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/苍穹外卖.assets/image-20231122202159725.png" alt="image-20231122202159725"></p></li><li><p>数据库设计</p><ul><li><p>订单表 <code>orders</code></p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/苍穹外卖.assets/image-20231122202411139.png" alt="image-20231122202411139"></p></li><li><p>订单明细表 <code>order_detail</code></p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/苍穹外卖.assets/image-20231122202403269.png" alt="image-20231122202403269"></p></li><li><p>订单表和订单明细表的关系：一对多</p></li></ul></li></ul><h4 id="2-2-代码与测试"><a href="#2-2-代码与测试" class="headerlink" title="2.2 代码与测试"></a>2.2 代码与测试</h4><h3 id="三-订单支付"><a href="#三-订单支付" class="headerlink" title="三 订单支付"></a>三 订单支付</h3><h4 id="3-1-微信支付介绍"><a href="#3-1-微信支付介绍" class="headerlink" title="3.1 微信支付介绍"></a>3.1 微信支付介绍</h4><ul><li><p>微信支付产品</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/苍穹外卖.assets/image-20231122210746038.png" alt="image-20231122210746038"></p></li><li><p>微信支付接入流程</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/苍穹外卖.assets/image-20231122210810830.png" alt="image-20231122210810830"></p></li><li><p>微信小程序支付时序图</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/苍穹外卖.assets/image-20231122210859604.png" alt="image-20231122210859604"></p></li><li><p><a href="https://pay.weixin.qq.com/wiki/doc/apiv3/apis/chapter3_5_4.shtml">微信小程序调起支付</a>：通过JSAPI下单接口获取到发起支付的必要参数prepay_id，然后使用微信支付提供的小程序方法调起小程序支付</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/苍穹外卖.assets/image-20231122210950716.png" alt="image-20231122210950716"></p></li></ul><h4 id="3-2-微信支付准备工作"><a href="#3-2-微信支付准备工作" class="headerlink" title="3.2 微信支付准备工作"></a>3.2 微信支付准备工作</h4><ul><li>如何保证数据安全</li><li>微信后台如何调用到商户系统？</li><li>获取微信支付平台证书、商户私钥文件</li><li><a href="https://dashboard.cpolar.com/login">获取临时域名</a>：支付成功后微信服务通过该域名回调我们的程序</li></ul><h4 id="3-3-代码与功能测试"><a href="#3-3-代码与功能测试" class="headerlink" title="3.3 代码与功能测试"></a>3.3 代码与功能测试</h4><ul><li>（看看就好）</li></ul><h2 id="Ⅷ-订单处理"><a href="#Ⅷ-订单处理" class="headerlink" title="Ⅷ 订单处理"></a>Ⅷ 订单处理</h2><h3 id="一-Spring-Task"><a href="#一-Spring-Task" class="headerlink" title="一 Spring Task"></a>一 Spring Task</h3><h4 id="1-1-介绍-1"><a href="#1-1-介绍-1" class="headerlink" title="1.1 介绍"></a>1.1 介绍</h4><ul><li><p>Spring Task 是Spring框架提供的任务调度工具，可以按照约定的时间自动执行某个代码逻辑。</p></li><li><p>作用：定时自动执行某段Java代码</p></li><li>应用场景<ul><li>信用卡每月还款提醒</li><li>银行贷款每月还款提醒</li><li>火车票售票系统处理未支付订单</li><li>入职纪念日为用户发送通知</li></ul></li></ul><h4 id="1-2-cron表达式"><a href="#1-2-cron表达式" class="headerlink" title="1.2 cron表达式"></a>1.2 cron表达式</h4><ul><li><p>cron表达式其实就是一个字符串，通过cron表达式可以<strong>定义任务触发的时间</strong></p></li><li><p>构成规则</p><ul><li><p>分为6或7个域，由空格分隔开，每个域代表一个含义</p></li><li><p>每个域的含义分别为：秒、分钟、小时、日、月、周、年(可选)</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/苍穹外卖.assets/image-20231123195357807.png" alt="image-20231123195357807"></p></li></ul></li></ul><ul><li>cron表达式在线生成器：<a href="https://cron.qqe2.com/">https://cron.qqe2.com/</a></li></ul><h4 id="1-3-demo"><a href="#1-3-demo" class="headerlink" title="1.3 demo"></a>1.3 demo</h4><ul><li><p>导入坐标<code>spring-context</code></p></li><li><p>启动类添加注解<code>@EnableScheduling</code>开启任务调度</p></li><li><p>自定义定时任务类（要加入<code>@Component</code>交给容器管理）</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/苍穹外卖.assets/image-20231123195755121.png" alt="image-20231123195755121"></p></li></ul><h3 id="二-订单状态定时处理"><a href="#二-订单状态定时处理" class="headerlink" title="二 订单状态定时处理"></a>二 订单状态定时处理</h3><h4 id="2-1-需求分析"><a href="#2-1-需求分析" class="headerlink" title="2.1 需求分析"></a>2.1 需求分析</h4><ul><li><p>场景</p><ul><li><p>下单后未支付，订单一直处于“待支付”状态</p></li><li><p>用户收货后管理端未点击完成按钮，订单一直处于“派送中”状态</p></li></ul></li><li><p>逻辑</p><ul><li>通过定时任务<strong>每分钟检查一次</strong>是否存在支付超时订单（下单后超过15分钟仍未支付则判定为支付超时订单），如果存在则修改订单状态为“已取消”</li><li>通过定时任务每天凌晨1点检查一次是否存在“派送中”的订单，如果存在则修改订单状态为“已完成”</li></ul></li></ul><h4 id="2-2-代码与功能测试"><a href="#2-2-代码与功能测试" class="headerlink" title="2.2 代码与功能测试"></a>2.2 代码与功能测试</h4><ul><li>自定义定时任务类OrderTask</li><li>在OrderMapper接口中扩展方法</li></ul><h3 id="三-WebSocket"><a href="#三-WebSocket" class="headerlink" title="三 WebSocket"></a>三 WebSocket</h3><h4 id="3-1-介绍"><a href="#3-1-介绍" class="headerlink" title="3.1 介绍"></a>3.1 介绍</h4><ul><li><p>WebSocket 是基于 TCP 的一种新的网络协议。它实现了浏览器与服务器全双工通信——浏览器和服务器只需要完成一次握手，两者之间就可以创建持久性的连接， 并进行双向数据传输。</p></li><li><p>与http对比</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/苍穹外卖.assets/image-20231123201650217.png" alt="image-20231123201650217"></p></li><li><p>应用场景</p><ul><li>视频弹幕</li><li>网页聊天</li><li>体育实况更新</li><li>股票基金报价实时更新</li></ul></li><li><p>缺点</p><ul><li>服务器长期维护长连接需要一定的成本</li><li>各个浏览器支持程度不一</li><li>WebSocket 是长连接，受网络限制比较大，需要处理好重连</li><li>结论：WebSocket并不能完全取代HTTP，它只适合在特定的场景下使用</li></ul></li></ul><h4 id="3-2-demo"><a href="#3-2-demo" class="headerlink" title="3.2 demo"></a>3.2 demo</h4><ul><li>直接使用websocket.html页面作为WebSocket客户端</li><li>导入WebSocket的maven坐标</li><li>导入WebSocket服务端组件WebSocketServer，用于和客户端通信</li><li>导入配置类WebSocketConfiguration，注册WebSocket的服务端组件</li><li>导入定时任务类WebSocketTask，定时向客户端推送数据</li></ul><h3 id="四-来电提醒"><a href="#四-来电提醒" class="headerlink" title="四 来电提醒"></a>四 来电提醒</h3><h4 id="4-1-需求分析与设计-1"><a href="#4-1-需求分析与设计-1" class="headerlink" title="4.1 需求分析与设计"></a>4.1 需求分析与设计</h4><ul><li><p>需求分析</p><ul><li>语音播报</li><li>弹出提示框</li></ul></li><li><p>设计</p><ul><li>通过WebSocket实现管理端页面和服务端保持长连接状态</li><li>当客户支付后，调用WebSocket的相关API实现服务端向客户端推送消息</li><li>客户端浏览器解析服务端推送的消息，判断是来单提醒还是客户催单，进行相应的消息提示和语音播报</li><li>约定服务端发送给客户端浏览器的数据格式为JSON，字段包括：type，orderId，content<ul><li>type 为消息类型，1为来单提醒 2为客户催单</li><li>orderId 为订单id</li><li>content 为消息内容</li></ul></li></ul></li></ul><h3 id="五-客户催单"><a href="#五-客户催单" class="headerlink" title="五 客户催单"></a>五 客户催单</h3><ul><li>需求分析<ul><li>语音播报</li><li>弹出提示框</li></ul></li><li>设计<ul><li>通过WebSocket实现管理端页面和服务端保持长连接状态</li><li>当客户支付后，调用WebSocket的相关API实现服务端向客户端推送消息</li><li>客户端浏览器解析服务端推送的消息，判断是来单提醒还是客户催单，进行相应的消息提示和语音播报</li><li>约定服务端发送给客户端浏览器的数据格式为JSON，字段包括：type，orderId，content<ul><li>type 为消息类型，1为来单提醒 2为客户催单</li><li>orderId 为订单id</li><li>content 为消息内容</li></ul></li></ul></li></ul><h2 id="Ⅸ-数据统计-图形"><a href="#Ⅸ-数据统计-图形" class="headerlink" title="Ⅸ 数据统计-图形"></a>Ⅸ 数据统计-图形</h2><h3 id="一-Apache-ECharts"><a href="#一-Apache-ECharts" class="headerlink" title="一 Apache ECharts"></a>一 Apache ECharts</h3><h4 id="1-1-介绍-2"><a href="#1-1-介绍-2" class="headerlink" title="1.1 介绍"></a>1.1 介绍</h4><ul><li>Apache ECharts 是一款基于 Javascript 的数据可视化图表库，提供直观，生动，可交互，可个性化定制的数据可视化图表。</li><li><p>官网地址：<a href="https://echarts.apache.org/zh/index.html">https://echarts.apache.org/zh/index.html</a></p></li><li><p>总结：使用Echarts，重点在于研究当前图表所需的数据格式。通常是需要后端提供符合格式要求的动态数据，然后响应给前端来展示图表。</p></li></ul><h3 id="二-营业额统计"><a href="#二-营业额统计" class="headerlink" title="二 营业额统计"></a>二 营业额统计</h3><h4 id="2-1-需求分析和设计-3"><a href="#2-1-需求分析和设计-3" class="headerlink" title="2.1 需求分析和设计"></a>2.1 需求分析和设计</h4><ul><li><p>业务规则</p><ul><li>营业额指订单状态为已完成的订单金额合计</li><li>基于可视化报表的折线图展示营业额数据，X轴为日期，Y轴为营业额</li><li>根据时间选择区间，展示每天的营业额数据</li></ul></li><li><p>接口设计</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/苍穹外卖.assets/image-20231123214519493.png" alt="image-20231123214519493"></p></li></ul><h3 id="三-用户统计"><a href="#三-用户统计" class="headerlink" title="三 用户统计"></a>三 用户统计</h3><h4 id="3-1-需求分析和设计-2"><a href="#3-1-需求分析和设计-2" class="headerlink" title="3.1 需求分析和设计"></a>3.1 需求分析和设计</h4><ul><li><p>业务规则</p><ul><li>基于可视化报表的折线图展示用户数据，X轴为日期，Y轴为用户数</li><li>根据时间选择区间，展示每天的用户总量和新增用户量数据</li></ul></li><li><p>接口设计</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/苍穹外卖.assets/image-20231123221333769.png" alt="image-20231123221333769"></p></li></ul><h3 id="四-订单统计"><a href="#四-订单统计" class="headerlink" title="四 订单统计"></a>四 订单统计</h3><h4 id="4-1-订单统计"><a href="#4-1-订单统计" class="headerlink" title="4.1 订单统计"></a>4.1 订单统计</h4><ul><li><p>业务规则</p><ul><li>有效订单指状态为 “已完成” 的订单</li><li>基于可视化报表的折线图展示订单数据，X轴为日期，Y轴为订单数量</li><li>根据时间选择区间，展示每天的订单总数和有效订单数</li><li>展示所选时间区间内的有效订单数、总订单数、订单完成率，订单完成率 = 有效订单数 / 总订单数 * 100%</li></ul></li><li><p>接口</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/苍穹外卖.assets/image-20231123222330814.png" alt="image-20231123222330814"></p></li></ul><h3 id="五-销量排名"><a href="#五-销量排名" class="headerlink" title="五 销量排名"></a>五 销量排名</h3><ul><li><p>业务规则</p><ul><li>根据时间选择区间，展示销量前10的商品（包括菜品和套餐）</li><li>基于可视化报表的柱状图降序展示商品销量</li><li>此处的销量为商品销售的份数</li></ul></li><li><p>接口</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/苍穹外卖.assets/image-20231123223256614.png" alt="image-20231123223256614"></p></li></ul><h2 id="Ⅹ-数据统计-excel"><a href="#Ⅹ-数据统计-excel" class="headerlink" title="Ⅹ 数据统计-excel"></a>Ⅹ 数据统计-excel</h2><h3 id="一-工作台"><a href="#一-工作台" class="headerlink" title="一 工作台"></a>一 工作台</h3><ul><li><p>展示数据</p><ul><li>今日数据</li><li>订单管理</li><li>菜品总览</li><li>套餐总览</li><li>订单信息</li></ul></li><li><p>接口设计</p><ul><li><p>今日数据接口</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/苍穹外卖.assets/image-20231124093537630.png" alt="image-20231124093537630"></p></li><li><p>订单管理接口</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/苍穹外卖.assets/image-20231124093545626.png" alt="image-20231124093545626"></p></li><li><p>菜品总览接口</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/苍穹外卖.assets/image-20231124093606798.png" alt="image-20231124093606798"></p></li><li><p>套餐总览接口</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/苍穹外卖.assets/image-20231124093615891.png" alt="image-20231124093615891"></p></li><li><p>订单搜索</p></li><li><p>各个状态订单数量统计</p></li></ul></li></ul><h3 id="二-Apache-POI"><a href="#二-Apache-POI" class="headerlink" title="二 Apache POI"></a>二 Apache POI</h3><h4 id="2-1-介绍-1"><a href="#2-1-介绍-1" class="headerlink" title="2.1 介绍"></a>2.1 介绍</h4><ul><li>Apache POI 是一个处理Miscrosoft Office各种文件格式的开源项目。简单来说就是，我们可以使用 POI 在 Java 程序中对Miscrosoft Office各种文件进行读写操作。</li><li>一般情况下，POI 都是用于操作 Excel 文件。</li></ul><h4 id="2-2-应用场景"><a href="#2-2-应用场景" class="headerlink" title="2.2 应用场景"></a>2.2 应用场景</h4><ul><li>银行网银系统导出交易明细</li><li>各种业务系统导出Excel报表</li><li>批量导入业务数据</li></ul><h4 id="2-3-demo"><a href="#2-3-demo" class="headerlink" title="2.3 demo"></a>2.3 demo</h4><ul><li>导入坐标</li><li>读写</li></ul><h3 id="三-导出运营数据Excel报表"><a href="#三-导出运营数据Excel报表" class="headerlink" title="三 导出运营数据Excel报表"></a>三 导出运营数据Excel报表</h3><ul><li><p>业务规则</p><ul><li><p>导出Excel形式的报表文件</p></li><li><p>导出最近30天的运营数据</p></li></ul></li><li><p>接口设计</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/苍穹外卖.assets/image-20231124111425930.png" alt="image-20231124111425930"></p></li><li><p>设计excel模板文件</p></li><li>查询数据</li><li>将数据写入到模板文件</li><li>通过输出流将Excel文件下载到客户端浏览器</li></ul><h2 id="十一-苍穹外卖部署管理端到远程服务器"><a href="#十一-苍穹外卖部署管理端到远程服务器" class="headerlink" title="十一 苍穹外卖部署管理端到远程服务器"></a>十一 苍穹外卖部署管理端到远程服务器</h2><p>参考<a href="https://blog.csdn.net/weixin_74266825/article/details/134899613">https://blog.csdn.net/weixin_74266825/article/details/134899613</a></p><p>及<a href="https://zhuanlan.zhihu.com/p/660284743">https://zhuanlan.zhihu.com/p/660284743</a></p><ul><li>预期结果：实现本地和远程的一键启动，无需额外启动mysql redis nginx</li></ul><h3 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h3><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/image-20240408171713405.png" alt="image-20240408171713405" style="zoom:67%;" /></p><ul><li>sql生成脚本存储在mysql-init目录下，便于创建相关数据表及导入数据</li></ul><h3 id="sky-server工程"><a href="#sky-server工程" class="headerlink" title="sky-server工程"></a>sky-server工程</h3><ul><li><p>sky-server下新建<code>Dockerfile</code></p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用包含 Java 8 的官方 OpenJDK 基础镜像</span></span><br><span class="line"><span class="keyword">FROM</span> openjdk:<span class="number">8</span>-jdk-alpine</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个目录来存储你的应用</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> /app</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 将你的 Spring Boot 应用的 jar 文件复制到镜像中</span></span><br><span class="line"><span class="comment"># 假设你的 jar 文件名为 sky-server-1.0-SNAPSHOT.jar，并且位于 target 目录下</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> ./target/sky-server-1.0-SNAPSHOT.jar /app/sky-server-1.0-SNAPSHOT.jar</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 向外界暴露 8080 端口</span></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">8080</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义容器启动时运行的命令</span></span><br><span class="line"><span class="comment"># 使用 java -jar 命令启动 Spring Boot 应用</span></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> [<span class="string">&quot;java&quot;</span>, <span class="string">&quot;-jar&quot;</span>, <span class="string">&quot;/app/sky-server-1.0-SNAPSHOT.jar&quot;</span>]</span></span><br></pre></td></tr></table></figure></li><li><p>新建一个<code>application-prod.yml</code>，主要是修改了数据库和redis的host和port</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 远程服务器版</span></span><br><span class="line"><span class="attr">sky:</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">driver-class-name:</span> <span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line">    <span class="attr">host:</span> <span class="string">sky-take-out-mysql</span> <span class="comment"># 通过容器的id来访问对应的容器</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">3306</span> <span class="comment"># 应用和mysql容器是在同一个网络中，所以直接访问3306端口，如果是在不同网络中，需要访问外部映射端口，也就是3305</span></span><br><span class="line">    <span class="attr">database:</span> <span class="string">sky_take_out</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">xx</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">xx</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">#阿里oss文件上传的配置</span></span><br><span class="line">  <span class="attr">alioss:</span></span><br><span class="line">    <span class="attr">endpoint:</span> <span class="string">xx</span></span><br><span class="line">    <span class="attr">access-key-id:</span> <span class="string">xx</span></span><br><span class="line">    <span class="attr">access-key-secret:</span> <span class="string">xx</span></span><br><span class="line">    <span class="attr">bucket-name:</span> <span class="string">xx</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">redis:</span></span><br><span class="line">    <span class="attr">host:</span> <span class="string">sky-take-out-redis</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">6379</span></span><br><span class="line">    <span class="comment">#password:</span></span><br><span class="line">    <span class="attr">database:</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">wechat:</span></span><br><span class="line">    <span class="attr">secret:</span> <span class="string">xxx</span></span><br><span class="line">    <span class="attr">appid:</span> <span class="string">xxx</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">shop:</span></span><br><span class="line">    <span class="attr">address:</span> <span class="string">xxx</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">baidu:</span></span><br><span class="line">    <span class="attr">ak:</span> <span class="string">xxx</span></span><br></pre></td></tr></table></figure></li><li><p>之后<code>application.yml</code>工作环境也修改为prod</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8080</span></span><br><span class="line"></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">config:</span></span><br><span class="line">    <span class="attr">use-legacy-processing:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">profiles:</span></span><br><span class="line">    <span class="attr">active:</span> <span class="string">prod</span></span><br><span class="line">    </span><br><span class="line">    <span class="string">...</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="docker-compose文件"><a href="#docker-compose文件" class="headerlink" title="docker compose文件"></a>docker compose文件</h3><ul><li><p>分为service和env两个，其中service主要是mysql、redis等依赖服务，env是项目服务</p></li><li><p>在项目目录下新建<code>docker-compose-service.yml</code></p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">version: <span class="string">&#x27;3&#x27;</span></span><br><span class="line">services:</span><br><span class="line">  mysql:</span><br><span class="line">    image: mysql:<span class="number">8</span> <span class="comment"># 使用的镜像</span></span><br><span class="line">    container_name: sky-take-out-mysql <span class="comment"># 启动的实例名称,这里的name和刚刚在-prod.yml中指定的host一致</span></span><br><span class="line">    environment:</span><br><span class="line">      MYSQL_ROOT_PASSWORD: <span class="number">1234</span> <span class="comment"># root 用户密码</span></span><br><span class="line"></span><br><span class="line">      <span class="comment"># 可以在这里添加额外的环境变量, 但更改认证插件需要使用 command 选项 客户端连接mysql8.0有点问题，设置了这个</span></span><br><span class="line">    command: --default-authentication-plugin=mysql_native_password</span><br><span class="line"></span><br><span class="line">    ports:</span><br><span class="line">      - <span class="string">&quot;3305:3306&quot;</span> <span class="comment"># 端口映射</span></span><br><span class="line">    volumes:</span><br><span class="line">      - ./.mysql-data:/var/lib/mysql <span class="comment"># 将数据目录挂载到本地目录以进行持久化，这个目录存储的就是数据，可以自动生成</span></span><br><span class="line">      - ./mysql-init:/docker-<span class="keyword">entrypoint</span><span class="language-bash">-initdb.d <span class="comment"># 自动执行启动脚本，这个mysql-init是需要手动创建的，目录里面存放sql脚本用来初始化数据库</span></span></span><br><span class="line">    restart: always <span class="comment"># 崩溃后自动重启</span></span><br><span class="line">    networks:</span><br><span class="line">      - mynetwork <span class="comment"># 指定网络</span></span><br><span class="line"></span><br><span class="line">  redis:</span><br><span class="line">    image: redis:<span class="number">6</span></span><br><span class="line">    container_name: sky-take-out-redis</span><br><span class="line">    ports:</span><br><span class="line">      - <span class="string">&quot;6380:6379&quot;</span></span><br><span class="line">    networks:</span><br><span class="line">      - mynetwork</span><br><span class="line">    volumes:</span><br><span class="line">      - ./.redis-data:/data <span class="comment"># 持久化，目录可以自动生成</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># nginx后面讲</span></span><br><span class="line">  nginx:</span><br><span class="line">    image: nginx:latest</span><br><span class="line">    container_name: sky-take-out-nginx </span><br><span class="line">    ports:</span><br><span class="line">      - <span class="string">&quot;8081:80&quot;</span>  <span class="comment"># 将宿主机的 8081 端口映射到容器的 80 端口,项目访问入口：ip:8081</span></span><br><span class="line">    volumes:</span><br><span class="line">      - ./nginx/html:/usr/share/nginx/html:ro  <span class="comment"># 将宿主机的 /data/html 映射到容器的 /usr/share/nginx/html 以提供静态内容</span></span><br><span class="line">      - ./nginx/conf/nginx.conf:/etc/nginx/nginx.conf  <span class="comment"># 使用宿主机的 Nginx 配置文件替换容器中的默认配置</span></span><br><span class="line">    networks:</span><br><span class="line">      - mynetwork</span><br><span class="line"></span><br><span class="line">networks:</span><br><span class="line">  mynetwork: <span class="comment"># 自定义网络，实现网络互通和隔离</span></span><br></pre></td></tr></table></figure></li><li><p>在项目目录下新建<code>docker-compose-env.yml</code></p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">version: <span class="string">&#x27;3.8&#x27;</span></span><br><span class="line">services:</span><br><span class="line">  sky-take-out-service:</span><br><span class="line">    container_name: sky-take-out-service <span class="comment"># 这里的name需要记住，后面nginx有用</span></span><br><span class="line">    build: ./sky-server  <span class="comment"># 会去 sky-server 目录下寻找Dockerfile文件</span></span><br><span class="line">    ports:</span><br><span class="line">      - <span class="string">&quot;8080:8080&quot;</span>  <span class="comment"># 将容器的 8080 端口映射到宿主机的 8080 端口</span></span><br><span class="line">    volumes:</span><br><span class="line">      - ./sky-server:/app/data  <span class="comment"># Optional: 如果你需要持久化日志等数据，或者直接运行编译后的代码</span></span><br><span class="line">    networks:</span><br><span class="line">      - mynetwork</span><br><span class="line"></span><br><span class="line">networks:</span><br><span class="line">  mynetwork:  <span class="comment"># 定义一个网络，使得未来的服务能加入到同一网络中</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="nginx"><a href="#nginx" class="headerlink" title="nginx"></a>nginx</h3><ul><li><p>项目目录下的nginx文件夹</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/image-20240408173241503.png" alt="image-20240408173241503"></p></li><li><p>这里的html和资料中的nginx里面的一样，conf也是，接下来对conf进行修改</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="section">upstream</span> webservers&#123;</span><br><span class="line">    <span class="attribute">server</span> sky-take-out-service:<span class="number">8080</span> weight=<span class="number">90</span> ; <span class="comment"># 直接指定容器名称和容器内部的端口,这里的sky-take-out-service就是docker-compose-env.yml中配置的，端口也是</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span>       <span class="number">80</span>;</span><br><span class="line">    <span class="attribute">server_name</span>  localhost;</span><br><span class="line"></span><br><span class="line">    <span class="section">location</span> / &#123;</span><br><span class="line">        <span class="attribute">root</span>   /usr/share/nginx/html/sky; <span class="comment"># 这里的目录需要修改，这个目录是在docker-compose-service.yml中nginx部分配置的</span></span><br><span class="line">        <span class="attribute">index</span>  index.html index.htm;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">error_page</span>   <span class="number">500</span> <span class="number">502</span> <span class="number">503</span> <span class="number">504</span>  /50x.html;</span><br><span class="line">    <span class="section">location</span> = /50x.html &#123;</span><br><span class="line">        <span class="attribute">root</span>   html;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 反向代理,处理管理端发送的请求</span></span><br><span class="line">    <span class="section">location</span> /api/ &#123;</span><br><span class="line">        <span class="attribute">proxy_pass</span>   http://webservers/admin/;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 反向代理,处理用户端发送的请求</span></span><br><span class="line">    <span class="section">location</span> /user/ &#123;</span><br><span class="line">        <span class="attribute">proxy_pass</span>   http://webservers/user/;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"># WebSocket</span></span><br><span class="line">    <span class="section">location</span> /ws/ &#123;</span><br><span class="line">        <span class="attribute">proxy_pass</span>   http://webservers/ws/;</span><br><span class="line">        <span class="attribute">proxy_http_version</span> <span class="number">1</span>.<span class="number">1</span>;</span><br><span class="line">        <span class="attribute">proxy_read_timeout</span> <span class="number">3600s</span>;</span><br><span class="line">        <span class="attribute">proxy_set_header</span> Upgrade <span class="variable">$http_upgrade</span>;</span><br><span class="line">        <span class="attribute">proxy_set_header</span> Connection <span class="string">&quot;<span class="variable">$connection_upgrade</span>&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure></li></ul><h3 id="本地测试"><a href="#本地测试" class="headerlink" title="本地测试"></a>本地测试</h3><ul><li><p>执行<code>mvn clean</code>， <code>mvn package -DskipTests</code> 在target目录下生成jar包</p></li><li><p>在<code>docker-compose-service.yml</code>中点击启动（这里nginx会启动失败，先不管）</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/image-20240408173901934.png" alt="image-20240408173901934" style="zoom:67%;" /></p></li><li><p>工具测试是否可以连接，mysql端口是3305 redis是6380</p></li><li><p>再运行<code>docker-compose-env.yml</code>，项目成功启动</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/image-20240408174058947.png" alt="image-20240408174058947"></p></li><li><p>过一分钟会有超时订单的处理也可以判断是否成功连接数据库</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/image-20240408174145053.png" alt="image-20240408174145053" style="zoom:67%;" /></p></li><li><p>回去再把nginx容器启动了</p></li><li>访问localhost:8081</li><li>以后就可以直接这样本地启动了</li></ul><h3 id="部署到云服务器"><a href="#部署到云服务器" class="headerlink" title="部署到云服务器"></a>部署到云服务器</h3><ul><li><p>准备一个云服务器 centos 7，安装好maven、docker</p></li><li><p>在根目录下创建 <code>code/sky-take-out</code>目录</p></li><li><p>先在本地执行<code>mvn clean</code>删除jar包，删掉刚刚生成的文件夹，只需要图中右边的那些，然后上传整个项目目录到服务器的目录中</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/image-20240408174550437.png" alt="image-20240408174550437"></p></li><li><p>进入到<code>sky-take-out</code>目录</p></li><li><p>执行<code>mvn package -DskipTests</code> 打包</p></li><li><p>启动环境依赖服务，也可以不用sudo</p><p><code>sudo docker compose -f docker-compose-service.yml up -d</code></p></li><li><p>启动sky-take-out服务，也可以不用sudo</p><p><code>sudo docker compose -f docker-compose-env.yml up -d</code> </p></li><li><p>在docker restart一下nginx容器</p></li></ul><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/image-20240408175006710.png" alt="image-20240408175006710"></p><ul><li>最后访问 服务器ip:8081即可</li></ul><link rel="stylesheet" href="https://cdn1.tianli0.top/gh/zhheo/Post-Abstract-AI@0.15.2/tianli_gpt.css"><script>let tianliGPT_postSelector = '#post #article-container';let tianliGPT_key = 'c9b7741d290063ab872e';</script><script src="https://cdn1.tianli0.top/gh/zhheo/Post-Abstract-AI@0.15.2/tianli_gpt.js"></script>]]></content>
      
      
      <categories>
          
          <category> 实战 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 项目 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>力扣刷题</title>
      <link href="/posts/46256.html"/>
      <url>/posts/46256.html</url>
      
        <content type="html"><![CDATA[<h1 id="力扣刷题"><a href="#力扣刷题" class="headerlink" title="力扣刷题"></a>力扣刷题</h1><h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><h3 id="1-数据结构简介"><a href="#1-数据结构简介" class="headerlink" title="1 数据结构简介"></a>1 数据结构简介</h3><ul><li>线性数据结构<ul><li>数组</li><li>链表：</li><li>栈：<code>LinkedList</code><ul><li><code>addLast(E e)</code>、<code>removeLast()</code></li></ul></li><li>队列：<code>Queue</code><ul><li><code>offer(E e)</code>、<code>poll()</code></li></ul></li></ul></li><li>非线性数据结构<ul><li>树</li><li>堆</li><li>散列表</li><li>图</li></ul></li></ul><h3 id="2-stream-流处理"><a href="#2-stream-流处理" class="headerlink" title="2 stream 流处理"></a>2 stream 流处理</h3><ul><li>中间处理<ul><li><code>filter()</code></li><li><code>limit()</code></li></ul></li><li>最终处理<ul><li><code>forEach()</code></li><li><code>count()</code></li><li><code>collect()</code></li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Arrays.stream(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;...&#125;).max().getAsInt(); <span class="comment">// 获取int数组最大值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取List&lt;Node&gt;中 node.val &gt; 123的 100 个数据</span></span><br><span class="line">List&lt;Node&gt; list2 = list.stream().filter(a -&gt; a.val &gt; <span class="number">123</span>).limit(<span class="number">100</span>).collect(Collectors.toList()); </span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h2><h3 id="一-链表"><a href="#一-链表" class="headerlink" title="一 链表"></a>一 链表</h3><h4 id="1-图书整理Ⅰ"><a href="#1-图书整理Ⅰ" class="headerlink" title="1 图书整理Ⅰ"></a>1 图书整理Ⅰ</h4><blockquote><p>书店店员有一张链表形式的书单，每个节点代表一本书，节点中的值表示书的编号。为更方便整理书架，店员需要将书单倒过来排列，就可以从最后一本书开始整理，逐一将书放回到书架上。请倒序返回这个书单链表。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [3,6,4,1]</span><br><span class="line"></span><br><span class="line">输出：[1,4,6,3]</span><br></pre></td></tr></table></figure></blockquote><ul><li><p>法1：计算长度，然后插入</p></li><li><p>法2：先正向遍历，插入栈中，然后一个一个出栈</p></li><li><p>法3：递归：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] res;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] reversePrint(ListNode head) &#123;</span><br><span class="line">        solve(head);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">solve</span><span class="params">(ListNode head)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">null</span>)&#123;</span><br><span class="line">            res = <span class="keyword">new</span> <span class="title class_">int</span>[i];</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        i++; </span><br><span class="line">        solve(head.next);</span><br><span class="line">        res[j] = head.val;</span><br><span class="line">        j++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="2-反转链表"><a href="#2-反转链表" class="headerlink" title="2 反转链表"></a>2 反转链表</h4><ul><li><p>双指针</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">trainningPlan</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> head, pre = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">tmp</span> <span class="operator">=</span> cur.next; <span class="comment">// 暂存后继节点 cur.next</span></span><br><span class="line">            cur.next = pre;          <span class="comment">// 修改 next 引用指向</span></span><br><span class="line">            pre = cur;               <span class="comment">// pre 暂存 cur</span></span><br><span class="line">            cur = tmp;               <span class="comment">// cur 访问下一节点</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>递归</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">trainningPlan</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> recur(head, <span class="literal">null</span>);    <span class="comment">// 调用递归并返回</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> ListNode <span class="title function_">recur</span><span class="params">(ListNode cur, ListNode pre)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (cur == <span class="literal">null</span>) <span class="keyword">return</span> pre; <span class="comment">// 终止条件</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">res</span> <span class="operator">=</span> recur(cur.next, cur);  <span class="comment">// 递归后继节点</span></span><br><span class="line">        cur.next = pre;              <span class="comment">// 修改节点引用指向</span></span><br><span class="line">        <span class="keyword">return</span> res;                  <span class="comment">// 返回反转链表的头节点</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>k个一组反转链表，不足k个就保持原序</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 主要是找出四个节点：pre, left, right, post 然后反转[left, right]，最后接上left.next和pre.next</span></span><br><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">reverseKGroup</span><span class="params">(ListNode head, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">dummy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(-<span class="number">1</span>);</span><br><span class="line">    dummy.next = head;</span><br><span class="line"></span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">pre</span> <span class="operator">=</span> dummy; <span class="comment">// 反转左端点左侧</span></span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">right</span> <span class="operator">=</span> dummy; <span class="comment">// 反转右端点</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(right.next != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; k &amp;&amp; right != <span class="literal">null</span>; i++) &#123;</span><br><span class="line">            right = right.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(right == <span class="literal">null</span>) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">left</span> <span class="operator">=</span> pre.next; <span class="comment">// 反转左端点</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">post</span> <span class="operator">=</span> right.next; <span class="comment">// 反转右端点右侧</span></span><br><span class="line"></span><br><span class="line">        right.next = <span class="literal">null</span>;</span><br><span class="line">        pre.next = reverse(left);</span><br><span class="line"></span><br><span class="line">        left.next = post;</span><br><span class="line">        pre = left;</span><br><span class="line"></span><br><span class="line">        right = pre;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dummy.next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 反转单一链表</span></span><br><span class="line"><span class="keyword">private</span> ListNode <span class="title function_">reverse</span><span class="params">(ListNode node)</span> &#123;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">pre</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> node;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(cur != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">next</span> <span class="operator">=</span> cur.next;</span><br><span class="line">        cur.next = pre;</span><br><span class="line">        pre = cur;</span><br><span class="line">        cur = next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pre;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="3-链表中倒数第k个"><a href="#3-链表中倒数第k个" class="headerlink" title="3 链表中倒数第k个"></a>3 链表中倒数第k个</h4><ul><li>快慢指针：先让快指针前进k步，然后一起前进直到fast指针到null</li></ul><h4 id="4-合并链表"><a href="#4-合并链表" class="headerlink" title="4 合并链表"></a>4 合并链表</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">trainningPlan</span><span class="params">(ListNode l1, ListNode l2)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">dum</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>), cur = dum;</span><br><span class="line">        <span class="keyword">while</span>(l1 != <span class="literal">null</span> &amp;&amp; l2 != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(l1.val &lt; l2.val) &#123;</span><br><span class="line">                cur.next = l1;</span><br><span class="line">                l1 = l1.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                cur.next = l2;</span><br><span class="line">                l2 = l2.next;</span><br><span class="line">            &#125;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        cur.next = l1 != <span class="literal">null</span> ? l1 : l2;</span><br><span class="line">        <span class="keyword">return</span> dum.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-寻找链表公共节点"><a href="#5-寻找链表公共节点" class="headerlink" title="5 寻找链表公共节点"></a>5 寻找链表公共节点</h4><ul><li><p>快慢指针：先让长的链表先走k步，然后一起走</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">getIntersectionNode</span><span class="params">(ListNode headA, ListNode headB)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">lena</span> <span class="operator">=</span> <span class="number">0</span>, lenb = <span class="number">0</span>;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">a</span> <span class="operator">=</span> headA, b = headB;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(a != <span class="literal">null</span>)&#123;</span><br><span class="line">            lena++;</span><br><span class="line">            a = a.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(b != <span class="literal">null</span>)&#123;</span><br><span class="line">            lenb++;</span><br><span class="line">            b = b.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">d</span> <span class="operator">=</span> lena - lenb;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(d &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">while</span>(d-- &gt; <span class="number">0</span>)</span><br><span class="line">                headA = headA.next;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(d &lt; <span class="number">0</span>)&#123;</span><br><span class="line">            d = -d;</span><br><span class="line">            <span class="keyword">while</span>(d-- &gt; <span class="number">0</span>)</span><br><span class="line">                headB = headB.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(headA != headB)&#123;</span><br><span class="line">            headA = headA.next;</span><br><span class="line">            headB = headB.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> headA;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>循环指针：两个指针分别先走自己的链表，再走另一条链表，如果有公共节点，则会再某一时刻相同</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">getIntersectionNode</span><span class="params">(ListNode headA, ListNode headB)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">A</span> <span class="operator">=</span> headA, B = headB;</span><br><span class="line">        <span class="keyword">while</span> (A != B) &#123;</span><br><span class="line">            A = A != <span class="literal">null</span> ? A.next : headB;</span><br><span class="line">            B = B != <span class="literal">null</span> ? B.next : headA;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> A;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="6-随机链表的复制"><a href="#6-随机链表的复制" class="headerlink" title="6 随机链表的复制"></a>6 随机链表的复制</h4><ul><li><p>方式一：使用map：第一遍构造原node和新node的对应关系，第二遍构造原node的next和random指针和新node的next和random指针的关系</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> Node <span class="title function_">copyRandomList</span><span class="params">(Node head)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">cur</span> <span class="operator">=</span> head;</span><br><span class="line">        Map&lt;Node, Node&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 3. 复制各节点，并建立 “原节点 -&gt; 新节点” 的 Map 映射</span></span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="literal">null</span>) &#123;</span><br><span class="line">            map.put(cur, <span class="keyword">new</span> <span class="title class_">Node</span>(cur.val));</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        cur = head;</span><br><span class="line">        <span class="comment">// 4. 构建新链表的 next 和 random 指向</span></span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="literal">null</span>) &#123;</span><br><span class="line">            map.get(cur).next = map.get(cur.next);</span><br><span class="line">            map.get(cur).random = map.get(cur.random);</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 5. 返回新链表的头节点</span></span><br><span class="line">        <span class="keyword">return</span> map.get(head);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>方式二：考虑构建 原节点 1 -&gt; 新节点 1 -&gt; 原节点 2 -&gt; 新节点 2 -&gt; …… 的拼接链表，如此便可在访问原节点的 random 指向节点的同时找到新对应新节点的 random 指向节点。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> Node <span class="title function_">copyRandomList</span><span class="params">(Node head)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">cur</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="comment">// 1. 复制各节点，并构建拼接链表</span></span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">Node</span> <span class="variable">tmp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(cur.val);</span><br><span class="line">            tmp.next = cur.next;</span><br><span class="line">            cur.next = tmp;</span><br><span class="line">            cur = tmp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 2. 构建各新节点的 random 指向</span></span><br><span class="line">        cur = head;</span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(cur.random != <span class="literal">null</span>)</span><br><span class="line">                cur.next.random = cur.random.next;</span><br><span class="line">            cur = cur.next.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 3. 拆分两链表</span></span><br><span class="line">        cur = head.next;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">pre</span> <span class="operator">=</span> head, res = head.next;</span><br><span class="line">        <span class="keyword">while</span>(cur.next != <span class="literal">null</span>) &#123;</span><br><span class="line">            pre.next = pre.next.next;</span><br><span class="line">            cur.next = cur.next.next;</span><br><span class="line">            pre = pre.next;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        pre.next = <span class="literal">null</span>; <span class="comment">// 单独处理原链表尾节点</span></span><br><span class="line">        <span class="keyword">return</span> res;      <span class="comment">// 返回新链表头节点</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="7-归并排序"><a href="#7-归并排序" class="headerlink" title="7 归并排序"></a>7 归并排序</h4><ul><li>给你链表的头结点 <code>head</code> ，请将其按 升序 排列并返回 排序后的链表</li></ul><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/image-20240630221715150.png" alt="image-20240630221715150" style="zoom:50%;" /></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">sortList</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">null</span> || head.next == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 找到中点</span></span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">fast</span> <span class="operator">=</span> head.next, slow = head;</span><br><span class="line">    <span class="keyword">while</span> (fast != <span class="literal">null</span> &amp;&amp; fast.next != <span class="literal">null</span>) &#123;</span><br><span class="line">        slow = slow.next;</span><br><span class="line">        fast = fast.next.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">temp</span> <span class="operator">=</span> slow.next;</span><br><span class="line">    slow.next = <span class="literal">null</span>;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">left</span> <span class="operator">=</span> sortList(head);</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">right</span> <span class="operator">=</span> sortList(temp);</span><br><span class="line"></span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">h</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">res</span> <span class="operator">=</span> h;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (left != <span class="literal">null</span> &amp;&amp; right != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (left.val &lt; right.val) &#123;</span><br><span class="line">            h.next = left;</span><br><span class="line">            left = left.next;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            h.next = right;</span><br><span class="line">            right = right.next;</span><br><span class="line">        &#125;</span><br><span class="line">        h = h.next;</span><br><span class="line">    &#125;</span><br><span class="line">    h.next = left != <span class="literal">null</span> ? left : right;</span><br><span class="line">    <span class="keyword">return</span> res.next;        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="8-合并k个升序链表"><a href="#8-合并k个升序链表" class="headerlink" title="8 合并k个升序链表"></a>8 合并k个升序链表</h4><ul><li><p>法1：优先级队列</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">mergeKLists</span><span class="params">(ListNode[] lists)</span> &#123;</span><br><span class="line">    PriorityQueue&lt;ListNode&gt; queue = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;ListNode&gt;() &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(ListNode node1, ListNode node2)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> node1.val - node2.val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (ListNode node : lists) &#123;</span><br><span class="line">        <span class="keyword">if</span> (node != <span class="literal">null</span>) &#123;</span><br><span class="line">            queue.offer(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">dummy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(-<span class="number">1</span>);</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> dummy;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">node</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">        cur.next = node;</span><br><span class="line">        cur = cur.next;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (node.next != <span class="literal">null</span>) &#123;</span><br><span class="line">            queue.offer(node.next);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dummy.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>法2：分治合并</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">mergeKLists</span><span class="params">(ListNode[] lists)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> merge(lists, <span class="number">0</span>, lists.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ListNode <span class="title function_">merge</span><span class="params">(ListNode[] lists, <span class="type">int</span> l, <span class="type">int</span> r)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">            <span class="keyword">return</span> lists[l];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (l &gt; r) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line"><span class="comment">// 分</span></span><br><span class="line">        <span class="keyword">return</span> merge2Lists(merge(lists, l, mid), merge(lists, mid+<span class="number">1</span>, r));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 治</span></span><br><span class="line">    <span class="keyword">private</span> ListNode <span class="title function_">merge2Lists</span><span class="params">(ListNode node1, ListNode node2)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (node1 == <span class="literal">null</span> || node2 == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> node1 == <span class="literal">null</span> ? node2 : node1;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">dummy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>();</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> dummy;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">node1Temp</span> <span class="operator">=</span> node1;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">node2Temp</span> <span class="operator">=</span> node2;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (node1Temp != <span class="literal">null</span> &amp;&amp; node2Temp != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (node1Temp.val &lt; node2Temp.val) &#123;</span><br><span class="line">                cur.next = node1Temp;</span><br><span class="line">                node1Temp = node1Temp.next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                cur.next = node2Temp;</span><br><span class="line">                node2Temp = node2Temp.next;</span><br><span class="line">            &#125;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        cur.next = node1Temp == <span class="literal">null</span> ? node2Temp : node1Temp;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="二-数组"><a href="#二-数组" class="headerlink" title="二 数组"></a>二 数组</h3><ul><li><p>双指针:前后夹击</p></li><li><p>滑动窗口:一前一后</p></li><li><p>和为k的子数组</p><ul><li><p>方法一：前缀和+暴力O(n2)</p></li><li><p>方法二：前缀和+哈希表O(n)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// key：前缀和，value：key 对应的前缀和的个数</span></span><br><span class="line">Map&lt;Integer, Integer&gt; preSumFreq = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"><span class="comment">// 对于下标为 0 的元素，前缀和为 0，个数为 1</span></span><br><span class="line">preSumFreq.put(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="variable">preSum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line">    preSum += num;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 先获得前缀和为 preSum - k 的个数，加到计数变量里</span></span><br><span class="line">    <span class="keyword">if</span> (preSumFreq.containsKey(preSum - k)) &#123;</span><br><span class="line">        count += preSumFreq.get(preSum - k);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 然后维护 preSumFreq 的定义</span></span><br><span class="line">    preSumFreq.put(preSum, preSumFreq.getOrDefault(preSum, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> count;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>寻找数组中的众数（一定存在）</p><ul><li><p>哈希表</p></li><li><p>排序，然后中间的就是众数</p></li><li><p>Boyer-Moore 投票算法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">majorityElement</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(nums.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> nums[<span class="number">0</span>];</span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; nums.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[i] == temp) &#123;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            count--;</span><br><span class="line">            <span class="keyword">if</span>(count == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 因为一定存在众数，所以count = 0时i一定不是最后一个</span></span><br><span class="line">                temp = nums[++i];</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h4 id="2-1-股票问题"><a href="#2-1-股票问题" class="headerlink" title="2.1 股票问题"></a>2.1 股票问题</h4><ul><li><p>动态规划</p></li><li><p>只能买卖一次</p><ul><li><code>dp[i]</code>表示第<code>i</code>天所能获得的最大利润</li><li>动态维护一个最小价格<code>minPrice</code></li><li><code>dp[i] = max(dp[i-1], price[i] - minPrice)</code></li></ul></li><li><p>可以多次买卖，同一时刻最多持有一股</p><ul><li><code>dp[i][j]</code>，<code>j</code>表示状态0为没有股票，1表示持有股票，表示第<code>i</code>天的利润。</li><li><code>dp[0][1] = -price[0]</code></li><li>状态转移<ul><li><code>dp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i])</code> 维持前一天状态or当天卖掉</li><li><code>dp[i][1] = max(dp[i-1][1], dp[i-1][0] - prices[i])</code> 维持前一天状态or当天买入</li></ul></li></ul></li><li><p>可以完成两次买卖，同一时刻最多持有一股</p><ul><li>状态说明<ul><li>未进行操作，利润为0，可以不记录</li><li>只买了一次 buy1</li><li>买一次和卖一次 sell1</li><li>买两次和卖一次 buy2</li><li>买两次和卖两次 sell2</li></ul></li><li>初始状态<ul><li><code>buy1 = buy2 = -prices[0]</code></li><li><code>sell1= sell2 = 0</code></li></ul></li><li>状态转移<ul><li><code>buy1 = Math.max(buy1, -prices[i]);</code></li><li><code>sell1 = Math.max(sell1, buy1 + prices[i]);</code></li><li><code>buy2 = Math.max(buy2, sell1 - prices[i]);</code></li><li><code>sell2 = Math.max(sell2, buy2 + prices[i]);</code></li></ul></li></ul></li><li><p>可以完成k次买卖，同一时刻最多持有一股</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span>[] prices)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> prices.length;</span><br><span class="line"><span class="comment">// 1 定义</span></span><br><span class="line">    <span class="comment">// buy[i][j] 第i天进行了j笔交易且还有股票的情况下的最大利润</span></span><br><span class="line">    <span class="comment">// sell[i][j] 第i天进行了j笔交易且没有股票的情况下的最大利润</span></span><br><span class="line">    <span class="type">int</span>[][] buy = <span class="keyword">new</span> <span class="title class_">int</span>[n][k+<span class="number">1</span>];</span><br><span class="line">    <span class="type">int</span>[][] sell = <span class="keyword">new</span> <span class="title class_">int</span>[n][k+<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2 初始状态：初始化 第一行和第一列</span></span><br><span class="line">    <span class="comment">// 2.1 只买一股但是不卖： buy[0:n-1][0] = -prices[0]</span></span><br><span class="line">    <span class="comment">// 2.2 第1天最多操作一次：buy[0][1:k] 、sell[0][1:k]</span></span><br><span class="line">    buy[<span class="number">0</span>][<span class="number">0</span>] = -prices[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// buy[1:n-1][0] sell[1:n-1][0]</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        buy[i][<span class="number">0</span>] = Math.max(buy[i-<span class="number">1</span>][<span class="number">0</span>], -prices[i]);</span><br><span class="line">        <span class="comment">// sell[i][0] = 0;</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="comment">// buy[0][1:k] sell[0][1:k]</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= k; j++) &#123;</span><br><span class="line">        <span class="comment">// 没有意义的数据：第一次不可能完成一次完整交易, /2是为了防止数据溢出</span></span><br><span class="line">        buy[<span class="number">0</span>][j] = Integer.MIN_VALUE / <span class="number">2</span>;</span><br><span class="line">        sell[<span class="number">0</span>][j] = Integer.MIN_VALUE / <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3 状态转移</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= k; j++) &#123;</span><br><span class="line">            <span class="comment">// 第i天持股且完成了j次交易：由i-1天持股状态变来 or i-1天不持股但是第i天买入</span></span><br><span class="line">            buy[i][j] = Math.max(buy[i-<span class="number">1</span>][j], sell[i-<span class="number">1</span>][j] - prices[i]);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 第i天不持股完成了j次交易：由i-1天不持股状态变来 or i-1天持股但是第i天卖出</span></span><br><span class="line">            sell[i][j] = Math.max(sell[i-<span class="number">1</span>][j], buy[i-<span class="number">1</span>][j-<span class="number">1</span>] + prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4 返回sell[n-1]中最大的一个，分别对应完成了k次交易后的最大收益</span></span><br><span class="line">    <span class="keyword">return</span> Arrays.stream(sell[n - <span class="number">1</span>]).max().getAsInt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="2-2-吃橘子-记忆存储dp"><a href="#2-2-吃橘子-记忆存储dp" class="headerlink" title="2.2 吃橘子(记忆存储dp)"></a>2.2 吃橘子(记忆存储dp)</h4><ul><li><p>厨房里总共有 <code>n</code> 个橘子，你决定每一天选择如下方式之一吃这些橘子：</p><ul><li>吃1个</li><li>吃1/2 前提是<code>n</code>被2整除</li><li>吃2/3 前提是<code>n</code>被3整除</li></ul><p>返回吃掉所有橘子最小的天数</p></li><li><p>法1：动态规划，<code>int[] dp = new int[n]</code>，时间复杂度<code>O(n)</code></p></li><li><p>法2：记忆存储，不一个一个的遍历</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;Integer, Integer&gt; memo = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Integer, Integer&gt;();</span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minDays</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(n &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(memo.containsKey(n)) &#123;</span><br><span class="line">        <span class="keyword">return</span> memo.get(n);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    memo.put(n, Math.min(n % <span class="number">2</span> + <span class="number">1</span> + minDays(n / <span class="number">2</span>), n % <span class="number">3</span> + <span class="number">1</span> + minDays(n / <span class="number">3</span>)));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> memo.get(n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="2-3-矩阵中最大得分-二维前缀和"><a href="#2-3-矩阵中最大得分-二维前缀和" class="headerlink" title="2.3 矩阵中最大得分(二维前缀和)"></a>2.3 矩阵中最大得分(二维前缀和)</h4><ul><li><p>给一个二维矩阵，求出其中的一个子矩阵(至少包含两个单元)，使其<code>右下角-左上角</code>的值最大</p><p>二维前缀和+动态规划</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxScore</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; grid)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> Integer.MIN_VALUE;</span><br><span class="line">    <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> grid.size()</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> grid.get(<span class="number">0</span>).size();</span><br><span class="line"><span class="comment">// f[i+1][j+1]表示矩阵左上角[0,0]，右下角[i,j]的子矩阵的最小值</span></span><br><span class="line">    <span class="comment">// f[i+1][j+1] = min(f[i+1][j], f[i][j+1], grid[i][j])</span></span><br><span class="line">    <span class="type">int</span>[][] f = <span class="keyword">new</span> <span class="title class_">int</span>[m + <span class="number">1</span>][n + <span class="number">1</span>];</span><br><span class="line">    Arrays.fill(f[<span class="number">0</span>], Integer.MAX_VALUE);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">        f[i + <span class="number">1</span>][<span class="number">0</span>] = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mn</span> <span class="operator">=</span> Math.min(f[i + <span class="number">1</span>][j], f[i][j + <span class="number">1</span>]); <span class="comment">// 上面和左边拿小的那个</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> grid.get(i).get(j);</span><br><span class="line">            ans = Math.max(ans, x - mn);</span><br><span class="line">            f[i + <span class="number">1</span>][j + <span class="number">1</span>] = Math.min(mn, x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="2-4-数组合并问题"><a href="#2-4-数组合并问题" class="headerlink" title="2.4 数组合并问题"></a>2.4 数组合并问题</h4><ul><li><p>关键是先将数组的左端点或者右端点按照大小排序</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Arrays.sort(points, <span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;<span class="type">int</span>[]&gt;() &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(<span class="type">int</span>[] a, <span class="type">int</span>[] b)</span> &#123;</span><br><span class="line">        <span class="comment">// 按照数组右边界从小到大排序</span></span><br><span class="line">    <span class="keyword">return</span> Integer.compare(a[<span class="number">1</span>], b[<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);   </span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里有一个坑：不能 return a[1] - b[1]，因为如果两个数组的左边界是Integer.MIN_VALUE，相减会导致超出int范围，返回错误的结果，Integer.compare的源码：</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> x &lt; y ? -<span class="number">1</span> : (x == y ? <span class="number">0</span> : <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="2-5-最大子数组"><a href="#2-5-最大子数组" class="headerlink" title="2.5 最大子数组"></a>2.5 最大子数组</h4><p>给你一个整数数组 <code>nums</code> ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p><p>法1：动态规划，O(n)时间</p><p>法2：分治，<em>O</em>(log<em>n</em>)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Status</span> &#123;</span><br><span class="line">        <span class="comment">// 定义一个数组的四个状态：左边界开始的子数组最大和，右边界开始的子数组最大和，子数组最大和，数组所有元素之和</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> lSum, rSum, mSum, iSum;</span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Status</span> <span class="params">(<span class="type">int</span> lSum, <span class="type">int</span> rSum, <span class="type">int</span> mSum, <span class="type">int</span> iSum)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.lSum = lSum;</span><br><span class="line">            <span class="built_in">this</span>.rSum = rSum;</span><br><span class="line">            <span class="built_in">this</span>.mSum = mSum;</span><br><span class="line">            <span class="built_in">this</span>.iSum = iSum;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxSubArray</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> getSum(nums, <span class="number">0</span>, nums.length - <span class="number">1</span>).mSum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Status <span class="title function_">getSum</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> l, <span class="type">int</span> r)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Status</span>(nums[l], nums[l], nums[l], nums[l]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (l + r) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 分</span></span><br><span class="line">        <span class="type">Status</span> <span class="variable">lStatus</span> <span class="operator">=</span> getSum(nums, l, mid);</span><br><span class="line">        <span class="type">Status</span> <span class="variable">rStatus</span> <span class="operator">=</span> getSum(nums, mid + <span class="number">1</span>, r);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 治</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">iSum</span> <span class="operator">=</span> lStatus.iSum + rStatus.iSum;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mSum</span> <span class="operator">=</span> Math.max(Math.max(lStatus.mSum, rStatus.mSum), lStatus.rSum + rStatus.lSum);</span><br><span class="line">        <span class="type">int</span> <span class="variable">lSum</span> <span class="operator">=</span> Math.max(lStatus.lSum, lStatus.iSum + rStatus.lSum);</span><br><span class="line">        <span class="type">int</span> <span class="variable">rSum</span> <span class="operator">=</span> Math.max(rStatus.rSum, rStatus.iSum + lStatus.rSum);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Status</span>(lSum, rSum, mSum, iSum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-6-最大子数组Ⅱ"><a href="#2-6-最大子数组Ⅱ" class="headerlink" title="2.6 最大子数组Ⅱ"></a>2.6 最大子数组Ⅱ</h4><ul><li><p>在2.5的基础上，添加一个可以首尾相连的条件（本质还是dp，但是很巧妙）</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/image-20240703224831944.png" alt="image-20240703224831944" style="zoom:50%;" /></p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxSubarraySumCircular</span><span class="params">(<span class="type">int</span>[] A)</span> &#123;</span><br><span class="line">    <span class="comment">// 最大子数组和最小子数组总有一个是连续的！</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">total</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 数组的总和 = maxSum + minSum</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">maxSum</span> <span class="operator">=</span> A[<span class="number">0</span>]; <span class="comment">// 最大子数组和</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">curMax</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 包含当前元素的最大子数组和</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">minSum</span> <span class="operator">=</span> A[<span class="number">0</span>]; <span class="comment">// 最小子数组和</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">curMin</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 包含当前元素的最小子数组和</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> a : A) &#123;</span><br><span class="line">        curMax = Math.max(curMax + a, a);</span><br><span class="line">        maxSum = Math.max(maxSum, curMax);</span><br><span class="line">        curMin = Math.min(curMin + a, a);</span><br><span class="line">        minSum = Math.min(minSum, curMin);</span><br><span class="line">        total += a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxSum &gt; <span class="number">0</span> ? Math.max(maxSum, total - minSum) : maxSum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-7-二分查找"><a href="#2-7-二分查找" class="headerlink" title="2.7 二分查找"></a>2.7 二分查找</h4><ul><li><p><a href="https://www.bilibili.com/video/BV1fA4y1o715/?spm_id_from=333.337.search-card.all.click&amp;vd_source=1a39594354c31d775ddc587407a55282">https://www.bilibili.com/video/BV1fA4y1o715/?spm_id_from=333.337.search-card.all.click&amp;vd_source=1a39594354c31d775ddc587407a55282</a></p></li><li><p>确定区间：左闭右闭 or 左闭右开</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> nums.length - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (l &lt;= r) &#123; <span class="comment">// 左闭右闭</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> l + (r - l) / <span class="number">2</span>; <span class="comment">// 注意越界问题</span></span><br><span class="line">    <span class="keyword">if</span> (nums[mid] &gt; target) &#123;</span><br><span class="line">        r = mid - <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">l = mid + <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> mid;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> -<span class="number">1</span>;</span><br></pre></td></tr></table></figure></li></ul><h4 id="2-8-快速排序"><a href="#2-8-快速排序" class="headerlink" title="2.8 快速排序"></a>2.8 快速排序</h4><ul><li><p>时间O(NlogN)，空间O(logN)~O(N),</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">int</span>[] fastSort(<span class="type">int</span>[] nums, <span class="type">int</span> l, <span class="type">int</span> r) &#123; <span class="comment">// 升序</span></span><br><span class="line">    <span class="keyword">if</span> (l &gt;= r) &#123;</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// int target = nums[l]; // 哨兵</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> l;</span><br><span class="line">    <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> r;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; j &amp;&amp; nums[j] &gt;= nums[l]) &#123; <span class="comment">// 哨兵在左，一定是从右边开始</span></span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (i &lt; j &amp;&amp; nums[i] &lt;= nums[l]) &#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (i &lt; j) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> nums[i];</span><br><span class="line">            nums[i] = nums[j];</span><br><span class="line">            nums[j] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> nums[l];</span><br><span class="line">    nums[l] = nums[j];</span><br><span class="line">    nums[j] = temp;</span><br><span class="line"></span><br><span class="line">    fastSort(nums, l, j-<span class="number">1</span>);</span><br><span class="line">    fastSort(nums, j+<span class="number">1</span>, r);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> nums;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="2-9-归并排序"><a href="#2-9-归并排序" class="headerlink" title="2.9 归并排序"></a>2.9 归并排序</h4><ul><li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">mergeSort</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> l, <span class="type">int</span> r)</span> &#123;</span><br><span class="line">    <span class="comment">// 终止条件</span></span><br><span class="line">    <span class="keyword">if</span> (l &gt;= r) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">// 递归划分</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> (l + r) / <span class="number">2</span>;</span><br><span class="line">    mergeSort(nums, l, m);</span><br><span class="line">    mergeSort(nums, m + <span class="number">1</span>, r);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 合并子数组</span></span><br><span class="line">    <span class="type">int</span>[] tmp = <span class="keyword">new</span> <span class="title class_">int</span>[r - l + <span class="number">1</span>]; <span class="comment">// 暂存需合并区间元素</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> l; k &lt;= r; k++) &#123;</span><br><span class="line">        tmp[k - l] = nums[k];</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, j = m - l + <span class="number">1</span>;       <span class="comment">// 两指针分别指向左/右子数组的首个元素</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> l; k &lt;= r; k++) &#123;  <span class="comment">// 遍历合并左/右子数组</span></span><br><span class="line">        <span class="keyword">if</span> (i == m - l + <span class="number">1</span>) &#123;</span><br><span class="line">            nums[k] = tmp[j++];</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (j == r - l + <span class="number">1</span> || tmp[i] &lt;= tmp[j]) &#123;</span><br><span class="line">            nums[k] = tmp[i++];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            nums[k] = tmp[j++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="2-10"><a href="#2-10" class="headerlink" title="2.10"></a>2.10</h3><ul><li><p>数组中前k个最频繁的数（<code>hashMap + PriorityQueue</code>）<code>O(NlogN)</code></p><ul><li>更好的方法：桶排序 <code>O(N)</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] topKFrequent(<span class="type">int</span>[] nums, <span class="type">int</span> k) &#123;</span><br><span class="line">    Map&lt;Integer, Integer&gt; frequencyMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 统计每个数字出现的频率</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line">            frequencyMap.put(num, frequencyMap.getOrDefault(num, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">   </span><br><span class="line">        <span class="comment">// 创建桶，桶的索引是频率，值是具有相同频率的数字列表</span></span><br><span class="line">        List&lt;Integer&gt;[] buckets = <span class="keyword">new</span> <span class="title class_">List</span>[nums.length + <span class="number">1</span>]; <span class="comment">// 比如1出现了3次，1就会在索引为3的桶出现</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> key : frequencyMap.keySet()) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">frequency</span> <span class="operator">=</span> frequencyMap.get(key);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (buckets[frequency] == <span class="literal">null</span>) &#123;</span><br><span class="line">                buckets[frequency] = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">            &#125;</span><br><span class="line">            buckets[frequency].add(key);</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// 从高频到低频遍历桶，收集前 k 个频率最高的元素</span></span><br><span class="line">        List&lt;Integer&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> buckets.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (buckets[i] == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (result.size() &gt;= k) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (result.size() &lt; k &amp;&amp; index &lt; buckets[i].size()) &#123;</span><br><span class="line">                result.add(buckets[i].get(index++));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 转换为数组返回</span></span><br><span class="line">        <span class="keyword">return</span> result.stream().mapToInt(i -&gt; i).toArray();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="三-图"><a href="#三-图" class="headerlink" title="三 图"></a>三 图</h3><h4 id="3-1-字典树"><a href="#3-1-字典树" class="headerlink" title="3.1 字典树"></a>3.1 字典树</h4><ul><li><p>典型应用是用于统计，排序和保存<strong>大量的字符串</strong>（但不仅限于字符串）。本质就是一个Node对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Trie</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Trie[] children;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> isEnd;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Trie</span><span class="params">()</span> &#123;</span><br><span class="line">        children = <span class="keyword">new</span> <span class="title class_">Trie</span>[<span class="number">26</span>];</span><br><span class="line">        isEnd = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(String word)</span> &#123;</span><br><span class="line">        <span class="type">Trie</span> <span class="variable">node</span> <span class="operator">=</span> <span class="built_in">this</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; word.length(); i++) &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">ch</span> <span class="operator">=</span> word.charAt(i);</span><br><span class="line">            <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> ch - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span> (node.children[index] == <span class="literal">null</span>) &#123;</span><br><span class="line">                node.children[index] = <span class="keyword">new</span> <span class="title class_">Trie</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            node = node.children[index];</span><br><span class="line">        &#125;</span><br><span class="line">        node.isEnd = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">search</span><span class="params">(String word)</span> &#123;</span><br><span class="line">        <span class="type">Trie</span> <span class="variable">node</span> <span class="operator">=</span> searchPrefix(word);</span><br><span class="line">        <span class="keyword">return</span> node != <span class="literal">null</span> &amp;&amp; node.isEnd;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">startsWith</span><span class="params">(String prefix)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> searchPrefix(prefix) != <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Trie <span class="title function_">searchPrefix</span><span class="params">(String prefix)</span> &#123;</span><br><span class="line">        <span class="type">Trie</span> <span class="variable">node</span> <span class="operator">=</span> <span class="built_in">this</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; prefix.length(); i++) &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">ch</span> <span class="operator">=</span> prefix.charAt(i);</span><br><span class="line">            <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> ch - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span> (node.children[index] == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            node = node.children[index];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="四-位运算"><a href="#四-位运算" class="headerlink" title="四 位运算"></a>四 位运算</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">n &gt;&gt; <span class="number">1</span>; <span class="comment">// 向右移动一位 100110 ==&gt; 010011，相当于/2</span></span><br><span class="line">n &amp; <span class="number">1</span>; <span class="comment">// 最低一位与1 100 &amp; 1 = 0</span></span><br><span class="line">n | <span class="number">1</span>; <span class="comment">// 最低一位变成1 100 | 1 = 101</span></span><br><span class="line"><span class="comment">//进阶：可以用来对某一位赋值：ans |= (1 &lt;&lt; i); //</span></span><br><span class="line">x = x ^ num; <span class="comment">// 异或 相同变0不同为1</span></span><br></pre></td></tr></table></figure><h4 id="4-1-快速幂"><a href="#4-1-快速幂" class="headerlink" title="4.1 快速幂"></a>4.1 快速幂</h4><ul><li><p>快速幂法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="type">long</span> <span class="title function_">qpow</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> mod)</span> &#123;</span><br><span class="line">    <span class="comment">// 求a翻倍b次，结果取模mod</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">1</span>, t = a;</span><br><span class="line">    <span class="keyword">while</span> (b &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((b &amp; <span class="number">1</span>) == <span class="number">1</span>) &#123; <span class="comment">// 只计算末尾是1的指数，因为任何数的0次方=1，就没必要乘了</span></span><br><span class="line">        res = (res * t) % mod;</span><br><span class="line">        &#125;</span><br><span class="line">        b &gt;&gt;= <span class="number">1</span>;<span class="comment">// 指数位右移动：1011(2) -&gt; 101(2)</span></span><br><span class="line">        t = (t * t) % mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">res = (res + qpow(<span class="number">2</span>, s[i + <span class="number">1</span>], mod) * a[i] % mod) % mod;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="五-其他"><a href="#五-其他" class="headerlink" title="五 其他"></a>五 其他</h3><h4 id="5-1-判断是否为质数"><a href="#5-1-判断是否为质数" class="headerlink" title="5.1 判断是否为质数"></a>5.1 判断是否为质数</h4><ul><li><p>只要把循环一直从2尝试到根号x（一个数的两个因数中，毕然有一个小于等于根号x，一个大于等于根号x）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isPrime1</span><span class="params">(<span class="type">int</span> x)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x &lt;= <span class="number">2</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i &lt;= Math.sqrt(x); i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(x % j==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><link rel="stylesheet" href="https://cdn1.tianli0.top/gh/zhheo/Post-Abstract-AI@0.15.2/tianli_gpt.css"><script>let tianliGPT_postSelector = '#post #article-container';let tianliGPT_key = 'c9b7741d290063ab872e';</script><script src="https://cdn1.tianli0.top/gh/zhheo/Post-Abstract-AI@0.15.2/tianli_gpt.js"></script>]]></content>
      
      
      <categories>
          
          <category> study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java基础 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>微服务</title>
      <link href="/posts/65385.html"/>
      <url>/posts/65385.html</url>
      
        <content type="html"><![CDATA[<p>微服务</p><p><a href="https://www.bilibili.com/video/BV1LQ4y127n4/?p=4&amp;spm_id_from=pageDriver&amp;vd_source=1a39594354c31d775ddc587407a55282">https://www.bilibili.com/video/BV1LQ4y127n4/?p=4&amp;spm_id_from=pageDriver&amp;vd_source=1a39594354c31d775ddc587407a55282</a></p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/微服务.assets/image-20231225193851920.png" alt="image-20231225193851920"></p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/微服务.assets/image-20231225194031227.png" alt="image-20231225194031227"></p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/微服务.assets/image-20231225194055227.png" alt="image-20231225194055227"></p><h1 id="Ⅰ实用"><a href="#Ⅰ实用" class="headerlink" title="Ⅰ实用"></a>Ⅰ实用</h1><h2 id="一-微服务治理"><a href="#一-微服务治理" class="headerlink" title="一 微服务治理"></a>一 微服务治理</h2><h3 id="1-1-认识微服务"><a href="#1-1-认识微服务" class="headerlink" title="1.1 认识微服务"></a>1.1 认识微服务</h3><ul><li><p><strong>1.1.1 服务架构演变</strong></p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/微服务.assets/image-20231225195315177.png" alt="image-20231225195315177"></p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/微服务.assets/image-20231225195321668.png" alt="image-20231225195321668"></p><ul><li><p>分布式架构需要考虑的问题</p><ul><li>服务粒度</li><li>服务集群地址如何维护</li><li>服务之间如何远程调用</li><li>服务健康如何感知</li></ul></li><li><p>微服务</p><ul><li><p>微服务是一种经过良好架构设计的<strong>分布式</strong>架构方案</p></li><li><p>微服务架构特征：</p><ul><li><p>单一职责：微服务拆分粒度更小，每一个服务都对应唯一的业务能力，做到单一职责，避免重复业务开发</p></li><li><p>面向服务：微服务对外暴露业务接口</p></li><li><p>自治：团队独立、技术独立、数据独立、部署独立</p></li><li><p>隔离性强：服务调用做好隔离、容错、降级，避免出现级联问题</p></li></ul></li></ul></li></ul></li></ul><ul><li><p><strong>1.1.2 微服务技术对比</strong></p><ul><li>微服务这种方案需要技术框架来落地，全球的互联网公司都在积极尝试自己的微服务落地技术。在国内最知名的就是<code>SpringCloud</code>和阿里巴巴的<code>Dubbo</code>。</li><li><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/微服务.assets/image-20231226152113680.png" alt="image-20231226152113680"></li><li><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/微服务.assets/image-20231226152055182.png" alt="image-20231226152055182"></li></ul></li><li><p><strong>1.1.3 SpringCloud</strong></p><ul><li><p>SpringCloud是目前国内使用最广泛的微服务框架。官网地址：<a href="https://spring.io/projects/spring-cloud。">https://spring.io/projects/spring-cloud。</a></p></li><li><p>SpringCloud集成了各种微服务功能组件，并基于SpringBoot实现了这些组件的自动装配，从而提供了良好的开箱即用体验：</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/微服务.assets/image-20231226152831844.png" alt="image-20231226152831844"></p></li><li><p>本文档<code>Hoxton.SR10</code>、<code>使用2.3.x版本的SpringBoot</code></p></li></ul></li></ul><h3 id="1-2-微服务拆分调用"><a href="#1-2-微服务拆分调用" class="headerlink" title="1.2 微服务拆分调用"></a>1.2 微服务拆分调用</h3><ul><li><p><strong>1.2.1 服务拆分</strong></p><ul><li>注意事项<ul><li>单一职责：不同微服务，不要重复开发相同业务</li><li>数据独立：不要访问其它微服务的数据库</li><li>面向服务：将自己的业务暴露为接口，供其它微服务调用</li></ul></li></ul></li><li><p><strong>1.2.2 服务调用</strong></p><ul><li><p>本质：服务A发送http请求到服务B，获取返回数据</p></li><li><p>注册RestTemplate</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/微服务.assets/image-20231226154207705.png" alt="image-20231226154207705"></p></li><li><p>服务远程调用RestTemplate</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/微服务.assets/image-20231226154214893.png" alt="image-20231226154214893"></p></li><li><p>注意</p><ul><li>基于RestTemplate发起的http请求实现远程调用</li><li>http请求做远程调用是与语言无关的调用，只要知道对方的ip、端口、接口路径、请求参数即可。</li></ul></li></ul></li><li><p><strong>1.2.3 提供者与消费者</strong></p><ul><li>服务提供者：一次业务中，被其它微服务调用的服务。（提供接口给其它微服务）</li><li>服务消费者：一次业务中，调用其它微服务的服务。（调用其它微服务提供的接口）</li></ul></li></ul><h3 id="1-3-eureka注册中心"><a href="#1-3-eureka注册中心" class="headerlink" title="1.3 eureka注册中心"></a>1.3 eureka注册中心</h3><ul><li><p><strong>1.3.1 远程调用的问题</strong></p><ul><li>服务消费者该如何获取服务提供者的地址信息？<ul><li>服务提供者启动时向eureka注册自己的信息</li><li>eureka保存这些信息</li><li>消费者根据服务名称向eureka拉取提供者信息</li></ul></li><li>如果有多个服务提供者，消费者该如何选择？<ul><li>服务消费者利用负载均衡算法，从服务列表中挑选一个</li></ul></li><li>消费者如何得知服务提供者的健康状态？<ul><li>服务提供者会每隔30秒向EurekaServer发送心跳请求，报告健康状态</li><li>eureka会更新记录服务列表信息，心跳不正常会被剔除</li><li>消费者就可以拉取到最新的信息</li></ul></li></ul></li><li><p><strong>1.3.2 eureka原理</strong></p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/微服务.assets/image-20231226154919880.png" alt="image-20231226154919880"></p></li><li><p><strong>1.3.3 搭建EurekaServer</strong></p><ul><li><p>无论是消费者还是提供者都可以注册Eureka服务</p></li><li><p>导入<code>spring-cloud-starter-netflix-eureka-server</code>坐标</p></li><li><p>编写启动类，添加@EnableEurekaServer注解</p></li><li><p>添加application.yml文件，编写配置：</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/微服务.assets/image-20231226155909088.png" alt="image-20231226155909088"></p></li></ul></li><li><p><strong>1.3.4 服务拉取</strong></p><ul><li><p>服务拉取是基于服务名称获取服务列表，然后在对服务列表做负载均衡</p></li><li><p>步骤</p><ul><li><p>修改OrderService的代码，修改访问的url路径，用服务名代替ip、端口：</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/微服务.assets/image-20231226160833093.png" alt="image-20231226160833093"></p></li><li><p>在order-service项目的启动类OrderApplication中的RestTemplate添加<strong>负载均衡</strong>注解：</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/微服务.assets/image-20231226160841985.png" alt="image-20231226160841985"></p></li></ul></li></ul></li></ul><h3 id="1-4-Ribbon负载均衡原理"><a href="#1-4-Ribbon负载均衡原理" class="headerlink" title="1.4 Ribbon负载均衡原理"></a>1.4 Ribbon负载均衡原理</h3><ul><li><p><strong>1.4.1 负载均衡原理</strong></p><ul><li><p>请求流程</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/微服务.assets/image-20231226161000368.png" alt="image-20231226161000368"></p></li><li><p>负载均衡流程</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/微服务.assets/image-20231226161100240.png" alt="image-20231226161100240"></p></li></ul></li><li><p><strong>1.4.2 负载均衡策略</strong></p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/微服务.assets/image-20231226161909330.png" alt="image-20231226161909330"></p><ul><li><p>通过定义<code>IRule</code>实现可以修改负载均衡规则，有两种方式：</p><ul><li><p>代码方式：在order-service中的OrderApplication类中，定义一个新的IRule：</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/微服务.assets/image-20231226161959572.png" alt="image-20231226161959572"></p></li><li><p>配置文件方式：在order-service的application.yml文件中，添加新的配置也可以修改规则：</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/微服务.assets/image-20231226162009232.png" alt="image-20231226162009232"></p></li></ul></li></ul></li><li><p><strong>1.4.3 懒加载</strong></p><ul><li><p>Ribbon默认是采用<strong>懒加载</strong>，即第一次访问时才会去创建LoadBalanceClient，请求时间会很长。</p><p>而<strong>饥饿加载</strong>则会在项目启动时创建，降低第一次访问的耗时，通过下面配置开启饥饿加载：</p></li><li><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/微服务.assets/image-20231226162113706.png" alt="image-20231226162113706"></p></li></ul></li></ul><h3 id="1-5-nacos注册中心"><a href="#1-5-nacos注册中心" class="headerlink" title="1.5 nacos注册中心"></a>1.5 nacos注册中心</h3><ul><li><p><strong>1.5.1 简介</strong></p><ul><li><a href="https://nacos.io/">Nacos</a>是阿里巴巴的产品，现在是<a href="https://spring.io/projects/spring-cloud">SpringCloud</a>中的一个组件。相比<a href="https://github.com/Netflix/eureka">Eureka</a>功能更加丰富，在国内受欢迎程度较高。</li></ul></li><li><p><strong>1.5.2 入门</strong></p><ul><li><p>解压即可</p></li><li><p>conf目录下有一个配置文件<code>application.properties</code>，默认端口8848</p></li><li><p>bin目录为可执行文件，启动命令windows</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">startup.cmd -m standalone</span><br></pre></td></tr></table></figure></li><li><p>默认账号和密码： nacos</p></li><li><p>服务注册到nacos</p><ul><li><p>在cloud-demo父工程中添加<code>spring-cloud-alilbaba</code>的管理依赖：</p></li><li><p>注释掉order-service和user-service中原有的eureka依赖</p></li><li><p>添加nacos的客户端依赖：</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/微服务.assets/image-20231226163146936.png" alt="image-20231226163146936"></p></li><li><p>修改user-service&amp;order-service中的application.yml文件，注释eureka地址，添加nacos地址：</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/微服务.assets/image-20231226163212299.png" alt="image-20231226163212299"></p></li><li><p>启动并测试</p></li></ul></li></ul></li><li><p><strong>1.5.3 Nacos服务分级存储模型</strong></p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/微服务.assets/image-20231226163554779.png" alt="image-20231226163554779"></p><ul><li><p>问题</p><ul><li>服务调用尽可能选择本地集群的服务，跨集群调用延迟较高</li><li>本地集群不可访问时，再去访问其它集群</li></ul></li><li><p>服务集群属性</p><ul><li>集群属性</li></ul><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/微服务.assets/image-20231226163719746.png" alt="image-20231226163719746"></p><ul><li><p>负载均衡策略</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/微服务.assets/image-20231226164050472.png" alt="image-20231226164050472"></p></li><li><p>根据权重负载均衡</p><ul><li>在Nacos控制台可以设置实例的权重值，首先选中实例后面的编辑按钮</li><li>将权重设置为0.1，测试可以发现8081被访问到的频率大大降低</li></ul></li></ul></li></ul></li><li><p><strong>1.5.4 Nacos环境隔离</strong></p><ul><li><p>Nacos中服务存储和数据存储的最外层都是一个名为namespace的东西，用来做最外层隔离</p><ul><li>不同环境之间的服务不能相互访问</li></ul></li><li><p>步骤</p><ul><li><p>在Nacos控制台可以创建namespace，用来隔离不同环境</p></li><li><p>然后填写一个新的命名空间信息</p></li><li><p>保存后会在控制台看到这个命名空间的id</p></li><li><p>修改order-service的application.yml，添加namespace</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/微服务.assets/image-20231226171545634.png" alt="image-20231226171545634"></p></li><li><p>重启order-service后，再来查看控制台</p></li><li><p>此时访问order-service，因为namespace不同，会导致找不到userservice，控制台会报错</p></li></ul></li></ul></li><li><p><strong>1.5.5 nacos和eureka对比</strong></p><ul><li><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/微服务.assets/image-20231226171917654.png" alt="image-20231226171917654"></p></li><li><p>心跳检测失败对于非临时实例nacos不会直接挂掉它</p><ul><li><p>临时实例和非临时实例设置</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/微服务.assets/image-20231226172019183.png" alt="image-20231226172019183"></p></li></ul></li><li><p>其他对比</p><ul><li>相同点<ul><li>都支持服务注册和服务拉取</li><li>都支持服务提供者心跳方式做健康检测</li></ul></li><li>不同点<ul><li>Nacos支持服务端主动检测提供者状态：临时实例采用心跳模式，非临时实例采用主动检测模式</li><li>临时实例心跳不正常会被剔除，非临时实例则不会被剔除</li><li>Nacos支持服务列表变更的消息推送模式，服务列表更新更及时</li><li>Nacos集群默认采用AP方式，当集群中存在非临时实例时，采用CP模式；Eureka采用AP方式</li></ul></li></ul></li></ul></li></ul><h3 id="1-6-Nacos配置管理"><a href="#1-6-Nacos配置管理" class="headerlink" title="1.6 Nacos配置管理"></a>1.6 Nacos配置管理</h3><ul><li><p><strong>1.6.1 统一配置管理</strong></p><ul><li><p>配置更改热更新</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/微服务.assets/image-20231226172518141.png" alt="image-20231226172518141"></p></li><li><p>步骤</p><ul><li><p>在Nacos中添加配置信息</p><ul><li>配置文件id：<code>[服务名称]-[profile].[后缀]</code>  如： <code>userservice-dev.yaml</code></li><li>格式支持<code>yaml</code> <code>properties</code></li></ul></li><li><p>在弹出表单中填写配置信息</p></li><li><p>配置获取的步骤如下</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/微服务.assets/image-20231226172549902.png" alt="image-20231226172549902"></p></li></ul></li><li><p>在微服务中读取统一配置</p><ul><li><p>引入Nacos的配置管理客户端依赖：</p></li><li><p>在userservice中的resource目录添加一个<code>bootstrap.yml</code>文件，这个文件是引导文件，优先级高于<code>application.yml</code></p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/微服务.assets/image-20231226172910290.png" alt="image-20231226172910290"></p></li></ul></li><li><p>注意：</p><ul><li>不是所有的配置都适合放到配置中心，维护起来比较麻烦</li><li>建议将一些关键参数，需要运行时调整的参数放到nacos配置中心，一般都是自定义配置</li></ul></li></ul></li><li><p><strong>1.6.2 配置热更新</strong></p><ul><li>方式一：在@Value注入的变量所在类上添加注解@RefreshScope</li><li>方式二：使用@ConfigurationProperties注解</li></ul></li><li><p><strong>1.6.3 配置共享</strong></p><ul><li><p>微服务启动时会从nacos读取多个配置文件：</p><ul><li><code>[spring.application.name]-[spring.profiles.active].yaml</code>，例如：<code>userservice-dev.yaml</code></li><li><code>[spring.application.name].yaml</code>，例如：<code>userservice.yaml</code></li></ul></li><li><p>无论profile如何变化，<code>[spring.application.name].yaml</code>这个文件一定会加载，因此多环境共享配置可以写入这个文件</p></li><li><p>多种配置的优先级</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/微服务.assets/image-20231226173508631.png" alt="image-20231226173508631"></p></li></ul></li><li><p><strong>1.6.4 搭建Nacos集群</strong></p><ul><li>步骤<ul><li>搭建MySQL集群并初始化数据库表</li><li>下载解压nacos</li><li>修改集群配置（节点信息）、数据库</li><li>分别启动多个nacos节点</li><li>nginx反向代理</li></ul></li></ul></li></ul><h3 id="1-7-Feign"><a href="#1-7-Feign" class="headerlink" title="1.7 Feign"></a>1.7 Feign</h3><ul><li><p><strong>1.7.1 RestTemplate方式调用存在的问题</strong></p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/微服务.assets/image-20231226175217724.png" alt="image-20231226175217724"></p><ul><li>问题<ul><li>可读性差</li><li>参数复杂URL难以维护</li></ul></li></ul></li><li><p><strong>1.7.2 Feign简介</strong></p><ul><li><p>Feign是一个声明式的http客户端，官方地址：<a href="https://github.com/OpenFeign/feign">https://github.com/OpenFeign/feign</a></p></li><li><p>其作用就是帮助我们优雅的实现http请求的发送，解决上面提到的问题。</p></li><li><p>使用步骤</p><ul><li><p>引入依赖</p></li><li><p>在order-service的启动类添加注解开启Feign的功能</p><ul><li><code>@EnableFeignClients</code></li></ul></li><li><p>编写Feign客户端</p><p>​    <img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/微服务.assets/image-20231226175523847.png" alt="image-20231226175523847"></p></li><li><p>用Feign客户端代替RestTemplate</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/微服务.assets/image-20231226175604242.png" alt="image-20231226175604242"></p></li></ul></li></ul></li><li><p><strong>1.7.3 自定义Feign配置</strong></p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/微服务.assets/image-20231226175919842.png" alt="image-20231226175919842"></p><ul><li>两种方式修改，一个是修改配置文件，另一种是声明Bean</li></ul></li><li><p><strong>1.7.4 Feign性能优化</strong></p><ul><li><p>Feign底层</p><ul><li><code>URLConnection</code>：默认实现，不支持连接池</li><li><code>Apache HttpClient</code> ：支持连接池</li><li><code>OKHttp</code>：支持连接池</li></ul></li><li><p>因此优化Feign的性能主要包括：</p><ul><li>使用连接池代替默认的<code>URLConnection</code></li><li>日志级别，最好用<code>basic</code>或<code>none</code></li></ul></li><li><p>性能优化-连接池配置</p><ul><li><p>引入依赖</p><ul><li>feign-httpclient</li></ul></li><li><p>配置连接池</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/微服务.assets/image-20231226184843230.png" alt="image-20231226184843230"></p></li></ul></li></ul></li><li><p><strong>1.7.5 Feign最佳实践</strong></p><ul><li><p>方式一：继承，给消费者的FeignClient和提供者的controller定义统一的父接口作为标准。</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/微服务.assets/image-20231226185220376.png" alt="image-20231226185220376"></p><ul><li>缺点是会造成紧耦合，父接口参数列表中的映射不会被继承</li></ul></li><li><p>方式二：抽取，将FeignClient抽取为独立模块，并且把接口有关的POJO、默认的Feign配置都放到这个模块中，提供给所有消费者使用</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/微服务.assets/image-20231226185415060.png" alt="image-20231226185415060"></p><ul><li><p>缺点是需要写所有的东西，比如order-service引入提取出来的公共模块 feign-api 模块时，也有可能把不需要使用的远程调用方法引入进来了</p></li><li><p>当定义的FeignClient不在SpringBootApplication的扫描包范围时，这些FeignClient无法使用。有两种方式解决：</p><ul><li>方式一：指定FeignClient所在包</li><li>方式二：指定FeignClient字节码</li></ul></li></ul></li></ul></li></ul><h3 id="1-8-统一网关Gateway"><a href="#1-8-统一网关Gateway" class="headerlink" title="1.8 统一网关Gateway"></a>1.8 统一网关Gateway</h3><p><strong>1.8.1 为什么需要</strong></p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/微服务.assets/image-20231226190702250.png" alt="image-20231226190702250"></p><ul><li><p>在SpringCloud中网关的实现包括两种：</p><ul><li>gateway</li><li>zuul</li></ul></li><li><p>Zuul是基于Servlet的实现，属于阻塞式编程。而SpringCloudGateway则是基于Spring5中提供的WebFlux，属于响应式编程的实现，具备更好的性能。</p></li></ul><p><strong>1.8.2 入门</strong></p><ul><li><p>创建新的module,引入SpringCloudGateway的依赖和nacos的服务发现依赖：</p></li><li><p>编写路由配置及nacos地址</p><ul><li><p>路由配置</p><ul><li>路由id：路由的唯一标示</li><li>路由目标（uri）：路由的目标地址，http代表固定地址，lb代表根据服务名负载均衡</li><li>路由断言（predicates）：判断路由的规则</li><li>路由过滤器（filters）：对请求或响应做处理</li></ul><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/微服务.assets/image-20231226191243141.png" alt="z"></p></li></ul></li></ul><p><strong>1.8.3 断言工厂</strong></p><ul><li><p><strong>Route Predicate Factory</strong></p><ul><li>路由id</li><li>uri</li><li>predicates</li><li>filters</li></ul></li><li><p>在配置文件中写的断言规则只是字符串，这些字符串会被Predicate Factory读取并处理，转变为路由判断的条件</p><ul><li><p>例如<code>Path=/user/**</code>是按照路径匹配，这个规则是由org.springframework.cloud.gateway.handler.predicate.PathRoutePredicateFactory类来处理的</p></li><li><p>像这样的断言工厂在SpringCloudGateway还有十几个</p></li></ul></li><li><p>Spring提供的11种基本的Predicate工厂</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/微服务.assets/image-20231226191638193.png" alt="image-20231226191638193"></p></li></ul><p><strong>1.8.4 过滤器工厂GatewayFilter</strong></p><ul><li><p><strong>GatewayFilter</strong>是网关中提供的一种过滤器，可以对进入网关的<strong>请求</strong>和微服务返回的<strong>响应</strong>做处理：</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/微服务.assets/image-20231226191658938.png" alt="image-20231226191658938"></p></li><li><p>Spring提供了31种不同的路由过滤器工厂.</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/微服务.assets/image-20231226191717071.png" alt="image-20231226191717071"></p></li><li><p>默认过滤器</p><ul><li><p>如果要对所有的路由都生效，则可以将过滤器工厂写到default下。格式如下：</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/微服务.assets/image-20231226192549965.png" alt="image-20231226192549965"></p></li></ul></li></ul><p><strong>1.8.5 全局过滤器GlobalFilter</strong></p><ul><li><p>区别在于GatewayFilter通过配置定义，处理逻辑是固定的。而GlobalFilter的逻辑需要自己写代码实现。</p></li><li><p>定义方式是实现<code>GlobalFilter</code>接口。</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/微服务.assets/image-20231226192454491.png" alt="image-20231226192454491"></p></li><li><p>demo案例:定义全局过滤器，拦截并判断用户身份</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/微服务.assets/image-20231226192805427.png" alt="image-20231226192805427"></p><ul><li><p>自定义类，实现GlobalFilter接口，添加@Order注解：</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/微服务.assets/image-20231226192823337.png" alt="image-20231226192823337"></p></li></ul></li></ul><p><strong>1.8.6  过滤器执行顺序</strong></p><ul><li><p>请求进入网关会碰到三类过滤器：当前路由的过滤器、DefaultFilter、GlobalFilter</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/微服务.assets/image-20231226192940005.png" alt="image-20231226192940005"></p></li><li><p>执行顺序</p><ul><li><p>每一个过滤器都必须指定一个int类型的order值，<strong>order值越小，优先级越高，执行顺序越靠前</strong>。</p></li><li><p>路由过滤器和defaultFilter的order由Spring指定，默认是按照声明顺序从1递增。</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/微服务.assets/image-20231226193334218.png" alt="image-20231226193334218"></p></li><li><p>当过滤器的order值一样时，会按照 defaultFilter &gt; 路由过滤器 &gt; GlobalFilter的顺序执行。</p></li></ul></li></ul><p><strong>1.8.7  跨域问题</strong></p><ul><li><p>跨域：域名不一致就是跨域，主要包括：</p><ul><li>域名不同： www.taobao.com 和 www.taobao.org 和 www.jd.com 和 miaosha.jd.com</li><li>域名相同，端口不同：localhost:8080和localhost8081</li></ul></li><li><p>跨域问题：浏览器禁止请求的发起者与服务端发生跨域ajax请求，请求被浏览器拦截的问题</p></li><li><p>解决方案：CORS</p></li><li><p>网关处理跨域采用的同样是CORS方案，并且只需要简单配置即可实现：</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/微服务.assets/image-20231226193517515.png" alt="image-20231226193517515"></p></li></ul><h2 id="二-Docker"><a href="#二-Docker" class="headerlink" title="二 Docker"></a>二 Docker</h2><h3 id="2-1-简介"><a href="#2-1-简介" class="headerlink" title="2.1 简介"></a>2.1 简介</h3><ul><li><p>Docker如何解决依赖的兼容问题的？</p><ul><li>将应用的Libs（函数库）、Deps（依赖）、配置与应用一起打包</li><li>将每个应用放到一个隔离<strong>容器</strong>去运行，避免互相干扰</li></ul></li><li><p>Docker如何解决不同系统环境的问题？</p><ul><li>Docker将用户程序与所需要调用的系统(比如Ubuntu)函数库一起打包</li><li>Docker运行到不同操作系统时，直接基于打包的库函数，借助于操作系统的Linux内核来运行</li></ul></li><li><p>Docker如何解决大型项目依赖关系复杂，不同组件依赖的兼容性问题？</p><ul><li>Docker允许开发中将应用、依赖、函数库、配置一起<strong>打包</strong>，形成可移植镜像</li><li>Docker应用运行在容器中，使用沙箱机制，相互<strong>隔离</strong></li></ul></li><li>Docker如何解决开发、测试、生产环境有差异的问题<ul><li>Docker镜像中包含完整运行环境，包括系统函数库，仅依赖系统的Linux内核，因此可以在任意Linux操作系统上运行</li></ul></li></ul><p><strong>2.1.1 Docker与虚拟机</strong></p><ul><li><p>虚拟机（virtual machine）是在操作系统中模拟硬件设备，然后运行另一个操作系统，比如在 Windows 系统里面运行 Ubuntu 系统，这样就可以运行任意的Ubuntu应用了。</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/微服务.assets/image-20240102100734819.png" alt="image-20240102100734819"></p></li><li><p>差异</p><ul><li>docker是一个系统进程；虚拟机是在操作系统中的操作系统</li><li>docker体积小、启动速度快、性能好；虚拟机体积大、启动速度慢、性能一般</li></ul></li></ul><p><strong>2.1.2 Docker架构</strong></p><ul><li><p>镜像（image）：Docker将应用程序及其所需的依赖、函数库、环境、配置等文件打包在一起，称为镜像。</p></li><li><p>容器（Container）：镜像中的应用程序运行后形成的进程就是<strong>容器</strong>，只是Docker会给容器做隔离，对外不可见。</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/微服务.assets/image-20240102101207896.png" alt="image-20240102101207896"></p></li><li><p>DockerHub：DockerHub是一个Docker镜像的托管平台。这样的平台称为Docker Registry。</p><ul><li>类似的还有阿里云镜像服务，统称为DockerRegistry</li></ul></li><li><p>docker架构</p><ul><li>CS架构</li><li><p>服务端(server)：Docker守护进程，负责处理Docker指令，管理镜像、容器等</p></li><li><p>客户端(client)：通过命令或RestAPI向Docker服务端发送指令。可以在本地或远程向服务端发送指令。</p></li></ul><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/微服务.assets/image-20240102102347257.png" alt="image-20240102102347257"></p><ul><li>注：一般使用docker就是发送指令获取到镜像</li></ul></li></ul><h3 id="2-2-安装"><a href="#2-2-安装" class="headerlink" title="2.2 安装"></a>2.2 安装</h3><ul><li><p>如果之前安装过旧版本的Docker，可以使用下面命令卸载：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">yum remove docker /</span><br><span class="line">                  docker-client /</span><br><span class="line">                  docker-client-latest /</span><br><span class="line">                  docker-common /</span><br><span class="line">                  docker-latest /</span><br><span class="line">                  docker-latest-logrotate /</span><br><span class="line">                  docker-logrotate /</span><br><span class="line">                  docker-selinux /</span><br><span class="line">                  docker-engine-selinux /</span><br><span class="line">                  docker-engine /</span><br><span class="line">                  docker-ce</span><br></pre></td></tr></table></figure></li><li><p>虚拟机需要联网，安装yum工具</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">yum install -y yum-utils /</span><br><span class="line">           device-mapper-persistent-data /</span><br><span class="line">           lvm2 --skip-broken</span><br></pre></td></tr></table></figure></li><li><p>然后更新本地镜像源：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">设置docker镜像源</span></span><br><span class="line">yum-config-manager /</span><br><span class="line">    --add-repo /</span><br><span class="line">    https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo</span><br><span class="line">    </span><br><span class="line">sed -i &#x27;s/download.docker.com/mirrors.aliyun.com//docker-ce/g&#x27; /etc/yum.repos.d/docker-ce.repo</span><br><span class="line"></span><br><span class="line">yum makecache fast</span><br></pre></td></tr></table></figure><p>然后输入命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install -y docker-ce</span><br></pre></td></tr></table></figure><p>docker-ce为社区免费版本。稍等片刻，docker即可安装成功。</p></li><li><p>启动前关闭防火墙，因为Docker应用需要用到各种端口，逐一去修改防火墙设置。非常麻烦</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 关闭</span></span><br><span class="line">systemctl stop firewalld</span><br><span class="line"><span class="comment"># 禁止开机启动防火墙</span></span><br><span class="line">systemctl <span class="built_in">disable</span> firewalld</span><br></pre></td></tr></table></figure></li><li><p>通过命令启动docker：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">systemctl start docker  <span class="comment"># 启动docker服务</span></span><br><span class="line"></span><br><span class="line">systemctl stop docker  <span class="comment"># 停止docker服务</span></span><br><span class="line"></span><br><span class="line">systemctl restart docker  <span class="comment"># 重启docker服务</span></span><br></pre></td></tr></table></figure></li><li><p>然后输入命令，可以查看docker版本：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker -v</span><br></pre></td></tr></table></figure></li><li><p>查看状态</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl status docker</span><br></pre></td></tr></table></figure></li><li><p>配置镜像加速</p><p><a href="https://cr.console.aliyun.com/cn-hangzhou/instances/mirrors">https://cr.console.aliyun.com/cn-hangzhou/instances/mirrors</a></p></li></ul><h3 id="2-3-一般操作"><a href="#2-3-一般操作" class="headerlink" title="2.3 一般操作"></a>2.3 一般操作</h3><ul><li><p>镜像相关命令</p><ul><li>镜像名称一般分两部分组成：<code>[repository]:[tag]</code>。<ul><li>eg：<code>mysql:5.7</code></li></ul></li><li>在没有指定tag时，默认是latest，代表最新版本的镜像</li></ul></li><li><p>镜像操作</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/微服务.assets/image-20240102111427941.png" alt="image-20240102111427941"></p></li><li><p>容器操作</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/微服务.assets/image-20240102111916857.png" alt="image-20240102111916857"></p><ul><li><p>这里的 <code>docker rm</code>删除的是硬盘中的容器对象</p></li><li><p><code>docker run</code>的常见参数</p><ul><li><code>--name</code>：指定容器名称</li><li><code>-p</code>：指定端口</li><li><code>-d</code>：后台运行</li></ul><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/微服务.assets/image-20240102112848850.png" alt="image-20240102112848850"></p><ul><li>外部访问宿主机的80端口(前面的)的时候就会映射到内部指定的80端口(后面的 )，从而访问到nginx</li></ul></li></ul></li><li><p>数据卷</p><ul><li><p>容器与数据耦合的问题</p><ul><li>修改不方便：需要进入容器内部修改</li><li>数据不可复用：在容器内的修改对外不可见</li><li>升级困难：升级必然会删除旧容器</li></ul></li><li><p>数据卷：一个虚拟目录，指向宿主机文件系统中的某个目录</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/微服务.assets/image-20240102153532341.png" alt="image-20240102153532341"></p></li></ul></li><li><p>数据卷操作</p><ul><li><code>docker volume [COMMAND]</code><ul><li>create      创建一个volume</li><li>inspect    显示一个或多个volume信息</li><li>ls               列出所有volume</li><li>prune       删除未使用的volume</li><li>rm             删除一个或多个指定的volume</li></ul></li></ul></li><li><p>将数据卷挂载到容器中</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/微服务.assets/image-20240102154009301.png" alt="image-20240102154009301"></p><ul><li><code>-v volumeName:/targetContainerPath</code></li><li>如果容器运行时vlolume不存在，会被自动创建出来</li></ul></li><li><p>练习</p></li></ul><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/微服务.assets/image-20240102160118303.png" alt="image-20240102160118303"></p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/微服务.assets/image-20240102162712831.png" alt="image-20240102162712831"></p><h3 id="2-4-自定义镜像"><a href="#2-4-自定义镜像" class="headerlink" title="2.4 自定义镜像"></a>2.4 自定义镜像</h3><ul><li><p>镜像是将应用程序及其需要的系统函数库、环境、配置、依赖打包而成。</p></li><li><p>镜像结构</p><ul><li>基础镜像<strong>BaseImage</strong>：应用依赖的系统函数库、环境、配置、文件等</li><li>层<strong>Layer</strong>：在BaseImage基础上添加安装包、依赖、配置等，每次操作都形成新的一层<ul><li>为了节省升级成本</li></ul></li><li>入口<strong>Entrypoint</strong>：镜像运行入口，一般是程序启动的脚本和参数</li></ul></li><li><p>Dockerfile：就是一个文本文件，其中包含一个个的<strong>指令</strong>(Instruction)，用指令来说明要执行什么操作来构建镜像。每一个指令都会形成一层Layer</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/微服务.assets/image-20240102161834986.png" alt="image-20240102161834986"></p></li></ul><h3 id="2-5-DockerCompose"><a href="#2-5-DockerCompose" class="headerlink" title="2.5 DockerCompose"></a>2.5 DockerCompose</h3><ul><li><p>Docker Compose可以基于Compose文件帮我们快速的部署分布式应用，而无需手动一个个创建和运行容器</p></li><li><p>Compose文件是一个文本文件，通过指令定义集群中的每个容器如何运行（对比上面黑底白字的指令）</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/微服务.assets/image-20240102162600295.png" alt="image-20240102162600295"></p></li></ul><h3 id="2-6-镜像仓库"><a href="#2-6-镜像仓库" class="headerlink" title="2.6 镜像仓库"></a>2.6 镜像仓库</h3><ul><li><p>公共仓库：例如Docker官方的 <a href="https://hub.docker.com/">Docker Hub</a>，国内也有一些云服务商提供类似于 Docker Hub 的公开服务，比如 <a href="https://c.163.com/hub">网易云镜像服务</a>、<a href="https://hub.daocloud.io/">DaoCloud</a><a href="https://hub.daocloud.io/"> </a><a href="https://hub.daocloud.io/">镜像服务</a>、<a href="https://cr.console.aliyun.com/">阿里云镜像服务</a>等。</p></li><li><p>除了使用公开仓库外，用户还可以在本地搭建私有 Docker Registry。企业自己的镜像最好是采用私有Docker Registry来实现。</p><ul><li><a href="https://hub.docker.com/_/registry">https://hub.docker.com/_/registry</a></li></ul></li><li><p>简化版</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">docker run -d /</span><br><span class="line">    --restart=always /</span><br><span class="line">    --name registry/</span><br><span class="line">    -p 5000:5000 /</span><br><span class="line">    -v registry-data:/var/lib/registry /</span><br><span class="line">    registry</span><br></pre></td></tr></table></figure><ul><li><p>命令中挂载了一个数据卷registry-data到容器内的/var/lib/registry 目录，这是私有镜像库存放数据的目录。</p><p>访问<a href="http://YourIp:5000/v2/_catalog">http://YourIp:5000/v2/_catalog</a> 可以查看当前私有镜像服务中包含的镜像</p></li></ul></li><li><p>带有图形化界面版本（新建一个docker-compose.yml文件）</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">version: <span class="string">&#x27;3.0&#x27;</span></span><br><span class="line">services:</span><br><span class="line">  registry:</span><br><span class="line">    image: registry</span><br><span class="line">    volumes:</span><br><span class="line">      - ./registry-data:/var/lib/registry</span><br><span class="line">  ui:</span><br><span class="line">    image: joxit/docker-registry-ui:static</span><br><span class="line">    ports:</span><br><span class="line">      - 8080:80</span><br><span class="line">    environment:</span><br><span class="line">      - REGISTRY_TITLE=传智教育私有仓库</span><br><span class="line">      - REGISTRY_URL=http://registry:5000</span><br><span class="line">    depends_on:</span><br><span class="line">      - registry</span><br></pre></td></tr></table></figure><ul><li>执行命令 <code>docker-compose up -d</code></li></ul></li><li><p>配置docker信任地址</p><p>我们的私服采用的是http协议，默认不被Docker信任，所以需要做一个配置：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 打开要修改的文件</span></span><br><span class="line">vi /etc/docker/daemon.json</span><br><span class="line"><span class="comment"># 添加内容：</span></span><br><span class="line"><span class="string">&quot;insecure-registries&quot;</span>:[<span class="string">&quot;http://192.168.150.101:8080&quot;</span>]</span><br><span class="line"><span class="comment"># 重加载</span></span><br><span class="line">systemctl daemon-reload</span><br><span class="line"><span class="comment"># 重启docker</span></span><br><span class="line">systemctl restart docker</span><br></pre></td></tr></table></figure></li></ul><h2 id="三-异步通信"><a href="#三-异步通信" class="headerlink" title="三 异步通信"></a>三 异步通信</h2><h3 id="3-1-MQ"><a href="#3-1-MQ" class="headerlink" title="3.1 MQ"></a>3.1 MQ</h3><p><strong>3.1.1 简介</strong></p><ul><li>同步通讯和异步通讯区别<ul><li>视频和文字聊天的区别</li></ul></li><li>微服务之间的基于Feign的调用就属于同步方式，存在一些问题<ul><li>耦合度高，每次加入新的需求，都要修改原来的代码</li><li>性能下降，调用者需要等待服务提供者响应，如果调用链过长则响应时间等于每次调用的时间之和。</li><li>资源浪费，调用链中的每个服务在等待响应过程中，不能释放请求占用的资源，高并发场景下会极度浪费系统资源</li><li>级联失败，如果服务提供者出现问题，所有调用方都会跟着出问题，如同多米诺骨牌一样，迅速导致整个微服务群故障</li></ul></li><li>同步调用的优点是时效性强，可以立即得到结果</li></ul><p><strong>3.1.2 异步通讯</strong></p><ul><li><p>异步调用常见实现就是<strong>事件驱动模式</strong></p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/微服务.assets/image-20240103094411644.png" alt="image-20240103094411644"></p></li><li><p>优点</p><ul><li>服务解耦</li><li>性能提升，吞吐量提高</li><li>服务没有强依赖，不担心级联失败问题</li><li>流量削峰</li></ul></li><li><p>缺点</p><ul><li>依赖于Broker的可靠性、安全性、吞吐能力</li><li>架构复杂了，业务没有明显的流程线，不好追踪管理</li></ul></li></ul><p><strong>3.1.3 MQ常见框架</strong></p><ul><li><p>MQ （MessageQueue），中文是消息队列，字面来看就是存放消息的队列。也就是事件驱动架构中的Broker。</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/微服务.assets/image-20240103095429085.png" alt="image-20240103095429085"></p></li></ul><h3 id="3-2-RabbitMQ"><a href="#3-2-RabbitMQ" class="headerlink" title="3.2 RabbitMQ"></a>3.2 RabbitMQ</h3><p><strong>3.2.1 简介</strong></p><ul><li><p>RabbitMQ是基于Erlang语言开发的开源消息通信中间件，官网地址：<a href="https://www.rabbitmq.com/">https://www.rabbitmq.com/</a></p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/微服务.assets/image-20240103101849353.png" alt="image-20240103101849353"></p></li><li><p>相关概念</p><ul><li>channel：操作MQ的工具</li><li>exchange：路由消息到队列中</li><li>queue：缓存消息</li><li>virtual host：虚拟主机，是对queue、exchange等资源的逻辑分组</li></ul></li></ul><p><strong>3.2.2 常见消息模型</strong></p><ul><li><p>基本消息队列（BasicQueue）</p></li><li><p>工作消息队列（WorkQueue）</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/微服务.assets/image-20240103102207335.png" alt="image-20240103102207335"></p></li><li><p>发布订阅（Publish、Subscribe），又根据交换机类型不同分为三种：</p><ul><li>Fanout Exchange：广播</li><li>Direct Exchange：路由</li><li>Topic Exchange：主题</li></ul><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/微服务.assets/image-20240103102220169.png" alt="image-20240103102220169"></p></li></ul><p><strong>3.2.3 demo</strong></p><ul><li><p>基本消息队列的消息发送流程：</p><p>1.建立connection</p><p>2.创建channel</p><p>3.利用channel声明队列</p><p>4.利用channel向队列发送消息</p></li><li><p>基本消息队列的消息接收流程：</p><p>1.建立connection</p><p>2.创建channel</p><p>3.利用channel声明队列</p><p>4.定义consumer的消费行为<code>handleDelivery()</code></p><p>5.利用channel将消费者与队列绑定</p></li></ul><h3 id="3-3-SpringAMQP"><a href="#3-3-SpringAMQP" class="headerlink" title="3.3 SpringAMQP"></a>3.3 SpringAMQP</h3><ul><li><strong>A</strong>dvanced <strong>M</strong>essage <strong>Q</strong>ueuing <strong>P</strong>rotocol，是用于在应用程序之间传递业务消息的开放<strong>标准</strong>。该协议与语言和平台无关，更符合微服务中独立性的要求。</li><li>SpringAMQP是基于AMQP协议定义的一套API规范，提供了模板来接收和发送消息。包含两部分，其中spring-smqp是基础抽象，spring-rabbit是底层的默认实现</li><li>springAMQP如何发送消息<ul><li>引入amqp的starter依赖</li><li>配置RabbitMQ地址</li><li>利用RabbitTemplate的<code>convertAndSend</code>方法</li></ul></li></ul><p><strong>3.3.1 简单队列 BasicQueue</strong></p><ul><li><p>1对1</p></li><li><p>引入依赖</p></li><li><p>编写publisher，向simple.queue发送消息</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/微服务.assets/image-20240103104251376.png" alt="image-20240103104251376"></p></li><li><p>编写consumer，监听simple.queue</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/微服务.assets/image-20240103104338382.png" alt="image-20240103104338382"></p></li></ul><p><strong>3.3.2 工作队列 WorkQueue</strong> </p><ul><li><p>一个publisher对多个consumer</p><ul><li>可以提高消息处理速度，避免队列消息堆积</li></ul><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/微服务.assets/image-20240103104739557.png" alt="image-20240103104739557"></p></li><li><p>操作过程同上，只不过consumer中多了几个<code>@RabbitListener</code>注解的方法</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/微服务.assets/image-20240103104948786.png" alt="image-20240103104948786"></p><p><strong>3.3.3 发布、订阅模型</strong></p></li></ul><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/微服务.assets/image-20240103105323891.png" alt="image-20240103105323891"></p><ul><li><p>交换机的作用</p><ul><li>接收publisher发送的消息</li><li>将消息按照规则路由到与之绑定的队列</li><li>不能缓存消息，路由失败，消息丢失</li><li>FanoutExchange的会将消息路由到每个绑定的队列</li></ul></li><li><p>声明队列、交换机、绑定关系的Bean</p><ul><li><p>Queue</p></li><li><p>FanoutExchange</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/微服务.assets/image-20240103105928868.png" alt="image-20240103105928868"></p></li><li><p>Binding</p></li></ul></li><li><p>Fanout</p><ul><li><p>所有的队列都能接收</p></li><li><p>demo</p><ul><li>在consumer服务中，利用代码声明队列、交换机，并将两者绑定</li></ul><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/微服务.assets/image-20240103105732430.png" alt="image-20240103105732430"></p><ul><li>在consumer服务中，编写两个消费者方法，分别监听fanout.queue1和fanout.queue2</li></ul><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/微服务.assets/image-20240103105804740.png" alt="image-20240103105804740"></p><ul><li>在publisher中编写测试方法，向itcast.fanout发送消息</li></ul><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/微服务.assets/image-20240103105827347.png" alt="image-20240103105827347"></p></li></ul></li><li><p>Direct</p><ul><li><p>Direct Exchange 会将接收到的消息根据规则路由到指定的Queue，因此称为路由模式（routes）。</p><ul><li>每一个Queue都与Exchange设置一个BindingKey</li><li>发布者发送消息时，指定消息的RoutingKey</li><li>Exchange将消息路由到BindingKey与消息RoutingKey一致的队列</li><li>如果多个队列具有相同的RoutingKey，则与Fanout功能类似</li></ul></li><li><p>demo</p><ul><li><p>在consumer服务中，编写两个消费者方法，分别监听direct.queue1和direct.queue2</p></li><li><p>并利用@RabbitListener声明Exchange、Queue、RoutingKey（<strong>基于注解声明</strong>）</p><p><code>@Queue</code> <code>@Exchange</code></p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/微服务.assets/image-20240103110525148.png" alt="image-20240103110525148"></p></li></ul></li></ul></li><li><p>Topic</p><ul><li><p>TopicExchange与DirectExchange类似，区别在于routingKey必须是多个单词的列表，并且以 <strong>.</strong> 分割。</p><p>Queue与Exchange指定BindingKey时可以使用通配符：</p><h1 id="：代指0个或多个单词"><a href="#：代指0个或多个单词" class="headerlink" title="：代指0个或多个单词"></a>：代指0个或多个单词</h1><p>*：代指一个单词</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/微服务.assets/image-20240103111137943.png" alt="image-20240103111137943"></p></li><li><p>demo</p><ul><li><p>在consumer服务中，编写两个消费者方法，分别监听topic.queue1和topic.queue2，</p></li><li><p>并利用@RabbitListener声明Exchange、Queue、RoutingKey</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/微服务.assets/image-20240103111219907.png" alt="image-20240103111219907"></p></li><li><p>测试</p><p>&lt;img src=(<a href="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/微服务.assets/image-20240103111413444.png">https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/微服务.assets/image-20240103111413444.png</a>“ alt=”image-20240103111413444” style=”zoom:200%;” /&gt;</p></li></ul></li></ul></li></ul><p><strong>3.3.4 消息转换器</strong></p><ul><li><p>说明：在SpringAMQP的发送方法中，接收消息的类型是Object，也就是说我们可以发送任意对象类型的消息，SpringAMQP会帮我们序列化为字节后发送。</p></li><li><p>Spring的对消息对象的处理是由org.springframework.amqp.support.converter.MessageConverter来处理的。而默认实现是SimpleMessageConverter，<strong>基于JDK的ObjectOutputStream完成序列化</strong></p></li><li><p>注意发送方与接收方<strong>必须</strong>使用相同的MessageConverter</p></li><li><p>JSON方式序列化demo</p><ul><li><p>publisher服务</p><ul><li><p>引入依赖</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/微服务.assets/image-20240103112044867.png" alt="image-20240103112044867"></p></li><li><p>声明MessageConverter</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/微服务.assets/image-20240103112053478.png" alt="image-20240103112053478"></p></li></ul></li><li><p>consumer服务</p><ul><li><p>引入依赖</p><p>同上</p></li><li><p>定义MessageConverter</p><p>同上</p></li><li><p>定义一个消费者，监听object.queue队列并消费消息：</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/微服务.assets/image-20240103112140182.png" alt="image-20240103112140182"></p></li></ul></li></ul></li></ul><h2 id="四-分布式搜索引擎-ES基础"><a href="#四-分布式搜索引擎-ES基础" class="headerlink" title="四 分布式搜索引擎-ES基础"></a>四 分布式搜索引擎-ES基础</h2><h3 id="4-1-elasticsearch"><a href="#4-1-elasticsearch" class="headerlink" title="4.1 elasticsearch"></a>4.1 elasticsearch</h3><p><strong>4.1.1 ES</strong></p><ul><li><p>elasticsearch是一款非常强大的开源搜索引擎，可以帮助我们从海量数据中快速找到需要的内容。</p></li><li><p>elasticsearch结合kibana、Logstash、Beats，也就是elastic stack（ELK）。被广泛应用在日志数据分析、实时监控等领域。</p></li><li><p>elasticsearch是elastic stack的核心，负责存储、搜索、分析数据。</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/微服务.assets/image-20240103112433668.png" alt="image-20240103112433668"></p></li><li><p>发展</p><ul><li>Lucene是一个Java语言的搜索引擎类库，是Apache公司的顶级项目，由DougCutting于1999年研发。官网地址：<a href="https://lucene.apache.org/">https://lucene.apache.org/</a> 。<ul><li>优势：易扩展、高性能（基于倒排索引）</li><li>缺点：只限于java、学习曲线陡峭、不支持水平扩展</li></ul></li><li>2004年Shay Banon基于Lucene开发了Compass</li><li>2010年Shay Banon 重写了Compass，取名为Elasticsearch。<ul><li>相比与lucene，elasticsearch具备优势：<ul><li>支持分布式，可水平扩展</li><li>提供Restful接口，可被任何语言调用</li></ul></li></ul></li><li>搜索引擎技术排名：<ul><li>Elasticsearch：开源的分布式搜索引擎</li><li>Splunk：商业项目</li><li>Solr：Apache的开源搜索引擎</li></ul></li></ul></li></ul><p><strong>4.1.2 倒排索引</strong></p><ul><li><p>传统数据库（如MySQL）采用正向索引，例如给下表（tb_goods）中的id创建索引：</p></li><li><p>elasticsearch采用倒排索引：</p><ul><li>文档（document）：每条数据就是一个文档</li><li>词条（term）：文档按照语义分成的词语</li></ul><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/微服务.assets/image-20240103113255736.png" alt="image-20240103113255736"></p></li><li><p>索引</p><p>&lt;img src=(<a href="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/微服务.assets/image-20240103113341607.png">https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/微服务.assets/image-20240103113341607.png</a>“ alt=”image-20240103113341607” style=”zoom: 50%;” /&gt;</p></li><li><p>倒排索引中包含两部分内容：</p><ul><li>词条词典（Term Dictionary）：记录所有词条，以及词条与倒排列表（Posting List）之间的关系，会给词条创建索引，提高查询和插入效率</li><li>倒排列表（Posting List）：记录词条所在的文档id、词条出现频率 、词条在文档中的位置等信息<ul><li>文档id：用于快速获取文档</li><li>词条频率（TF）：文档在词条出现的次数，用于评分</li></ul></li></ul></li></ul><p><strong>4.1.3 es概念</strong></p><ul><li><p>文档：elasticsearch是面向文档存储的，可以是数据库中的一条商品数据，一个订单信息。</p><p>文档数据会被序列化为json格式后存储在elasticsearch中。</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/微服务.assets/image-20240103113558677.png" alt="image-20240103113558677"></p></li><li><p>索引（index）：相同类型的文档的集合</p></li><li><p>映射（mapping）：索引中文档的字段约束信息，类似表的结构约束</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/微服务.assets/image-20240103113645260.png" alt="image-20240103113645260"></p></li><li><p>与mysql概念对比</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/微服务.assets/image-20240103113710813.png" alt="image-20240103113710813"></p><ul><li>架构<ul><li>Mysql：擅长事务类型操作，可以确保数据的安全和一致性</li><li>Elasticsearch：擅长海量数据的搜索、分析、计算</li></ul></li></ul></li></ul><p><strong>4.1.4 安装es</strong></p><ul><li><p>创建网络（因为还需要部署kibana容器，因此需要让es和kibana容器互联）</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker network create es-net</span><br></pre></td></tr></table></figure></li><li><p>加载镜像</p></li><li><p>运行</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">docker run -d /</span><br><span class="line">--name es /</span><br><span class="line">    -e <span class="string">&quot;ES_JAVA_OPTS=-Xms512m -Xmx512m&quot;</span> /</span><br><span class="line">    -e <span class="string">&quot;discovery.type=single-node&quot;</span> /</span><br><span class="line">    -v es-data:/usr/share/elasticsearch/data /</span><br><span class="line">    -v es-plugins:/usr/share/elasticsearch/plugins /</span><br><span class="line">    --privileged /</span><br><span class="line">    --network es-net /</span><br><span class="line">    -p 9200:9200 /</span><br><span class="line">    -p 9300:9300 /</span><br><span class="line">elasticsearch:7.12.1</span><br></pre></td></tr></table></figure><ul><li><code>-e &quot;cluster.name=es-docker-cluster&quot;</code>：设置集群名称</li><li><code>-e &quot;http.host=0.0.0.0&quot;</code>：监听的地址，可以外网访问</li><li><code>-e &quot;ES_JAVA_OPTS=-Xms512m -Xmx512m&quot;</code>：内存大小</li><li><code>-e &quot;discovery.type=single-node&quot;</code>：非集群模式</li><li><code>-v es-data:/usr/share/elasticsearch/data</code>：挂载逻辑卷，绑定es的数据目录</li><li><code>-v es-logs:/usr/share/elasticsearch/logs</code>：挂载逻辑卷，绑定es的日志目录</li><li><code>-v es-plugins:/usr/share/elasticsearch/plugins</code>：挂载逻辑卷，绑定es的插件目录</li><li><code>--privileged</code>：授予逻辑卷访问权</li><li><code>--network es-net</code> ：加入一个名为es-net的网络中</li><li><code>-p 9200:9200</code>：端口映射配置</li></ul></li><li><p>在浏览器中输入：<a href="http://192.168.71.22:9200">http://192.168.71.22:9200</a> 即可看到elasticsearch的响应结果（虚拟机地址）</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/微服务.assets/image-20240103140928420.png" alt="image-20240103140928420"></p></li></ul><p><strong>4.1.5 安装kibana</strong></p><ul><li><p>kibana可以给我们提供一个elasticsearch的可视化界面，便于我们学习。</p></li><li><p>运行docker命令，部署kibana</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">docker run -d /</span><br><span class="line">--name kibana /</span><br><span class="line">-e ELASTICSEARCH_HOSTS=http://es:9200 /</span><br><span class="line">--network=es-net /</span><br><span class="line">-p 5601:5601  /</span><br><span class="line">kibana:7.12.1</span><br></pre></td></tr></table></figure><ul><li><code>--network es-net</code> ：加入一个名为es-net的网络中，<strong>与elasticsearch在同一个网络中</strong></li><li><code>-e ELASTICSEARCH_HOSTS=http://es:9200&quot;</code>：设置elasticsearch的地址，因为kibana已经与elasticsearch在一个网络，因此可以用容器名直接访问elasticsearch</li><li><code>-p 5601:5601</code>：端口映射配置</li></ul><p>kibana启动一般比较慢，需要多等待一会，可以通过命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker logs -f kibana</span><br></pre></td></tr></table></figure><p>此时，在浏览器输入地址访问：<a href="http://192.168.71.22:5601，即可看到结果">http://192.168.71.22:5601，即可看到结果</a></p></li></ul><p><strong>4.1.6 分词器</strong></p><ul><li><p>es在创建倒排索引时需要对文档分词；在搜索时，需要对用户输入内容分词。但默认的分词规则对中文处理并不友好</p></li><li><p>处理中文分词，一般会使用IK分词器。<a href="https://github.com/medcl/elasticsearch-analysis-ik">https://github.com/medcl/elasticsearch-analysis-ik</a></p></li><li><p>安装IK分词器</p><ul><li><p>查看elasticsearch的数据卷目录，通过下面命令查看:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker volume inspect es-plugins</span><br></pre></td></tr></table></figure><p>显示结果：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;CreatedAt&quot;</span><span class="punctuation">:</span> <span class="string">&quot;2022-05-06T10:06:34+08:00&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;Driver&quot;</span><span class="punctuation">:</span> <span class="string">&quot;local&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;Labels&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">null</span></span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;Mountpoint&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/var/lib/docker/volumes/es-plugins/_data&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;Name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;es-plugins&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;Options&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">null</span></span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;Scope&quot;</span><span class="punctuation">:</span> <span class="string">&quot;local&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">]</span></span><br></pre></td></tr></table></figure><p>说明plugins目录被挂载到了：<code>/var/lib/docker/volumes/es-plugins/_data</code>这个目录中。</p></li></ul></li><li><p>ik分词器包含两种模式：</p><ul><li>ik_smart：最少切分，粗粒度</li><li>ik_max_word：最细切分，细粒度</li></ul></li><li><p>扩展ik分词器</p><ul><li><p>需要修改一个ik分词器目录中的config目录中的IkAnalyzer.cfg.xml文件：</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/微服务.assets/image-20240103144534741.png" alt="image-20240103144534741"></p></li><li><p>然后在名为ext.dic的文件中，添加想要拓展的词语即可：</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/微服务.assets/image-20240103144548866.png" alt="image-20240103144548866"></p></li><li><p>要禁用某些敏感词条，只需要修改一个ik分词器目录中的config目录中的IkAnalyzer.cfg.xml文件：</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/微服务.assets/image-20240103144612795.png" alt="image-20240103144612795"></p></li><li><p>然后在名为stopword.dic的文件中，添加想要拓展的词语即可：</p></li></ul></li></ul><h3 id="4-2-索引库操作（数据列）"><a href="#4-2-索引库操作（数据列）" class="headerlink" title="4.2 索引库操作（数据列）"></a>4.2 索引库操作（数据列）</h3><p><strong>4.2.1 mapping映射属性</strong></p><ul><li>mapping是对索引库中文档的约束，常见的mapping属性包括：<ul><li>type：字段数据类型，常见的简单类型有：<ul><li>字符串：text（可分词的文本）、keyword（精确值，例如：品牌、国家、ip地址）</li><li>数值：long、integer、short、byte、double、float、</li><li>布尔：boolean</li><li>日期：date</li><li>对象：object</li></ul></li><li>index：是否创建索引，默认为true</li><li>analyzer：使用哪种分词器</li><li>properties：该字段的子字段</li></ul></li><li>注意：<strong>没有数组类型！</strong>一个数组的类型就是里面的元素的类型</li></ul><p><strong>4.2.2 索引库的CRUD</strong></p><ul><li><p>ES中通过Restful请求操作索引库、文档。请求内容用DSL语句来表示。</p></li><li><p>创建</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PUT/索引名</span><br></pre></td></tr></table></figure><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/微服务.assets/image-20240103145350802.png" alt="image-20240103145350802"></p></li><li><p>查看</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET/索引名</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET/heima</span><br></pre></td></tr></table></figure></li><li><p>删除</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DELETE/索引名</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DELETE/heima</span><br></pre></td></tr></table></figure></li><li><p>修改</p><p>索引库和mapping一旦创建无法修改，但是可以添加新的字段，语法如下：</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/微服务.assets/image-20240103145726938.png" alt="image-20240103145726938"></p></li></ul><h3 id="4-3-文档操作（数据行）"><a href="#4-3-文档操作（数据行）" class="headerlink" title="4.3 文档操作（数据行）"></a>4.3 文档操作（数据行）</h3><ul><li><p>新增DSL语法：</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/微服务.assets/image-20240103150027876.png" alt="image-20240103150027876"></p></li><li><p>查看</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/微服务.assets/image-20240103150041337.png" alt="image-20240103150041337"></p></li><li><p>删除</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/微服务.assets/image-20240103150046451.png" alt="image-20240103150046451"></p></li><li><p>修改</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/微服务.assets/image-20240103150055547.png" alt="image-20240103150055547"></p></li></ul><h3 id="4-4-RestAPI"><a href="#4-4-RestAPI" class="headerlink" title="4.4 RestAPI"></a>4.4 RestAPI</h3><ul><li>本质：组装DSL语句，通过http请求发送给ES。</li><li><p>官方文档地址：<a href="https://www.elastic.co/guide/en/elasticsearch/client/index.html">https://www.elastic.co/guide/en/elasticsearch/client/index.html</a></p></li><li><p>mapping要考虑的问题：</p><ul><li>字段名、数据类型、是否参与搜索、是否分词、如果分词，分词器是什么？</li></ul></li><li><p>demo</p><ul><li><p>引入依赖</p></li><li><p>覆盖默认的版本（SpringBoot默认的ES版本是7.6.2）</p></li><li><p>初始化<code>RestHighLevelClient</code></p></li><li><p>创建索引库</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/微服务.assets/image-20240103152832560.png" alt="image-20240103152832560"></p></li><li><p>删除索引库</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/微服务.assets/image-20240103153003864.png" alt="image-20240103153003864"></p></li><li><p>判断索引库是否存在</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/微服务.assets/image-20240103153016572.png" alt="image-20240103153016572"></p></li></ul></li><li><p>总结索引库基本操作</p><ul><li>初始化RestHighLevelClient</li><li>创建XxxIndexRequest。XXX是Create、Get、Delete</li><li>准备DSL（ Create时需要）</li><li>发送请求。调用RestHighLevelClient#indices().xxx()方法，xxx是create、exists、delete</li></ul></li><li><p>操作文档demo</p><ul><li><p>初始化<code>JavaRestClient</code></p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/微服务.assets/image-20240103153657357.png" alt="image-20240103153657357"></p></li><li><p>添加数据到索引库</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/微服务.assets/image-20240103153720102.png" alt="image-20240103153720102"></p></li><li><p>查询</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/微服务.assets/image-20240103153738121.png" alt="image-20240103153738121"></p></li><li><p>修改</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/微服务.assets/image-20240103153806395.png" alt="image-20240103153806395"></p></li><li><p>删除</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/微服务.assets/image-20240103153819637.png" alt="image-20240103153819637"></p></li></ul></li></ul><h3 id="4-5-批量导入数据到ES"><a href="#4-5-批量导入数据到ES" class="headerlink" title="4.5 批量导入数据到ES"></a>4.5 批量导入数据到ES</h3><ul><li>利用mp查询数据库中所以数据</li><li>将查询到的数据转换为文档类型数据</li><li>利用JavaRestClient中的Bulk批量处理，实现批量新增文档</li></ul><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/微服务.assets/image-20240103154713082.png" alt="image-20240103154713082"></p><h2 id="五-分布式搜索引擎-ES功能"><a href="#五-分布式搜索引擎-ES功能" class="headerlink" title="五 分布式搜索引擎-ES功能"></a>五 分布式搜索引擎-ES功能</h2><h3 id="5-1-DSL查询文档"><a href="#5-1-DSL查询文档" class="headerlink" title="5.1 DSL查询文档"></a>5.1 DSL查询文档</h3><p><strong>5.1.1 DSL查询分类</strong></p><ul><li><p>Elasticsearch提供了基于JSON的DSL（<a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl.html">Domain Specific Language</a>）来定义查询。常见的查询类型包括：</p><ul><li>查询所有：查询出所有数据，一般测试用。例如：<ul><li>match_all</li></ul></li><li>全文检索（full text）查询：利用分词器对用户输入内容分词，然后去倒排索引库中匹配。例如：<ul><li>match_query</li><li>multi_match_query    </li></ul></li><li>精确查询：根据精确词条值查找数据，一般是查找keyword、数值、日期、boolean等类型字段。例如：<ul><li>ids</li><li>range</li><li>term</li></ul></li><li>地理（geo）查询：根据经纬度查询。例如：<ul><li>geo_distance</li><li>geo_bounding_box</li></ul></li><li>复合（compound）查询：复合查询可以将上述各种查询条件组合起来，合并查询条件。例如：<ul><li>bool</li><li>function_score</li></ul></li></ul></li><li><p>基本语法</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/微服务.assets/image-20240103155740961.png" alt="image-20240103155740961"></p></li></ul><p><strong>5.1.2 全文检索查询</strong></p><ul><li><p>match查询：全文检索查询的一种，会对用户输入内容分词，然后去倒排索引库检索</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/微服务.assets/image-20240103160140156.png" alt="image-20240103160140156"></p></li><li><p>multi_match查询：与match查询类似，只不过允许同时查询多个字段</p></li></ul><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/微服务.assets/image-20240103160148178.png" alt="image-20240103160148178"></p><ul><li>注意：参与查询字段越多，查询性能越差</li></ul><p><strong>5.1.3 精确查询</strong></p><ul><li>精确查询一般是查找keyword、数值、日期、boolean等类型字段。所以不会对搜索条件分词。常见的<ul><li>term：根据词条精确值查询</li><li>range：根据值的范围查询</li></ul></li></ul><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/微服务.assets/image-20240103160316148.png" alt="image-20240103160316148"></p><p><strong>5.1.4 地理坐标查询</strong></p><ul><li><p>geo_bounding_box：查询geo_point值落在某个矩形范围的所有文档</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/微服务.assets/image-20240103160638139.png" alt="image-20240103160638139"></p></li><li><p>geo_distance：查询到指定中心点小于某个距离值的所有文档</p></li></ul><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/微服务.assets/image-20240103160643510.png" alt="image-20240103160643510"></p><p><strong>5.1.5 组合查询</strong></p><ul><li><p>复合查询可以将其它简单查询组合起来，实现更复杂的搜索逻辑</p><ul><li>算法查询</li><li>布尔查询</li></ul></li><li><p>fuction score：算分函数查询，可以控制文档相关性算分，控制文档排名。例如百度竞价</p><ul><li>使用 <a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-function-score-query.html">function score query</a>，可以修改文档的相关性算分（query score），根据新得到的算分排序。</li></ul><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/微服务.assets/image-20240103161413262.png" alt="image-20240103161413262"></p></li><li><p>算分demo：让”如家“这个酒店的排名靠前一点</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/微服务.assets/image-20240103161818213.png" alt="image-20240103161818213"></p></li><li><p>布尔查询 Boolean Query：是一个或多个查询子句的组合。子查询的组合方式有：</p><ul><li>must：必须匹配每个子查询，类似“与”</li><li>should：选择性匹配子查询，类似“或”</li><li>must_not：必须不匹配，不参与算分，类似“非”</li><li>filter：必须匹配，不参与算分</li></ul></li><li><p>布尔查询demo</p><ul><li><p>搜索名字包含“如家”，价格不高于400，在坐标31.21,121.5周围10km范围内的酒店。</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/微服务.assets/image-20240103161955639.png" alt="image-20240103161955639"></p></li></ul></li></ul><h3 id="5-2-搜索结果处理"><a href="#5-2-搜索结果处理" class="headerlink" title="5.2 搜索结果处理"></a>5.2 搜索结果处理</h3><p><strong>5.2.1排序</strong> </p><ul><li><p>elasticsearch支持对搜索<a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/sort-search-results.html">结果排序</a>，默认是根据相关度算分（_score）来排序。可以排序字段类型有：keyword类型、数值类型、地理坐标类型、日期类型等。</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/微服务.assets/image-20240103195008278.png" alt="image-20240103195008278"></p></li></ul><p><strong>5.2.2 分页</strong></p><ul><li><p>elasticsearch 默认情况下只返回top10的数据。而如果要查询更多数据就需要修改分页参数了。</p><ul><li><p>elasticsearch中通过修改from、size参数来控制要返回的分页结果：</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/微服务.assets/image-20240103195101351.png" alt="image-20240103195101351"></p></li></ul></li><li><p>深度分页问题：ES是分布式的，所以会面临深度分页问题。例如按price排序后，获取from = 990，size =10的数据。</p><ul><li><p>首先在每个数据分片上都排序并查询前1000条文档。</p></li><li><p>然后将所有节点的结果聚合，在内存中重新排序选出前1000条文档</p></li><li><p>最后从这1000条中，选取从990开始的10条文档</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/微服务.assets/image-20240103195521711.png" alt="image-20240103195521711"></p></li><li><p>问题：如果搜索页数过深，或者结果集（from + size）越大，对内存和CPU的消耗也越高。因此ES设定结果集查询的上限是10000</p></li></ul></li><li><p>深度分页问题解决方案</p><ul><li>方案一：search after：分页时需要排序，原理是从上一次的排序值开始，查询下一页数据。官方推荐使用的方式。<ul><li>优点：没有查询上限（单次查询的size不超过10000）</li><li>缺点：只能向后逐页查询，不支持随机翻页</li><li>场景：没有随机翻页需求的搜索，例如手机向下滚动翻页</li></ul></li><li>方案二：scroll：原理将排序数据形成快照，保存在内存。官方已经<strong>不推荐使用</strong>。<ul><li>优点：没有查询上限（单次查询的size不超过10000）</li><li>缺点：会有额外内存消耗，并且搜索结果是非实时的</li><li>场景：海量数据的获取和迁移。从ES7.1开始不推荐，建议用 after search方案。</li></ul></li></ul></li></ul><p><strong>5.2.3 高亮</strong></p><ul><li><p>就是在搜索结果中把搜索关键字突出显示</p></li><li><p>原理</p><ul><li>将搜索结果中的关键字用标签标记出来</li><li>在页面中给标签添加css样式</li></ul><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/微服务.assets/image-20240103195936333.png" alt="image-20240103195936333"></p></li></ul><p><strong>5.2.4 搜索结果处理整体语法</strong></p><p>&lt;img src=(<a href="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/微服务.assets/image-20240103200025546.png">https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/微服务.assets/image-20240103200025546.png</a>“ alt=”image-20240103200025546” style=”zoom: 50%;” /&gt;</p><h3 id="5-3-RestClient查询文档及结果处理"><a href="#5-3-RestClient查询文档及结果处理" class="headerlink" title="5.3 RestClient查询文档及结果处理"></a>5.3 RestClient查询文档及结果处理</h3><p><strong>5.3.1 demo</strong></p><ul><li><p>查询</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/微服务.assets/image-20240103200555989.png" alt="image-20240103200555989"></p><ul><li>RestAPI中其中构建DSL是通过HighLevelRestClient中的<code>source()</code>来实现的，其中包含了查询、排序、分页、高亮</li><li>RestAPI中其中构建查询条件的核心部分是由一个名为<code>QueryBuilders</code>的工具类提供的，其中包含了各种查询方法</li></ul></li><li><p>解析结果</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/微服务.assets/image-20240103200715615.png" alt="image-20240103200715615"></p></li></ul><p><strong>5.3.2 match查询</strong></p><ul><li><p>全文检索的match和multi_match查询与match_all的API基本一致。差别是查询条件，也就是query的部分。</p><p>同样是利用QueryBuilders提供的方法：</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/微服务.assets/image-20240103201338183.png" alt="image-20240103201338183"></p></li></ul><p><strong>5.3.3 精确查询</strong></p><ul><li><p>精确查询常见的有term查询和range查询，同样利用QueryBuilders实现：</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/微服务.assets/image-20240103201405792.png" alt="image-20240103201405792"></p></li></ul><p><strong>5.3.4 复合查询</strong></p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/微服务.assets/image-20240103201429642.png" alt="image-20240103201429642"></p><p><strong>5.3.5 排序、分页、高亮</strong></p><ul><li><p>排序和分页</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/微服务.assets/image-20240103201551392.png" alt="image-20240103201551392"></p></li><li><p>高亮</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/微服务.assets/image-20240103201614192.png" alt="image-20240103201614192"></p></li><li><p>高亮结果解析</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/微服务.assets/image-20240103201719261.png" alt="image-20240103201719261"></p></li></ul><p><strong>5.3.6 总结</strong></p><ul><li>要构建查询条件，只要记住一个类：<strong>QueryBuilders</strong></li></ul><h3 id="5-4-黑马旅游案例"><a href="#5-4-黑马旅游案例" class="headerlink" title="5.4 黑马旅游案例"></a>5.4 黑马旅游案例</h3><p><strong>5.4.1 关键字搜索功能</strong></p><ul><li>定义实体类</li><li><p>定义<code>Controller</code>，接收页面请求，调用<code>Service</code>对象的<code>search()</code>方法</p></li><li><p>在<code>Service</code>中的<code>search()</code>方法中实现查询，利用<code>match</code>查询实现根据关键字搜索酒店信息</p></li></ul><p><strong>5.4.2 添加品牌、城市、星级、价格等过滤功能</strong></p><ul><li>修改RequestParams类，添加brand、city、starName、minPrice、maxPrice等参数</li><li>修改search方法的实现，在关键字搜索时，如果brand等参数存在，对其做过滤</li></ul><p><strong>5.4.3 附近的酒店功能</strong></p><ul><li>前端发送位置，返回一个List</li><li>修改RequestParams参数，接收location字段</li><li>修改search方法业务逻辑，如果location有值，添加根据geo_distance排序的功能</li></ul><p><strong>5.4.4 让指定的酒店在搜索结果中排名置顶</strong></p><ul><li>给HotelDoc类添加isAD字段，Boolean类型</li><li>挑选几个你喜欢的酒店，给它的文档数据添加isAD字段，值为true</li><li>修改search方法，添加function score功能，给isAD值为true的酒店增加权重</li></ul><h2 id="六-分布式搜索引擎-ES深入"><a href="#六-分布式搜索引擎-ES深入" class="headerlink" title="六 分布式搜索引擎-ES深入"></a>六 分布式搜索引擎-ES深入</h2><h3 id="6-1-数据聚合"><a href="#6-1-数据聚合" class="headerlink" title="6.1 数据聚合"></a>6.1 数据聚合</h3><p><strong>6.1.1 聚合的种类</strong></p><ul><li><a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/search-aggregations.html">聚合（</a><a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/search-aggregations.html">aggregations</a><a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/search-aggregations.html">）</a>可以实现对文档数据的统计、分析、运算。聚合常见的有三类：<ul><li>桶（Bucket）聚合：用来对文档做分组<ul><li>TermAggregation：按照文档字段值分组</li><li>Date Histogram：按照日期阶梯分组，例如一周为一组，或者一月为一组</li></ul></li><li>度量（Metric）聚合：用以计算一些值，比如：最大值、最小值、平均值等</li><li>管道（pipeline）聚合：其它聚合的结果为基础做聚合</li></ul></li><li>参与聚合的字段类型必须是<ul><li>keyword</li><li>数值</li><li>日期</li><li>布尔</li></ul></li></ul><p><strong>6.1.2 DSL实现聚合</strong></p><ul><li><p>DSL实现Bucket聚合</p><ul><li><p>要统计所有数据中的酒店品牌有几种，此时可以根据酒店品牌的名称做聚合。</p><p>类型为term类型，DSL示例： </p></li></ul><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/微服务.assets/image-20240104100925547.png" alt="image-20240104100925547"></p><ul><li><p>默认情况下，Bucket聚合会统计Bucket内的文档数量，记为_count，并且按照_count降序排序。</p><p>我们可以修改结果排序方式：</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/微服务.assets/image-20240104101351875.png" alt="image-20240104101351875"></p></li><li><p>默认情况下，Bucket聚合是对索引库的所有文档做聚合，我们可以限定要聚合的文档范围，只要添加query条件即可</p><ul><li>aggs代表聚合，与query同级，此时query的作用是：限定聚合的的文档范围</li></ul><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/微服务.assets/image-20240104101408268.png" alt="image-20240104101408268"></p></li></ul></li><li><p>DSL实现Metrics聚合</p><ul><li><p>例如，我们要求获取每个品牌的用户评分的min、max、avg等值.</p><p>我们可以利用stats聚合</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/微服务.assets/image-20240104101528768.png" alt="image-20240104101528768"></p></li></ul></li></ul><p><strong>6.1.3 Rest API实现聚合</strong></p><ul><li><p>请求组装</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/微服务.assets/image-20240104101950558.png" alt="image-20240104101950558"></p></li><li><p>结果解析 </p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/微服务.assets/image-20240104102038015.png" alt="image-20240104102038015"></p></li></ul><h3 id="6-2-自动补全"><a href="#6-2-自动补全" class="headerlink" title="6.2 自动补全"></a>6.2 自动补全</h3><p><strong>6.2.1 拼音分词器</strong></p><ul><li>安装与IK分词器一样<ul><li>下载pinyin分词器</li><li>解压放到es的plugin目录</li><li>重启</li></ul></li></ul><p><strong>6.2.2 自定义分词器</strong></p><ul><li><p>elasticsearch中分词器（analyzer）的组成包含三部分：</p><ul><li>character filters：在tokenizer之前对文本进行处理。例如删除字符、替换字符</li><li>tokenizer：将文本按照一定的规则切割成词条（term）。例如keyword，就是不分词；还有ik_smart</li><li>tokenizer filter：将tokenizer输出的词条做进一步处理。例如大小写转换、同义词处理、拼音处理等</li></ul><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/微服务.assets/image-20240104104009496.png" alt="image-20240104104009496"></p></li><li><p>在创建索引库的时候，通过settings来配置自定义的analyzer（分词器）</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/微服务.assets/image-20240104104148463.png" alt="image-20240104104148463"></p></li><li><p>自定义分词器步骤</p><ul><li>创建索引库的时候，在settings中配置，可以包含三部分</li><li>character filter</li><li>tokenizer</li><li>filter</li></ul></li><li><p>注意事项</p><ul><li>为避免搜索到同音字，搜索时不要使用拼音分词器</li></ul></li></ul><p><strong>6.2.3 自动补全查询</strong></p><ul><li><p>elasticsearch提供了<a href="https://www.elastic.co/guide/en/elasticsearch/reference/7.6/search-suggesters.html">Completion Suggester</a>查询来实现自动补全功能。这个查询会匹配以用户输入内容开头的词条并返回。为了提高补全查询的效率，对于文档中字段的类型有一些约束：</p><ul><li><p>参与补全查询的字段必须是completion类型。</p></li><li><p>字段的内容一般是用来补全的多个词条形成的数组。</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/微服务.assets/image-20240104105159950.png" alt="image-20240104105159950"></p></li></ul></li><li><p>查询语法</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/微服务.assets/image-20240104105214066.png" alt="image-20240104105214066"></p></li></ul><p><strong>6.2.4 实现搜索框自动补全</strong></p><ul><li>思路<ul><li>修改hotel索引库结构，设置自定义拼音分词器</li><li>修改索引库的name、all字段，使用自定义分词器</li><li>索引库添加一个新字段suggestion，类型为completion类型，使用自定义的分词器</li><li>给HotelDoc类添加suggestion字段，内容包含brand、business</li><li>重新导入数据到hotel库</li></ul></li></ul><h3 id="6-3-数据同步"><a href="#6-3-数据同步" class="headerlink" title="6.3 数据同步"></a>6.3 数据同步</h3><ul><li>elasticsearch中的酒店数据来自于mysql数据库，因此mysql数据发生改变时，elasticsearch也必须跟着改变，这个就是elasticsearch与mysql之间的<strong>数据同步</strong>。</li></ul><p><strong>6.3.1 思路分析</strong></p><ul><li><p>方案一：同步调用</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/微服务.assets/image-20240104141643452.png" alt="image-20240104141643452"></p><ul><li>简单粗暴。但是业务耦合，影响性能</li></ul></li><li><p>方案二：异步通知</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/微服务.assets/image-20240104141758549.png" alt="image-20240104141758549"></p><ul><li>解决了业务耦合问题（推荐），但是依赖于MQ的可靠性</li></ul></li><li><p>方案三：监听binlog</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/微服务.assets/image-20240104141844829.png" alt="image-20240104141844829"></p><ul><li>完全解除服务间耦合，但是开启binlog增加数据库负担，实现复杂度高</li></ul></li></ul><p><strong>6.3.2 利用MQ实现ES与数据库的数据同步</strong></p><ul><li>目标：当酒店数据发生增、删、改时，要求对elasticsearch中数据也要完成相同操作。</li><li>步骤<ul><li>导入工程完成数据的CRUD</li><li>声明exchange、queue、RoutingKey<ul><li>配置文件中定义好rabbitmq的配置（host、port、username、password、virtual-host）</li><li>声明一个配置类，在里面定义交换机(1个)、队列(2个)及他们的绑定关系(2个)的bean</li></ul></li><li>在hotel-admin中的增、删、改业务中完成消息发送<ul><li>在service中修改or Controller中</li><li>调用RabbieTemplate中发送消息，消息内容是对象的id(不发送整个对象，耗内存)</li></ul></li><li>在hotel-demo中完成消息监听，并更新elasticsearch中数据<ul><li>在新建一个类，单独完成mq的消息监听</li><li>在方法上使用<code>@RabbitListener</code>定义好监听的队列</li><li>完成方法内容：根据id查询内容、准备Request、准备DSL、准备发送请求…</li></ul></li><li>启动并测试数据同步功能</li></ul></li></ul><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/微服务.assets/image-20240104142241296.png" alt="image-20240104142241296"></p><h3 id="6-4-集群"><a href="#6-4-集群" class="headerlink" title="6.4 集群"></a>6.4 集群</h3><p><strong>6.4.1 搭建ES集群</strong></p><ul><li><p>单机的elasticsearch做数据存储，必然面临两个问题：海量数据存储问题、单点故障问题。</p><ul><li>海量数据存储问题：将索引库从逻辑上拆分为N个分片（shard），存储到多个节点</li><li>单点故障问题：将分片数据在不同节点备份（replica）</li></ul></li><li><p>计划使用3个docker容器模拟3个es节点</p></li><li><p>集群节点不同的职责划分</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/微服务.assets/image-20240104152132396.png" alt="image-20240104152132396"></p></li></ul><p><strong>6.4.2 集群脑裂问题</strong></p><ul><li>默认情况下，每个节点都是master eligible节点，因此一旦master节点宕机，其它候选节点会选举一个成为主节点。当主节点与其他节点网络故障时，可能发生脑裂问题。</li><li>为了避免脑裂，需要要求选票超过 ( eligible节点数量 + 1 ）/ 2 才能当选为主，因此eligible节点数量最好是奇数。对应配置项是discovery.zen.minimum_master_nodes，在es7.0以后，已经成为默认配置，因此一般不会发生脑裂问题</li></ul><p><strong>6.4.3 集群分布式存储</strong></p><ul><li><p>当新增文档时，应该保存到不同分片，保证数据均衡，那么coordinating node如何确定数据该存储到哪个分片呢？</p></li><li><p>elasticsearch会通过hash算法来计算文档应该存储到哪个分片：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">shard = hash(_routing) % number_of_shards</span><br></pre></td></tr></table></figure><ul><li>_routing默认是文档的id</li><li>算法与分片数量有关，因此索引库一旦创建，分片数量不能修改！</li></ul></li><li><p>新增文档流程</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/微服务.assets/image-20240104152927610.png" alt="image-20240104152927610"></p></li></ul><p><strong>6.4.4 集群分布式查询</strong></p><ul><li><p>elasticsearch的查询分成两个阶段：</p><ul><li><p>scatter phase：分散阶段，coordinating node会把请求分发到每一个分片</p></li><li><p>gather phase：聚集阶段，coordinating node汇总data node的搜索结果，并处理为最终结果集返回给用户</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/微服务.assets/image-20240104153007367.png" alt="image-20240104153007367"></p></li></ul></li></ul><p><strong>6.4.5 集群故障转移</strong></p><ul><li><p>集群的master节点会监控集群中的节点状态，如果发现有节点宕机，会立即将宕机节点的分片数据迁移到其它节点，确保数据安全，这个叫做故障转移。</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/微服务.assets/image-20240104152830283.png" alt="image-20240104152830283"></p></li></ul><h1 id="Ⅱ-高级"><a href="#Ⅱ-高级" class="headerlink" title="Ⅱ 高级"></a>Ⅱ 高级</h1><h2 id="一-微服务保护"><a href="#一-微服务保护" class="headerlink" title="一 微服务保护"></a>一 微服务保护</h2><h3 id="1-1-Sentinel"><a href="#1-1-Sentinel" class="headerlink" title="1.1 Sentinel"></a>1.1 Sentinel</h3><p><strong>1.1.1 雪崩问题及解决方案</strong></p><ul><li><p>微服务调用链路中的某个服务故障，引起整个链路中的所有微服务都不可用，这就是<strong>雪崩</strong>。</p></li><li><p>解决雪崩问题的常见方式</p><ul><li>超时处理：设定超时时间，请求超过一定时间没有响应就返回错误信息，不会无休止等待</li><li>舱壁模式：限定每个业务能使用的线程数，避免耗尽整个tomcat的资源，因此也叫线程隔离。</li><li>熔断降级：由<strong>断路器</strong>统计业务执行的异常比例，如果超出阈值则会<strong>熔断</strong>该业务，拦截访问该业务的一切请求。</li><li>流量控制：限制业务访问的QPS，避免服务因流量的突增而故障。</li></ul></li></ul><p><strong>1.1.2 服务保护技术对比</strong></p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/微服务.assets/image-20240104154746183.png" alt="image-20240104154746183"></p><p><strong>1.1.3 Sentinel简介</strong></p><ul><li><p>Sentinel是阿里巴巴开源的一款微服务流量控制组件。</p></li><li><p>特点</p><ul><li><strong>丰富的应用场景</strong>：Sentinel 承接了阿里巴巴近 10 年的双十一大促流量的核心场景，例如秒杀（即突发流量控制在系统容量可以承受的范围）、消息削峰填谷、集群流量控制、实时熔断下游不可用应用等。</li><li><p><strong>完备的实时监控</strong>：Sentinel 同时提供实时的监控功能。您可以在控制台中看到接入应用的单台机器秒级数据，甚至 500 台以下规模的集群的汇总运行情况。</p></li><li><p><strong>广泛的开源生态</strong>：Sentinel 提供开箱即用的与其它开源框架/库的整合模块，例如与 Spring Cloud、Dubbo、gRPC 的整合。您只需要引入相应的依赖并进行简单的配置即可快速地接入 Sentinel。</p></li><li><p><strong>完善的</strong> <strong>SPI</strong> <strong>扩展点</strong>：Sentinel 提供简单易用、完善的 SPI 扩展接口。您可以通过实现扩展接口来快速地定制逻辑。例如定制规则管理、适配动态数据源等。</p></li></ul></li><li><p>安装sentinel控制台</p><ul><li><p>github下载jar包</p></li><li><p>运行jar包，访问localhost:8080</p></li><li><p>默认的账号密码为：sentinel</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/微服务.assets/image-20240104160300047.png" alt="image-20240104160300047"></p></li><li><p>修改配置项</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/微服务.assets/image-20240104160330932.png" alt="image-20240104160330932"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar sentinel-dashboard-1.8.1.jar -Dserver.port=8090</span><br></pre></td></tr></table></figure><p>修改端口</p></li></ul></li></ul><p><strong>1.1.4 微服务整合Sentinel</strong></p><ul><li><p>引入demo工程</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/微服务.assets/image-20240104160450077.png" alt="image-20240104160450077"></p></li><li><p>在order-service中整合sentinel，并连接控制台</p><ul><li><p>引入sentinel依赖</p></li><li><p>配置控制台地址</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/微服务.assets/image-20240104160713177.png" alt="image-20240104160713177"></p></li><li><p>访问微服务的任意端点，触发sentinel监控</p></li></ul></li></ul><h3 id="1-2-流量控制"><a href="#1-2-流量控制" class="headerlink" title="1.2 流量控制"></a>1.2 流量控制</h3><ul><li><p>簇点链路：就是项目内的调用链路，链路中被监控的每个接口就是一个资源。默认情况下sentinel会监控SpringMVC的每一个端点（Endpoint），因此SpringMVC的每一个端点（Endpoint）就是调用链路中的一个资源。</p><p>流控、熔断等都是针对簇点链路中的资源来设置的，因此我们可以点击对应资源后面的按钮来设置规则：</p></li></ul><p><strong>1.2.1 demo</strong></p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/微服务.assets/image-20240104161257305.png" alt="image-20240104161257305"></p><ul><li>可以使用jemeter测试：</li></ul><p><strong>1.2.2 流控模式</strong></p><ul><li><p>在添加限流规则时，点击高级选项，可以选择三种流控模式：</p><ul><li><strong>直接</strong>：统计当前资源的请求，触发阈值时对当前资源直接限流，也是默认的模式</li><li><strong>关联</strong>：统计与当前资源相关的另一个资源，触发阈值时，对当前资源限流<ul><li>比如用户支付时需要修改订单状态，同时用户要查询订单。查询和修改操作会争抢数据库锁，产生竞争。业务需求是有限支付和更新订单的业务，因此当修改订单业务触发阈值时，需要对查询订单业务限流。</li></ul></li><li><strong>链路</strong>：统计从指定链路访问到本资源的请求，触发阈值时，对指定链路限流</li></ul></li><li><p>Sentinel默认只标记Controller中的方法为资源，如果要标记其它方法，需要利用@SentinelResource注解，示例：</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/微服务.assets/image-20240104161939675.png" alt="image-20240104161939675"></p></li><li><p>Sentinel默认会将Controller方法做context整合，导致链路模式的流控失效，需要修改application.yml，添加配置：</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/微服务.assets/image-20240104161958558.png" alt="image-20240104161958558"></p></li></ul><p><strong>1.2.3 流控效果</strong></p><ul><li>流控效果是指请求达到流控阈值时应该采取的措施，包括三种：<ul><li>快速失败：达到阈值后，新的请求会被立即拒绝并抛出FlowException异常。是默认的处理方式。</li><li>warm up：预热模式，对超出阈值的请求同样是拒绝并抛出异常。但这种模式阈值会动态变化，从一个较小值逐渐增加到最大阈值。<ul><li>例如，我设置QPS的threshold为10，预热时间为5秒，那么初始阈值就是 10 / 3 ，也就是3，然后在5秒后逐渐增长到10.</li></ul></li><li>排队等待：让所有的请求按照先后次序排队执行，两个请求的间隔不能小于指定时长</li></ul></li></ul><p><strong>1.2.4 热点参数限流</strong></p><ul><li><p>之前的限流是统计访问某个资源的所有请求，判断是否超过QPS阈值。而热点参数限流是分别统计参数值相同的请求，判断是否超过QPS阈值。</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/微服务.assets/image-20240104163235566.png" alt="image-20240104163235566"></p></li><li><p>配置示例</p><p>&lt;img src=(<a href="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/微服务.assets/image-20240104163329088.png">https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/微服务.assets/image-20240104163329088.png</a>“ alt=”image-20240104163329088” style=”zoom:50%;” /&gt;</p></li><li><p>注意：热点参数限流对默认的springMVC资源无效</p><p>在Controller上添加注解 <code>@SentinelResource(&quot;hot&quot;)</code> ，其中hot是自定义名称</p></li></ul><h3 id="1-3-隔离和降级"><a href="#1-3-隔离和降级" class="headerlink" title="1.3 隔离和降级"></a>1.3 隔离和降级</h3><ul><li>虽然限流可以尽量避免因高并发而引起的服务故障，但服务还会因为其它原因而故障。而要将这些故障控制在一定范围，避免雪崩，就要靠线程隔离（舱壁模式）和熔断降级手段了。</li><li>不管是线程隔离还是熔断降级，都是对客户端（调用方）的保护。</li></ul><p><strong>1.3.1 FeignClient整合Sentinel</strong></p><ul><li><p>SpringCloud中，微服务调用都是通过Feign来实现的，因此做客户端保护必须整合Feign和Sentinel。</p><ul><li><p>修改OrderService的application.yml文件，开启Feign的Sentinel功能</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/微服务.assets/image-20240104164055977.png" alt="image-20240104164055977"></p></li></ul></li><li><p>给FeignClient编写失败后的降级逻辑</p><ul><li>方式一：FallbackClass，无法对远程调用的异常做处理</li><li>方式二：FallbackFactory，可以对远程调用的异常做处理，我们选择这种</li></ul></li><li><p>FallbackFactory步骤</p><ul><li><p>在feing-api项目中定义类，实现FallbackFactory</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/微服务.assets/image-20240104164142507.png" alt="image-20240104164142507"></p></li><li><p>在feing-api项目中的DefaultFeignConfiguration类中将UserClientFallbackFactory注册为一个Bean：</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/微服务.assets/image-20240104164219539.png" alt="image-20240104164219539"></p></li><li><p>在feing-api项目中的UserClient接口中使用UserClientFallbackFactory：</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/微服务.assets/image-20240104164233596.png" alt="image-20240104164233596"></p></li></ul></li></ul><p><strong>1.3.2 线程隔离（舱壁模式）</strong></p><ul><li><p>线程隔离有两种方式实现：</p><ul><li>线程池隔离<ul><li>优点：支持主动超时、支持异步调用</li><li>缺点：额外开销大</li><li>场景：低扇出</li></ul></li><li>信号量隔离（Sentinel默认采用）<ul><li>优点：轻量、无额外开销</li><li>缺点：不支持主动超时、不支持异步调用</li><li>场景：高频调用、高扇出</li></ul></li><li>注意：扇出是指这个请求后续依赖的服务数量，后续服务多就是高扇出<ul><li>网关服务就是高扇出</li></ul></li></ul><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/微服务.assets/image-20240104164633753.png" alt="image-20240104164633753"></p></li><li><p>在添加限流规则时，可以选择两种阈值类型：</p><ul><li>QPS：就是每秒的请求数，在快速入门中已经演示过</li><li>线程数：是该资源能使用用的tomcat线程数的最大值。也就是通过限制线程数量，实现<strong>舱壁模式。</strong></li></ul></li></ul><p><strong>1.3.3 熔断降级</strong></p><ul><li><p>熔断降级是解决雪崩问题的重要手段。其思路是由<strong>断路器</strong>统计服务调用的异常比例、慢请求比例，如果超出阈值则会<strong>熔断</strong>该服务。即拦截访问该服务的一切请求；而当服务恢复时，断路器会放行访问该服务的请求。</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/微服务.assets/image-20240104165129425.png" alt="image-20240104165129425"></p></li><li><p>断路器熔断策略：</p><ul><li>慢调用</li><li>异常比例</li><li>异常数</li></ul></li><li><p>慢调用：业务的响应时长（RT）大于指定时长的请求认定为慢调用请求。在指定时间内，如果请求数量超过设定的最小数量，慢调用比例大于设定的阈值，则触发熔断。例如：</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/微服务.assets/image-20240104165407747.png" alt="image-20240104165407747"></p></li><li><p>异常比例或异常系数：统计指定时间内的调用，如果调用次数超过指定请求数，并且出现异常的比例达到设定的比例阈值（或超过指定异常数），则触发熔断。例如：</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/微服务.assets/image-20240104165609296.png" alt="image-20240104165609296"></p></li></ul><h3 id="1-4-授权规则"><a href="#1-4-授权规则" class="headerlink" title="1.4 授权规则"></a>1.4 授权规则</h3><p><strong>1.4.1 授权规则</strong></p><ul><li><p>授权规则可以对调用方的来源做控制，有白名单和黑名单两种方式。</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/微服务.assets/image-20240104165858666.png" alt="image-20240104165858666"></p><ul><li>然而这个名称不是gateway</li></ul></li><li><p>具体做法：</p><p>Sentinel是通过RequestOriginParser这个接口的parseOrigin来获取请求的来源的。</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/微服务.assets/image-20240104170138629.png" alt="image-20240104170138629"></p><p>例如，我们尝试从request中获取一个名为origin的请求头，作为origin的值：</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/微服务.assets/image-20240104170159880.png" alt="image-20240104170159880"></p><p>我们还需要在gateway服务中，利用网关的过滤器添加名为gateway的origin头：</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/微服务.assets/image-20240104170213962.png" alt="image-20240104170213962"></p><p>给/order/{orderId} 配置授权规则：</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/微服务.assets/image-20240104170221805.png" alt="image-20240104170221805"></p></li></ul><p><strong>1.4.2 自定义异常结果</strong></p><ul><li><p>默认情况下，发生限流、降级、授权拦截时，都会抛出异常到调用方。如果要自定义异常时的返回结果，需要实现<code>BlockExceptionHandler</code>接口：</p></li><li><p>而<code>BlockException</code>包含很多个子类，分别对应不同的场景：</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/微服务.assets/image-20240104170505340.png" alt="image-20240104170505340"></p></li><li><p>实现</p><ul><li><p>在order-service中定义类，实现<code>BlockExceptionHandler</code>接口</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/微服务.assets/image-20240104170629318.png" alt="image-20240104170629318"></p></li></ul></li></ul><h3 id="1-5-规则持久化"><a href="#1-5-规则持久化" class="headerlink" title="1.5 规则持久化"></a>1.5 规则持久化</h3><p><strong>1.5.1 规则管理模式</strong> </p><ul><li><p>Sentinel的控制台规则管理有三种模式：</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/微服务.assets/image-20240104170754303.png" alt="image-20240104170754303"></p></li><li><p>原始模式：控制台配置的规则直接推送到Sentinel客户端，也就是我们的应用。然后保存在内存中，服务重启则丢失（<strong>保存在内存</strong>）</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/微服务.assets/image-20240104170930593.png" alt="image-20240104170930593"></p></li><li><p>pull模式：控制台将配置的规则推送到Sentinel客户端，而客户端会将配置规则保存在本地文件或数据库中。以后会定时去本地文件或数据库中查询，更新本地规则。（<strong>保存在本地文件或数据库，定时读取</strong>）</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/微服务.assets/image-20240104170935198.png" alt="image-20240104170935198"></p></li><li><p>push模式：控制台将配置规则推送到远程配置中心，例如Nacos。Sentinel客户端监听Nacos，获取配置变更的推送消息，完成本地配置更新。（<strong>保存在nasco，监听变更实时更新</strong>）</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/微服务.assets/image-20240104170940624.png" alt="image-20240104170940624"></p></li></ul><p><strong>1.5.2 实现push模式</strong></p><ul><li><p>push模式实现最为复杂，依赖于nacos，并且需要改在Sentinel控制台。整体步骤如下：</p><ul><li><p>修改order-service服务，使其监听Nacos配置中心</p><ul><li><p>引入nacos依赖</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/微服务.assets/image-20240104171156642.png" alt="image-20240104171156642"></p></li><li><p>配置nacos地址</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/微服务.assets/image-20240104171150059.png" alt="image-20240104171150059"></p></li></ul></li><li><p>修改Sentinel-dashboard源码，配置nacos数据源</p><ul><li>复杂</li></ul></li><li><p>修改Sentinel-dashboard源码，修改前端页面</p><ul><li>复杂</li></ul></li><li><p>重新编译、打包-dashboard源码</p></li></ul></li><li><p>也可以花钱用阿里的云服务器</p></li></ul><h2 id="二-分布式事务"><a href="#二-分布式事务" class="headerlink" title="二 分布式事务"></a>二 分布式事务</h2><ul><li><p>事务的ACID原则</p><ul><li>原子性：事务中的所有操作，要么全部成功，要么全部失败</li><li>一致性：要保证数据库内部完整性约束、声明性约束</li><li>隔离性：对同一资源操作的事务不能同时发生</li><li>持久性：对数据库做的一切修改将永久保存，不管是否出现故障</li></ul></li><li><p>在分布式系统下，一个业务跨越多个服务或数据源，每个服务都是一个分支事务，要保证所有分支事务最终状态一致，这样的事务就是分布式事务。</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/微服务.assets/image-20240104185109103.png" alt="image-20240104185109103"></p></li></ul><h3 id="2-1-理论基础"><a href="#2-1-理论基础" class="headerlink" title="2.1 理论基础"></a>2.1 理论基础</h3><p><strong>2.1.1 CAP定理</strong></p><ul><li><p>1998年，加州大学的计算机科学家 Eric Brewer 提出，分布式系统有三个指标：</p><ul><li>Consistency（一致性）</li><li>Availability（可用性）</li><li>Partition tolerance （分区容错性）</li></ul></li><li><p>Eric Brewer 说，分布式系统无法同时满足这三个指标。这个结论就叫做 CAP 定理。</p></li><li><p>Consistency（一致性）：用户访问分布式系统中的任意节点，得到的数据必须一致</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/微服务.assets/image-20240104191119433.png" alt="image-20240104191119433"></p></li><li><p>Availability（可用性）：用户访问集群中的任意健康节点，必须能得到响应，而不是超时或拒绝</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/微服务.assets/image-20240104191114140.png" alt="image-20240104191114140"></p></li><li><p>Partition（分区）：因为网络故障或其它原因导致分布式系统中的部分节点与其它节点失去连接，形成独立分区。</p></li><li><p>Tolerance （容错）：在集群出现分区时，整个系统也要持续对外提供服务</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/微服务.assets/image-20240104191126912.png" alt="image-20240104191126912"></p></li><li><p>CP和CA只能满足其中一种</p><ul><li>ES集群出现分区时，故障节点会被剔除集群，数据分片会重新分配到其它节点，保证数据一致。因此是低可用性，高一致性，属于CP</li></ul></li></ul><p><strong>2.1.2 BASE理论</strong></p><ul><li>BASE理论是对CAP的一种解决思路，包含三个思想：<ul><li><strong>Basically Available</strong> <strong>（基本可用）</strong>：分布式系统在出现故障时，允许损失部分可用性，即保证核心可用。</li><li><strong>Soft State（软状态）</strong>：在一定时间内，允许出现中间状态，比如临时的不一致状态。</li><li><strong>Eventually Consistent（最终一致性）</strong>：虽然无法保证强一致性，但是在软状态结束后，最终达到数据一致。</li></ul></li><li>而分布式事务最大的问题是各个子事务的一致性问题，因此可以借鉴CAP定理和BASE理论：<ul><li>AP模式：各子事务分别执行和提交，允许出现结果不一致，然后采用弥补措施恢复数据即可，实现最终一致。</li><li>CP模式：各个子事务执行后互相等待，同时提交，同时回滚，达成强一致。但事务等待过程中，处于弱可用状态。</li></ul></li><li>解决分布式事务，各个子系统之间必须能感知到彼此的事务状态，才能保证状态一致，因此需要一个事务协调者来协调每一个事务的参与者（子系统事务）。<ul><li>这里的子系统事务，称为<strong>分支事务</strong>；有关联的各个分支事务在一起称为<strong>全局事务</strong></li></ul></li></ul><h3 id="2-2-Seata"><a href="#2-2-Seata" class="headerlink" title="2.2 Seata"></a>2.2 Seata</h3><p><strong>2.2.1 简介、架构</strong></p><ul><li>Seata是 2019 年 1 月份蚂蚁金服和阿里巴巴共同开源的分布式事务解决方案。致力于提供高性能和简单易用的分布式事务服务，为用户打造一站式的分布式解决方案。</li><li><p>官网地址：<a href="http://seata.io/">http://seata.io/</a></p></li><li><p>Seata事务管理中有三个重要的角色：</p><ul><li><p><strong>TC (Transaction Coordinator) -</strong> <strong>事务协调者：</strong>维护全局和分支事务的状态，协调全局事务提交或回滚。</p></li><li><p><strong>TM (Transaction Manager) -</strong> <strong>事务管理器：</strong>定义全局事务的范围、开始全局事务、提交或回滚全局事务。</p></li><li><p><strong>RM (Resource Manager) -</strong> <strong>资源管理器：</strong>管理分支事务处理的资源，与TC交谈以注册分支事务和报告分支事务的状态，并驱动分支事务提交或回滚。</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/微服务.assets/image-20240104191710280.png" alt="image-20240104191710280"></p></li></ul></li><li><p>Seata提供了四种不同的分布式事务解决方案：</p><ul><li>XA模式：强一致性分阶段事务模式，牺牲了一定的可用性，无业务侵入</li><li>TCC模式：最终一致的分阶段事务模式，有业务侵入</li><li>AT模式：最终一致的分阶段事务模式，无业务侵入，也是Seata的默认模式</li><li>SAGA模式：长事务模式，有业务侵入</li></ul></li></ul><p><strong>2.2.2 部署TC服务</strong></p><p>略</p><p><strong>2.2.3 微服务集成Seata</strong></p><ul><li>引入seata依赖</li><li>配置application.yml，让微服务通过注册中心找到seata-tc-server</li></ul><h3 id="2-3-实践"><a href="#2-3-实践" class="headerlink" title="2.3 实践"></a>2.3 实践</h3><p><strong>2.3.1 XA模式</strong></p><ul><li><p>XA 规范 是 X/Open 组织定义的分布式事务处理（DTP，Distributed Transaction Processing）标准，XA 规范 描述了全局的TM与局部的RM之间的接口，几乎所有主流的数据库都对 XA 规范 提供了支持。</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/微服务.assets/image-20240104193046683.png" alt="image-20240104193046683"></p></li><li><p>seata的XA模式做了一些调整，但大体相似：</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/微服务.assets/image-20240104193116198.png" alt="image-20240104193116198"></p><ul><li><p>RM一阶段的工作：</p><ul><li>注册分支事务到TC</li><li>执行分支业务sql但不提交</li><li>报告执行状态到TC</li></ul></li><li><p>TC二阶段的工作：</p><ul><li><p>TC检测各分支事务执行状态</p><p>a.如果都成功，通知所有RM提交事务</p><p>b.如果有失败，通知所有RM回滚事务</p></li></ul></li><li><p>RM二阶段的工作：接收TC指令，提交或回滚事务</p></li></ul></li></ul><p><strong>2.3.2 AT模式</strong></p><ul><li><p>AT模式同样是分阶段提交的事务模型，不过缺弥补了XA模型中资源锁定周期过长的缺陷。</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/微服务.assets/image-20240104193215113.png" alt="image-20240104193215113"></p><ul><li><p>阶段一RM的工作：</p><ul><li>注册分支事务</li><li>记录undo-log（数据快照）</li><li>执行业务sql并提交</li><li>报告事务状态</li></ul></li><li><p>阶段二提交时RM的工作：</p><ul><li>删除undo-log即可</li></ul></li><li><p>阶段二回滚时RM的工作：</p><ul><li>根据undo-log恢复数据到更新前</li></ul></li></ul></li></ul><p><strong>2.3.3 TCC模式</strong></p><ul><li><p>TCC模式与AT模式非常相似，每阶段都是独立事务，不同的是TCC通过人工编码来实现数据恢复。需要实现三个方法：</p><ul><li>Try：资源的检测和预留； </li><li>Confirm：完成资源操作业务；要求 Try 成功 Confirm 一定要能成功。</li><li>Cancel：预留资源释放，可以理解为try的反向操作。</li></ul><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/微服务.assets/image-20240104193618583.png" alt="image-20240104193618583"></p></li></ul><p><strong>2.3.4 SAGA模式</strong></p><ul><li>Saga模式是SEATA提供的长事务解决方案。也分为两个阶段：<ul><li>一阶段：直接提交本地事务</li><li>二阶段：成功则什么都不做；失败则通过编写补偿业务来回滚</li></ul></li></ul><p><strong>2.3.5 四种模式对比</strong></p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/微服务.assets/image-20240104193714481.png" alt="image-20240104193714481"></p><h3 id="2-4-高可用"><a href="#2-4-高可用" class="headerlink" title="2.4 高可用"></a>2.4 高可用</h3><h2 id="三-分布式缓存"><a href="#三-分布式缓存" class="headerlink" title="三 分布式缓存"></a>三 分布式缓存</h2><ul><li>单点redis问题<ul><li>数据丢失</li><li>并发能力：单点redis并发能力虽然不错，但无法满足如618这样的高并发场景</li><li>故障恢复问题</li><li>存储能力问题：难以满足海量级的数据需求</li></ul></li></ul><h3 id="3-1-redis持久化"><a href="#3-1-redis持久化" class="headerlink" title="3.1 redis持久化"></a>3.1 redis持久化</h3><p><strong>3.1.1 RDB持久化</strong></p><ul><li><p>RDB全称Redis Database Backup file（Redis数据备份文件），也被叫做Redis数据快照。简单来说就是把内存中的所有数据都记录到磁盘中。当Redis实例故障重启后，从磁盘读取快照文件，恢复数据。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">save <span class="comment">#由redis主进程来执行RDB，会阻塞所有命令</span></span><br></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bgsave <span class="comment">#开启子进程执行，避免主进程受影响</span></span><br></pre></td></tr></table></figure></li></ul><ul><li><p>redis停机的时候会执行一次RDB，默认保存在当前运行目录</p></li><li><p>redis内部有触发RDB的机制，在redis.conf文件中找到</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/微服务.assets/image-20240104194236609.png" alt="image-20240104194236609"></p></li><li><p>bgsave开始时会fork主进程得到子进程，子进程共享主进程的内存数据。完成fork后读取内存数据并写入 RDB 文件。</p></li><li><p>fork采用的是copy-on-write技术：</p><ul><li>当主进程执行读操作时，访问共享内存；</li><li>当主进程执行写操作时，则会拷贝一份数据，执行写操作。</li></ul><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/微服务.assets/image-20240104194527389.png" alt="image-20240104194527389"></p></li><li><p>RDB缺点：</p><ul><li>RDB执行间隔时间长，两次RDB之间写入数据有丢失的风险</li><li>fork子进程、压缩、写出RDB文件都比较耗时</li></ul></li></ul><p><strong>3.1.2 AOF持久化</strong></p><ul><li><p>AOF全称为Append Only File（追加文件）。Redis处理的每一个写命令都会记录在AOF文件，可以看做是命令日志文件。</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/微服务.assets/image-20240104194622739.png" alt="image-20240104194622739"></p></li><li><p>AOF默认是关闭的，需要修改redis.conf配置文件来开启AOF：</p></li></ul><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/微服务.assets/image-20240104194635856.png" alt="image-20240104194635856"></p><ul><li><p>AOF的命令记录的频率也可以通过redis.conf文件来配：</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/微服务.assets/image-20240104194649688.png" alt="image-20240104194649688"></p></li><li><p>因为是记录命令，AOF文件会比RDB文件大的多。而且AOF会记录对同一个key的多次写操作，但只有最后一次写操作才有意义。通过执行bgrewriteaof命令，可以让AOF文件执行重写功能，用最少的命令达到相同效果。</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/微服务.assets/image-20240104194739202.png" alt="image-20240104194739202"></p></li><li><p>Redis也会在触发阈值时自动去重写AOF文件。阈值也可以在redis.conf中配置：</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/微服务.assets/image-20240104194804131.png" alt="image-20240104194804131"></p></li></ul><p><strong>3.1.3 对比</strong></p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/微服务.assets/image-20240104194827628.png" alt="image-20240104194827628"></p><h3 id="3-2-redis主从"><a href="#3-2-redis主从" class="headerlink" title="3.2 redis主从"></a>3.2 redis主从</h3><p><strong>3.2.1 搭建主从架构</strong></p><ul><li>单节点Redis的并发能力是有上限的，要进一步提高Redis的并发能力，就需要搭建主从集群，实现读写分离。<ul><li>redis读操作多一些，所以留一个master负责写其他从节点负责读</li></ul></li></ul><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/微服务.assets/image-20240104194948377.png" alt="image-20240104194948377"></p><ul><li><p>比如有7001 7002 7003 三个端口的redis，现在要把7001作为主节点</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 连接 7002</span></span><br><span class="line">redis-cli -p 7002</span><br><span class="line"><span class="comment"># 执行slaveof</span></span><br><span class="line">slaveof 192.168.150.101 7001</span><br></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 连接 7003</span></span><br><span class="line">redis-cli -p 7003</span><br><span class="line"><span class="comment"># 执行slaveof</span></span><br><span class="line">slaveof 192.168.150.101 7001</span><br></pre></td></tr></table></figure><p>然后可以查看集群状态</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 连接 7001</span></span><br><span class="line">redis-cli -p 7001</span><br><span class="line"><span class="comment"># 查看状态</span></span><br><span class="line">info replication</span><br></pre></td></tr></table></figure><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/微服务.assets/image-20240105100315821.png" alt="image-20240105100315821"></p></li></ul><p><strong>3.2.2 主从数据同步原理</strong></p><ul><li>主从第一次同步是全量同步</li></ul><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/微服务.assets/image-20240104195158147.png" alt="image-20240104195158147"></p><ul><li><p>过程</p><ul><li>slave节点请求增量同步</li><li>master节点判断replid，发现不一致，拒绝增量同步</li><li>master将完整内存数据生成RDB，发送RDB到slave</li><li>slave清空本地数据，加载master的RDB</li><li>master将RDB期间的命令记录在repl_baklog，并持续将log中的命令发送给slave、</li><li>slave执行接收到的命令，保持与master之间的同步</li></ul></li><li><p>master如何判断slave是不是第一次来同步数据？这里会用到两个很重要的概念：</p><ul><li>Replication Id：简称replid，是数据集的标记，id一致则说明是同一数据集。每一个master都有唯一的replid，slave则会继承master节点的replid/</li><li>offset：偏移量，随着记录在repl_baklog中的数据增多而逐渐增大。slave完成同步时也会记录当前同步的offset。如果slave的offset小于master的offset，说明slave数据落后于master，需要更新。</li></ul><p>因此slave做数据同步，必须向master声明自己的replication id 和offset，master才可以判断到底需要同步哪些数据</p></li><li><p>增量同步</p><ul><li>从repl_baklog中获取offset之后的数据，主节点发送命令过去，从节点执行</li><li>注意：repl_baklog大小有上限，写满后会覆盖最早的数据。如果slave断开时间过久，导致尚未备份的数据被覆盖，则无法基于log做增量同步，只能再次全量同步。</li></ul></li><li><p>主从集群优化</p><ul><li>在master中配置repl-diskless-sync yes启用无磁盘复制，避免全量同步时的磁盘IO。</li><li>Redis单节点上的内存占用不要太大，减少RDB导致的过多磁盘IO</li><li>适当提高repl_baklog的大小，发现slave宕机时尽快实现故障恢复，尽可能避免全量同步</li><li>限制一个master上的slave节点数量，如果实在是太多slave，则可以采用主-从-从链式结构，减少master压力</li></ul></li></ul><h3 id="3-3-redis哨兵"><a href="#3-3-redis哨兵" class="headerlink" title="3.3 redis哨兵"></a>3.3 redis哨兵</h3><p><strong>3.3.1 哨兵作用和原理</strong></p><ul><li><p>Redis提供了哨兵（Sentinel）机制来实现主从集群的自动故障恢复。哨兵的结构和作用如下：</p><ul><li><p><strong>监控</strong>：Sentinel 会不断检查您的master和slave是否按预期工作</p></li><li><p><strong>自动故障恢复</strong>：如果master故障，Sentinel会将一个slave提升为master。当故障实例恢复后也以新的master为主</p></li><li><p><strong>通知</strong>：Sentinel充当Redis客户端的服务发现来源，当集群发生故障转移时，会将最新信息推送给Redis的客户端</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/微服务.assets/image-20240105101335004.png" alt="image-20240105101335004"></p></li></ul></li><li><p>服务状态监控</p><ul><li>Sentinel基于心跳机制监测服务状态，每隔1秒向集群的每个实例发送ping命令：<ul><li>主观下线：如果某sentinel节点发现某实例未在规定时间响应，则认为该实例<strong>主观下线</strong>。、</li><li>客观下线：若超过指定数量（quorum）的sentinel都认为该实例主观下线，则该实例<strong>客观下线</strong>。quorum值最好超过Sentinel实例数量的一半。</li></ul></li></ul></li><li><p>选举新的master</p><ul><li>一旦发现master故障，sentinel需要在salve中选择一个作为新的master，选择依据是这样的：<ul><li>首先会判断slave节点与master节点断开时间长短，如果超过指定值（down-after-milliseconds * 10）则会排除该slave节点</li><li>然后判断slave节点的slave-priority值，越小优先级越高，如果是0则永不参与选举</li><li>如果slave-prority一样，则判断slave节点的offset值，越大说明数据越新，优先级越高</li><li>最后是判断slave节点的运行id大小，越小优先级越高。</li></ul></li></ul></li><li><p>如何实现故障转移</p><ul><li>sentinel给备选的slave1节点发送slaveof no one命令，让该节点成为master</li><li>sentinel给所有其它slave发送slaveof 192.168.150.101 7002 命令，让这些slave成为新master的从节点，开始从新的master上同步数据。</li><li>最后，sentinel将故障节点标记为slave，当故障节点恢复后会自动成为新的master的slave节点</li></ul></li></ul><p><strong>3.3.2 搭建哨兵集群</strong></p><p><strong>3.3.3 RedisTemplate的哨兵模式</strong></p><ul><li><p>Spring的RedisTemplate底层利用lettuce实现了节点的感知和自动切换。</p></li><li><p>步骤</p><ul><li><p>引入redis的starter依赖</p></li><li><p>配置文件application.yml中指定sentinel信息（因为主节点可能会不断的变化）</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/微服务.assets/image-20240105102803529.png" alt="image-20240105102803529"></p></li><li><p>配置主从读写分离</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/微服务.assets/image-20240105102825129.png" alt="image-20240105102825129"></p></li><li><p>这里的ReadFrom是配置Redis的读取策略，是一个枚举，包括下面选择：</p><ul><li>MASTER：从主节点读取</li><li>MASTER_PREFERRED：优先从master节点读取，master不可用才读取replica</li><li>REPLICA：从slave（replica）节点读</li><li>REPLICA _PREFERRED：优先从slave（replica）节点读取，所有的slave都不可用才读取master</li></ul></li></ul></li></ul><h3 id="3-4-redis分片集群"><a href="#3-4-redis分片集群" class="headerlink" title="3.4 redis分片集群"></a>3.4 redis分片集群</h3><p><strong>3.4.1 搭建分片集群</strong></p><ul><li><p>主从和哨兵可以解决高可用、高并发读的问题。但是依然有两个问题没有解决：</p><ul><li>海量数据存储问题</li><li>高并发写的问题</li></ul></li><li><p>使用分片集群可以解决上述问题，分片集群特征：</p><ul><li>集群中有多个master，每个master保存不同数据</li><li>每个master都可以有多个slave节点</li><li>master之间通过ping监测彼此健康状态</li><li>客户端请求可以访问集群任意节点，最终都会被转发到正确节点</li></ul><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/微服务.assets/image-20240105103628914.png" alt="image-20240105103628914"></p></li></ul><ul><li><p>搭建</p><ul><li><p>启动六个redis</p></li><li><p>```sh<br>redis-cli —cluster create —cluster-replicas 1 192.168.150.101:7001 192.168.150.101:7002 192.168.150.101:7003 192.168.150.101:8001 192.168.150.101:8002 192.168.150.101:8003</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  - `redis-cli --cluster`或者`./redis-trib.rb`：代表集群操作命令</span><br><span class="line">  - `create`：代表是创建集群</span><br><span class="line">  - `--replicas 1`或者`--cluster-replicas 1` ：指定集群中每个master的副本个数为1，此时`节点总数 ÷ (replicas + 1)` 得到的就是master的数量。因此节点列表中的前n个就是master，其它节点都是slave节点，随机分配到不同master</span><br><span class="line"></span><br><span class="line">- 查看集群状态</span><br><span class="line"></span><br><span class="line">  ```sh</span><br><span class="line">  redis-cli -p 7001 cluster nodes</span><br></pre></td></tr></table></figure></li></ul></li></ul><p><strong>3.4.2 散列插槽</strong></p><ul><li><p>Redis会把每一个master节点映射到0~16383共16384个插槽（hash slot）上，查看集群信息时就能看到</p></li><li><p>数据key不是与节点绑定，而是与插槽绑定。redis会根据key的有效部分计算插槽值，分两种情况：</p><ul><li>key中包含”{}”，且“{}”中至少包含1个字符，“{}”中的部分是有效部分</li><li>key中不包含“{}”，整个key都是有效部分</li></ul><p>例如：key是num，那么就根据num计算，如果是{itcast}num，则根据itcast计算。计算方式是利用CRC16算法得到一个hash值，然后对16384取余，得到的结果就是slot值。</p></li><li><p>一个节点对应的插槽是很多的</p></li></ul><p><strong>3.4.3 集群伸缩</strong></p><ul><li>添加一个节点到集群<ul><li>启动一个新的redis实例，端口为7004</li><li>添加7004到之前的集群，并作为一个master节点</li><li>给7004节点分配插槽，使得num这个key可以存储到7004实例</li></ul></li><li>删除一个节点</li></ul><p><strong>3.4.4 故障转移</strong></p><ul><li><p>集群中一个master宕机</p><ul><li>首先是该实例与其它实例失去连接</li><li>然后是疑似宕机：</li><li>最后是确定下线，自动提升一个slave为新的master</li></ul></li><li><p>数据迁移</p><ul><li>利用cluster failover命令可以手动让集群中的某个master宕机，切换到执行cluster failover命令的这个slave节点，实现无感知的数据迁移。其流程如下：</li></ul><p>&lt;img src=(<a href="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/微服务.assets/image-20240105105202163.png">https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/微服务.assets/image-20240105105202163.png</a>“ alt=”image-20240105105202163” style=”zoom:67%;” /&gt;</p><ul><li>场景：老旧机器的更换</li></ul></li><li><p>手动的Failover支持三种不同模式：</p><ul><li>缺省：默认的流程，如图1~6歩</li><li>force：省略了对offset的一致性校验</li><li>takeover：直接执行第5歩，忽略数据一致性、忽略master状态和其它master的意见</li></ul></li></ul><p><strong>3.4.5 RedisTemplate访问分片集群</strong></p><ul><li><p>RedisTemplate底层同样基于lettuce实现了分片集群的支持，而使用的步骤与哨兵模式基本一致：</p><ul><li>引入redis的starter依赖</li><li>配置分片集群地址</li><li>配置读写分离</li></ul></li><li><p>与哨兵模式相比，其中只有分片集群的配置方式略有差异，如下：</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/微服务.assets/image-20240105105531251.png" alt="image-20240105105531251"></p></li></ul><h2 id="四-多级缓存"><a href="#四-多级缓存" class="headerlink" title="四 多级缓存"></a>四 多级缓存</h2><ul><li><p>传统的缓存策略一般是请求到达Tomcat后，先查询Redis，如果未命中则查询数据库，存在下面的问题：</p><ul><li>请求要经过Tomcat处理，Tomcat的性能成为整个系统的瓶颈</li><li>Redis缓存失效时，会对数据库产生冲击</li></ul><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/微服务.assets/image-20240105105755866.png" alt="image-20240105105755866"></p></li><li><p>多级缓存就是充分利用请求处理的每个环节，分别添加缓存，减轻Tomcat压力，提升服务性能：</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/微服务.assets/image-20240105105746987.png" alt="image-20240105105746987"></p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/微服务.assets/image-20240105105822419.png" alt="image-20240105105822419"></p></li></ul><h3 id="4-1-JVM进程缓存"><a href="#4-1-JVM进程缓存" class="headerlink" title="4.1 JVM进程缓存"></a>4.1 JVM进程缓存</h3><p><strong>4.1.1 Caffeine</strong></p><ul><li>缓存在日常开发中启动至关重要的作用，由于是存储在内存中，数据的读取速度是非常快的，能大量减少对数据库的访问，减少数据库的压力。我们把缓存分为两类：<ul><li>分布式缓存，例如Redis：<ul><li>优点：存储容量更大、可靠性更好、可以在集群间共享</li><li>缺点：访问缓存有网络开销</li><li>场景：缓存数据量较大、可靠性要求较高、需要在集群间共享</li></ul></li><li>进程本地缓存，例如HashMap、GuavaCache：<ul><li>优点：读取本地内存，没有网络开销，速度更快</li><li>缺点：存储容量有限、可靠性较低、无法共</li><li>场景：性能要求较高，缓存数据量较小</li></ul></li></ul></li><li><p>Caffeine是一个基于Java8开发的，提供了近乎最佳命中率的高性能的本地缓存库。目前Spring内部的缓存使用的就是Caffeine。GitHub地址：<a href="https://github.com/ben-manes/caffeine">https://github.com/ben-manes/caffeine</a></p></li><li><p>demo</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/微服务.assets/image-20240105111031515.png" alt="image-20240105111031515"></p></li><li><p>caffeine的三种缓存驱逐策略</p><ul><li><p><strong>基于容量</strong>：设置缓存的数量上限</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/微服务.assets/image-20240105111209468.png" alt="image-20240105111209468"></p></li><li><p><strong>基于时间</strong>：设置缓存的有效时间</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/微服务.assets/image-20240105111215390.png" alt="image-20240105111215390"></p></li><li><p><strong>基于引用</strong>：设置缓存为软引用或弱引用，利用GC来回收缓存数据。性能较差，不建议使用。</p></li></ul><p>在默认情况下，当一个缓存元素过期的时候，Caffeine不会自动立即将其清理和驱逐。而是在一次读或写操作后，或者在空闲时间完成对失效数据的驱逐</p></li></ul><p><strong>4.1.2 实现进程缓存</strong></p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/微服务.assets/image-20240105111318932.png" alt="image-20240105111318932"></p><ul><li><p>新建一个配置类，声明多个Cache bean</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/微服务.assets/image-20240105111451417.png" alt="image-20240105111451417"></p></li><li><p>然后在Controller中注入bean并调用</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/微服务.assets/image-20240105111552251.png" alt="image-20240105111552251"></p><p>​    意思是优先查询cache中的“id”，如果没有就调用itemService的query</p></li></ul><h3 id="4-2-Lua语法入门"><a href="#4-2-Lua语法入门" class="headerlink" title="4.2 Lua语法入门"></a>4.2 Lua语法入门</h3><p><strong>4.2.1 初识Lua</strong></p><ul><li>Lua 是一种轻量小巧的<strong>脚本语言</strong>，用标准C语言编写并以源代码形式开放， 其设计目的是为了嵌入应用程序中，从而为应用程序提供灵活的扩展和定制功能。官网：<a href="https://www.lua.org/">https://www.lua.org/</a></li></ul><p><strong>4.2.2 变量和循环</strong></p><ul><li><p>数据类型</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/微服务.assets/image-20240105133051689.png" alt="image-20240105133051689"></p></li><li><p>变量</p><ul><li><p>Lua声明变量的时候不需要指定数据类型</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/微服务.assets/image-20240105133246810.png" alt="image-20240105133246810"></p></li><li><p>访问table</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/微服务.assets/image-20240105133257354.png" alt="image-20240105133257354"></p></li></ul></li><li><p>循环</p><ul><li><p>数组、table都可以利用for循环来遍历</p></li><li><p>遍历数组</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/微服务.assets/image-20240105133406895.png" alt="image-20240105133406895"></p></li><li><p>遍历table</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/微服务.assets/image-20240105133413164.png" alt="image-20240105133413164"></p></li></ul></li></ul><p><strong>4.2.3 条件控制、函数</strong></p><ul><li><p>定义函数的语法</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/微服务.assets/image-20240105133944042.png" alt="image-20240105133944042"></p></li><li><p>举例</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/微服务.assets/image-20240105133955372.png" alt="image-20240105133955372"></p></li><li><p>条件控制</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/微服务.assets/image-20240105134013837.png" alt="image-20240105134013837"></p></li><li><p>其中布尔表达式中的逻辑运算符是基于英文单词的</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/微服务.assets/image-20240105134055822.png" alt="image-20240105134055822"></p></li></ul><h3 id="4-3-多级缓存"><a href="#4-3-多级缓存" class="headerlink" title="4.3 多级缓存"></a>4.3 多级缓存</h3><p><strong>4.3.1 安装OpenResty</strong></p><ul><li>OpenResty® 是一个基于 Nginx的高性能 Web 平台，用于方便地搭建能够处理超高并发、扩展性极高的动态 Web 应用、Web 服务和动态网关。具备下列特点：<ul><li>具备Nginx的完整功能</li><li>基于Lua语言进行扩展，集成了大量精良的 Lua 库、第三方模块</li><li>允许使用Lua自定义业务逻辑、自定义库</li></ul></li><li>官方网站： <a href="https://openresty.org/cn/">https://openresty.org/cn/</a></li></ul><p><strong>4.3.2 OpenResty入门</strong></p><ul><li><p>实现商品详情页数据查询</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/微服务.assets/image-20240105135454452.png" alt="image-20240105135454452"></p></li><li><p>1.在nginx.conf的http下面，添加对OpenResty的Lua模块的加载：</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/微服务.assets/image-20240105135517832.png" alt="image-20240105135517832"></p></li><li><p>2.在nginx.conf的server下面，添加对/api/item这个路径的监听：</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/微服务.assets/image-20240105135522494.png" alt="image-20240105135522494"></p></li><li><p>3.在nginx目录创建lua/item.lua文件</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/微服务.assets/image-20240105135620438.png" alt="image-20240105135620438"></p></li><li><p>4.重新加载配置</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nginx -s reload</span><br></pre></td></tr></table></figure></li></ul><p><strong>4.3.3 请求参数处理</strong></p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/微服务.assets/image-20240105135657452.png" alt="image-20240105135657452"></p><p><strong>4.3.4 查询Tomcat</strong></p><p><strong>4.3.5 redis缓存预热</strong></p><ul><li><strong>冷启动</strong>：服务刚刚启动时，Redis中并没有缓存，如果所有商品数据都在第一次查询时添加缓存，可能会给数据库带来较大压力。</li><li><strong>缓存预热</strong>：在实际开发中，我们可以利用大数据统计用户访问的热点数据，在项目启动时将这些热点数据提前查询并保存到Redis中。</li></ul><p><strong>4.3.6 查询redis缓存</strong></p><ul><li><p>openresty查询redis</p></li><li><p>引入redis模块，并初始化redis对象</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/微服务.assets/image-20240105144404477.png" alt="image-20240105144404477"></p></li><li><p>封装函数，用来释放redis连接，其实是放入连接池</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/微服务.assets/image-20240105144431372.png" alt="image-20240105144431372"></p></li><li><p>封装函数，从Redis读数据并返回</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/微服务.assets/image-20240105144453451.png" alt="image-20240105144453451"></p></li></ul><p><strong>4.3.7 Nginx本地缓存</strong></p><h3 id="4-4-缓存同步策略"><a href="#4-4-缓存同步策略" class="headerlink" title="4.4 缓存同步策略"></a>4.4 缓存同步策略</h3><p><strong>4.4.1 数据同步策略</strong></p><ul><li><p>设置数据同步策略的三种：</p><ul><li><p><strong>设置有效期</strong>：给缓存设置有效期，到期后自动删除。再次查询时更新</p><ul><li>优势：简单、方便</li><li>缺点：时效性差，缓存过期之前可能不一致</li><li>场景：更新频率较低，时效性要求低的业务</li></ul></li><li><p><strong>同步双写</strong>：在修改数据库的同时，直接修改缓存</p><ul><li>优势：时效性强，缓存与数据库强一致</li><li>缺点：有代码侵入，耦合度高；</li><li>场景：对一致性、时效性要求较高的缓存数据</li></ul></li><li><p><strong>异步通知：</strong>修改数据库时发送事件通知，相关服务监听到通知后修改缓存数据</p><ul><li><p>优势：低耦合，可以同时通知多个缓存服务</p></li><li><p>缺点：时效性一般，可能存在中间不一致状态</p></li><li><p>场景：时效性要求一般，有多个服务需要同步</p></li></ul></li></ul></li><li><p>基于MQ的异步通知</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/微服务.assets/image-20240105144815167.png" alt="image-20240105144815167"></p></li><li><p>基于Canal的异步通知</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/微服务.assets/image-20240105144832272.png" alt="image-20240105144832272"></p></li></ul><p><strong>4.4.2 安装Canal</strong></p><ul><li>canal是阿里巴巴旗下的一款开源项目，基于Java开发。基于数据库增量日志解析，提供增量数据订阅&amp;消费。GitHub的地址：<a href="https://github.com/alibaba/canal">https://github.com/alibaba/canal</a></li><li>Canal是基于mysql的主从同步来实现的，MySQL主从同步的原理如下：<ul><li>MySQL master 将数据变更写入二进制日志( binary log），其中记录的数据叫做binary log events</li><li>MySQL slave 将 master 的 binary log events拷贝到它的中继日志(relay log)</li><li>MySQL slave 重放 relay log 中事件，将数据变更反映它自己的数据</li></ul></li></ul><p><strong>4.4.3 监听Canal</strong></p><ul><li><p>引入依赖canal-starter</p></li><li><p>配置</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/微服务.assets/image-20240105145629143.png" alt="image-20240105145629143"></p></li><li><p>编写监听器，监听Canal消息</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/微服务.assets/image-20240105145656038.png" alt="image-20240105145656038"></p></li></ul><h3 id="4-5-多级缓存总结"><a href="#4-5-多级缓存总结" class="headerlink" title="4.5 多级缓存总结"></a>4.5 多级缓存总结</h3><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/微服务.assets/image-20240105145830764.png" alt="image-20240105145830764"></p><h2 id="五-服务异步通讯"><a href="#五-服务异步通讯" class="headerlink" title="五 服务异步通讯"></a>五 服务异步通讯</h2><ul><li>MQ 的一些常见问题<ul><li>消息可靠性：如何确保发送的消息至少被消费一次</li><li>延迟消息问题：如何实现消息的延迟投递</li><li>消息堆积问题：如何解决数百万消息堆积，无法及时消费的问题</li><li>高可用问题：如何避免单点的MQ故障而导致的不可用问题</li></ul></li></ul><h3 id="5-1-消息可靠性"><a href="#5-1-消息可靠性" class="headerlink" title="5.1 消息可靠性"></a>5.1 消息可靠性</h3><ul><li><p>消息从生产者发送到exchange，再到queue，再到消费者，有哪些导致消息丢失的可能性？</p><ul><li>发送时丢失：<ul><li>生产者发送的消息未送达exchange</li><li>消息到达exchange后未到达queue</li></ul></li><li>MQ宕机，queue将消息丢失</li><li>consumer接收到消息后未消费就宕机</li></ul><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/微服务.assets/image-20240105150839158.png" alt="image-20240105150839158"></p></li></ul><p><strong>5.1.1 生产者消息确认</strong></p><ul><li><p>RabbitMQ提供了publisher confirm机制来避免消息发送到MQ过程中丢失。消息发送到MQ以后，会返回一个结果给发送者，表示消息是否处理成功。结果有两种请求：</p><ul><li><p>publisher-confirm，发送者确认</p><ul><li>消息成功投递到交换机，返回ack</li><li>消息未投递到交换机，返回nack</li></ul></li><li><p>publisher-return，发送者回执</p><ul><li>消息投递到交换机了，但是没有路由到队列。返回ACK，及路由失败原因。</li></ul></li></ul><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/微服务.assets/image-20240105151149479.png" alt="image-20240105151149479"></p></li><li><p>注意：确认机制发送消息时，需要给每个消息设置一个全局唯一id，以区分不同消息，避免ack冲突</p></li></ul><p><strong>5.1.2 消息持久化</strong></p><ul><li><p>MQ默认是内存存储消息，开启持久化功能可以确保缓存在MQ中的消息不丢失。</p><ul><li><p>交换机持久化</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/微服务.assets/image-20240105154849235.png" alt="image-20240105154849235"></p></li><li><p>队列持久化</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/微服务.assets/image-20240105154844560.png" alt="image-20240105154844560"></p></li><li><p>消息持久化</p></li></ul><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/微服务.assets/image-20240105154858770.png" alt="image-20240105154858770"></p></li></ul><p><strong>5.1.3 消费者消息确认</strong></p><p>RabbitMQ支持消费者确认机制，即：消费者处理消息后可以向MQ发送ack回执，MQ收到ack回执后才会删除该消息。而SpringAMQP则允许配置三种确认模式：</p><ul><li><p>manual：手动ack，需要在业务代码结束后，调用api发送ack。</p></li><li><p>auto：自动ack，由spring监测listener代码是否出现异常，没有异常则返回ack；抛出异常则返回nack</p></li><li><p>none：关闭ack，MQ假定消费者获取消息后会成功处理，因此消息投递后立即被删除</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/微服务.assets/image-20240105155029190.png" alt="image-20240105155029190"></p></li></ul><p><strong>5.1.4 消费失败重试机制</strong></p><ul><li><p>当消费者出现异常后，消息会不断requeue（重新入队）到队列，再重新发送给消费者，然后再次异常，再次requeue，无限循环，导致mq的消息处理飙升，带来不必要的压力：</p></li><li><p>解决：利用Spring的retry机制，在消费者出现异常时利用本地重试，而不是无限制的requeue到mq队列。</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/微服务.assets/image-20240105155428537.png" alt="image-20240105155428537"></p></li><li><p>在开启重试模式后，重试次数耗尽，如果消息依然失败，则需要有MessageRecoverer接口来处理，它包含三种不同的实现：</p><ul><li><code>RejectAndDontRequeueRecoverer</code>：重试耗尽后，直接reject，丢弃消息。默认就是这种方式</li><li><code>ImmediateRequeueMessageRecoverer</code>：重试耗尽后，返回nack，消息重新入队</li><li><code>RepublishMessageRecoverer</code>：重试耗尽后，将失败消息投递到指定的交换机</li></ul></li><li><p>步骤</p><ul><li><p>首先定义接收失败消息的交换机、队列及其绑定关系：</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/微服务.assets/image-20240105160204514.png" alt="image-20240105160204514"></p></li><li><p>然后定义<code>RejectAndDontRequeueRecoverer</code></p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/微服务.assets/image-20240105160216734.png" alt="image-20240105160216734"></p></li></ul></li></ul><h3 id="5-2-死信交换机"><a href="#5-2-死信交换机" class="headerlink" title="5.2 死信交换机"></a>5.2 死信交换机</h3><p><strong>5.2.1 简介</strong></p><ul><li><p>当一个队列中的消息满足下列情况之一时，可以成为死信（dead letter）：</p><ul><li>消费者使用basic.reject或 basic.nack声明消费失败，并且消息的requeue参数设置为false</li><li>消息是一个过期消息，超时无人消费</li><li>要投递的队列消息堆积满了，最早的消息可能成为死信</li></ul></li><li><p>如果该队列配置了dead-letter-exchange属性，指定了一个交换机，那么队列中的死信就会投递到这个交换机中，而这个交换机称为<strong>死信交换机</strong>（Dead Letter Exchange，简称DLX）。</p></li></ul><p><strong>5.2.2 TTL</strong></p><ul><li><p>TTL，也就是Time-To-Live。如果一个队列中的消息TTL结束仍未消费，则会变为死信，ttl超时分为两种情况：</p><ul><li>消息所在的队列设置了存活时间</li><li>消息本身设置了存活时间</li></ul></li><li><p>声明一组死信交换机和队列，基于注解</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/微服务.assets/image-20240105161311264.png" alt="image-20240105161311264"></p></li><li><p>要给队列设置超时时间，需要在声明队列时配置x-message-ttl属性：</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/微服务.assets/image-20240105161324736.png" alt="image-20240105161324736"></p></li><li><p>发送消息时，给消息本身设置超时时间</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/微服务.assets/image-20240105161340661.png" alt="image-20240105161340661"></p></li></ul><p><strong>5.2.3 延迟队列</strong></p><ul><li><p>利用TTL结合死信交换机，我们实现了消息发出后，消费者延迟收到消息的效果。这种消息模式就称为延迟队列（Delay Queue）模式。</p></li><li><p>延迟队列的使用场景包括：</p><ul><li>延迟发送短信</li><li>用户下单，如果用户在15 分钟内未支付，则自动取消</li><li>预约工作会议，20分钟后自动通知所有参会人员</li></ul></li><li><p>因为延迟队列的需求非常多，所以RabbitMQ的官方也推出了一个插件，原生支持延迟队列效果。</p></li><li><p>SpringAMQP使用延迟队列插件</p><ul><li><p>基于注解（推荐）</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/微服务.assets/image-20240105162354097.png" alt="image-20240105162354097"></p></li><li><p>基于代码</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/微服务.assets/image-20240105162427982.png" alt="image-20240105162427982"></p></li><li><p>然后向这个delay为true的交换机中发送消息，一定要给消息添加一个header：<strong>x-delay</strong>，值为延迟的时间，单位为毫秒：</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/微服务.assets/image-20240105162458309.png" alt="image-20240105162458309"></p></li></ul></li></ul><h3 id="5-3-惰性队列"><a href="#5-3-惰性队列" class="headerlink" title="5.3 惰性队列"></a>5.3 惰性队列</h3><p><strong>5.3.1 消息堆积问题</strong></p><ul><li><p>当生产者发送消息的速度超过了消费者处理消息的速度，就会导致队列中的消息堆积，直到队列存储消息达到上限。最早接收到的消息，可能就会成为死信，会被丢弃，这就是消息堆积问题。</p></li><li><p>解决思路</p><ul><li>增加更多消费者，提高消费速度</li><li>在消费者内开启线程池加快消息处理速度</li><li>扩大队列容积，提高堆积上限                                                                                                                                                                                                                     </li></ul></li></ul><p><strong>5.3.2 惰性队列</strong></p><ul><li><p>从RabbitMQ的3.6.0版本开始，就增加了Lazy Queues的概念，也就是惰性队列。</p><p>惰性队列的特征如下：</p><ul><li>接收到消息后直接存入磁盘而非内存</li><li>消费者要消费消息时才会从磁盘中读取并加载到内存</li><li>支持数百万条的消息存储</li></ul></li><li><p>如何声明：只需要在声明队列时，指定x-queue-mode属性为lazy即可。可以通过命令行将一个运行中的队列修改为惰性队列：</p></li></ul><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/微服务.assets/image-20240105163310226-1704443594008-1.png" alt="image-20240105163310226"></p><ul><li><p>用SpringAMQP声明惰性队列的两种方式</p><ul><li><p><code>@Bean</code>（简单一些）</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/微服务.assets/image-20240105163346000.png" alt="image-20240105163346000"></p></li><li><p>注解</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/微服务.assets/image-20240105163351421.png" alt="image-20240105163351421"></p></li></ul></li></ul><h3 id="5-4-MQ集群"><a href="#5-4-MQ集群" class="headerlink" title="5.4 MQ集群"></a>5.4 MQ集群</h3><p><strong>5.4.1 集群分类</strong></p><ul><li>RabbitMQ的是基于Erlang语言编写，而Erlang又是一个面向并发的语言，天然支持集群模式。RabbitMQ的集群有两种模式：<ul><li>普通集群：是一种分布式集群，将队列分散到集群的各个节点，从而提高整个集群的并发能力。</li><li>镜像集群：是一种主从集群，普通集群的基础上，添加了主从备份功能，提高集群的数据可用性。</li></ul></li><li>镜像集群虽然支持主从，但主从同步并不是强一致的，某些情况下可能有数据丢失的风险。因此在RabbitMQ的3.8版本以后，推出了新的功能：<strong>仲裁队列</strong>来代替镜像集群，底层采用Raft协议确保主从的数据一致性。</li></ul><p><strong>5.4.2 普通集群</strong></p><ul><li>普通集群，或者叫标准集群（classic cluster），具备下列特征：<ul><li>会在集群的各个节点间共享部分数据，包括：交换机、队列元信息。不包含队列中的消息。</li><li>当访问集群某节点时，如果队列不在该节点，会从数据所在节点传递到当前节点并返回</li><li>队列所在节点宕机，队列中的消息就会丢失</li></ul></li></ul><p><strong>5.4.3 镜像集群</strong></p><ul><li>镜像集群：本质是主从模式，具备下面的特征：<ul><li>交换机、队列、队列中的消息会在各个mq的镜像节点之间同步备份。</li><li>创建队列的节点被称为该队列的<strong>主节点，</strong>备份到的其它节点叫做该队列的<strong>镜像</strong>节点。</li><li>一个队列的主节点可能是另一个队列的镜像节点</li><li>所有操作都是主节点完成，然后同步给镜像节点</li><li>主宕机后，镜像节点会替代成新的主</li></ul></li></ul><p><strong>5.4.4 仲裁队列</strong></p><ul><li><p>3.8之后的新功能，用于替换镜像队列。特征： </p><ul><li>与镜像队列一样，都是主从模式，支持主从数据同步</li><li>使用非常简单，没有复杂的配置</li><li>主从同步基于Raft协议，强一致</li></ul></li><li><p>SpringAMQP创建仲裁队列</p><ul><li><p>定义队列</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/微服务.assets/image-20240105164220451.png" alt="image-20240105164220451"></p></li><li><p>SpringAMQP连接集群，只需要在yaml中配置即可：</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/微服务.assets/image-20240105164238568.png" alt="image-20240105164238568"></p></li></ul></li></ul><h1 id="Ⅲ-面试"><a href="#Ⅲ-面试" class="headerlink" title="Ⅲ 面试"></a>Ⅲ 面试</h1><h2 id="一-Nacos"><a href="#一-Nacos" class="headerlink" title="一 Nacos"></a>一 Nacos</h2><h2 id="二-Sentinel"><a href="#二-Sentinel" class="headerlink" title="二 Sentinel"></a>二 Sentinel</h2><h2 id="三-Redis-热点问题"><a href="#三-Redis-热点问题" class="headerlink" title="三 Redis 热点问题"></a>三 Redis 热点问题</h2><link rel="stylesheet" href="https://cdn1.tianli0.top/gh/zhheo/Post-Abstract-AI@0.15.2/tianli_gpt.css"><script>let tianliGPT_postSelector = '#post #article-container';let tianliGPT_key = 'c9b7741d290063ab872e';</script><script src="https://cdn1.tianli0.top/gh/zhheo/Post-Abstract-AI@0.15.2/tianli_gpt.js"></script>]]></content>
      
      
      <categories>
          
          <category> study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java高级 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>黑马头条</title>
      <link href="/posts/62391.html"/>
      <url>/posts/62391.html</url>
      
        <content type="html"><![CDATA[<h1 id="黑马头条"><a href="#黑马头条" class="headerlink" title="黑马头条"></a>黑马头条</h1><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/黑马头条.assets/image-20240114221656050.png" alt="image-20240114221656050"></p><ul><li>登录管理</li></ul><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/黑马头条.assets/image-20240114222133667.png" alt="image-20240114222133667"></p><link rel="stylesheet" href="https://cdn1.tianli0.top/gh/zhheo/Post-Abstract-AI@0.15.2/tianli_gpt.css"><script>let tianliGPT_postSelector = '#post #article-container';let tianliGPT_key = 'c9b7741d290063ab872e';</script><script src="https://cdn1.tianli0.top/gh/zhheo/Post-Abstract-AI@0.15.2/tianli_gpt.js"></script>]]></content>
      
      
      <categories>
          
          <category> 实战 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 项目 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>若依学习</title>
      <link href="/posts/55918.html"/>
      <url>/posts/55918.html</url>
      
        <content type="html"><![CDATA[<h1 id="若依学习"><a href="#若依学习" class="headerlink" title="若依学习"></a>若依学习</h1><ul><li><p>登录</p><ul><li><p>前端进入页面，发送请求<code>/captchaImage</code>生成验证码图片与uuid返回，同时在redis中添加数据（后面的一串是uuid）</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/若依学习.assets/image-20240107142412819.png" alt="image-20240107142412819"></p></li><li><p>用户提交登录信息，携带uuid再次请求<code>/login</code></p><ul><li><p>验证码校验：根据uuid查询redis中是否存在该key，并校对key对应的value，也就是验证码的值</p><ul><li>注意：这个验证码有时效性的</li></ul></li><li><p>用户密码合法性校验：异步任务管理器类 <code>AsyncManager</code></p><ul><li><code>AsyncManager</code>的本质：调用了<code>scheduledExecutorService</code></li></ul></li><li><p>校验密码是否匹配</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/若依学习.assets/image-20240107144235191.png" alt="image-20240107144235191"></p><p>关键是<code>UserDetailsServiceImpl.loadUserByUsername()</code>方法</p></li><li><p>记录登录信息生成token并返回</p></li><li><p>登录成功：记录token在redis中</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/若依学习.assets/image-20240107143024674.png" alt="image-20240107143024674"></p></li></ul></li></ul></li></ul><link rel="stylesheet" href="https://cdn1.tianli0.top/gh/zhheo/Post-Abstract-AI@0.15.2/tianli_gpt.css"><script>let tianliGPT_postSelector = '#post #article-container';let tianliGPT_key = 'c9b7741d290063ab872e';</script><script src="https://cdn1.tianli0.top/gh/zhheo/Post-Abstract-AI@0.15.2/tianli_gpt.js"></script>]]></content>
      
      
      <categories>
          
          <category> 中间件/框架 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java高级 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>瑞吉外卖</title>
      <link href="/posts/57008.html"/>
      <url>/posts/57008.html</url>
      
        <content type="html"><![CDATA[<h1 id="瑞吉外卖"><a href="#瑞吉外卖" class="headerlink" title="瑞吉外卖"></a>瑞吉外卖</h1><ul><li>项目简介</li></ul><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/瑞吉外卖.assets/image-20231211101708485.png" alt="image-20231211101708485"></p><ul><li><p>技术选型</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/瑞吉外卖.assets/image-20231211101850364.png" alt="image-20231211101850364"></p></li><li><p>功能架构</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/瑞吉外卖.assets/image-20231211102001535.png" alt="image-20231211102001535"></p></li></ul><h4 id="1-阿里云短信服务"><a href="#1-阿里云短信服务" class="headerlink" title="1 阿里云短信服务"></a>1 阿里云短信服务</h4><ul><li>注册阿里云</li><li><p>获取短信服务（需要资质验证）</p></li><li><p>导入maven</p></li><li>参照官方API文档</li></ul><h4 id="2-部署项目到linux"><a href="#2-部署项目到linux" class="headerlink" title="2 部署项目到linux"></a>2 部署项目到linux</h4><ul><li><p>linux安装mysql java环境</p></li><li><p>项目打包jar</p></li><li><p>上传到linux系统</p><ul><li><p>创建一个目录</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir /usr/local/app</span><br></pre></td></tr></table></figure></li><li><p>通过XShell连接linux并将jar包上传到目录中</p></li></ul></li><li><p>在linux终端中启动springboot</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar xxxx.jar</span><br></pre></td></tr></table></figure></li><li><p>开启linux指定端口的防火墙</p></li></ul><h4 id="3-优化"><a href="#3-优化" class="headerlink" title="3 优化"></a>3 优化</h4><ul><li><p>改为后台运行</p><ul><li><pre><code>nohup命令<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  ![image-20231219214540162](https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/瑞吉外卖.assets/image-20231219214540162.png)</span><br><span class="line"></span><br><span class="line">- 这个时候要停下来的话需要杀进程</span><br><span class="line"></span><br><span class="line">  - 先找到进程</span><br><span class="line"></span><br></pre></td></tr></table></figure>  ps -ef | grep java-jar  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  ![image-20231219215320104](https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/瑞吉外卖.assets/image-20231219215320104.png)</span><br><span class="line"></span><br><span class="line">- 杀死进程</span><br><span class="line"></span><br></pre></td></tr></table></figure>  kill -9 3969</code></pre></li></ul></li><li><p>通过shell脚本自动部署项目</p><ul><li><p>linux安装git</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/瑞吉外卖.assets/image-20231219220205846.png" alt="image-20231219220205846"></p></li><li><p>linux安装maven</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/瑞吉外卖.assets/image-20231219221533672.png" alt="image-20231219221533672"></p></li><li><p>编写shell脚本（拉取代码、编译、打包、启动）</p></li><li><p>为用户授予执行shell脚本的权限</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/瑞吉外卖.assets/image-20231219223714387.png" alt="image-20231219223714387"></p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/瑞吉外卖.assets/image-20231219223926307.png" alt="image-20231219223926307"></p></li></ul></li></ul><ul><li><p>执行shell脚本</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/瑞吉外卖.assets/image-20231219215538413.png" alt="image-20231219215538413"></p></li></ul><ul><li><p>设置静态IP</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/瑞吉外卖.assets/image-20231219224544886.png" alt="image-20231219224544886"></p></li></ul><link rel="stylesheet" href="https://cdn1.tianli0.top/gh/zhheo/Post-Abstract-AI@0.15.2/tianli_gpt.css"><script>let tianliGPT_postSelector = '#post #article-container';let tianliGPT_key = 'c9b7741d290063ab872e';</script><script src="https://cdn1.tianli0.top/gh/zhheo/Post-Abstract-AI@0.15.2/tianli_gpt.js"></script>]]></content>
      
      
      <categories>
          
          <category> 实战 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 项目 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring高级</title>
      <link href="/posts/30720.html"/>
      <url>/posts/30720.html</url>
      
        <content type="html"><![CDATA[<h1 id="Spring高级"><a href="#Spring高级" class="headerlink" title="Spring高级"></a>Spring高级</h1><p><a href="https://www.bilibili.com/video/BV1P44y1N7QG?p=26&amp;spm_id_from=pageDriver&amp;vd_source=1a39594354c31d775ddc587407a55282">https://www.bilibili.com/video/BV1P44y1N7QG?p=26&amp;spm_id_from=pageDriver&amp;vd_source=1a39594354c31d775ddc587407a55282</a></p><h2 id="Ⅰ-容器与bean"><a href="#Ⅰ-容器与bean" class="headerlink" title="Ⅰ 容器与bean"></a>Ⅰ 容器与bean</h2><h3 id="一-容器接口"><a href="#一-容器接口" class="headerlink" title="一 容器接口"></a>一 容器接口</h3><h4 id="1-1-BeanFactory"><a href="#1-1-BeanFactory" class="headerlink" title="1.1 BeanFactory"></a>1.1 BeanFactory</h4><ul><li>简介<ul><li>是ApplicationContext的父接口</li><li>它才是Spring的核心容器，主要的ApplicationContext的实现都组合了他的功能</li></ul></li><li>功能<ul><li>表面只有getBean</li><li>实际上控制反转、基本的依赖注入，直至Bean的声明周期的各种功能，都由它的实现类提供</li></ul></li></ul><h4 id="1-2-ApplicationContext"><a href="#1-2-ApplicationContext" class="headerlink" title="1.2 ApplicationContext"></a>1.2 ApplicationContext</h4><ul><li><p>比BeanFactory多的一些容器接口  </p><ul><li><p>国际化</p><ul><li><code>context.getMessage(&quot;hi&quot;, null, Locale.ENGLISH)</code></li></ul></li><li><p>根据通配符获取资源</p><ul><li><code>context.getResource(...)</code></li></ul></li><li><p>获取配置信息</p><ul><li><code>context.getEnvironment().getProperty()</code></li></ul></li><li><p>发布事件（实现组件解耦）</p><ul><li><p><code>context.getBean(..).register(...)</code></p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/Spring高级.assets/image-20231127202739234.png" alt="image-20231127202739234"></p></li></ul></li></ul></li></ul><h3 id="二-容器实现"><a href="#二-容器实现" class="headerlink" title="二  容器实现"></a>二  容器实现</h3><h4 id="2-1-BeanFactory实现特点"><a href="#2-1-BeanFactory实现特点" class="headerlink" title="2.1 BeanFactory实现特点"></a>2.1 BeanFactory实现特点</h4><ul><li><p><code>DefaultListableBeanFactory</code></p><ul><li><p>是 BeanFactory 最重要的实现，像<strong>控制反转</strong>和<strong>依赖注入</strong>功能，都是它来实现</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/Spring高级.assets/image-20231127203722980.png" alt="image-20231127203722980"></p><ul><li>bean的定义</li><li>注册bean</li></ul></li><li><p>不能解析bean内部的bean</p><ul><li><p>解决：给bean工厂添加后处理器并将其加入与bean工厂的联系（<code>addBeanPostProcessor</code>）</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/Spring高级.assets/image-20231127203924081.png" alt="image-20231127203924081"></p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/Spring高级.assets/image-20231127204756823.png" alt="image-20231127204756823"></p></li><li><p>针对bean的生命周期的各个阶段提供 扩展,如<code>@Autowired</code> <code>@Resource</code>…</p></li></ul></li></ul></li><li><p>特点</p><ul><li>不会主动对beanFactory后处理器</li><li>不会主动添加Bean后处理器</li><li>不会主动实例化单例</li><li>不会解析beanFactory 还不会解析 <code>$&#123;&#125;</code> <code>#&#123;&#125;</code></li></ul></li><li><p>后处理器的排序</p><ul><li>先添加进去的后处理器的优先级高，如果一个bean同时加了<code>@Autowired</code> 和<code>@Resource</code>，则看这两个后处理器谁先被加入bean容器谁就优先执行</li><li>也可以通过比较器来改变后处理器的优先级</li></ul></li></ul><h4 id="2-2-ApplicationContext常见实现"><a href="#2-2-ApplicationContext常见实现" class="headerlink" title="2.2 ApplicationContext常见实现"></a>2.2 ApplicationContext常见实现</h4><ul><li><p><code>ClassPathXmlApplicationContext</code></p><ul><li><p>基于类路径下读取xml配置文件加载bean</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/Spring高级.assets/image-20231127210244668.png" alt="image-20231127210244668"></p></li></ul></li><li><p><code>FileSystemXmlApplicationContext</code></p><ul><li>基于文件路径读取xml</li></ul></li><li><p><strong>读取xml的原理</strong></p><ul><li><code>XmlBeanDefinitionReader</code>读取xml中的xml然后加入到<code>DefaultListableBeanFactory</code>中</li></ul></li><li><p><code>AnnotationApplicationContext</code></p><ul><li><p>基于注解,通过配置类加载bean</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/Spring高级.assets/image-20231127211045533.png" alt="image-20231127211045533"></p><ul><li>其中Config类需要<code>@Configuration</code>修饰</li></ul></li><li><p>这里加了<code>@Autowired</code> 和<code>@Resource</code>等后处理器</p></li></ul></li><li><p><code>AnnotationConfigServletWebServerApplicationContext</code></p><ul><li><p>用于web环境,基于java配置类加载bean</p></li><li><p>配置类中需要定义</p><ul><li><code>ServletWebServerFactory</code>:web服务器容器(tomcat)</li><li><code>DispatcherServlet</code>:前控制器,所有请求先经过它</li><li><code>DispatcherServletRegistrationBean</code>:将前控制器注册到服务器中</li><li>controller</li></ul><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/Spring高级.assets/image-20231127212543543.png" alt="image-20231127212543543"></p></li></ul></li></ul><h3 id="三-bean生命周期"><a href="#三-bean生命周期" class="headerlink" title="三 bean生命周期"></a>三 bean生命周期</h3><h4 id="3-1-生命周期"><a href="#3-1-生命周期" class="headerlink" title="3.1 生命周期"></a>3.1 生命周期</h4><ol><li><p>创建：根据 bean 的构造方法或者工厂方法来创建 bean 实例对象</p></li><li><p>依赖注入：根据 @Autowired，@Value 或其它一些手段，为 bean 的成员变量填充值、建立关系</p></li><li><p>初始化：回调各种 Aware 接口，调用对象的各种初始化方法</p></li><li><p>可用</p></li><li><p>销毁：在容器关闭时，会销毁所有单例对象（即调用它们的销毁方法）</p><ul><li>prototype 对象也能够销毁，不过需要容器这边主动调用</li></ul><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/Spring高级.assets/image-20231127212949420.png" alt="image-20231127212949420"></p></li></ol><h4 id="3-2-生命周期增强方法"><a href="#3-2-生命周期增强方法" class="headerlink" title="3.2 生命周期增强方法"></a>3.2 生命周期增强方法</h4><ul><li><p>创建前后的增强</p><ul><li><p><code>postProcessBeforeInstantiation</code></p><ul><li>这里返回的对象若不为 null 会替换掉原本的 bean，并且仅会走 postProcessAfterInitialization 流程</li></ul></li><li><p><code>postProcessAfterInstantiation</code></p><ul><li>这里如果返回 false 会跳过依赖注入阶段</li></ul></li></ul></li><li><p>依赖注入前的增强</p><ul><li><code>postProcessProperties</code><ul><li>如 <code>@Autowired</code>、<code>@Value</code>、<code>@Resource</code> </li></ul></li></ul></li><li><p>初始化前后的增强</p><ul><li><code>postProcessBeforeInitialization</code><ul><li>这里返回的对象会替换掉原本的 bean</li><li>如 <code>@PostConstruct</code>、<code>@ConfigurationProperties</code></li></ul></li><li><code>postProcessAfterInitialization</code> <ul><li>这里返回的对象会替换掉原本的 bean</li><li>如代理增强</li></ul></li></ul></li><li><p>销毁之前的增强</p><ul><li><code>postProcessBeforeDestruction</code><ul><li>如 <code>@PreDestroy</code> </li></ul></li></ul></li></ul><h4 id="3-3-模板方法设计模式"><a href="#3-3-模板方法设计模式" class="headerlink" title="3.3 模板方法设计模式"></a>3.3 模板方法设计模式</h4><ul><li>后处理器原理</li></ul><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/Spring高级.assets/image-20231127213721710.png" alt="image-20231127213721710"></p><ul><li>通过实现<code>BeanPostProcessor</code>接口，可以实现在不改变<code>getBean</code>方法的前提下扩展功能 </li></ul><h3 id="四-Bean后处理器"><a href="#四-Bean后处理器" class="headerlink" title="四 Bean后处理器"></a>四 Bean后处理器</h3><ul><li><p>作用:为Bean生命周期各个阶段提供扩展</p></li><li><p><code>GenericApplicationContext</code>:一个比较干净的容器(没有定义后处理器)</p><ul><li><code>registerBean()</code>:注册bean,后处理器</li><li><code>refresh()</code>:初始化容器</li><li><code>close()</code>:销毁容器</li></ul></li><li><p>常见bean后处理器</p><ul><li><code>AutowiredAnnotationBeanPostProcessor</code><ul><li>解析<code>@Autowired</code> <code>@Value</code></li></ul></li></ul><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/Spring高级.assets/image-20231127215306236.png" alt="image-20231127215306236"></p><ul><li><code>CommonAnnotationBeanPostProcessor</code><ul><li>解析<code>@Resource</code> <code>@PostConstruct</code> <code>@PreDestroy</code></li></ul></li><li><code>ConfigurationPropertiesBindingPostProcessor.register()</code><ul><li>解析<code>@configurationProperties</code></li></ul></li></ul></li></ul><h3 id="五-BeanFactory后处理器"><a href="#五-BeanFactory后处理器" class="headerlink" title="五 BeanFactory后处理器"></a>五 BeanFactory后处理器</h3><h4 id="5-1-介绍"><a href="#5-1-介绍" class="headerlink" title="5.1 介绍"></a>5.1 介绍</h4><ul><li>作用:为BeanFactory提供扩展</li><li><p>常见BeanFactory后处理器</p><ul><li><code>ConfigurationClassPostProcessor</code><ul><li>解析<code>@ComponentScan</code> <code>@Bean</code> <code>@Import</code> <code>@ImportResource</code>…</li></ul></li><li><code>MapperScannerConfigurer</code><ul><li>扫描mapper接口</li><li>基本方式是创建MapperFactoryBean，然后通过Mapper接口类创建对应对象</li><li>在此基础上扫描包，读取Mapper接口，然后再创建</li></ul></li></ul></li><li><p>使用注册</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/Spring高级.assets/image-20231127220822227.png" alt="image-20231127220822227"></p></li></ul><h4 id="5-2-常见BeanFactory后处理器1"><a href="#5-2-常见BeanFactory后处理器1" class="headerlink" title="5.2 常见BeanFactory后处理器1"></a>5.2 常见BeanFactory后处理器1</h4><ul><li><p><code>ConfigurationClassPostProcessor</code>原理</p></li><li><p>以<code>@ComponentScan</code>为例</p><ul><li><p>判断当前类是否有<code>@ComponentScan</code></p></li><li><p>如果有则获取<code>@ComponentScan</code>扫描的包下的所有class文件是否加了<code>@Component</code>及其衍生注解</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/Spring高级.assets/image-20231127221432603.png" alt="image-20231127221432603"></p></li><li><p>如果加了<code>@Component</code>及其衍生注解，则获取到这个bean，起名字并加入到bean工厂 </p><ul><li><code>BeanDefinitionBuilder</code>(获取bean)</li></ul><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/Spring高级.assets/image-20231127221719123.png" alt="image-20231127221719123"></p></li></ul></li></ul><h4 id="5-3-常见BeanFactory后处理器2"><a href="#5-3-常见BeanFactory后处理器2" class="headerlink" title="5.3 常见BeanFactory后处理器2"></a>5.3 常见BeanFactory后处理器2</h4><ul><li><p><code>MapperScannerConfigurer</code></p></li><li><p>Mapper 接口被 Spring 管理的本质：实际是被作为 MapperFactoryBean 注册到容器中</p></li><li><p>原理</p><ul><li><p>扫描Mapper包</p></li><li><p>判断是不是Interface</p></li><li><p>根据接口创建MapperFactoryBean注入到bean工厂中</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/Spring高级.assets/image-20231127223637027.png" alt="image-20231127223637027"></p><ul><li><p>上面的bd2的作用是生成name，最终不会添加到容器</p><p>不然的话添加到容器的就是<code>MapperFactoryBean</code>了</p></li></ul></li></ul></li></ul><h3 id="六-Aware-接口"><a href="#六-Aware-接口" class="headerlink" title="六 Aware 接口"></a>六 Aware 接口</h3><h4 id="6-1-Aware-接口"><a href="#6-1-Aware-接口" class="headerlink" title="6.1 Aware 接口"></a>6.1 Aware 接口</h4><ul><li><p>用于注入一些与容器相关的信息</p><ul><li><p><code>BeanNameAware</code>注入bean的名字</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/Spring高级.assets/image-20231128201148264.png" alt="image-20231128201148264"></p></li><li><p><code>BeanFactoryAware</code>注入<code>BeanFactory</code> 容器</p></li><li><p><code>ApplicationContextAware</code> 注入 <code>ApplicationContext</code> 容器</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/Spring高级.assets/image-20231128201236286.png" alt="image-20231128201236286"></p></li><li><p><code>EmbeddedValueResolverAware</code> 注入 <code>$&#123;&#125;</code> 解析器</p></li></ul></li></ul><h4 id="6-2-InitializingBean-接口"><a href="#6-2-InitializingBean-接口" class="headerlink" title="6.2 InitializingBean 接口"></a>6.2 InitializingBean 接口</h4><ul><li><p>InitializingBean 接口提供了一种【内置】的初始化手段</p></li><li><p>对比</p><ul><li><p>内置的注入(ApplicationContextAware)和初始化(InitializingBean )不受扩展功能的影响，总会被执行</p></li><li><p>而扩展功能受某些情况影响可能会失效</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/Spring高级.assets/image-20231128202809671.png" alt="image-20231128202809671"></p></li><li><p>因此 Spring 框架内部的类常用内置注入和初始化</p></li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">sequenceDiagram </span><br><span class="line">participant ac as ApplicationContext</span><br><span class="line">participant bfpp as BeanFactoryPostProcessor</span><br><span class="line">participant bpp as BeanPostProcessor</span><br><span class="line">participant config as Java配置类</span><br><span class="line">ac -&gt;&gt; bfpp : 1. 执行 BeanFactoryPostProcessor(bean工厂后处理器)</span><br><span class="line">ac -&gt;&gt; bpp : 2. 注册 BeanPostProcessor(bean后处理器)</span><br><span class="line">ac -&gt;&gt; +config : 3. 创建和初始化</span><br><span class="line">bpp -&gt;&gt; config : 3.1 依赖注入扩展(如 @Value 和 @Autowired)</span><br><span class="line">bpp -&gt;&gt; config : 3.2 初始化扩展(如 @PostConstruct)</span><br><span class="line">ac -&gt;&gt; config : 3.3 执行 Aware 及 InitializingBean</span><br><span class="line">config --&gt;&gt; -ac : 3.4 创建成功</span><br></pre></td></tr></table></figure><h3 id="七-初始化与销毁"><a href="#七-初始化与销毁" class="headerlink" title="七 初始化与销毁"></a>七 初始化与销毁</h3><h4 id="7-1-初始化"><a href="#7-1-初始化" class="headerlink" title="7.1 初始化"></a>7.1 初始化</h4><ul><li><p>初始化手段</p><ul><li><p><code>@PostConstruct</code></p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/Spring高级.assets/image-20231128211206737.png" alt="image-20231128211206737"></p></li><li><p><code>@Bean(initMethod)</code> </p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/Spring高级.assets/image-20231128211002711.png" alt="image-20231128211002711"></p><ul><li>执行Bean1内定义的init3方法</li></ul></li><li><p>实现 <code>InitializingBean</code> 接口</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/Spring高级.assets/image-20231128211218810.png" alt="image-20231128211218810"></p></li></ul></li><li><p>三种初始化手段的执行顺序</p><ol><li><code>@PostConstruct</code> 标注的初始化方法</li><li><code>InitializingBean</code> 接口的初始化方法</li><li><code>@Bean(initMethod)</code> 指定的初始化方法</li></ol></li></ul><h4 id="7-2-销毁"><a href="#7-2-销毁" class="headerlink" title="7.2 销毁"></a>7.2 销毁</h4><ul><li>顺序为<ol><li><code>@PreDestroy</code> 标注的销毁方法</li><li><code>DisposableBean</code> 接口的销毁方法</li><li><code>@Bean(destroyMethod)</code> 指定的销毁方法</li></ol></li></ul><h3 id="八-Scope"><a href="#八-Scope" class="headerlink" title="八 Scope"></a>八 Scope</h3><h4 id="8-1-Scope类型"><a href="#8-1-Scope类型" class="headerlink" title="8.1 Scope类型"></a>8.1 Scope类型</h4><ul><li><code>singleton</code>，容器启动时创建（未设置延迟），容器关闭时销毁</li><li><code>prototype</code>，每次使用时创建，不会自动销毁，需要调用 DefaultListableBeanFactory.destroyBean(bean) 销毁</li><li><code>request</code>，每次请求用到此 bean 时创建，请求结束时销毁</li><li><code>session</code>，每个会话用到此 bean 时创建，会话结束时销毁</li><li><code>application</code>，web 容器用到此 bean 时创建，容器停止时销毁</li></ul><h4 id="8-2-在singleton中使用其他几种scope的Bean"><a href="#8-2-在singleton中使用其他几种scope的Bean" class="headerlink" title="8.2 在singleton中使用其他几种scope的Bean"></a>8.2 在singleton中使用其他几种scope的Bean</h4><ul><li><p>单例对象，依赖注入仅发生一次，后续用的始终是第一次依赖注入的对象</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/Spring高级.assets/image-20231128215002221.png" alt="image-20231128215002221"></p><ul><li>e是单例，其中有一个多例的bean f</li></ul></li><li><p>解决</p><ul><li><p><code>@Lazy</code>生成代理</p><ul><li><p>代理对象还是同一个，但是每次使用代理对象的任意方法时，由代理创建新的f对象</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/Spring高级.assets/image-20231128215138340.png" alt="image-20231128215138340"></p></li></ul></li><li><p><code>@Scope(proxyMode = ScopedProxyMode.TARGET_CLASS)</code></p></li><li><p><code>ObjectFactory</code></p></li><li><p><code>ApplicationContext.getBean</code></p></li></ul></li><li><p>解决的理念都是：推迟其他scope bean的获取</p></li></ul><h2 id="Ⅱ-AOP"><a href="#Ⅱ-AOP" class="headerlink" title="Ⅱ AOP"></a>Ⅱ AOP</h2><p>AOP 底层实现方式之一是代理，由代理结合通知和目标，提供增强功能</p><p>除此以外，aspectj 提供了两种另外的 AOP 底层实现：</p><ul><li><p>第一种是通过 ajc 编译器在<strong>编译</strong> class 类文件时，就把通知的增强功能，织入到目标类的字节码中</p></li><li><p>第二种是通过 agent 在<strong>加载</strong>目标类时，修改目标类的字节码，织入增强功能</p></li><li>作为对比，之前学习的代理是<strong>运行</strong>时生成新的字节码</li></ul><p>简单比较的话：</p><ul><li><code>aspectj</code> 在编译和加载时，修改目标字节码，性能较高，并没有用spring</li><li><code>aspectj</code> 因为不用代理，能突破一些技术上的限制，例如对构造、对静态方法、对 final 也能增强</li><li>但 <code>aspectj</code> 侵入性较强，且需要学习新的 <code>aspectj</code> 特有语法，因此没有广泛流行</li></ul><h3 id="一-ajc增强"><a href="#一-ajc增强" class="headerlink" title="一 ajc增强"></a>一 ajc增强</h3><ul><li>编译器也能修改 class 实现增强</li><li>编译器增强能突破代理仅能通过方法重写增强的限制：可以对构造方法、静态方法等实现增强</li></ul><h3 id="二-agent增强"><a href="#二-agent增强" class="headerlink" title="二 agent增强"></a>二 agent增强</h3><ul><li>类加载时可以通过 agent 修改 class 实现增强</li></ul><h3 id="三-proxy增强"><a href="#三-proxy增强" class="headerlink" title="三 proxy增强"></a>三 proxy增强</h3><h4 id="3-1-jdk-动态代理"><a href="#3-1-jdk-动态代理" class="headerlink" title="3.1  jdk 动态代理"></a>3.1  jdk 动态代理</h4><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/Spring高级.assets/image-20231128223224135.png" alt="image-20231128223224135"></p><ul><li>jdk 动态代理要求目标<strong>必须</strong>实现接口，生成的代理类实现相同接口，因此代理与目标之间是平级兄弟关系</li></ul><h4 id="3-2-cglib代理"><a href="#3-2-cglib代理" class="headerlink" title="3.2 cglib代理"></a>3.2 cglib代理</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CglibProxyDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Target</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">foo</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;target foo&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] param)</span> &#123;</span><br><span class="line">        <span class="comment">// 目标对象</span></span><br><span class="line">        <span class="type">Target</span> <span class="variable">target</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Target</span>();</span><br><span class="line">        <span class="comment">// 代理对象</span></span><br><span class="line">        <span class="type">Target</span> <span class="variable">proxy</span> <span class="operator">=</span> (Target) Enhancer.create(Target.class, </span><br><span class="line">                (MethodInterceptor) (p, method, args, methodProxy) -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;proxy before...&quot;</span>);</span><br><span class="line">            <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> method.invoke(target, args);<span class="comment">//用反射调用目标，性能稍弱</span></span><br><span class="line">            <span class="comment">//Object result = methodProxy.invoke(target, args); //避免反射的调用，需要目标</span></span><br><span class="line">            <span class="comment">//Object result = methodProxy.invokeSuper(target, args); //同上但是需要代理</span></span><br><span class="line">            <span class="comment">//spring用的第二种方法</span></span><br><span class="line">            System.out.println(<span class="string">&quot;proxy after...&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// 调用代理</span></span><br><span class="line">        proxy.foo();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>cglib 不要求目标实现接口，它生成的代理类是目标的子类，因此代理与目标之间是子父关系</li><li>父类以及父类的方法不能是final修饰的（本质是方法的重写）</li></ul><h3 id="四-jdk代理原理"><a href="#四-jdk代理原理" class="headerlink" title="四 jdk代理原理"></a>四 jdk代理原理</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">A12</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">interface</span> <span class="title class_">Foo</span> &#123;</span><br><span class="line">        <span class="keyword">void</span> <span class="title function_">foo</span><span class="params">()</span>;</span><br><span class="line">        <span class="type">int</span> <span class="title function_">bar</span><span class="params">()</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Target</span> <span class="keyword">implements</span> <span class="title class_">Foo</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">foo</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;target foo&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">bar</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;target bar&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">100</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] param)</span> &#123;</span><br><span class="line">        <span class="comment">// ⬇️1. 创建代理，这时传入 InvocationHandler</span></span><br><span class="line">        <span class="type">Foo</span> <span class="variable">proxy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">$Proxy0</span>(<span class="keyword">new</span> <span class="title class_">InvocationHandler</span>() &#123;    </span><br><span class="line">            <span class="comment">// ⬇️5. 进入 InvocationHandler</span></span><br><span class="line">            <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable&#123;</span><br><span class="line">                <span class="comment">// ⬇️6. 功能增强</span></span><br><span class="line">                System.out.println(<span class="string">&quot;before...&quot;</span>);</span><br><span class="line">                <span class="comment">// ⬇️7. 反射调用目标方法</span></span><br><span class="line">                <span class="keyword">return</span> method.invoke(<span class="keyword">new</span> <span class="title class_">Target</span>(), args);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// ⬇️2. 调用代理方法</span></span><br><span class="line">        proxy.foo();</span><br><span class="line">        proxy.bar();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>模拟代理实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.UndeclaredThrowableException;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ⬇️这就是 jdk 代理类的源码, 秘密都在里面</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">$Proxy0</span> <span class="keyword">extends</span> <span class="title class_">Proxy</span> <span class="keyword">implements</span> <span class="title class_">A12</span>.Foo &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> $Proxy0(InvocationHandler h) &#123;</span><br><span class="line">        <span class="built_in">super</span>(h);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ⬇️3. 进入代理方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">foo</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// ⬇️4. 回调 InvocationHandler</span></span><br><span class="line">            h.invoke(<span class="built_in">this</span>, foo, <span class="keyword">new</span> <span class="title class_">Object</span>[<span class="number">0</span>]);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException | Error e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UndeclaredThrowableException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">bar</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> h.invoke(<span class="built_in">this</span>, bar, <span class="keyword">new</span> <span class="title class_">Object</span>[<span class="number">0</span>]);</span><br><span class="line">            <span class="keyword">return</span> (<span class="type">int</span>) result;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException | Error e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UndeclaredThrowableException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> Method foo;</span><br><span class="line">    <span class="keyword">static</span> Method bar;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            foo = A12.Foo.class.getMethod(<span class="string">&quot;foo&quot;</span>);</span><br><span class="line">            bar = A12.Foo.class.getMethod(<span class="string">&quot;bar&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchMethodException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoSuchMethodError</span>(e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>优化：反射创建性能低<ul><li>前 16 次反射性能较低</li><li>第 17 次调用会生成代理类，优化为非反射调用</li><li>会用 arthas 的 jad 工具反编译第 17 次调用生成的代理类</li></ul></li></ul><h3 id="五-cglib代理原理"><a href="#五-cglib代理原理" class="headerlink" title="五 cglib代理原理"></a>五 cglib代理原理</h3><ul><li>和JDK动态代理原理差不多<ul><li>回调的接口换了一下，<code>InvocationHandler</code> 改成了 <code>MethodInterceptor</code></li><li>调用目标时有所改进，见下面代码片段<ol><li>method.invoke 是反射调用，必须调用到足够次数才会进行优化</li><li>methodProxy.invoke 是不反射调用，它会正常（间接）调用目标对象的方法（Spring 采用）</li><li>methodProxy.invokeSuper 也是不反射调用，它会正常（间接）调用代理对象的方法，可以省略目标对象</li></ol></li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">A14Application</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InvocationTargetException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">Target</span> <span class="variable">target</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Target</span>();</span><br><span class="line">        <span class="type">Proxy</span> <span class="variable">proxy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Proxy</span>();</span><br><span class="line">        </span><br><span class="line">        proxy.setCallbacks(<span class="keyword">new</span> <span class="title class_">Callback</span>[]&#123;(MethodInterceptor) (p, m, a, mp) -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;proxy before...&quot;</span> + mp.getSignature());</span><br><span class="line">            <span class="comment">// ⬇️调用目标方法(三种)</span></span><br><span class="line"><span class="comment">//            Object result = m.invoke(target, a);  // ⬅️反射调用(m是Method对象)</span></span><br><span class="line">            <span class="comment">//mp是MethodProxy对象</span></span><br><span class="line"><span class="comment">//            Object result = mp.invoke(target, a); // ⬅️非反射调用, 结合目标用</span></span><br><span class="line">            <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> mp.invokeSuper(p, a);   <span class="comment">// ⬅️非反射调用, 结合代理用</span></span><br><span class="line">            System.out.println(<span class="string">&quot;proxy after...&quot;</span> + mp.getSignature());</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;&#125;);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// ⬇️调用代理方法</span></span><br><span class="line">        proxy.save();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="六-cglib如何避免发射调用"><a href="#六-cglib如何避免发射调用" class="headerlink" title="六 cglib如何避免发射调用"></a>六 cglib如何避免发射调用</h3><h4 id="6-1-MethodProxy实现"><a href="#6-1-MethodProxy实现" class="headerlink" title="6.1 MethodProxy实现"></a>6.1 MethodProxy实现</h4><ul><li>当调用 <code>MethodProxy</code> 的 invoke 或 invokeSuper 方法时, 会动态生成两个类<ul><li><code>ProxyFastClass</code> 配合代理对象一起使用, 避免反射</li><li><code>TargetFastClass</code> 配合目标对象一起使用, 避免反射 (Spring 用的这种)</li></ul></li><li><code>TargetFastClass</code> 记录了 Target 中方法与编号的对应关系<ul><li>save(long) 编号 2</li><li>save(int) 编号 1 </li><li>save() 编号 0</li><li>首先根据方法名和参数个数、类型, 用 switch 和 if 找到这些方法编号</li><li>然后再根据编号去调用目标方法, 又用了一大堆 switch 和 if, 但避免了反射</li></ul></li><li><code>ProxyFastClass</code> 记录了 Proxy 中方法与编号的对应关系，不过 Proxy 额外提供了下面几个方法<ul><li>saveSuper(long) 编号 2，不增强，仅是调用 super.save(long)</li><li>saveSuper(int) 编号 1，不增强, 仅是调用 super.save(int)</li><li>saveSuper() 编号 0，不增强, 仅是调用 super.save()</li><li>查找方式与 TargetFastClass 类似</li></ul></li><li>为什么有这么麻烦的一套东西呢？<ul><li>避免反射, 提高性能, 代价是一个代理类配两个 FastClass 类, 代理类中还得增加仅调用 super 的一堆方法</li><li>用编号处理方法对应关系比较省内存, 另外, 最初获得方法顺序是不确定的, 这个过程没法固定死</li></ul></li></ul><h3 id="七-jdk和cglib的统一"><a href="#七-jdk和cglib的统一" class="headerlink" title="七 jdk和cglib的统一"></a>七 jdk和cglib的统一</h3><h4 id="7-1-Spring的代理选择规则"><a href="#7-1-Spring的代理选择规则" class="headerlink" title="7.1 Spring的代理选择规则"></a>7.1 Spring的代理选择规则</h4><ul><li><p>Spring 中对切点、通知、切面的抽象如下</p><ul><li>切点：接口 Pointcut，典型实现 <code>AspectJExpressionPointcut</code></li><li>通知：典型接口为 <code>MethodInterceptor</code> 代表环绕通知</li><li>切面：Advisor，包含一个 Advice 通知，<code>PointcutAdvisor</code> 包含一个 Advice 通知和一个 Pointcut</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">classDiagram</span><br><span class="line"></span><br><span class="line">class Advice</span><br><span class="line">class MethodInterceptor</span><br><span class="line">class Advisor</span><br><span class="line">class PointcutAdvisor</span><br><span class="line"></span><br><span class="line">Pointcut &lt;|-- AspectJExpressionPointcut</span><br><span class="line">Advice &lt;|-- MethodInterceptor</span><br><span class="line">Advisor &lt;|-- PointcutAdvisor</span><br><span class="line">PointcutAdvisor o-- &quot;一&quot; Pointcut</span><br><span class="line">PointcutAdvisor o-- &quot;一&quot; Advice</span><br><span class="line"></span><br><span class="line">&lt;&lt;interface&gt;&gt; Advice</span><br><span class="line">&lt;&lt;interface&gt;&gt; MethodInterceptor</span><br><span class="line">&lt;&lt;interface&gt;&gt; Pointcut</span><br><span class="line">&lt;&lt;interface&gt;&gt; Advisor</span><br><span class="line">&lt;&lt;interface&gt;&gt; PointcutAdvisor</span><br></pre></td></tr></table></figure><ul><li><p>代理相关类图</p><ul><li>AopProxyFactory 根据 proxyTargetClass 等设置选择 AopProxy 实现</li><li>AopProxy 通过 getProxy 创建代理对象</li><li>图中 Proxy 都实现了 Advised 接口，能够获得关联的切面集合与目标（其实是从 ProxyFactory 取得）</li><li>调用代理方法时，会借助 ProxyFactory 将通知统一转为环绕通知：MethodInterceptor</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">classDiagram</span><br><span class="line"></span><br><span class="line">Advised &lt;|-- ProxyFactory</span><br><span class="line">ProxyFactory o-- Target</span><br><span class="line">ProxyFactory o-- &quot;多&quot; Advisor</span><br><span class="line"></span><br><span class="line">ProxyFactory --&gt; AopProxyFactory : 使用</span><br><span class="line">AopProxyFactory --&gt; AopProxy</span><br><span class="line">Advised &lt;|-- 基于CGLIB的Proxy</span><br><span class="line">基于CGLIB的Proxy &lt;-- ObjenesisCglibAopProxy : 创建</span><br><span class="line">AopProxy &lt;|-- ObjenesisCglibAopProxy</span><br><span class="line">AopProxy &lt;|-- JdkDynamicAopProxy</span><br><span class="line">基于JDK的Proxy &lt;-- JdkDynamicAopProxy : 创建</span><br><span class="line">Advised &lt;|-- 基于JDK的Proxy</span><br><span class="line"></span><br><span class="line">class AopProxy &#123;</span><br><span class="line">   +getProxy() Object</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class ProxyFactory &#123;</span><br><span class="line">proxyTargetClass : boolean</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class ObjenesisCglibAopProxy &#123;</span><br><span class="line">advised : ProxyFactory</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class JdkDynamicAopProxy &#123;</span><br><span class="line">advised : ProxyFactory</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;&lt;interface&gt;&gt; Advised</span><br><span class="line">&lt;&lt;interface&gt;&gt; AopProxyFactory</span><br><span class="line">&lt;&lt;interface&gt;&gt; AopProxy</span><br></pre></td></tr></table></figure><ul><li><p>ProxyFactory 用来创建代理</p><ul><li><p>如果指定了接口，且 proxyTargetClass = false，使用 JdkDynamicAopProxy</p></li><li><p>如果没有指定接口，或者 proxyTargetClass = true，使用 ObjenesisCglibAopProxy</p><ul><li>例外：如果目标是接口类型或已经是 Jdk 代理，使用 JdkDynamicAopProxy                     </li></ul><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/Spring高级.assets/image-20231130221021934.png" alt="image-20231130221021934">                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             </p></li></ul></li></ul><h4 id="7-2-底层切点实现"><a href="#7-2-底层切点实现" class="headerlink" title="7.2 底层切点实现"></a>7.2 底层切点实现</h4><ul><li><p>切点的匹配</p><ul><li><p>常见 aspectj 切点用法</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/Spring高级.assets/image-20231203130810802.png" alt="image-20231203130810802"></p></li><li><p>aspectj 切点的局限性，实际的 <code>@Transactional</code> 切点实现</p><ul><li><p>不能处理加在类上的注解或者加在接口上的注解（加在类上表示类中所有方法都匹配，接口类似）</p></li><li><p>实际的实现（多加了一些判断）</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/Spring高级.assets/image-20231203131333433.png" alt="image-20231203131333433"></p></li></ul></li></ul></li></ul><h4 id="7-3-底层切面实现"><a href="#7-3-底层切面实现" class="headerlink" title="7.3 底层切面实现"></a>7.3 底层切面实现</h4><ul><li><p>高级的<code>@Aspect</code>切面</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/Spring高级.assets/image-20231203132443723.png" alt="image-20231203132443723"></p></li><li><p>低级的Advisor切面</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/Spring高级.assets/image-20231203132454991.png" alt="image-20231203132454991"></p></li><li><p>一些方法</p><ul><li><code>AnnotationAwareAspectJAutoProxyCreator</code> 的作用<ul><li>将高级 @Aspect 切面统一为低级 Advisor 切面</li><li>在合适的时机创建代理</li></ul></li><li><code>findEligibleAdvisors</code> 找到有【资格】的 Advisors<ul><li>有【资格】的 Advisor 一部分是低级的, 可以由自己编写, 如本例 A17 中的 advisor3</li><li>有【资格】的 Advisor 另一部分是高级的, 由解析 @Aspect 后获得</li></ul></li><li><code>wrapIfNecessary</code><ul><li>它内部调用 <code>findEligibleAdvisors</code>, 只要返回集合不空, 则表示需要创建代理</li><li>它的调用时机通常在原始对象初始化后执行, 但碰到循环依赖会提前至依赖注入之前执行</li></ul></li></ul></li><li><p>高级转换未低级切面的时机及代理生成时机</p><ul><li>代理的创建时机<ul><li>初始化之后 (无循环依赖时)</li><li>实例创建后, 依赖注入前 (有循环依赖时), 并暂存于二级缓存</li></ul></li><li>依赖注入与初始化不应该被增强, 仍应被施加于原始对象</li></ul></li><li><p>切面的控制顺序</p><ul><li><code>@Order</code></li></ul></li><li><p>高级切面解析为低级切面的过程</p><ul><li><p>拿到类中所有的方法</p></li><li><p>解析方法是否有注解（<code>@Before</code>，<code>@After</code>…）</p></li><li><p>拿到注解，并获取到切点表达式，然后创建切点对象</p></li><li><p>创建通知类，参数是方法、切点以及切面实例对象</p></li><li><p>创建切面<code>Advisor</code>并放到一个集合中</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/Spring高级.assets/image-20231203140403263.png" alt="image-20231203140403263"></p></li></ul></li></ul><h4 id="7-4-底层通知实现"><a href="#7-4-底层通知实现" class="headerlink" title="7.4 底层通知实现"></a>7.4 底层通知实现</h4><ul><li><p>静态通知</p><ul><li><p>通过 <code>proxyFactory</code> 的 <code>getInterceptorsAndDynamicInterceptionAdvice()</code> 将其他通知统一转换为 <code>MethodInterceptor</code> 环绕通知</p><ul><li><code>MethodBeforeAdviceAdapter</code> 将 <code>@Before</code> <code>AspectJMethodBeforeAdvice</code> 适配为 <code>MethodBeforeAdviceInterceptor</code></li><li><code>AfterReturningAdviceAdapter</code> 将 <code>@AfterReturning</code> <code>AspectJAfterReturningAdvice</code> 适配为 <code>AfterReturningAdviceInterceptor</code></li><li>这体现的是适配器设计模式</li></ul></li><li><p>所谓静态通知，体现在上面方法的 <code>Interceptors</code> 部分，这些通知调用时无需再次检查切点，直接调用即可</p></li><li><p>结合目标与环绕通知链，创建 <code>MethodInvocation</code> 对象，通过它完成整个调用（递归）</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/Spring高级.assets/image-20231203144733359.png" alt="image-20231203144733359"></p></li></ul></li><li><p>动态通知</p><ul><li><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/Spring高级.assets/image-20231203145127731.png" alt="image-20231203145127731"></li><li>动态通知：<ul><li>需要参数的绑定（性能稍微低一些，因为需要处理参数）</li><li>需要切点。静态执行时不需要切点</li></ul></li><li>过程<ul><li>通过 <code>proxyFactory</code> 的 <code>getInterceptorsAndDynamicInterceptionAdvice()</code> 将其他通知统一转换为 <code>MethodInterceptor</code> 环绕通知</li><li>所谓动态通知，体现在上面方法的 <code>DynamicInterceptionAdvice</code> 部分，这些通知调用时因为要为通知方法绑定参数，还需再次利用切点表达式</li><li>动态通知调用复杂程度高，性能较低</li></ul></li></ul></li></ul><h2 id="Ⅲ-Web-MVC"><a href="#Ⅲ-Web-MVC" class="headerlink" title="Ⅲ Web MVC"></a>Ⅲ Web MVC</h2><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/Spring高级.assets/image-20231207153421513.png" alt="image-20231207153421513"></p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/Spring高级.assets/image-20231207154139758.png" alt="image-20231207154139758"></p><h3 id="一-Controller解析请求"><a href="#一-Controller解析请求" class="headerlink" title="一 Controller解析请求"></a>一 Controller解析请求</h3><h4 id="1-1-DispatcherServlet-初始化"><a href="#1-1-DispatcherServlet-初始化" class="headerlink" title="1.1 DispatcherServlet 初始化"></a>1.1 DispatcherServlet 初始化</h4><ul><li><p>创建WebConfig配置类</p><ul><li>三个必须组件：web容器工厂、DispatcherServlet 、注册DispatcherServlet （Spring MVC入口）</li></ul><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/Spring高级.assets/image-20231203153928889.png" alt="image-20231203153928889"></p></li><li><p>创建<code>AnnotationConfigServletWebServerApplicationContext</code>，导入配置类</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/Spring高级.assets/image-20231203153855015.png" alt="image-20231203153855015"></p></li><li><p><code>DispatcherServlet</code>初始化时间</p><ul><li>默认在首次使用的时候才会初始化</li><li>也可以修改为tomcat初始化的时候就初始化</li></ul></li><li><p><code>DispatcherServlet</code>初始化过程</p><ul><li>在初始化时会从 Spring 容器中找一些 Web 需要的组件, 如 <code>HandlerMapping</code>、<code>HandlerAdapter</code> 等，并逐一调用它们的初始化</li></ul></li></ul><h4 id="1-2-RequestMappingHandlerMapping初始化"><a href="#1-2-RequestMappingHandlerMapping初始化" class="headerlink" title="1.2 RequestMappingHandlerMapping初始化"></a>1.2 RequestMappingHandlerMapping初始化</h4><ul><li><code>RequestMappingHandlerMapping</code> 初始化时，会收集所有 <code>@RequestMapping</code> 映射信息，封装为 Map，其中<ul><li>key 是 RequestMappingInfo 类型，包括请求路径、请求方法等信息</li><li>value 是 HandlerMethod 类型，包括控制器方法对象、控制器对象</li><li>有了这个 Map，就可以在请求到达时，快速完成映射，找到 HandlerMethod 并与匹配的拦截器一起返回给 DispatcherServlet</li></ul></li></ul><h4 id="1-3-RequestMappingHandlerAdapter初始化"><a href="#1-3-RequestMappingHandlerAdapter初始化" class="headerlink" title="1.3 RequestMappingHandlerAdapter初始化"></a>1.3 RequestMappingHandlerAdapter初始化</h4><ul><li><p><code>RequestMappingHandlerAdapter</code> 初始化时，会准备 <code>HandlerMethod</code> 调用时需要的各个组件，如：</p><ul><li>HandlerMethodArgumentResolver 解析控制器方法参数</li><li>HandlerMethodReturnValueHandler 处理控制器方法返回值<ul><li>一般是将返回值转为json发送到响应体中</li></ul></li></ul></li><li><p>自定义参数与自定义返回值处理器</p><ul><li><p>继承<code>HandlerMethodArgumentResolver</code>并重写相关方法</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/Spring高级.assets/image-20231206203820252.png" alt="image-20231206203820252"></p><ul><li><p>e要在配置类中在<code>RequestMappingHandlerAdapter</code>中添加这个处理器</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/Spring高级.assets/image-20231206203939295.png" alt="image-20231206203939295"></p></li></ul></li><li><p>继承<code>HandlerMethodReturnValueHandler</code>并重写相关方法</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/Spring高级.assets/image-20231206204616764.png" alt="image-20231206204616764"></p><ul><li>同样的也需要在配置类中的<code>RequestMappingHandlerAdapter</code>中添加这个处理器（略）</li></ul></li></ul></li></ul><h3 id="二-参数解析器"><a href="#二-参数解析器" class="headerlink" title="二 参数解析器"></a>二 参数解析器</h3><ul><li><p>常见参数解析器</p><ul><li><p><code>@RequesParam</code>、<code>@PathVariable</code>、<code>@RquestHeader</code>、<code>@CookieValue</code>、<code>@Value</code>、<code>@ModelAttribute</code>、<code>@RequestBody</code></p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/Spring高级.assets/image-20231206205750880.png" alt="image-20231206205750880"></p></li></ul></li><li><p>组合模式在Spring中的应用</p><ul><li><p>组合解析器</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/Spring高级.assets/image-20231206212857993.png" alt="image-20231206212857993"></p></li></ul></li><li><p>获取参数名</p><ul><li>如果编译时添加了 <code>-parameters</code> 可以生成参数表, 反射时就可以拿到参数名</li><li>如果编译时添加了 <code>-g</code> 可以生成调试信息, 但分为两种情况<ul><li>普通类, 会包含局部变量表, 用 asm 可以拿到参数名</li><li>接口, 不会包含局部变量表, 无法获得参数名<ul><li>这也是 MyBatis 在实现 Mapper 接口时为何要提供 @Param 注解来辅助获得参数名</li></ul></li></ul></li></ul></li></ul><h3 id="三-对象绑定和类型转换"><a href="#三-对象绑定和类型转换" class="headerlink" title="三 对象绑定和类型转换"></a>三 对象绑定和类型转换</h3><h4 id="3-1-底层第一套转换接口与实现"><a href="#3-1-底层第一套转换接口与实现" class="headerlink" title="3.1 底层第一套转换接口与实现"></a>3.1 底层第一套转换接口与实现</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">classDiagram</span><br><span class="line"></span><br><span class="line">Formatter --|&gt; Printer</span><br><span class="line">Formatter --|&gt; Parser</span><br><span class="line"></span><br><span class="line">class Converters &#123;</span><br><span class="line">   Set~GenericConverter~</span><br><span class="line">&#125;</span><br><span class="line">class Converter</span><br><span class="line"></span><br><span class="line">class ConversionService</span><br><span class="line">class FormattingConversionService</span><br><span class="line"></span><br><span class="line">ConversionService &lt;|-- FormattingConversionService</span><br><span class="line">FormattingConversionService o-- Converters</span><br><span class="line"></span><br><span class="line">Printer --&gt; Adapter1</span><br><span class="line">Adapter1 --&gt; Converters</span><br><span class="line">Parser --&gt; Adapter2</span><br><span class="line">Adapter2 --&gt; Converters</span><br><span class="line">Converter --&gt; Adapter3</span><br><span class="line">Adapter3 --&gt; Converters</span><br><span class="line"></span><br><span class="line">&lt;&lt;interface&gt;&gt; Formatter</span><br><span class="line">&lt;&lt;interface&gt;&gt; Printer</span><br><span class="line">&lt;&lt;interface&gt;&gt; Parser</span><br><span class="line">&lt;&lt;interface&gt;&gt; Converter</span><br><span class="line">&lt;&lt;interface&gt;&gt; ConversionService</span><br></pre></td></tr></table></figure><ul><li>Printer 把其它类型转为 String</li><li>Parser 把 String 转为其它类型</li><li>Formatter 综合 Printer 与 Parser 功能</li><li>Converter 把类型 S 转为类型 T</li><li>Printer、Parser、Converter 经过适配转换成 GenericConverter 放入 Converters 集合</li><li>FormattingConversionService 利用其它们实现转换</li></ul><h4 id="3-2-底层第二套转换接口"><a href="#3-2-底层第二套转换接口" class="headerlink" title="3.2 底层第二套转换接口"></a>3.2 底层第二套转换接口</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">classDiagram</span><br><span class="line"></span><br><span class="line">PropertyEditorRegistry o-- &quot;多&quot; PropertyEditor</span><br><span class="line"></span><br><span class="line">&lt;&lt;interface&gt;&gt; PropertyEditorRegistry</span><br><span class="line">&lt;&lt;interface&gt;&gt; PropertyEditor</span><br></pre></td></tr></table></figure><ul><li>PropertyEditor 把 String 与其它类型相互转换</li><li>PropertyEditorRegistry 可以注册多个 PropertyEditor 对象</li><li>与第一套接口直接可以通过 FormatterPropertyEditorAdapter 来进行适配</li></ul><h4 id="3-3-高层接口与实现"><a href="#3-3-高层接口与实现" class="headerlink" title="3.3 高层接口与实现"></a>3.3 高层接口与实现</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">classDiagram</span><br><span class="line">TypeConverter &lt;|-- SimpleTypeConverter</span><br><span class="line">TypeConverter &lt;|-- BeanWrapperImpl</span><br><span class="line">TypeConverter &lt;|-- DirectFieldAccessor</span><br><span class="line">TypeConverter &lt;|-- ServletRequestDataBinder</span><br><span class="line"></span><br><span class="line">SimpleTypeConverter --&gt; TypeConverterDelegate</span><br><span class="line">BeanWrapperImpl --&gt; TypeConverterDelegate</span><br><span class="line">DirectFieldAccessor --&gt; TypeConverterDelegate</span><br><span class="line">ServletRequestDataBinder --&gt; TypeConverterDelegate</span><br><span class="line"></span><br><span class="line">TypeConverterDelegate --&gt; ConversionService</span><br><span class="line">TypeConverterDelegate --&gt; PropertyEditorRegistry</span><br><span class="line"></span><br><span class="line">&lt;&lt;interface&gt;&gt; TypeConverter</span><br><span class="line">&lt;&lt;interface&gt;&gt; ConversionService</span><br><span class="line">&lt;&lt;interface&gt;&gt; PropertyEditorRegistry</span><br></pre></td></tr></table></figure><ul><li>它们都实现了 TypeConverter 这个高层转换接口，在转换时，会用到 TypeConverter Delegate 委派ConversionService 与 PropertyEditorRegistry 真正执行转换（Facade 门面模式）<ul><li>首先看是否有自定义转换器, @InitBinder 添加的即属于这种 (用了适配器模式把 Formatter 转为需要的 PropertyEditor)</li><li>再看有没有 ConversionService 转换</li><li>再利用默认的 PropertyEditor 转换</li><li>最后有一些特殊处理</li></ul></li><li>SimpleTypeConverter 仅做类型转换</li><li>BeanWrapperImpl 为 bean 的属性赋值，当需要时做类型转换，走 Property</li><li>DirectFieldAccessor 为 bean 的属性赋值，当需要时做类型转换，走 Field</li><li>ServletRequestDataBinder 为 bean 的属性执行绑定，当需要时做类型转换，根据 directFieldAccess 选择走 Property 还是 Field，具备校验与获取校验结果功能</li></ul><h4 id="3-4-示例"><a href="#3-4-示例" class="headerlink" title="3.4 示例"></a>3.4 示例</h4><ul><li><code>SimpleTypeConverter</code></li></ul><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/Spring高级.assets/image-20231206215723463.png" alt="image-20231206215723463"></p><ul><li><p><code>BeanWrapperImpl</code></p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/Spring高级.assets/image-20231206215907603.png" alt="image-20231206215907603"></p></li><li><p><code>DirectFieldAccessor</code></p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/Spring高级.assets/image-20231206215936147.png" alt="image-20231206215936147"></p></li><li><p><code>ServletRequesrDataBinder</code></p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/Spring高级.assets/image-20231206220014794.png" alt="image-20231206220014794"></p></li></ul><h4 id="3-5-绑定器工厂"><a href="#3-5-绑定器工厂" class="headerlink" title="3.5 绑定器工厂"></a>3.5 绑定器工厂</h4><ul><li><p>将创建DataBinder的过程放到工厂里面(没有功能)，通过一些方式可以自定义转换功能 <code>ServletRequestDataBinderFactory</code></p></li><li><p>扩展转换功能</p><ul><li><code>@initBinder</code></li><li><code>ConversionService</code></li><li>同时用了以上两者</li><li>默认使用<code>ConversionService</code></li></ul></li></ul><h4 id="3-6-如何获取泛型参数"><a href="#3-6-如何获取泛型参数" class="headerlink" title="3.6 如何获取泛型参数"></a>3.6 如何获取泛型参数</h4><ul><li>开发框架中用</li><li>java api获取泛型参数</li><li>Spring api获取</li></ul><h3 id="四-ControllerAdvice"><a href="#四-ControllerAdvice" class="headerlink" title="四 @ControllerAdvice"></a>四 <code>@ControllerAdvice</code></h3><ul><li><p>和AOP的代理没关系，只是借鉴了Advice这个名字</p></li><li><p><code>@ExceptionHandler</code>：处理异常的</p></li><li><p><code>@ModelAttribute</code>：补充模型数据</p></li><li><p><code>@InitBinder</code>：类型转换器</p></li></ul><h4 id="4-1-InitBinder"><a href="#4-1-InitBinder" class="headerlink" title="4.1 @InitBinder"></a>4.1 <code>@InitBinder</code></h4><ul><li><p>加在ControllerAdivce中的是全局的，加在Controller中的是局部的</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/Spring高级.assets/image-20231207144031836.png" alt="image-20231207144031836"></p></li><li><p>RequestMappingHandlerAdapter 初始化时会解析 @ControllerAdvice 中的 @InitBinder 方法</p></li><li>RequestMappingHandlerAdapter 会以类为单位，在该类首次使用时，解析此类的 @InitBinder 方法</li><li>以上两种 @InitBinder 的解析结果都会缓存来避免重复解析</li><li>控制器方法调用时，会综合利用本类的 @InitBinder 方法和 @ControllerAdvice 中的 @InitBinder 方法创建绑定工厂</li></ul><h4 id="4-2-ModelAttribute"><a href="#4-2-ModelAttribute" class="headerlink" title="4.2 @ModelAttribute"></a>4.2 <code>@ModelAttribute</code></h4><ul><li><p>加在参数上</p><ul><li><p>将模型数据加到modelandview中</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/Spring高级.assets/image-20231207151201385.png" alt="image-20231207151201385"></p></li><li><p>没有指定名字（图中 的“u”）则以类名首字母小写存</p></li></ul></li><li><p>加载类方法上</p><ul><li><p>将方法返回结果加到modelandview中</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/Spring高级.assets/image-20231207151326746.png" alt="image-20231207151326746"></p></li><li><p>没有指定名字则以方法返回值首字母小写存</p></li></ul></li></ul><h4 id="4-3-控制器方法执行流程"><a href="#4-3-控制器方法执行流程" class="headerlink" title="4.3 控制器方法执行流程"></a>4.3 控制器方法执行流程</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">classDiagram</span><br><span class="line">class ServletInvocableHandlerMethod &#123;</span><br><span class="line">+invokeAndHandle(ServletWebRequest,ModelAndViewContainer)</span><br><span class="line">&#125;</span><br><span class="line">HandlerMethod &lt;|-- ServletInvocableHandlerMethod</span><br><span class="line">HandlerMethod o-- bean</span><br><span class="line">HandlerMethod o-- method</span><br><span class="line">ServletInvocableHandlerMethod o-- WebDataBinderFactory</span><br><span class="line">ServletInvocableHandlerMethod o-- ParameterNameDiscoverer</span><br><span class="line">ServletInvocableHandlerMethod o-- HandlerMethodArgumentResolverComposite</span><br><span class="line">ServletInvocableHandlerMethod o-- HandlerMethodReturnValueHandlerComposite</span><br></pre></td></tr></table></figure><p>HandlerMethod 需要</p><ul><li>bean 即是哪个 Controller</li><li>method 即是 Controller 中的哪个方法</li></ul><p>ServletInvocableHandlerMethod 需要</p><ul><li>WebDataBinderFactory 负责对象绑定、类型转换</li><li>ParameterNameDiscoverer 负责参数名解析</li><li>HandlerMethodArgumentResolverComposite 负责解析参数</li><li>HandlerMethodReturnValueHandlerComposite 负责处理返回值</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">sequenceDiagram</span><br><span class="line">participant adapter as RequestMappingHandlerAdapter</span><br><span class="line">participant bf as WebDataBinderFactory</span><br><span class="line">participant mf as ModelFactory</span><br><span class="line">participant container as ModelAndViewContainer</span><br><span class="line">adapter -&gt;&gt; +bf: 准备 @InitBinder</span><br><span class="line">bf --&gt;&gt; -adapter: </span><br><span class="line">adapter -&gt;&gt; +mf: 准备 @ModelAttribute</span><br><span class="line">mf -&gt;&gt; +container: 添加Model数据</span><br><span class="line">container --&gt;&gt; -mf: </span><br><span class="line">mf --&gt;&gt; -adapter: </span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">sequenceDiagram</span><br><span class="line">participant adapter as RequestMappingHandlerAdapter</span><br><span class="line">participant ihm as ServletInvocableHandlerMethod</span><br><span class="line">participant ar as ArgumentResolvers</span><br><span class="line">participant rh as ReturnValueHandlers</span><br><span class="line">participant container as ModelAndViewContainer</span><br><span class="line"></span><br><span class="line">adapter -&gt;&gt; +ihm: invokeAndHandle</span><br><span class="line">ihm -&gt;&gt; +ar: 获取 args</span><br><span class="line">ar -&gt;&gt; ar: 有的解析器涉及 RequestBodyAdvice</span><br><span class="line">ar -&gt;&gt; container: 有的解析器涉及数据绑定生成模型数据</span><br><span class="line">container --&gt;&gt; ar: </span><br><span class="line">ar --&gt;&gt; -ihm: args</span><br><span class="line">ihm -&gt;&gt; ihm: method.invoke(bean,args) 得到 returnValue</span><br><span class="line">ihm -&gt;&gt; +rh: 处理 returnValue</span><br><span class="line">rh -&gt;&gt; rh: 有的处理器涉及 ResponseBodyAdvice</span><br><span class="line">rh -&gt;&gt; +container: 添加Model数据,处理视图名,是否渲染等</span><br><span class="line">container --&gt;&gt; -rh: </span><br><span class="line">rh --&gt;&gt; -ihm: </span><br><span class="line">ihm --&gt;&gt; -adapter: </span><br><span class="line">adapter -&gt;&gt; +container: 获取 ModelAndView</span><br><span class="line">container --&gt;&gt; -adapter: </span><br></pre></td></tr></table></figure><h3 id="五-返回值处理器"><a href="#五-返回值处理器" class="headerlink" title="五 返回值处理器"></a>五 返回值处理器</h3><ul><li>返回值类型<ul><li><code>ModelAndView</code></li><li><code>String</code></li><li><code>void</code></li><li><code>Object</code></li></ul></li><li>常见返回值处理器<ul><li>返回值类型为ModelAndView，分别获取其模型和视图名，放入 ModelAndViewContainer</li><li>返回值类型为 String 时，把它当做视图名，放入 ModelAndViewContainer</li><li>返回值添加了 @ModelAttribute 注解时，将返回值作为模型，放入 ModelAndViewContainer<ul><li>此时需找到默认视图名</li></ul></li><li>返回值省略 @ModelAttribute 注解且返回非简单类型时，将返回值作为模型，放入 ModelAndViewContainer<ul><li>此时需找到默认视图名</li></ul></li><li>返回值类型为 ResponseEntity 时<ul><li>此时走 MessageConverter，并设置 ModelAndViewContainer.requestHandled 为 true</li></ul></li><li>返回值类型为 HttpHeaders 时<ul><li>会设置 ModelAndViewContainer.requestHandled 为 true</li></ul></li><li>返回值添加了 @ResponseBody 注解时<ul><li>此时走 MessageConverter，并设置 ModelAndViewContainer.requestHandled 为 true</li></ul></li></ul></li></ul><h3 id="六-异常处理"><a href="#六-异常处理" class="headerlink" title="六 异常处理"></a>六 异常处理</h3><ul><li><code>ExceptionHandlerExceptionResolver</code><ul><li>它能够重用参数解析器、返回值处理器，实现组件重用</li><li>它能够支持嵌套异常</li></ul></li><li><code>@ExceptionHandler</code> 只能处理发生在 mvc 流程中的异常，例如控制器内、拦截器内</li></ul><h4 id="6-1-tomcat异常处理"><a href="#6-1-tomcat异常处理" class="headerlink" title="6.1 tomcat异常处理"></a>6.1 tomcat异常处理</h4><ul><li>比ExceptionHandler更高级，处理的异常等级更高，比如Filter的异常</li><li>在 Spring Boot 中，是这么实现的：<ol><li>因为内嵌了 Tomcat 容器，因此可以配置  Tomcat 的错误页面，Filter 与 错误页面之间是通过请求转发跳转的，可以在这里做手脚</li><li>先通过 ErrorPageRegistrarBeanPostProcessor 这个后处理器配置错误页面地址，默认为 <code>/error</code> 也可以通过 <code>$&#123;server.error.path&#125;</code> 进行配置</li><li>当 Filter 发生异常时，不会走 Spring 流程，但会走 Tomcat 的错误处理，于是就希望转发至 <code>/error</code> 这个地址<ul><li>当然，如果没有 @ExceptionHandler，那么最终也会走到 Tomcat 的错误处理</li></ul></li><li>Spring Boot 又提供了一个 BasicErrorController，它就是一个标准 @Controller，@RequestMapping 配置为 <code>/error</code>，所以处理异常的职责就又回到了 Spring</li><li>异常信息由于会被 Tomcat 放入 request 作用域，因此 BasicErrorController 里也能获取到</li><li>具体异常信息会由 DefaultErrorAttributes 封装好</li><li>BasicErrorController 通过 Accept 头判断需要生成哪种 MediaType 的响应<ul><li>如果要的不是 text/html，走 MessageConverter 流程</li><li>如果需要 text/html，走 mvc 流程，此时又分两种情况<ul><li>配置了 ErrorViewResolver，根据状态码去找 View</li><li>没配置或没找到，用 BeanNameViewResolver 根据一个固定为 error 的名字找到 View，即所谓的 WhitelabelErrorView</li></ul></li></ul></li></ol></li></ul><h3 id="七-其他的Handler"><a href="#七-其他的Handler" class="headerlink" title="七 其他的Handler"></a>七 其他的Handler</h3><ul><li><p><code>@BeanNameUrlHandlerMapping</code>:请求路径不找Controller方法而是对应的bean</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> BeanNameUrlHandlerMapping <span class="title function_">beanNameUrlHandlerMapping</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">BeanNameUrlHandlerMapping</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> SimpleControllerHandlerAdapter <span class="title function_">simpleControllerHandlerAdapter</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">SimpleControllerHandlerAdapter</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean(&quot;/c3&quot;)</span><span class="comment">// /c3的请求将访问这个bean作为控制器，bean需要实现Controller接口</span></span><br><span class="line"><span class="keyword">public</span> Controller <span class="title function_">controller3</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (request, response) -&gt; &#123;</span><br><span class="line">        response.getWriter().print(<span class="string">&quot;this is c3&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>BeanNameUrlHandlerMapping，以 / 开头的 bean 的名字会被当作映射路径</li><li>这些 bean 本身当作 handler，要求实现 Controller 接口</li><li>SimpleControllerHandlerAdapter，调用 handler</li><li>模拟实现这组映射器和适配器</li></ul></li><li><p>总结</p><ul><li><code>HandlerMapping</code> 负责建立请求与控制器之间的映射关系<ul><li>RequestMappingHandlerMapping (与 @RequestMapping 匹配)</li><li>WelcomePageHandlerMapping    (/)</li><li>BeanNameUrlHandlerMapping    (与 bean 的名字匹配 以 / 开头)</li><li>RouterFunctionMapping        (函数式 RequestPredicate, HandlerFunction)</li><li>SimpleUrlHandlerMapping      (静态资源 通配符 /<strong> /img/</strong>)</li><li>之间也会有顺序问题, boot 中默认顺序如上</li></ul></li><li><code>HandlerAdapter</code> 负责实现对各种各样的 handler 的适配调用<ul><li>RequestMappingHandlerAdapter 处理：@RequestMapping 方法<ul><li>参数解析器、返回值处理器体现了组合模式</li></ul></li><li>SimpleControllerHandlerAdapter 处理：Controller 接口</li><li>HandlerFunctionAdapter 处理：HandlerFunction 函数式接口</li><li>HttpRequestHandlerAdapter 处理：HttpRequestHandler 接口 (静态资源处理)</li><li>这也是典型适配器模式体现</li></ul></li></ul></li></ul><h3 id="八-MVC处理流程"><a href="#八-MVC处理流程" class="headerlink" title="八 MVC处理流程"></a>八 MVC处理流程</h3><ul><li>当浏览器发送一个请求 <code>http://localhost:8080/hello</code> 后，请求到达服务器，其处理流程是：</li><li><p>服务器提供了 DispatcherServlet，它使用的是标准 Servlet 技术</p><ul><li>路径：默认映射路径为 <code>/</code>，即会匹配到所有请求 URL，可作为请求的统一入口，也被称之为<strong>前控制器</strong><ul><li>jsp 不会匹配到 DispatcherServlet</li><li>其它有路径的 Servlet 匹配优先级也高于 DispatcherServlet</li></ul></li><li>创建：在 Boot 中，由 DispatcherServletAutoConfiguration 这个自动配置类提供 DispatcherServlet 的 bean</li><li>初始化：DispatcherServlet 初始化时会优先到容器里寻找各种组件，作为它的成员变量<ul><li><code>HandlerMapping</code>，初始化时记录映射关系</li><li><code>HandlerAdapter</code>，初始化时准备参数解析器、返回值处理器、消息转换器</li><li><code>HandlerExceptionResolver</code>，初始化时准备参数解析器、返回值处理器、消息转换器</li><li>ViewResolver</li></ul></li></ul></li><li><p>DispatcherServlet 会利用 RequestMappingHandlerMapping 查找控制器方法</p><ul><li><p>例如根据 /hello 路径找到 @RequestMapping(“/hello”) 对应的控制器方法</p></li><li><p>控制器方法会被封装为 HandlerMethod 对象，并结合匹配到的拦截器一起返回给 DispatcherServlet </p></li><li><p>HandlerMethod 和拦截器合在一起称为 HandlerExecutionChain（调用链）对象</p></li></ul></li><li><p>DispatcherServlet 接下来会：</p><ol><li>调用拦截器的 preHandle 方法</li><li>RequestMappingHandlerAdapter 调用 handle 方法，准备数据绑定工厂、模型工厂、ModelAndViewContainer、将 HandlerMethod 完善为 ServletInvocableHandlerMethod<ul><li>@ControllerAdvice 全局增强点1️⃣：补充模型数据</li><li>@ControllerAdvice 全局增强点2️⃣：补充自定义类型转换器</li><li>使用 HandlerMethodArgumentResolver 准备参数<ul><li>@ControllerAdvice 全局增强点3️⃣：RequestBody 增强</li></ul></li><li>调用 ServletInvocableHandlerMethod </li><li>使用 HandlerMethodReturnValueHandler 处理返回值<ul><li>@ControllerAdvice 全局增强点4️⃣：ResponseBody 增强</li></ul></li><li>根据 ModelAndViewContainer 获取 ModelAndView<ul><li>如果返回的 ModelAndView 为 null，不走第 4 步视图解析及渲染流程<ul><li>例如，有的返回值处理器调用了 HttpMessageConverter 来将结果转换为 JSON，这时 ModelAndView 就为 null</li></ul></li><li>如果返回的 ModelAndView 不为 null，会在第 4 步走视图解析及渲染流程</li></ul></li></ul></li><li>调用拦截器的 postHandle 方法</li><li>处理异常或视图渲染<ul><li>如果 1~3 出现异常，走 ExceptionHandlerExceptionResolver 处理异常流程<ul><li>@ControllerAdvice 全局增强点5️⃣：@ExceptionHandler 异常处理</li></ul></li><li>正常，走视图解析及渲染流程</li></ul></li><li>调用拦截器的 afterCompletion 方法</li></ol></li></ul><h2 id="Ⅳ-Spring-boot"><a href="#Ⅳ-Spring-boot" class="headerlink" title="Ⅳ Spring boot"></a>Ⅳ Spring boot</h2><h3 id="一-Boot启动过程"><a href="#一-Boot启动过程" class="headerlink" title="一 Boot启动过程"></a>一 Boot启动过程</h3><h4 id="1-1-构造分析"><a href="#1-1-构造分析" class="headerlink" title="1.1 构造分析"></a>1.1 构造分析</h4><ul><li><code>springApplication</code>构造<ol><li>记录 BeanDefinition 源</li><li>推断应用类型</li><li>记录 ApplicationContext 初始化器</li><li>记录监听器</li><li>推断主启动类</li></ol></li></ul><h4 id="1-2-run分析"><a href="#1-2-run分析" class="headerlink" title="1.2 run分析"></a>1.2 run分析</h4><ul><li><p>执行run方法</p><ol><li><p>得到 <code>SpringApplicationRunListeners</code>，名字取得不好，实际是事件发布器</p><ul><li>发布 application starting 事件1️⃣</li></ul></li><li>封装启动 args</li><li>准备 Environment 添加命令行参数（*）<ul><li>ApplicationEnvironment</li></ul></li><li><p>ConfigurationPropertySources 处理（*）</p><ul><li>发布 application environment 已准备事件2️⃣</li></ul></li><li>通过 EnvironmentPostProcessorApplicationListener 进行 env 后处理（*）<ul><li>application.properties，由 StandardConfigDataLocationResolver 解析</li><li>spring.application.json</li></ul></li><li>绑定 spring.main 到 SpringApplication 对象（*）</li><li>打印 banner（*）</li><li>创建容器</li><li><p>准备容器</p><ul><li>发布 application context 已初始化事件3️⃣</li></ul></li><li><p>加载 bean 定义</p><ul><li>发布 application prepared 事件4️⃣</li></ul></li><li><p>refresh 容器</p><ul><li>发布 application started 事件5️⃣</li></ul></li><li><p>执行 runner</p><ul><li><p>发布 application ready 事件6️⃣</p></li><li><p>这其中有异常，发布 application failed 事件7️⃣</p></li></ul></li></ol></li></ul><h3 id="二-tomcat内嵌容器"><a href="#二-tomcat内嵌容器" class="headerlink" title="二 tomcat内嵌容器"></a>二 tomcat内嵌容器</h3><ul><li><p>tomcat基本结构</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Server</span><br><span class="line">└───Service</span><br><span class="line">    ├───Connector (协议, 端口)</span><br><span class="line">    └───Engine</span><br><span class="line">        └───Host(虚拟主机 localhost)</span><br><span class="line">            ├───Context1(应用1, 可以设置虚拟路径, / 即 url 起始路径; 项目磁盘路径, 即 docBase)</span><br><span class="line">            │   │   index.html</span><br><span class="line">            │   └───WEB-INF</span><br><span class="line">            │       │   web.xml (servlet, filter, listener) 3.0</span><br><span class="line">            │       ├───classes (servlet, controller, service ...)</span><br><span class="line">            │       ├───jsp</span><br><span class="line">            │       └───lib (第三方 jar 包)</span><br><span class="line">            └───Context2 (应用2)</span><br><span class="line">                │   index.html</span><br><span class="line">                └───WEB-INF</span><br><span class="line">                        web.xml</span><br></pre></td></tr></table></figure></li><li><p>tomcat内嵌容器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> LifecycleException, IOException &#123;</span><br><span class="line">    <span class="comment">// 1.创建 Tomcat 对象</span></span><br><span class="line">    <span class="type">Tomcat</span> <span class="variable">tomcat</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Tomcat</span>();</span><br><span class="line">    tomcat.setBaseDir(<span class="string">&quot;tomcat&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.创建项目文件夹, 即 docBase 文件夹</span></span><br><span class="line">    <span class="type">File</span> <span class="variable">docBase</span> <span class="operator">=</span> Files.createTempDirectory(<span class="string">&quot;boot.&quot;</span>).toFile();</span><br><span class="line">    docBase.deleteOnExit();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3.创建 Tomcat 项目, 在 Tomcat 中称为 Context</span></span><br><span class="line">    <span class="type">Context</span> <span class="variable">context</span> <span class="operator">=</span> tomcat.addContext(<span class="string">&quot;&quot;</span>, docBase.getAbsolutePath());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4.编程添加 Servlet</span></span><br><span class="line">    context.addServletContainerInitializer(<span class="keyword">new</span> <span class="title class_">ServletContainerInitializer</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onStartup</span><span class="params">(Set&lt;Class&lt;?&gt;&gt; c, ServletContext ctx)</span> <span class="keyword">throws</span> ServletException &#123;</span><br><span class="line">            <span class="type">HelloServlet</span> <span class="variable">helloServlet</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HelloServlet</span>();<span class="comment">//这个是自定义的继承自HttpServlet的类</span></span><br><span class="line">            ctx.addServlet(<span class="string">&quot;aaa&quot;</span>, helloServlet).addMapping(<span class="string">&quot;/hello&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, Collections.emptySet());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5.启动 Tomcat</span></span><br><span class="line">    tomcat.start();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 6.创建连接器, 设置监听端口</span></span><br><span class="line">    <span class="type">Connector</span> <span class="variable">connector</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Connector</span>(<span class="keyword">new</span> <span class="title class_">Http11Nio2Protocol</span>());</span><br><span class="line">    connector.setPort(<span class="number">8080</span>);</span><br><span class="line">    tomcat.setConnector(connector);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>集成Spring容器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">WebApplicationContext</span> <span class="variable">springContext</span> <span class="operator">=</span> getApplicationContext();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4.编程添加 Servlet</span></span><br><span class="line">context.addServletContainerInitializer(<span class="keyword">new</span> <span class="title class_">ServletContainerInitializer</span>() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onStartup</span><span class="params">(Set&lt;Class&lt;?&gt;&gt; c, ServletContext ctx)</span> <span class="keyword">throws</span> ServletException &#123;</span><br><span class="line">        <span class="comment">// ⬇️通过 ServletRegistrationBean 添加 DispatcherServlet 等</span></span><br><span class="line">        <span class="keyword">for</span> (ServletRegistrationBean registrationBean : </span><br><span class="line">             springContext.getBeansOfType(ServletRegistrationBean.class).values()) &#123;</span><br><span class="line">            registrationBean.onStartup(ctx);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;, Collections.emptySet());</span><br></pre></td></tr></table></figure></li></ul><h3 id="三-自动配置"><a href="#三-自动配置" class="headerlink" title="三 自动配置"></a>三 自动配置</h3><ul><li>自动配置类<code>EnableAutoConfiguration</code>中提供了常用的一些bean</li><li>如果冲突了怎么办<ul><li>解析时机 @Import先解析，本项目中的bean后解析</li><li>默认会同名覆盖，springboot中默认不能覆盖，会报错</li></ul></li></ul><h4 id="3-0-原理"><a href="#3-0-原理" class="headerlink" title="3.0 原理"></a>3.0 原理</h4><p>假设已有第三方的两个自动配置类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span> <span class="comment">// ⬅️第三方的配置类</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">AutoConfiguration1</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Bean1 <span class="title function_">bean1</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Bean1</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span> <span class="comment">// ⬅️第三方的配置类</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">AutoConfiguration2</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Bean2 <span class="title function_">bean2</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Bean2</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>提供一个配置文件 META-INF/spring.factories，key 为导入器类名，值为多个自动配置类名，用逗号分隔</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">MyImportSelector</span>=<span class="string">/</span></span><br><span class="line"><span class="attr">AutoConfiguration1,/</span></span><br><span class="line"><span class="attr">AutoConfiguration2</span></span><br></pre></td></tr></table></figure><p>引入自动配置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span> <span class="comment">// ⬅️本项目的配置类</span></span><br><span class="line"><span class="meta">@Import(MyImportSelector.class)</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Config</span> &#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">MyImportSelector</span> <span class="keyword">implements</span> <span class="title class_">DeferredImportSelector</span> &#123;</span><br><span class="line">    <span class="comment">// ⬇️该方法从 META-INF/spring.factories 读取自动配置类名，返回的 String[] 即为要导入的配置类</span></span><br><span class="line">    <span class="keyword">public</span> String[] selectImports(AnnotationMetadata importingClassMetadata) &#123;</span><br><span class="line">        <span class="keyword">return</span> SpringFactoriesLoader</span><br><span class="line">            .loadFactoryNames(MyImportSelector.class, <span class="literal">null</span>).toArray(<span class="keyword">new</span> <span class="title class_">String</span>[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>自动配置类本质上就是一个配置类而已，只是用 META-INF/spring.factories 管理，与应用配置类解耦</li><li>@Enable 打头的注解本质是利用了 @Import</li><li>@Import 配合 DeferredImportSelector 即可实现导入，selectImports 方法的返回值即为要导入的配置类名</li><li>DeferredImportSelector 的导入会在最后执行，为的是让其它配置优先解析</li></ul><h4 id="3-1-AOP自动配置"><a href="#3-1-AOP自动配置" class="headerlink" title="3.1 AOP自动配置"></a>3.1 AOP自动配置</h4><ul><li>AOP 自动配置类为 <code>org.springframework.boot.autoconfigure.aop.AopAutoConfiguration</code></li><li>可以通过 <code>spring.aop.auto=false</code> 禁用 aop 自动配置</li><li>AOP 自动配置的本质是通过 <code>@EnableAspectJAutoProxy</code> 来开启了自动代理，如果在引导类上自己添加了 <code>@EnableAspectJAutoProxy</code> 那么以自己添加的为准</li><li><code>@EnableAspectJAutoProxy</code> 的本质是向容器中添加了 <code>AnnotationAwareAspectJAutoProxyCreator</code> 这个 bean 后处理器，它能够找到容器中所有切面，并为匹配切点的目标类创建代理，创建代理的工作一般是在 bean 的初始化阶段完成的</li></ul><h4 id="3-2-DataSource自动配置"><a href="#3-2-DataSource自动配置" class="headerlink" title="3.2 DataSource自动配置"></a>3.2 DataSource自动配置</h4><ul><li>对应的自动配置类为：<code>org.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfiguration</code></li><li>它内部采用了条件装配，通过检查容器的 bean，以及类路径下的 class，来决定该 @Bean 是否生效</li></ul><p>简单说明一下，Spring Boot 支持两大类数据源：</p><ul><li><p>EmbeddedDatabase - 内嵌数据库连接池</p></li><li><p>PooledDataSource - 非内嵌数据库连接池</p><ul><li><p>hikari 提供的 HikariDataSource</p></li><li><p>tomcat-jdbc 提供的 DataSource</p></li><li><p>dbcp2 提供的 BasicDataSource</p></li><li><p>oracle 提供的 PoolDataSourceImpl</p></li></ul></li></ul><p>如果知道数据源的实现类类型，即指定了 <code>spring.datasource.type</code>，理论上可以支持所有数据源，但这样做的一个最大问题是无法订制每种数据源的详细配置（如最大、最小连接数等）</p><h4 id="3-3-MyBatis自动配置"><a href="#3-3-MyBatis自动配置" class="headerlink" title="3.3 MyBatis自动配置"></a>3.3 MyBatis自动配置</h4><ul><li>MyBatis 自动配置类为 <code>org.mybatis.spring.boot.autoconfigure.MybatisAutoConfiguration</code></li><li>它主要配置了两个 bean<ul><li>SqlSessionFactory - MyBatis 核心对象，用来创建 SqlSession</li><li>SqlSessionTemplate - SqlSession 的实现，此实现会与当前线程绑定</li><li>用 ImportBeanDefinitionRegistrar 的方式扫描所有标注了 @Mapper 注解的接口</li><li>用 AutoConfigurationPackages 来确定扫描的包</li></ul></li><li>还有一个相关的 bean：MybatisProperties，它会读取配置文件中带 <code>mybatis.</code> 前缀的配置项进行定制配置</li></ul><p>@MapperScan 注解的作用与 MybatisAutoConfiguration 类似，会注册 MapperScannerConfigurer 有如下区别</p><ul><li>@MapperScan 扫描具体包（当然也可以配置关注哪个注解）</li><li>@MapperScan 如果不指定扫描具体包，则会把引导类范围内，所有接口当做 Mapper 接口</li><li>MybatisAutoConfiguration 关注的是所有标注 @Mapper 注解的接口，会忽略掉非 @Mapper 标注的接口</li></ul><h4 id="3-4-事务自动配置"><a href="#3-4-事务自动配置" class="headerlink" title="3.4 事务自动配置"></a>3.4 事务自动配置</h4><ul><li><p>事务自动配置类有两个：</p><ul><li><code>org.springframework.boot.autoconfigure.jdbc.DataSourceTransactionManagerAutoConfiguration</code></li><li><code>org.springframework.boot.autoconfigure.transaction.TransactionAutoConfiguration</code></li></ul></li><li><p>前者配置了 DataSourceTransactionManager 用来执行事务的提交、回滚操作</p></li><li>后者功能上对标 @EnableTransactionManagement，包含以下三个 bean<ul><li>BeanFactoryTransactionAttributeSourceAdvisor 事务切面类，包含通知和切点</li><li>TransactionInterceptor 事务通知类，由它在目标方法调用前后加入事务操作</li><li>AnnotationTransactionAttributeSource 会解析 @Transactional 及事务属性，也包含了切点功能</li></ul></li><li>如果自己配置了 DataSourceTransactionManager 或是在引导类加了 @EnableTransactionManagement，则以自己配置的为准</li></ul><h4 id="3-5-MVC自动配置"><a href="#3-5-MVC自动配置" class="headerlink" title="3.5 MVC自动配置"></a>3.5 MVC自动配置</h4><ul><li><code>ServletWebServerFactoryAutoConfiguration</code><ul><li>提供 ServletWebServerFactory</li></ul></li><li><code>DispatcherServletAutoConfiguration</code><ul><li>提供 DispatcherServlet</li><li>提供 DispatcherServletRegistrationBean</li></ul></li><li><code>WebMvcAutoConfiguration</code><ul><li>配置 DispatcherServlet 的各项组件，提供的 bean 见过的有<ul><li>多项 HandlerMapping</li><li>多项 HandlerAdapter</li><li>HandlerExceptionResolver</li></ul></li></ul></li><li><code>ErrorMvcAutoConfiguration</code><ul><li>供的 bean 有 BasicErrorController</li></ul></li></ul><h3 id="四-条件装配类"><a href="#四-条件装配类" class="headerlink" title="四 条件装配类"></a>四 条件装配类</h3><ul><li><p><code>@Conditional()</code>确定要不要判断</p></li><li><p>实现了<code>Condition</code>接口的类来做具体的判断</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">MyCondition1</span> <span class="keyword">implements</span> <span class="title class_">Condition</span> &#123; </span><br><span class="line">    <span class="comment">// ⬇️如果存在 Druid 依赖，条件成立</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">matches</span><span class="params">(ConditionContext context, AnnotatedTypeMetadata metadata)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ClassUtils.isPresent(<span class="string">&quot;com.alibaba.druid.pool.DruidDataSource&quot;</span>, <span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>具体使用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span> <span class="comment">// 第三方的配置类</span></span><br><span class="line"><span class="meta">@Conditional(MyCondition1.class)</span> <span class="comment">// ⬅️加入条件</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">AutoConfiguration1</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Bean1 <span class="title function_">bean1</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Bean1</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>本质：</p><ul><li>一种特殊的if-else</li></ul><h3 id="五-FactoryBean"><a href="#五-FactoryBean" class="headerlink" title="五 FactoryBean"></a>五 FactoryBean</h3></li></ul><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/Spring高级.assets/image-20231210123453030.png" alt="image-20231210123453030"></p><ul><li>它的作用是用制造创建过程较为复杂的产品, 如 SqlSessionFactory, 但 @Bean 已具备等价功能</li><li>使用上较为古怪, 一不留神就会用错<ol><li>被 FactoryBean 创建的产品<ul><li>会认为创建、依赖注入、Aware 接口回调、前初始化这些都是 FactoryBean 的职责, 这些流程都不会走</li><li>唯有后初始化的流程会走, 也就是产品可以被代理增强</li><li>单例的产品不会存储于 BeanFactory 的 singletonObjects 成员中, 而是另一个 factoryBeanObjectCache 成员中</li></ul></li><li>按名字去获取时, 拿到的是产品对象, 名字前面加 &amp; 获取的是工厂对象</li></ol></li></ul><h3 id="六-index"><a href="#六-index" class="headerlink" title="六 @index"></a>六 <code>@index</code></h3><ul><li>在编译时就根据 <code>@Indexed</code> 生成 META-INF/spring.components 文件<ul><li>@Component注解中就间接使用了@Index</li></ul></li><li>扫描时<ul><li>如果发现 META-INF/spring.components 存在, 以它为准加载 bean definition</li><li>否则, 会遍历包下所有 class 资源 (包括 jar 内的)</li></ul></li><li>解决的问题，在编译期就找到 @Component 组件，节省运行期间扫描 @Component 的时间</li></ul><h3 id="七-代理"><a href="#七-代理" class="headerlink" title="七 代理"></a>七 代理</h3><ul><li><p>spring 代理的设计特点</p><ul><li><p>依赖注入和初始化影响的是原始对象</p><ul><li>因此 cglib 不能用 MethodProxy.invokeSuper()</li></ul></li><li><p>代理与目标是两个对象，二者成员变量并不共用数据</p></li></ul></li><li><p>static 方法、final 方法、private 方法均无法增强</p><ul><li>进一步理解代理增强基于方法重写</li></ul></li></ul><h3 id="八-Value"><a href="#八-Value" class="headerlink" title="八 @Value"></a>八 <code>@Value</code></h3><ul><li><code>$&#123;&#125;</code></li><li><code>#&#123;&#125;</code></li><li>类型转换： <code>TypeConverter</code> </li></ul><h3 id="九-Autowired"><a href="#九-Autowired" class="headerlink" title="九 @Autowired"></a>九 <code>@Autowired</code></h3><ul><li><p><code>@Autowired</code> 本质上是根据成员变量或方法参数的类型进行装配</p></li><li><p><code>beanfactory.doResolveDependency()</code>要点</p><ul><li>结果包装为Optional<Bean2> ObjectProvider<ul><li>如果待装配类型是 Optional，需要根据 Optional 泛型找到 bean，再封装为 Optional 对象装配</li><li>如果待装配的类型是 ObjectFactory，需要根据 ObjectFactory 泛型创建 ObjectFactory 对象装配<ul><li>此方法可以延迟真实 bean 的获取</li></ul></li></ul></li><li><p>对@Lazy的处理</p><ul><li>如果待装配的成员变量或方法参数上用 @Lazy 标注，会创建代理对象装配<ul><li>此方法可以延迟真实 bean 的获取</li><li>被装配的代理不作为 bean</li></ul></li></ul></li><li><p>其他</p><ul><li>如果待装配类型是数组，需要获取数组元素类型，根据此类型找到多个 bean 进行装配</li><li>如果待装配类型是 Collection 或其子接口，需要获取 Collection 泛型，根据此类型找到多个 bean</li><li>如果待装配类型是 ApplicationContext 等特殊类型<ul><li>会在 BeanFactory 的 resolvableDependencies 成员按类型查找装配</li><li>resolvableDependencies 是 map 集合，key 是特殊类型，value 是其对应对象</li><li>不能直接根据 key 进行查找，而是用 isAssignableFrom 逐一尝试右边类型是否可以被赋值给左边的 key 类型</li></ul></li><li>如果待装配类型有泛型参数<ul><li>需要利用 ContextAnnotationAutowireCandidateResolver 按泛型参数类型筛选</li></ul></li><li>如果待装配类型有 @Qualifier<ul><li>需要利用 ContextAnnotationAutowireCandidateResolver 按注解提供的 bean 名称筛选</li></ul></li></ul></li></ul></li></ul><h3 id="十-事件监听器"><a href="#十-事件监听器" class="headerlink" title="十 事件监听器"></a>十 事件监听器</h3><h4 id="10-1-ApplicationListener"><a href="#10-1-ApplicationListener" class="headerlink" title="10.1 ApplicationListener"></a>10.1 ApplicationListener</h4><ul><li>实现 ApplicationListener 接口<ul><li>根据接口泛型确定事件类型</li></ul></li></ul><h4 id="10-2-EventListener"><a href="#10-2-EventListener" class="headerlink" title="10.2 @EventListener"></a>10.2 @EventListener</h4><ul><li>根据监听器方法参数确定事件类型</li><li>解析时机：在 SmartInitializingSingleton（所有单例初始化完成后），解析每个单例 bean</li></ul><h4 id="10-3-事件发布器"><a href="#10-3-事件发布器" class="headerlink" title="10.3 事件发布器"></a>10.3 事件发布器</h4><ul><li><code>addApplicationListenerBean</code> 负责收集容器中的监听器<ul><li>监听器会统一转换为 GenericApplicationListener 对象，以支持判断事件类型</li></ul></li><li><code>multicastEvent</code> 遍历监听器集合，发布事件<ul><li>发布前先通过 GenericApplicationListener.supportsEventType 判断支持该事件类型才发事件</li><li>可以利用线程池进行异步发事件优化</li></ul></li><li>如果发送的事件对象不是 ApplicationEvent 类型，Spring 会把它包装为 PayloadApplicationEvent 并用泛型技术解析事件对象的原始类型<ul><li>视频中未讲解</li></ul></li></ul><link rel="stylesheet" href="https://cdn1.tianli0.top/gh/zhheo/Post-Abstract-AI@0.15.2/tianli_gpt.css"><script>let tianliGPT_postSelector = '#post #article-container';let tianliGPT_key = 'c9b7741d290063ab872e';</script><script src="https://cdn1.tianli0.top/gh/zhheo/Post-Abstract-AI@0.15.2/tianli_gpt.js"></script>]]></content>
      
      
      <categories>
          
          <category> study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java高级 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot</title>
      <link href="/posts/33757.html"/>
      <url>/posts/33757.html</url>
      
        <content type="html"><![CDATA[<h1 id="SpringBoot"><a href="#SpringBoot" class="headerlink" title="SpringBoot"></a>SpringBoot</h1><p><a href="https://www.bilibili.com/video/BV15b4y1a7yG/?spm_id_from=333.788.video.desc.click&amp;vd_source=1a39594354c31d775ddc587407a55282">https://www.bilibili.com/video/BV15b4y1a7yG/?spm_id_from=333.788.video.desc.click&amp;vd_source=1a39594354c31d775ddc587407a55282</a></p><h2 id="基础篇"><a href="#基础篇" class="headerlink" title="基础篇"></a>基础篇</h2><h3 id="一-demo"><a href="#一-demo" class="headerlink" title="一 demo"></a>一 demo</h3><ul><li><p>SpringBoot是由Pivotal团队提供的全新框架，其设计目的是用来简化Spring应用的初始搭建以及开发过程</p></li><li><p>创建项目的时候<code>start.spring.io</code> 改为 <code>start.aliyun.com</code></p></li></ul><h4 id="1-1-创建"><a href="#1-1-创建" class="headerlink" title="1.1 创建"></a>1.1 创建</h4><ul><li>四种创建方式<ul><li>基于idea创建springboot</li><li>基于官网创建springboot</li><li>基于阿里云创建springboot</li><li>手工创建Maven工程修改为springboot</li></ul></li></ul><h4 id="1-2-四个要点"><a href="#1-2-四个要点" class="headerlink" title="1.2 四个要点"></a>1.2 四个要点</h4><ul><li><p>parent</p><ul><li><p>定义一系列常用坐标版本</p></li><li><p>定义一系列常用坐标组合</p></li><li><p>直接组合使用</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/SpringBoot.assets/image-20231024220613754.png" alt="image-20231024220613754"></p><ul><li><code>spring-boot-starter-parent</code>又继承了<code>spring-boot-dependencies</code>，其中包含了很多依赖的版本，就不需要用户自定定义版本，方便管理</li><li>如果是阿里云的话就直接使用<code>spring-boot-dependencies</code>了</li></ul></li></ul></li><li><p>starter</p><ul><li>springboot中常见的项目名称，定义了当前项目使用的所有依赖坐标，以达到减少依赖配置的目的</li><li>这也是spring方便的原因之一</li><li>实际开发的时候<ul><li>仅书写GAV中的GA，V由SpringBoot提供</li><li>如果发生坐标错误，再指定version（小心版本冲突）</li></ul></li></ul></li><li><p>引导类</p><ul><li>启动方式</li><li>springboot的引导类是boot工程的执行入口，运行main方法就可以启动项目</li><li>springboot工程运行后初始化spring容器，扫描引导类所在包加载bean</li></ul></li><li><p>内嵌tomcat</p><ul><li><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/SpringBoot.assets/image-20231024222152879.png" alt="image-20231024222152879"></li><li><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/SpringBoot.assets/image-20231024222215333.png" alt="image-20231024222215333"></li><li><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/SpringBoot.assets/image-20231024222240728.png" alt="image-20231024222240728"></p></li><li><p>实际上是将服务器作为了一个bean管理加入到容器中</p></li><li>内置服务器<ul><li>tomcat，默认</li><li>jetty，更轻量级，负载性能远不及tomcat</li><li>undertow，负载性能勉强跑赢tomcat    </li></ul></li></ul></li></ul><h4 id="1-3-REST风格"><a href="#1-3-REST风格" class="headerlink" title="1.3 REST风格"></a>1.3 REST风格</h4><ul><li>REST(Representational State Transfer),表现形式状态转换</li><li>优点<ul><li>隐藏了资源访问的行为,无法通过地址得知对资源是何操作</li><li>书写简化</li></ul></li><li>根据rest风格对资源进行访问称为<strong>RESTful</strong></li><li><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/SpringBoot.assets/image-20231024223143713.png" alt="image-20231024223143713"></li></ul><h3 id="二-基础配置"><a href="#二-基础配置" class="headerlink" title="二 基础配置"></a>二 基础配置</h3><h4 id="2-1-快速复制项目"><a href="#2-1-快速复制项目" class="headerlink" title="2.1 快速复制项目"></a>2.1 快速复制项目</h4><ul><li>复制项目</li><li>修改pom中的<code>&lt;artifactId&gt;项目名&lt;/artifactId&gt;</code></li><li>删除pom中的<code>&lt;name&gt;</code>和<code>&lt;description&gt;</code>标签(否则idea右侧的maven中显示的是name而不是项目名)</li><li>在idea中导入复制的项目</li></ul><h4 id="2-2-属性配置"><a href="#2-2-属性配置" class="headerlink" title="2.2 属性配置"></a>2.2 属性配置</h4><ul><li><p>属性修改</p><ul><li><p>修改端口</p><ul><li>```yaml<br>server.port=80<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 关闭运行日志图标(banner)</span><br><span class="line"></span><br><span class="line">  - ```yaml</span><br><span class="line">    spring.main.banner-mode=off</span><br></pre></td></tr></table></figure></li></ul></li><li><p>设置日志相关</p><ul><li>```yaml<br>logging.level.root=debug<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- springboot内置属性查询</span><br><span class="line">  - https://docs.spring.io/spring-boot/docs/current/reference/html/application-properties.html#application-properties </span><br><span class="line"></span><br><span class="line">- 属性配置方式</span><br><span class="line">  - `application.properties`</span><br><span class="line">  - `application.yml`:主流</span><br><span class="line">  - `application.yaml`</span><br><span class="line">  - 加载顺序: `.properties` &gt; `.yml` &gt; `.yaml`</span><br><span class="line">- `yaml`语法</span><br><span class="line">  - 大小写铭感</span><br><span class="line">  - 属性层级关系使用多行描述,每行结尾使用冒号结束</span><br><span class="line">  - 使用缩进表示层级关系,同层级左侧对齐,只允许使用空格,不允许Tab键</span><br><span class="line">  - 属性值前加空格(属性名与属性值之间使用冒号+空格作为分隔)</span><br><span class="line">  - `#`号表示注释</span><br><span class="line">  - 如果出现转移字符,需要使用双引号包裹</span><br><span class="line">- `yaml`数据读取</span><br><span class="line">  - 使用`@Value`读取单个数据,属性名引用方式:`$&#123;一级属性名.二级属性名...&#125;`</span><br><span class="line">  - 数据全部封装到对象</span><br><span class="line">    - ![image-20231024230015217](https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/SpringBoot.assets/image-20231024230015217.png)</span><br><span class="line">  - 自定义对象封装指定数据</span><br><span class="line">    - ![image-20231024230036635](https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/SpringBoot.assets/image-20231024230036635.png)</span><br><span class="line"></span><br><span class="line">### 三 整合第三方技术</span><br><span class="line"></span><br><span class="line">#### 3.1 整合JUnit</span><br><span class="line"></span><br><span class="line">- `@SpringBootTest`</span><br><span class="line">  - 类型:测试类注解</span><br><span class="line">  - 位置:测试类定义上方</span><br><span class="line">  - 作用:设置JUnit加载的SpringBoot启动类</span><br><span class="line">  - 属性:</span><br><span class="line">    - `classes`:设置springboot启动类</span><br><span class="line">    - 如果测试类在springboot启动类的包或子包中,可以省略启动类的设置,也就是省略classes的设定</span><br><span class="line"></span><br><span class="line">#### 3.2 整合MyBatis</span><br><span class="line"></span><br><span class="line">- 内容</span><br><span class="line"></span><br><span class="line">  - 核心配置:数据库连接相关信息(连什么,连谁,什么权限)</span><br><span class="line">  - 映射配置:SQL映射(XML/注解)</span><br><span class="line"></span><br><span class="line">- 步骤</span><br><span class="line"></span><br><span class="line">  - 创建项目时候选择技术集(MyBatis MySQL Driver)</span><br><span class="line"></span><br><span class="line">  - 设置数据源参数(yaml)</span><br><span class="line"></span><br><span class="line">    ![image-20231024231609608](https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/SpringBoot.assets/image-20231024231609608.png)</span><br><span class="line"></span><br><span class="line">  - 定义数据层接口与映射配置</span><br><span class="line"></span><br><span class="line">    ![image-20231024231639358](https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/SpringBoot.assets/image-20231024231639358.png)</span><br><span class="line"></span><br><span class="line">  - 测试类中注入dao接口,测试功能</span><br><span class="line"></span><br><span class="line">    ![image-20231024231709273](https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/SpringBoot.assets/image-20231024231709273.png)</span><br><span class="line"></span><br><span class="line">  - 注:当springboot版本低于2.4.3,mysql驱动版本大于8.0时,需要在url连接中配置时区</span><br><span class="line"></span><br><span class="line">    ![image-20231024231923170](https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/SpringBoot.assets/image-20231024231923170.png)</span><br><span class="line"></span><br><span class="line">    或在mysql数据库端配置时区解决此问题</span><br><span class="line"></span><br><span class="line">#### 3.3 整合MyBatis-Plus</span><br><span class="line"></span><br><span class="line">- 与MyBatis区别</span><br><span class="line"></span><br><span class="line">  - 导入坐标不同</span><br><span class="line">  - 数据层实现简化</span><br><span class="line"></span><br><span class="line">- 步骤</span><br><span class="line"></span><br><span class="line">  - 引入坐标</span><br><span class="line"></span><br><span class="line">    ![image-20231024232049634](https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/SpringBoot.assets/image-20231024232049634.png)</span><br><span class="line"></span><br><span class="line">    - 需要指定版本</span><br><span class="line"></span><br><span class="line">  - 定义数据层接口与映射配置,继承BaseMapper</span><br><span class="line"></span><br><span class="line">    ![image-20231024232138954](https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/SpringBoot.assets/image-20231024232138954.png)</span><br><span class="line"></span><br><span class="line">  - 测试(略)</span><br><span class="line"></span><br><span class="line">#### 3.4 整合Druid</span><br><span class="line"></span><br><span class="line">- 步骤</span><br><span class="line"></span><br><span class="line">  - 指定数据源类型</span><br><span class="line"></span><br><span class="line">    ![image-20231024232354780](https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/SpringBoot.assets/image-20231024232354780.png)</span><br><span class="line"></span><br><span class="line">  - 导入Druid对应的starter</span><br><span class="line"></span><br><span class="line">    ![image-20231024232421913](https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/SpringBoot.assets/image-20231024232421913.png)</span><br><span class="line"></span><br><span class="line">  - 变更Druid的配置方式</span><br><span class="line"></span><br><span class="line">    ![image-20231024232500990](https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/SpringBoot.assets/image-20231024232500990.png)</span><br><span class="line"></span><br><span class="line">#### 3.5 整合任意第三方技术</span><br><span class="line"></span><br><span class="line">- 导入对应的starter</span><br><span class="line">- 配置对应的设置或采用默认配置</span><br><span class="line"></span><br><span class="line">### 四 SSMP整合案例</span><br><span class="line"></span><br><span class="line">#### 4.1 简介</span><br><span class="line"></span><br><span class="line">- 方案分析</span><br><span class="line">  - 实体类:使用Lombok快速制作实体类</span><br><span class="line">  - Dao:整合MyBatisPlus,制作数据层测试类</span><br><span class="line">  - Service:基于MP进行增量开发,制作业务层测试类</span><br><span class="line">  - Controller:基于Restful开发,使用PostMan测试接口功能</span><br><span class="line">  - 页面:基于Vue+ElementUI制作,前后端联调,页面数据处理,页面消息处理</span><br><span class="line">    - 列表,增,删,改,分页,查</span><br><span class="line">  - 项目异常处理</span><br><span class="line">  - 按条件查询-----页面功能调整 Controller修正功能 Servcice修正功能</span><br><span class="line"></span><br><span class="line">#### 4.2 创建工程</span><br><span class="line"></span><br><span class="line">- 创建springboot工程，导入web，sql drive</span><br><span class="line"></span><br><span class="line">- 在pom中添加mp和druid依赖</span><br><span class="line"></span><br><span class="line">  ![image-20231025193114316](https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/SpringBoot.assets/image-20231025193114316.png)</span><br><span class="line"></span><br><span class="line">- 创建application.yml，并设置端口为80 </span><br><span class="line"></span><br><span class="line">  ![image-20231025193445560](https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/SpringBoot.assets/image-20231025193445560.png)</span><br><span class="line"></span><br><span class="line">#### 4.3 设计数据库表</span><br><span class="line"></span><br><span class="line">- ![image-20231025194604827](https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/SpringBoot.assets/image-20231025194604827.png)</span><br><span class="line"></span><br><span class="line">#### 4.4 开发实体类</span><br><span class="line"></span><br><span class="line">- lombok，导入依赖</span><br><span class="line">- 给类名上方 `@Data`</span><br><span class="line">- 如果需要构造方法还需要自己定义</span><br><span class="line"></span><br><span class="line">#### 4.5 数据层开发</span><br><span class="line"></span><br><span class="line">- MyBatisPlus</span><br><span class="line"></span><br><span class="line">- 数据源：Druid</span><br><span class="line"></span><br><span class="line">- pom导入对应的starter </span><br><span class="line"></span><br><span class="line">- 配置</span><br><span class="line"></span><br><span class="line">  ![image-20231025200237326](https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/SpringBoot.assets/image-20231025200237326.png)</span><br><span class="line"></span><br><span class="line">- 创建数据层接口继承 `BaseMapper&lt;Book&gt;`</span><br><span class="line"></span><br><span class="line">- 开启MP运行日志</span><br><span class="line"></span><br><span class="line">  ![image-20231025200930683](https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/SpringBoot.assets/image-20231025200930683.png)</span><br><span class="line"></span><br><span class="line">- 分页</span><br><span class="line"></span><br><span class="line">  - 需要定义一个拦截器配置类</span><br><span class="line"></span><br><span class="line">    ![image-20231025201825122](https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/SpringBoot.assets/image-20231025201825122.png)</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">  - `IPage`对象封装了当前查询到的数据</span><br><span class="line">    - 数据</span><br><span class="line">    - 当前页码</span><br><span class="line">    - 每页数据总量</span><br><span class="line">    - 最大页码值</span><br><span class="line">    - 数据总量</span><br><span class="line">  - 分页操作是在MP的常规操作基础上增强得到，内部是动态的拼写SQL语句，因此需要增强对应的功能，使用MP拦截器实现</span><br><span class="line"></span><br><span class="line">- 条件查询</span><br><span class="line"></span><br><span class="line">  - 使用`QueryWrapper`对象封装查询条件，推荐使用`LambdaQueryWrapper`对象，所有查询操作封装成方法调用</span><br><span class="line"></span><br><span class="line">    ![image-20231025203223584](https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/SpringBoot.assets/image-20231025203223584.png)</span><br><span class="line"></span><br><span class="line">#### 4.6 业务层开发</span><br><span class="line"></span><br><span class="line">- Service层接口定义与数据层接口定义具有较大区别，不要混用</span><br><span class="line"></span><br><span class="line">  - `selectByUserNameAndPassword(String username,String password);`数据层偏向数据</span><br><span class="line">  - `login(String username,String password);`业务层偏向业务名称</span><br><span class="line"></span><br><span class="line">- 定义接口</span><br><span class="line"></span><br><span class="line">- 实现接口</span><br><span class="line"></span><br><span class="line">- 测试实现类方法</span><br><span class="line"></span><br><span class="line">- 快速开发</span><br><span class="line"></span><br><span class="line">  - 继承`IService&lt;T&gt;`与业务层通用实现类`ServiceImpl&lt;M,T&gt;`</span><br><span class="line"></span><br><span class="line">    ![image-20231025205328655](https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/SpringBoot.assets/image-20231025205328655.png)</span><br><span class="line"></span><br><span class="line">    ![image-20231025205314691](https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/SpringBoot.assets/image-20231025205314691.png)</span><br><span class="line"></span><br><span class="line">#### 4.7 表现层开发</span><br><span class="line"></span><br><span class="line">- 基于Restful进行表现层接口开发</span><br><span class="line"></span><br><span class="line">  - 新增：POST</span><br><span class="line">  - 删除：DELETE</span><br><span class="line">  - 修改：PUT</span><br><span class="line">  - 查询：GET</span><br><span class="line"></span><br><span class="line">- 接收参数</span><br><span class="line"></span><br><span class="line">  - 实体数据 `@RequestBody`</span><br><span class="line"></span><br><span class="line">    ![image-20231025210832541](https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/SpringBoot.assets/image-20231025210832541.png)</span><br><span class="line"></span><br><span class="line">  - 路径变量 `@PathVariable`</span><br><span class="line"></span><br><span class="line">    ![image-20231025210846852](https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/SpringBoot.assets/image-20231025210846852.png)</span><br><span class="line"></span><br><span class="line">- 使用Postman测试表现层接口功能</span><br><span class="line"></span><br><span class="line">- 表现层数据一致性处理</span><br><span class="line"></span><br><span class="line">  - 设计表现层返回结果的模型类，用于后端与前端进行数据格式统一，也称为前后端数据协议</span><br><span class="line"></span><br><span class="line">    ```java</span><br><span class="line">    @Data</span><br><span class="line">    public class R&#123;</span><br><span class="line">        private Boolean flag;</span><br><span class="line">        private Object data;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>表现层接口统一返回值类型结果</p></li></ul></li></ul><h4 id="4-8-前后端协议联调"><a href="#4-8-前后端协议联调" class="headerlink" title="4.8 前后端协议联调"></a>4.8 前后端协议联调</h4><ul><li><p>前后端分离结构设计中页面归属前端服务器</p></li><li><p>单体工程中页面放置在resources目录下的static目录中（建议执行clean）</p></li><li><p>前端发送异步请求，调用后端接口</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">getAll</span>(<span class="params"></span>) &#123;</span><br><span class="line">    axios.<span class="title function_">get</span>(<span class="string">&quot;/books&quot;</span>).<span class="title function_">then</span>(<span class="function">(<span class="params">res</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(res.<span class="property">data</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><ul><li>这里的res.data是后端发过来的所有数据，如果要得到刚刚定义的data与flag<ul><li><code>res.data.data</code></li><li><code>res.data.flag</code></li></ul></li></ul></li></ul><h4 id="4-9-异常消息处理"><a href="#4-9-异常消息处理" class="headerlink" title="4.9 异常消息处理"></a>4.9 异常消息处理</h4><ul><li><p>定义异常处理类</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/SpringBoot.assets/image-20231025220101533.png" alt="image-20231025220101533"></p></li><li><p>在前端中显示data.msg</p></li></ul><h4 id="4-10-分页"><a href="#4-10-分页" class="headerlink" title="4.10 分页"></a>4.10 分页</h4><h2 id="运维实用篇"><a href="#运维实用篇" class="headerlink" title="运维实用篇"></a>运维实用篇</h2><h3 id="一-打包与运行"><a href="#一-打包与运行" class="headerlink" title="一 打包与运行"></a>一 打包与运行</h3><h4 id="1-1-基本流程"><a href="#1-1-基本流程" class="headerlink" title="1.1 基本流程"></a>1.1 基本流程</h4><ul><li><p>对SpringBoot项目打包（执行Maven构建指令package）</p><ul><li><code>mvn package</code></li></ul></li><li><p>运行项目</p><ul><li><p><code>java –jar springboot.jar</code></p></li><li><p>注意：jar支持命令行启动需要依赖maven插件支持，请确认打包时是否具有SpringBoot对应的maven插件</p></li><li><p>```xml<br><build></p><pre><code>&lt;plugins&gt;    &lt;plugin&gt;        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;        &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;    &lt;/plugin&gt;&lt;/plugins&gt;</code></pre><p>&lt;/build&gt;</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 注意跳过test的过程</span><br><span class="line"></span><br><span class="line">#### 1.2 jar包描述文件</span><br><span class="line"></span><br><span class="line">- MANIFEST.M</span><br><span class="line"></span><br><span class="line">- 普通工程</span><br><span class="line"></span><br><span class="line">  - ```</span><br><span class="line">    Manifest-Version: 1.0</span><br><span class="line">    Implementation-Title: springboot_08_ssmp</span><br><span class="line">    Implementation-Version: 0.0.1-SNAPSHOT</span><br><span class="line">    Build-Jdk-Spec: 1.8</span><br><span class="line">    Created-By: Maven Jar Plugin 3.2.0</span><br></pre></td></tr></table></figure></li></ul></li><li><p>基于spring-boot-maven-plugin打包的工程</p><ul><li>```<br>Manifest-Version: 1.0<br>Spring-Boot-Classpath-Index: BOOT-INF/classpath.idx<br>Implementation-Title: springboot_08_ssmp<br>Implementation-Version: 0.0.1-SNAPSHOT<br>Spring-Boot-Layers-Index: BOOT-INF/layers.idx<br>Start-Class: com.itheima.SSMPApplication<br>Spring-Boot-Classes: BOOT-INF/classes/<br>Spring-Boot-Lib: BOOT-INF/lib/<br>Build-Jdk-Spec: 1.8<br>Spring-Boot-Version: 2.5.4<br>Created-By: Maven Jar Plugin 3.2.0<br>Main-Class: org.springframework.boot.loader.JarLauncher<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#### 1.3 命令行启动常见问题</span><br><span class="line"></span><br><span class="line">- Windows端口被占用</span><br><span class="line"></span><br><span class="line">  - ```</span><br><span class="line">    # 查询端口</span><br><span class="line">    netstat -ano</span><br><span class="line">    # 查询指定端口</span><br><span class="line">    netstat -ano |findstr &quot;端口号&quot;</span><br><span class="line">    # 根据进程PID查询进程名称</span><br><span class="line">    tasklist |findstr &quot;进程PID号&quot;</span><br><span class="line">    # 根据PID杀死任务</span><br><span class="line">    taskkill /F /PID &quot;进程PID号&quot;</span><br><span class="line">    # 根据进程名称杀死任务</span><br><span class="line">    taskkill -f -t -im &quot;进程名称</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="二-配置高级"><a href="#二-配置高级" class="headerlink" title="二 配置高级"></a>二 配置高级</h3><h4 id="2-1-临时属性设置"><a href="#2-1-临时属性设置" class="headerlink" title="2.1 临时属性设置"></a>2.1 临时属性设置</h4><ul><li><p>带属性数启动SpringBoot</p><ul><li><p>```cmd<br>java –jar springboot.jar –-server.port=80</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  -  携带多个属性启动，属性间适用空格分隔</span><br><span class="line"></span><br><span class="line">  - 属性加载优先顺序</span><br><span class="line"></span><br><span class="line">    - 看https://docs.spring.io/spring-boot/docs/current/reference/html/spring-boot-features.html#boot-features-external-config</span><br><span class="line"></span><br><span class="line">  - 临时属性必须是当前boot工程支持的属性，否则设置无效</span><br><span class="line"></span><br><span class="line">- 开发环境下的临时属性设置</span><br><span class="line"></span><br><span class="line">  - 带属性启动SpringBoot程序，为程序添加运行属性</span><br><span class="line"></span><br><span class="line">    ![image-20231108215208331](https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/SpringBoot.assets/image-20231108215208331.png)</span><br><span class="line"></span><br><span class="line">  - 通过编程形式带参数启动SpringBoot程序，为程序添加运行参数</span><br><span class="line"></span><br><span class="line">    ```java</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        String[] arg = new String[1];</span><br><span class="line">        arg[0] = &quot;--server.port=8080&quot;;</span><br><span class="line">        SpringApplication.run(SSMPApplication.class, arg);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//不携带参数启动SpringBoot程序</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">SpringApplication.run(SSMPApplication.class);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h4 id="2-2-配置文件分类"><a href="#2-2-配置文件分类" class="headerlink" title="2.2 配置文件分类"></a>2.2 配置文件分类</h4><ul><li><p>问题</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/SpringBoot.assets/image-20231108215639337.png" alt="image-20231108215639337"></p></li><li><p>SpringBoot中4级配置文件</p><ul><li>1级： file ：config/application.yml 最高</li><li>2级： file ：application.yml</li><li>3级：classpath：config/application.yml</li><li>4级：classpath：application.yml</li></ul></li><li><p>作用</p><ul><li><p>1级与2级留做系统打包后设置通用属性，1级常用于运维经理进行线上整体项目部署方案调控</p></li><li><p>3级与4级用于系统开发阶段设置通用属性，3级常用于项目经理进行整体项目属性调控</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/SpringBoot.assets/image-20231108220144271.png" alt="image-20231108220144271"></p></li></ul></li></ul><h4 id="2-3-自定义配置文件"><a href="#2-3-自定义配置文件" class="headerlink" title="2.3 自定义配置文件"></a>2.3 自定义配置文件</h4><ul><li><p>通过启动参数加载指定文件路径下的配置文件</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/SpringBoot.assets/image-20231108220508301.png" alt="image-20231108220508301"></p></li><li><p>通过启动参数加载指定文件路径下的配置文件时可以加载多个配置</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/SpringBoot.assets/image-20231108220524671.png" alt="image-20231108220524671"></p></li><li><p>单服务器项目：使用自定义配置文件需求较低</p></li><li><p>多服务器项目：使用自定义配置文件需求较高，将所有配置放置在一个目录中，统一管理</p></li><li><p>基于SpringCloud技术，所有的服务器将不再设置配置文件，而是通过配置中心进行设定，动态加载配置信息</p></li></ul><h3 id="三-多环境开发"><a href="#三-多环境开发" class="headerlink" title="三 多环境开发"></a>三 多环境开发</h3><h4 id="3-1-多环境开发（YAML）"><a href="#3-1-多环境开发（YAML）" class="headerlink" title="3.1 多环境开发（YAML）"></a>3.1 多环境开发（YAML）</h4><ul><li><p>生产环境、开发环境、测试环境</p></li><li><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/SpringBoot.assets/image-20231108221130227.png" alt="image-20231108221130227"></p></li><li><p>多配置文件</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/SpringBoot.assets/image-20231108221413507.png" alt="image-20231108221413507"></p><ul><li>主配置文件中设置公共配置（全局）</li><li>环境分类配置文件中常用于设置冲突属性（局部）</li></ul></li><li><p>书写技巧</p><ul><li><p>根据功能对配置文件中的信息进行拆分，并制作成独立的配置文件，命名规则如下】</p><ul><li>application-devDB.yml</li><li>application-devRedis.yml</li><li>application-devMVC.yml</li></ul></li><li><p>使用include属性在激活指定环境的情况下，同时对多个环境进行加载使其生效，多个环境间使用逗号分隔</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/SpringBoot.assets/image-20231108221634078.png" alt="image-20231108221634078"></p></li><li><p>从Spring2.4版开始使用group属性替代include属性，降低了配置书写量</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/SpringBoot.assets/image-20231108221716660.png" alt="image-20231108221716660"></p></li></ul></li></ul><h4 id="3-2-多环境开发（Properties）"><a href="#3-2-多环境开发（Properties）" class="headerlink" title="3.2 多环境开发（Properties）"></a>3.2 多环境开发（Properties）</h4><ul><li><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/SpringBoot.assets/image-20231108221500030.png" alt="image-20231108221500030"></li></ul><h4 id="3-3-多环境开发控制"><a href="#3-3-多环境开发控制" class="headerlink" title="3.3 多环境开发控制"></a>3.3 多环境开发控制</h4><h3 id="四-日志"><a href="#四-日志" class="headerlink" title="四 日志"></a>四 日志</h3><h4 id="4-1-日志基础"><a href="#4-1-日志基础" class="headerlink" title="4.1 日志基础"></a>4.1 日志基础</h4><ul><li><p>作用</p><ul><li>编程期调试代码</li><li>运营期记录信息</li></ul></li><li><p>添加日志记录操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/books&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookController</span> <span class="keyword">extends</span> <span class="title class_">BaseController</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">log</span> <span class="operator">=</span> LoggerFactory.getLogger(BookController.class);</span><br><span class="line">    <span class="meta">@GetMapping</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getById</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;springboot is running...&quot;</span>);</span><br><span class="line">        log.debug(<span class="string">&quot;debug ...&quot;</span>);</span><br><span class="line">        log.info(<span class="string">&quot;info ...&quot;</span>);</span><br><span class="line">        log.warn(<span class="string">&quot;warn ...&quot;</span>);</span><br><span class="line">        log.error(<span class="string">&quot;error ...&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;springboot is running...&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>日志级别</p><ul><li>TRACE：运行堆栈信息，使用率低</li><li>DEBUG：程序员调试代码使用</li><li>INFO：记录运维过程数据</li><li>WARN：记录运维过程报警数据</li><li>ERROR：记录错误堆栈信息</li><li>FATAL：灾难信息，合并计入ERROR</li></ul></li><li><p>设置日志输出级别</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 开启debug模式，输出调试信息，常用于检查系统运行状况</span></span><br><span class="line"><span class="attr">debug:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置日志级别，root表示根节点，即整体应用日志级别</span></span><br><span class="line"><span class="attr">logging:</span></span><br><span class="line">  <span class="attr">level:</span></span><br><span class="line">    <span class="attr">root:</span> <span class="string">debug</span></span><br></pre></td></tr></table></figure></li><li><p>设置日志组，控制指定包对应的日志输出级别，也可以直接控制指定包对应的日志输出级别</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">logging:</span></span><br><span class="line">  <span class="comment"># 设置日志组</span></span><br><span class="line">  <span class="attr">group:</span></span><br><span class="line">    <span class="comment"># 自定义组名，设置当前组中所包含的包</span></span><br><span class="line">    <span class="attr">ebank:</span> <span class="string">com.itheima.controller</span></span><br><span class="line">  <span class="attr">level:</span></span><br><span class="line">    <span class="attr">root:</span> <span class="string">warn</span></span><br><span class="line">    <span class="comment"># 为对应组设置日志级别</span></span><br><span class="line">    <span class="attr">ebank:</span> <span class="string">debug</span></span><br><span class="line">    <span class="comment"># 为对包设置日志级别</span></span><br><span class="line">    <span class="attr">com.itheima.controller:</span> <span class="string">debug</span></span><br></pre></td></tr></table></figure></li><li><p>优化日志对象创建代码 </p><p>`private static final Logger log = LoggerFactory.getLogger(BookController.class);</p><pre><code>`</code></pre><p>使用lombok提供的注解<code>@Slf4j</code>简化开发</p></li></ul><h4 id="4-2-日志输出格式控制"><a href="#4-2-日志输出格式控制" class="headerlink" title="4.2 日志输出格式控制"></a>4.2 日志输出格式控制</h4><ul><li><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/SpringBoot.assets/image-20231108223409178.png" alt="image-20231108223409178"></p></li><li><p>PID：进程ID，用于表明当前操作所处的进程，当多服务同时记录日志时，该值可用于协助程序员调试程序</p></li><li><p>所属类/接口名：当前显示信息为SpringBoot重写后的信息，名称过长时，简化包名书写为首字母，甚至直接删除</p></li><li><p>设置日志输出格式</p><ul><li>```yml<br>logging:<br>  pattern:<pre><code>console: &quot;%d - %m%n&quot;</code></pre><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- `%d`:日期     `%m`：消息    `%n`:换行</span><br><span class="line"></span><br><span class="line">- ```yml</span><br><span class="line">  logging:</span><br><span class="line">    pattern:</span><br><span class="line">      console: &quot;%d %clr(%p) --- [%16t] %clr(%-40.40c)&#123;cyan&#125; : %m %n&quot;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h4 id="4-3-日志文件"><a href="#4-3-日志文件" class="headerlink" title="4.3 日志文件"></a>4.3 日志文件</h4><ul><li><p>设置日志文件</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">logging:</span></span><br><span class="line">  <span class="attr">file:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">server.log</span></span><br></pre></td></tr></table></figure></li><li><p>日志文件详细配置</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">logging:</span></span><br><span class="line">  <span class="attr">file:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">server.log</span></span><br><span class="line">  <span class="attr">logback:</span></span><br><span class="line">    <span class="attr">rollingpolicy:</span></span><br><span class="line">      <span class="attr">max-file-size:</span> <span class="string">3KB</span></span><br><span class="line">      <span class="attr">file-name-pattern:</span> <span class="string">server.%d&#123;yyyy-MM-dd&#125;.%i.log</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="开发实用篇"><a href="#开发实用篇" class="headerlink" title="开发实用篇"></a>开发实用篇</h2><h3 id="一-热部署"><a href="#一-热部署" class="headerlink" title="一 热部署"></a>一 热部署</h3><h4 id="1-1-手动启动热部署"><a href="#1-1-手动启动热部署" class="headerlink" title="1.1 手动启动热部署"></a>1.1 手动启动热部署</h4><ul><li><p>开发者工具</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-devtools<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>激活热部署</p><ul><li><code>ctrl + F9</code></li><li>每次修改后执行一次</li></ul></li><li><p>关于热部署</p><ul><li>重启（Restart）：自定义开发代码，包含类、页面、配置文件等，加载位置restart类加载器</li><li>重载（ReLoad）：jar包，加载位置base类加载器</li></ul></li><li><p>热部署仅仅加载当前开发者自定义开发的资源，不加载jar资源</p></li></ul><h4 id="1-2-自动启动热部署"><a href="#1-2-自动启动热部署" class="headerlink" title="1.2 自动启动热部署"></a>1.2 自动启动热部署</h4><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/SpringBoot.assets/image-20231109201931762.png" alt="image-20231109201931762"></p><p><code>ctrl + shift + alt</code></p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/SpringBoot.assets/image-20231109201948367.png" alt="image-20231109201948367"></p><p>激活方式：idea失去焦点5秒后启动热部署</p><h4 id="1-3-热部署范围配置"><a href="#1-3-热部署范围配置" class="headerlink" title="1.3 热部署范围配置"></a>1.3 热部署范围配置</h4><ul><li><p>默认不触发重启的目录列表</p><ul><li><code>/META-INF/maven</code></li><li><code>/META-INF/resources</code></li><li><code>/resources</code></li><li><code>/static</code></li><li><code>/public</code></li><li><code>/templates</code></li></ul></li><li><p>自定</p><ul><li>```yml<br>devtools:<br>  restart:<pre><code>exclude: public/**,static/**</code></pre><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#### 1.4 关闭热部署</span><br><span class="line"></span><br><span class="line">- 设置高优先级属性禁用热部署</span><br><span class="line"></span><br><span class="line">  - ```java</span><br><span class="line">    public static void main(String[] args) &#123; </span><br><span class="line">        System.setProperty(&quot;spring.devtools.restart.enabled&quot;, &quot;false&quot;);</span><br><span class="line">        SpringApplication.run(SSMPApplication.class);                                 </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="二-配置高级-1"><a href="#二-配置高级-1" class="headerlink" title="二 配置高级"></a>二 配置高级</h3><h4 id="2-1-ConfigurationProperties"><a href="#2-1-ConfigurationProperties" class="headerlink" title="2.1 @ConfigurationProperties"></a>2.1 <code>@ConfigurationProperties</code></h4><ul><li><p>使用<code>@ConfigurationProperties</code>为第三方bean绑定属性</p><ul><li>```java<br>@Bean<br>@ConfigurationProperties(prefix = “datasource”)<br>public DruidDataSource dataSource(){<pre><code>DruidDataSource ds = new DruidDataSource();return ds;</code></pre>}<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- ```yml</span><br><span class="line">  datasource:</span><br><span class="line">    driverClassName: com.mysql.jdbc.Driver</span><br></pre></td></tr></table></figure></li></ul></li><li><p><code>@EnableConfigurationProperties</code>注解可以将使用<code>@ConfigurationProperties</code>注解对应的类加入Spring容器</p></li></ul><h4 id="2-2-宽松-松散绑定"><a href="#2-2-宽松-松散绑定" class="headerlink" title="2.2 宽松/松散绑定"></a>2.2 宽松/松散绑定</h4><ul><li><p><code>@ConfigurationProperties</code>绑定属性支持属性名宽松绑定</p><ul><li><pre><code class="lang-java">public class ServerConfig &#123;    private String ipAddress;    private int port;    private long timeout;&#125;</code></pre></li><li><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/SpringBoot.assets/image-20231109204215641.png" alt="image-20231109204215641"></p></li></ul></li><li><p>宽松绑定不支持注解<code>@Value</code>引用单个属性的方式</p></li></ul><h4 id="2-3-常用计量单位绑定"><a href="#2-3-常用计量单位绑定" class="headerlink" title="2.3 常用计量单位绑定"></a>2.3 常用计量单位绑定</h4><ul><li><p>SpringBoot支持JDK8提供的时间与空间计量单位</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/SpringBoot.assets/image-20231109204850384.png" alt="image-20231109204850384"></p></li></ul><h4 id="2-4-数据校验"><a href="#2-4-数据校验" class="headerlink" title="2.4 数据校验"></a>2.4 数据校验</h4><ul><li><p>开启数据校验有助于系统安全性，J2EE规范中JSR303规范定义了一组有关数据校验相关的API</p></li><li><p>开启Bean数据校验</p><ul><li><p>添加JSR303规范坐标与Hibernate校验框架对应坐标</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/SpringBoot.assets/image-20231109205233350.png" alt="image-20231109205233350"></p></li><li><p>对Bean开启校验功能</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/SpringBoot.assets/image-20231109205250965.png" alt="image-20231109205250965"></p></li><li><p>设置校验规则</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/SpringBoot.assets/image-20231109205308339.png" alt="image-20231109205308339"></p></li></ul></li></ul><h3 id="三-测试"><a href="#三-测试" class="headerlink" title="三 测试"></a>三 测试</h3><h4 id="3-1-加载测试专用属性"><a href="#3-1-加载测试专用属性" class="headerlink" title="3.1 加载测试专用属性"></a>3.1 加载测试专用属性</h4><ul><li><p>在启动测试环境时可以通过properties参数设置测试环境专用的属性</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/SpringBoot.assets/image-20231109210537977.png" alt="image-20231109210537977"></p><ul><li>优势：比多环境开发中的测试环境影响范围更小，仅对当前测试类有效</li></ul></li><li><p>在启动测试环境时可以通过args参数设置测试环境专用的传入参数</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/SpringBoot.assets/image-20231109211058663.png" alt="image-20231109211058663"></p></li></ul><h4 id="3-2-加载测试专用配置"><a href="#3-2-加载测试专用配置" class="headerlink" title="3.2 加载测试专用配置"></a>3.2 加载测试专用配置</h4><ul><li><p>使用<code>@Import</code>注解加载当前测试类专用的配置</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/SpringBoot.assets/image-20231109211147654.png" alt="image-20231109211147654"></p></li></ul><h4 id="3-3-Web环境模拟测试"><a href="#3-3-Web环境模拟测试" class="headerlink" title="3.3 Web环境模拟测试"></a>3.3 Web环境模拟测试</h4><ul><li><p>模拟端口</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/SpringBoot.assets/image-20231109211658481.png" alt="image-20231109211658481"></p><ul><li>可以选择 NONE、MOCK、DEFINED_PORT、RANDOM_PORT</li></ul></li><li><p>虚拟请求测试</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/SpringBoot.assets/image-20231109211846100.png" alt="image-20231109211846100"></p></li><li><p>虚拟请求状态匹配</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/SpringBoot.assets/image-20231109211903924.png" alt="image-20231109211903924">、</p></li><li><p>虚拟请求响应体匹配</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/SpringBoot.assets/image-20231109211921136.png" alt="image-20231109211921136"></p></li><li><p>虚拟请求响应体(json)匹配</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/SpringBoot.assets/image-20231109211941415.png" alt="image-20231109211941415"></p></li><li><p>虚拟请求响应头匹配</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/SpringBoot.assets/image-20231109211955439.png" alt="image-20231109211955439"></p></li></ul><h4 id="3-4-数据层测试回滚"><a href="#3-4-数据层测试回滚" class="headerlink" title="3.4 数据层测试回滚"></a>3.4 数据层测试回滚</h4><ul><li><p>为测试用例添加事务，SpringBoot会对测试用例对应的事务提交操作进行回滚</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/SpringBoot.assets/image-20231109213727643.png" alt="image-20231109213727643"></p></li><li><p>如果想在测试用例中提交事务，可以通过@Rollback注解设置</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/SpringBoot.assets/image-20231109213744743.png" alt="image-20231109213744743"></p></li></ul><h4 id="3-5-测试用例数据设定"><a href="#3-5-测试用例数据设定" class="headerlink" title="3.5 测试用例数据设定"></a>3.5 测试用例数据设定</h4><ul><li>测试用例数据通常采用随机值进行测试，使用SpringBoot提供的随机数为其赋值</li></ul><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/SpringBoot.assets/image-20231109213820897.png" alt="image-20231109213820897"></p><h3 id="四-数据层解决方案"><a href="#四-数据层解决方案" class="headerlink" title="四 数据层解决方案"></a>四 数据层解决方案</h3><h4 id="4-1-SQL"><a href="#4-1-SQL" class="headerlink" title="4.1 SQL"></a>4.1 SQL</h4><ul><li><p>现有数据层解决方案技术选型</p><ul><li><code>Druid + MyBatis-Plus + MySQL</code></li><li>数据源：<code>DruidDataSource</code></li><li>持久化技术：<code>MyBatis-Plus / MyBatis</code></li><li>数据库：MySQL</li></ul></li><li><p>数据源配置格式</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/SpringBoot.assets/image-20231109214853028.png" alt="image-20231109214853028"></p></li><li><p>SpringBoot提供了3种内嵌的数据源对象供开发者选择</p><ul><li>HikariCP（轻量级）：默认内置数据源对象</li><li>Tomcat提供DataSource：HikariCP不可用的情况下，且在web环境中，将使用tomcat服务器配置的数据源对象</li><li>Commons DBCP：Hikari不可用，tomcat数据源也不可用，将使用dbcp数据源</li></ul></li><li><p>内置持久化解决方案——JdbcTemplate</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/SpringBoot.assets/image-20231109215618810.png" alt="image-20231109215618810"></p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/SpringBoot.assets/image-20231109215653408.png" alt="image-20231109215653408"></p><ul><li><p>JdbcTemplate配置</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/SpringBoot.assets/image-20231109215747282.png" alt="image-20231109215747282"></p></li></ul></li><li><p>内嵌数据库</p><ul><li><p>H2</p><ul><li><p>导入坐标</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/SpringBoot.assets/image-20231109220811869.png" alt="image-20231109220811869"></p></li><li><p>设置当前项目为web工程，并配置H2管理控制台参数</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/SpringBoot.assets/image-20231109220823184.png" alt="image-20231109220823184"></p><p>启动项目浏览器输入：<code>localhost/h2</code>访问</p></li><li><p>操作数据库（创建表）</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/SpringBoot.assets/image-20231109220834247.png" alt="image-20231109220834247"></p></li><li><p>设置访问数据源</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/SpringBoot.assets/image-20231109220847029.png" alt="image-20231109220847029"></p></li><li><p>H2数据库控制台仅用于开发阶段，线上项目请务必关闭控制台功能</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/SpringBoot.assets/image-20231109221024438.png" alt="image-20231109221024438"></p></li></ul></li><li><p>HSQL</p></li><li><p>Derby</p></li></ul></li><li><p>总结</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/SpringBoot.assets/image-20231109221710139.png" alt="image-20231109221710139"></p></li></ul><h4 id="4-2-NoSQL"><a href="#4-2-NoSQL" class="headerlink" title="4.2 NoSQL"></a>4.2 NoSQL</h4><ul><li><p>市面上常见的NoSQL解决方案</p><ul><li>Redis</li><li>Mongo</li><li>ES</li><li>Solr</li><li>说明：上述技术通常在Linux系统中安装部署</li></ul></li><li><p>Redis</p><ul><li><p>Redis是一款key-value存储结构的内存级NoSQL数据库</p><ul><li>支持多种数据存储格式、支持持久化、支持集群</li></ul></li><li><p>导入坐标</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/SpringBoot.assets/image-20231109222004007.png" alt="image-20231109222004007"></p></li><li><p>配置</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/SpringBoot.assets/image-20231109222014599.png" alt="image-20231109222014599"></p></li><li><p>RedisTemplate以对象作为key和value，内部对数据进行序列化</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/SpringBoot.assets/image-20231109223017858.png" alt="image-20231109223017858"></p></li><li><p>StringRedisTemplate以字符串作为key和value，与Redis客户端操作等效（常用）</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/SpringBoot.assets/image-20231109223053707.png" alt="image-20231109223053707"></p></li></ul></li><li><p>Mongodb</p><ul><li>最像关系型数据的非关系型数据库</li></ul></li><li>ElasticSearch（ES）<ul><li>Elasticsearch是一个分布式全文搜索引擎</li></ul></li></ul><h3 id="五-整合第三方技术"><a href="#五-整合第三方技术" class="headerlink" title="五 整合第三方技术"></a>五 整合第三方技术</h3><h4 id="5-1-缓存"><a href="#5-1-缓存" class="headerlink" title="5.1 缓存"></a>5.1 缓存</h4><ul><li><p>缓存是一种介于数据永久存储介质与数据应用之间的数据临时存储介质</p></li><li><p>使用缓存可以有效的减少低速数据读取过程的次数（例如磁盘IO），提高系统性能</p></li><li><p>缓存不仅可以用于提高永久性存储介质的数据读取效率，还可以提供临时的数据存储空间</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/SpringBoot.assets/image-20231109224153931.png" alt="image-20231109224153931"></p></li><li><p>缓存的使用</p><ul><li><p>启用缓存</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/SpringBoot.assets/image-20231109224228328.png" alt="image-20231109224228328"></p></li><li><p>设置进入缓存的数据</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/SpringBoot.assets/image-20231109224236201.png" alt="image-20231109224236201"></p></li><li><p>设置读取缓存的数据</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/SpringBoot.assets/image-20231109224243849.png" alt="image-20231109224243849"></p></li></ul></li><li><p>SpringBoot提供的缓存技术除了提供默认的缓存方案，还可以对其他缓存技术进行整合，统一接口，方便缓存技术的开发与管理</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/SpringBoot.assets/image-20231112130616514.png" alt="image-20231112130616514"></p></li><li><p>手机验证码案例（使用SB内置的缓存）</p><ul><li><p>需求</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/SpringBoot.assets/image-20231112133728809.png" alt="image-20231112133728809"></p></li><li><p>开启缓存</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/SpringBoot.assets/image-20231112133742246.png" alt="image-20231112133742246"></p></li><li><p>业务层接口</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/SpringBoot.assets/image-20231112133757097-1699767477557-1.png" alt="image-20231112133757097"></p></li><li><p>业务层设置获取验证码操作，并存储缓存，手机号为key，验证码为value</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/SpringBoot.assets/image-20231112133821704.png" alt="image-20231112133821704"></p></li><li><p>业务层设置校验验证码操作，校验码通过缓存读取，返回校验结果</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/SpringBoot.assets/image-20231112133858857.png" alt="image-20231112133858857"></p></li><li><p><code>codeUtils</code>工具类</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/SpringBoot.assets/image-20231112134209720.png" alt="image-20231112134209720"></p></li></ul></li><li><p>缓存供应商变更1：Ehcache</p><ul><li><p>导入坐标</p></li><li><p>缓存设定为使用Ehcache（ehcache改为simple是默认）</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/SpringBoot.assets/image-20231112134330039.png" alt="image-20231112134330039"></p></li><li><p>提供ehcache配置文件ehcache.xml</p></li></ul></li><li><p>缓存供应商变更2：Redis</p><ul><li><p>导入坐标</p></li><li><p>配置Redis服务器，缓存设定为使用Redis</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/SpringBoot.assets/image-20231112134533636.png" alt="image-20231112134533636"></p></li><li><p>设置Reids相关配置</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/SpringBoot.assets/image-20231112134604703.png" alt="image-20231112134604703"></p></li></ul></li><li><p>缓存供应商变更3：memcached</p><ul><li><p>下载：<a href="https://www.runoob.com/memcached/window-install-memcached.html">https://www.runoob.com/memcached/window-install-memcached.html</a></p></li><li><p>安装</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/SpringBoot.assets/image-20231112134701541.png" alt="image-20231112134701541"></p></li><li><p>启动与停止服务</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/SpringBoot.assets/image-20231112134714655.png" alt="image-20231112134714655"></p></li></ul></li><li><p>缓存供应商变更4：jetcache</p><ul><li>jetCache对SpringCache进行了封装，在原有功能基础上实现了多级缓存、缓存统计、自动刷新、异步调用、数据报表等功能</li><li>jetCache设定了本地缓存与远程缓存的多级缓存解决方案<ul><li>本地缓存<ul><li>LinkedHashMap</li><li>Caffeine</li></ul></li><li>远程缓存<ul><li>Redis</li><li>Tair</li></ul></li></ul></li><li>导入坐标</li><li>配置远程缓存属性</li><li>配置本地缓存属性</li></ul></li><li><p>缓存供应商变更4：j2cache</p><ul><li>j2cache是一个缓存整合框架，可以提供缓存的整合方案，使各种缓存搭配使用，自身不提供缓存功能<ul><li>基于 ehcache + redis 进行整合</li><li>加入坐标</li><li>配置使用j2cache(application.yml)</li><li>配置一级缓存与二级缓存以及一级缓存数据到二级缓存的发送方式（j2cache.properties）</li><li>设置使用缓存</li></ul></li></ul></li></ul><h4 id="5-2-任务"><a href="#5-2-任务" class="headerlink" title="5.2 任务"></a>5.2 任务</h4><ul><li><p>定时任务是企业级应用中的常见操作</p></li><li><p>市面上流行的定时任务技术</p><ul><li>Quartz</li><li>Spring Task</li></ul></li><li><p>SpringBoot整合Quartz</p><ul><li><p>相关概念</p><ul><li>工作（Job）：用于定义具体执行的工作</li><li>工作明细（JobDetail）：用于描述定时工作相关的信息</li><li>触发器（Trigger）：用于描述触发工作的规则，通常使用cron表达式定义调度规则</li><li>调度器（Scheduler）：描述了工作明细与触发器的对应关系</li></ul></li><li><p>导入坐标</p></li><li><p>定义具体要执行的任务，继承<code>QuartzJobBean</code></p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/SpringBoot.assets/image-20231112145532018.png" alt="image-20231112145532018"></p></li><li><p>定义工作明细与触发器，并绑定对应关系</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/SpringBoot.assets/image-20231112145610931.png" alt="image-20231112145610931"></p></li></ul></li><li><p>Spring Task</p><ul><li><p>开启定时任务功能</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/SpringBoot.assets/image-20231112150253984.png" alt="image-20231112150253984"></p></li><li><p>设置定时执行的任务，并设定执行周期</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/SpringBoot.assets/image-20231112150312700.png" alt="image-20231112150312700"></p></li><li><p>定时任务相关配置</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/SpringBoot.assets/image-20231112150330806.png" alt="image-20231112150330806"></p></li></ul></li></ul><h4 id="5-3-邮件"><a href="#5-3-邮件" class="headerlink" title="5.3 邮件"></a>5.3 邮件</h4><ul><li><p>邮件协议</p><ul><li>SMTP（Simple Mail Transfer Protocol）：简单邮件传输协议，用于<strong>发送</strong>电子邮件的传输协议</li><li>POP3（Post Office Protocol - Version 3）：用于<strong>接收</strong>电子邮件的标准协议</li><li>IMAP（Internet Mail Access Protocol）：互联网消息协议，是POP3的替代协议</li></ul></li><li><p>SpringBoot整合JavaMail</p><ul><li><p>导入坐标</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/SpringBoot.assets/image-20231112150821074.png" alt="image-20231112150821074"></p></li><li><p>配置JavaMail</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/SpringBoot.assets/image-20231112150832155.png" alt="image-20231112150832155"></p><p>​      注意：这个密码不是邮件密码，是服务器密码</p></li><li><p>开启定时功能</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/SpringBoot.assets/image-20231112150851879.png" alt="image-20231112150851879"></p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/SpringBoot.assets/image-20231112150902837.png" alt="image-20231112150902837"></p></li></ul></li></ul><h4 id="5-4-消息"><a href="#5-4-消息" class="headerlink" title="5.4 消息"></a>5.4 消息</h4><ul><li><p>消息发送方：生产者    消息接收方：消费者</p></li><li><p>同步消息；异步消息</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/SpringBoot.assets/image-20231112160458443.png" alt="image-20231112160458443"></p></li><li><p>企业级应用中广泛使用的三种异步消息传递技术</p><ul><li>JMS</li><li>AMQP</li><li>MQTT</li></ul></li><li><p>JMS（Java Message Service）：</p><ul><li>简介：一个规范，等同于JDBC规范，提供了与消息服务相关的API接口</li><li>JMS消息模型<ul><li>peer-2-peer：点对点模型，消息发送到一个队列中，队列保存消息。队列的消息只能被一个消费者消费，或超时</li><li><strong>pub</strong>lish-<strong>sub</strong>scribe：发布订阅模型，消息可以被多个消费者消费，生产者和消费者完全独立，不需要感知对方的存在</li></ul></li><li>JMS消息种类<ul><li>TextMessage、MapMessage、<strong>BytesMessage</strong>、StreamMessage、ObjectMessage、Message</li></ul></li><li>JMS消息实现<ul><li><strong>ActiveMQ</strong>、Redis、HornetMQ、RabbitMQ、RocketMQ（没有完全遵守JMS规范）</li></ul></li></ul></li><li><p>AMQP（advanced message queuing protocol）</p><ul><li>简介：一种协议（高级消息队列协议，也是消息代理规范），规范了网络交换的数据格式，兼容JMS</li><li><p>AMQP消息模型</p><ul><li>direct exchange、fanout exchange、topic exchange、headers exchange、system exchange</li></ul></li><li><p>AMQP消息种类：byte[]</p></li><li>AMQP实现：<ul><li>RabbitMQ、StormMQ、RocketMQ</li></ul></li></ul></li><li><p>MQTT（Message Queueing Telemetry Transport）</p><ul><li>消息队列遥测传输，专为小设备设计，是物联网（IOT）生态系统中主要成分之一</li></ul></li><li><p>Kafka</p><ul><li>一种高吞吐量的分布式发布订阅消息系统，提供实时消息功能。</li></ul></li><li><p>整合ActiveMQ</p><ul><li><p>下载安装</p></li><li><p>启动服务，访问服务器</p></li><li><p>SpringBoot导入ActiveMQ坐标</p></li><li><p>配置Active MQ</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/SpringBoot.assets/image-20231112162116579.png" alt="image-20231112162116579"></p></li><li><p>生产与消费消息（使用默认消息存储队列）</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/SpringBoot.assets/image-20231112162202670.png" alt="image-20231112162202670"></p></li><li><p>生产与消费消息（指定消息存储队列）</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/SpringBoot.assets/image-20231112162210100.png" alt="image-20231112162210100"></p></li><li><p>使用消息监听器对消息队列监听</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/SpringBoot.assets/image-20231112162224705.png" alt="image-20231112162224705"></p></li><li><p>流程性业务消息消费完转入下一个消息队列</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/SpringBoot.assets/image-20231112162241036.png" alt="image-20231112162241036"></p></li></ul></li><li><p>整合RabbitMQ</p><ul><li><p>RabbitMQ基于Erlang语言编写，需要安装Erlang</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/SpringBoot.assets/image-20231112204047483.png" alt="image-20231112204047483"></p></li><li><p>导入坐标</p></li><li><p>配置</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/SpringBoot.assets/image-20231112204604568.png" alt="image-20231112204604568"></p></li><li><p>定义消息队列（direct）</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/SpringBoot.assets/image-20231112204631647.png" alt="image-20231112204631647"></p></li><li><p>生产与消费信息（direct）</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/SpringBoot.assets/image-20231112205105051.png" alt="image-20231112205105051"></p></li><li><p>使用消息监听器对消息队列监听(direct)</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/SpringBoot.assets/image-20231112205647222.png" alt="image-20231112205647222"></p></li><li><p>使用多消息监听器对消息队列监听进行消息轮循处理(direct)</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/SpringBoot.assets/image-20231112205705466.png" alt="image-20231112205705466">                            </p></li></ul></li></ul><h3 id="六-监控"><a href="#六-监控" class="headerlink" title="六 监控"></a>六 监控</h3><h4 id="6-1-监控的意义"><a href="#6-1-监控的意义" class="headerlink" title="6.1 监控的意义"></a>6.1 监控的意义</h4><ul><li><p>意义</p><ul><li><p>监控服务状态是否宕机</p></li><li><p>监控服务运行指标（内存、虚拟机、线程、请求等）</p></li><li><p>监控日志</p></li><li><p>管理服务（服务下线）</p></li></ul></li><li><p>监控实施方式</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/SpringBoot.assets/image-20231112210522637.png" alt="image-20231112210522637"></p></li></ul><h4 id="6-2-可视化监控平台"><a href="#6-2-可视化监控平台" class="headerlink" title="6.2 可视化监控平台"></a>6.2 可视化监控平台</h4><ul><li><p>Spring Boot Admin，开源社区项目，用于管理和监控SpringBoot应用程序。 客户端注册到服务端后，通过HTTP请求方式，服务端定期从客户端获取对应的信息，并通过UI界面展示对应信息。</p></li><li><p>服务端（导入坐标后）</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/SpringBoot.assets/image-20231112211220037.png" alt="image-20231112211220037"></p></li><li><p>客户端（导入坐标后），注意端口不与服务端一致</p><ul><li>配置监控信息</li></ul><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/SpringBoot.assets/image-20231112211231800.png" alt="image-20231112211231800"></p></li></ul><h4 id="6-3-监控原理"><a href="#6-3-监控原理" class="headerlink" title="6.3 监控原理"></a>6.3 监控原理</h4><ul><li>Actuator提供了SpringBoot生产就绪功能，通过端点的配置与访问，获取端点信息</li><li>端点描述了一组监控信息，SpringBoot提供了多个内置端点，也可以根据需要自定义端点信息</li><li>访问当前应用所有端点信息：<strong>/actuator</strong></li><li>访问端点详细信息：/actuator/<strong>端点名称</strong></li></ul><h4 id="6-4-自定义监控指标"><a href="#6-4-自定义监控指标" class="headerlink" title="6.4 自定义监控指标"></a>6.4 自定义监控指标</h4><link rel="stylesheet" href="https://cdn1.tianli0.top/gh/zhheo/Post-Abstract-AI@0.15.2/tianli_gpt.css"><script>let tianliGPT_postSelector = '#post #article-container';let tianliGPT_key = 'c9b7741d290063ab872e';</script><script src="https://cdn1.tianli0.top/gh/zhheo/Post-Abstract-AI@0.15.2/tianli_gpt.js"></script>]]></content>
      
      
      <categories>
          
          <category> study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java高级 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MyBatis-PLus</title>
      <link href="/posts/19329.html"/>
      <url>/posts/19329.html</url>
      
        <content type="html"><![CDATA[<h1 id="MyBatis-PLus"><a href="#MyBatis-PLus" class="headerlink" title="MyBatis-PLus"></a>MyBatis-PLus</h1><p>飞书链接：<a href="https://b11et3un53m.feishu.cn/wiki/PsyawI04ei2FQykqfcPcmd7Dnsc">https://b11et3un53m.feishu.cn/wiki/PsyawI04ei2FQykqfcPcmd7Dnsc</a></p><p>视频链接：<a href="https://www.bilibili.com/video/BV1Xu411A7tL?p=20&amp;spm_id_from=pageDriver&amp;vd_source=1a39594354c31d775ddc587407a55282">https://www.bilibili.com/video/BV1Xu411A7tL?p=20&amp;spm_id_from=pageDriver&amp;vd_source=1a39594354c31d775ddc587407a55282</a></p><h2 id="一-入门"><a href="#一-入门" class="headerlink" title="一 入门"></a>一 入门</h2><h3 id="1-1-demo"><a href="#1-1-demo" class="headerlink" title="1.1 demo"></a>1.1 demo</h3><ul><li><p>引入依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.baomidou<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-plus-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.5.3.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>Mapper 继承BaseMapper<User></p></li><li><p>测试</p></li></ul><h3 id="1-2-常见注解"><a href="#1-2-常见注解" class="headerlink" title="1.2 常见注解"></a>1.2 常见注解</h3><ul><li><p>MP通过扫描实体类，并基于反射获取实体类信息作为数据库表信息</p><ul><li>类名驼峰转下划线作为表名</li><li>名为id的字段为主键</li><li>变量名驼峰转下划线作为表的字段名</li></ul></li><li><p><code>@TableName</code>:表名注解，标识实体类对应的表</p><ul><li><p>```java<br>@TableName(“tb_user”)<br>public class User {</p><pre><code>private Long id;private String name;</code></pre><p>}</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  - 两种属性</span><br><span class="line"></span><br><span class="line">    ![image-20231018204639104](https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/MybatisPlus.assets/image-20231018204639104.png)</span><br><span class="line"></span><br><span class="line">- `@TableId`:主键注解，标识实体类中的主键字段</span><br><span class="line"></span><br><span class="line">  - ```java</span><br><span class="line">    @TableName(&quot;user&quot;)</span><br><span class="line">    public class User &#123;</span><br><span class="line">        @TableId(&quot;id&quot;)</span><br><span class="line">        private Long id;</span><br><span class="line">        private String name;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li><p>常见三种属性</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/MybatisPlus.assets/image-20231018204611220.png" alt="image-20231018204611220"></p></li></ul></li><li><p><code>@TableField</code>：普通字段注解</p><ul><li>```java<br>@TableName(“user”)<br>public class User {<pre><code>@TableIdprivate Long id;private String name;private Integer age;@TableField(&quot;isMarried&quot;)private Boolean isMarried;@TableField(&quot;concat&quot;)private String concat;</code></pre>}<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  - 一般情况下我们并不需要给字段添加`@TableField`注解，一些特殊情况除外：</span><br><span class="line"></span><br><span class="line">    - 成员变量名与数据库字段名不一致</span><br><span class="line">    - 成员变量是以`isXXX`命名，按照`JavaBean`的规范，`MybatisPlus`识别字段时会把`is`去除，这就导致与数据库不符。</span><br><span class="line">    - 成员变量名与数据库一致，但是与数据库的关键字冲突。使用`@TableField`注解给字段名添加````转义</span><br><span class="line"></span><br><span class="line">### 1.3 常见配置</span><br><span class="line"></span><br><span class="line">- yaml配置文件</span><br><span class="line"></span><br><span class="line">  - 注意：注解的配置优先级别下面这个全局的优先级高</span><br><span class="line"></span><br><span class="line">  - ```yaml</span><br><span class="line">    mybatis-plus:</span><br><span class="line">      # 实体类的别名扫描包</span><br><span class="line">      type-aliases-package: com.itheima.mp.domain.po</span><br><span class="line">      </span><br><span class="line">      # Mapper.xml文件地址，当前这个是默认值。  </span><br><span class="line">      mapper-locations: &quot;classpath*:/mapper/**/*.xml&quot; </span><br><span class="line">      </span><br><span class="line">      # 全局id类型为自增长</span><br><span class="line">      global-config:</span><br><span class="line">        db-config:</span><br><span class="line">          id-type: auto #assigh_id 雪花算法</span><br></pre></td></tr></table></figure></li></ul></li></ul><h2 id="二-核心功能"><a href="#二-核心功能" class="headerlink" title="二 核心功能"></a>二 核心功能</h2><h3 id="2-1-条件构造器"><a href="#2-1-条件构造器" class="headerlink" title="2.1 条件构造器"></a>2.1 条件构造器</h3><ul><li>除了新增以外，修改、删除、查询的SQL语句都需要指定where条件。因此BaseMapper中提供的相关方法除了以<code>id</code>作为<code>where</code>条件以外，还支持更加复杂的<code>where</code>条件。</li><li><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/MybatisPlus.assets/image-20231018210233951.png" alt="image-20231018210233951"></li><li><code>Wrapper</code>为条件构造器的抽象类<ul><li><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/MybatisPlus.assets/image-20231018210359247.png" alt="image-20231018210359247"></li><li><code>AbstractWrapper</code>提供了where中包含的所有条件构造方法</li><li><code>QueryWrapper</code>在<code>AbstractWrapper</code>的基础上拓展了一个select方法，允许指定查询字段</li><li><code>UpdateWrapper</code>在<code>AbstractWrapper</code>的基础上拓展了一个set方法，允许指定SQL中的SET部分</li></ul></li></ul><h4 id="2-1-1-QueryWrapper"><a href="#2-1-1-QueryWrapper" class="headerlink" title="2.1.1 QueryWrapper"></a>2.1.1 QueryWrapper</h4><ul><li>```java<br>@Test<br>void testQueryWrapper() {<pre><code>// 1.构建查询条件 where name like &quot;%o%&quot; AND balance &gt;= 1000QueryWrapper&lt;User&gt; wrapper = new QueryWrapper&lt;User&gt;()        .select(&quot;id&quot;, &quot;username&quot;, &quot;info&quot;, &quot;balance&quot;)        .like(&quot;username&quot;, &quot;o&quot;)        .ge(&quot;balance&quot;, 1000);// 2.查询数据List&lt;User&gt; users = userMapper.selectList(wrapper);users.forEach(System.out::println);</code></pre>}<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- ```Java</span><br><span class="line">  @Test</span><br><span class="line">  void testUpdateByQueryWrapper() &#123;</span><br><span class="line">      // 1.构建查询条件 where name = &quot;Jack&quot;</span><br><span class="line">      QueryWrapper&lt;User&gt; wrapper = new QueryWrapper&lt;User&gt;().eq(&quot;username&quot;, &quot;Jack&quot;);</span><br><span class="line">      // 2.更新数据，user中非null字段都会作为set语句</span><br><span class="line">      User user = new User();</span><br><span class="line">      user.setBalance(2000);</span><br><span class="line">      userMapper.update(user, wrapper);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="2-1-2-UpdateWrapper"><a href="#2-1-2-UpdateWrapper" class="headerlink" title="2.1.2 UpdateWrapper"></a>2.1.2 UpdateWrapper</h4><ul><li>```Java<br>@Test<br>void testUpdateWrapper() {<pre><code>List&lt;Long&gt; ids = List.of(1L, 2L, 4L);// 1.生成SQLUpdateWrapper&lt;User&gt; wrapper = new UpdateWrapper&lt;User&gt;()        .setSql(&quot;balance = balance - 200&quot;) // SET balance = balance - 200        .in(&quot;id&quot;, ids); // WHERE id in (1, 2, 4)    // 2.更新，注意第一个参数可以给null，也就是不填更新字段和数据，// 而是基于UpdateWrapper中的setSQL来更新userMapper.update(null, wrapper);</code></pre>}<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#### 2.1.3 LambdaQueryWrapper</span><br><span class="line"></span><br><span class="line">- 无论是`QueryWrapper`还是`UpdateWrapper`在构造条件的时候都需要写死字段名称，会出现字符串`魔法值`。这在编程规范中显然是不推荐的。</span><br><span class="line"></span><br><span class="line">- 其中一种办法是基于变量的`gettter`方法结合反射技术。因此我们只要将条件对应的字段的`getter`方法传递给MybatisPlus，它就能计算出对应的变量名了</span><br><span class="line"></span><br><span class="line">- `LambdaQueryWrapper`和`LambdaUpdateWrapper`</span><br><span class="line"></span><br><span class="line">- ```java</span><br><span class="line">  @Test</span><br><span class="line">  void testLambdaQueryWrapper() &#123;</span><br><span class="line">      // 1.构建条件 WHERE username LIKE &quot;%o%&quot; AND balance &gt;= 1000</span><br><span class="line">      QueryWrapper&lt;User&gt; wrapper = new QueryWrapper&lt;&gt;();</span><br><span class="line">      wrapper.lambda()</span><br><span class="line">              .select(User::getId, User::getUsername, User::getInfo, User::getBalance)</span><br><span class="line">              .like(User::getUsername, &quot;o&quot;)</span><br><span class="line">              .ge(User::getBalance, 1000);</span><br><span class="line">      // 2.查询</span><br><span class="line">      List&lt;User&gt; users = userMapper.selectList(wrapper);</span><br><span class="line">      users.forEach(System.out::println);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="2-2-自定义SQL"><a href="#2-2-自定义SQL" class="headerlink" title="2.2 自定义SQL"></a>2.2 自定义SQL</h3><h4 id="2-2-1-基本用法"><a href="#2-2-1-基本用法" class="headerlink" title="2.2.1 基本用法"></a>2.2.1 基本用法</h4><ul><li><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/MybatisPlus.assets/image-20231018212805019.png" alt="image-20231018212805019"></p><p>这种写法在某些企业是不允许的，因为SQL语句最好都维护在持久层，而不是业务层</p></li><li><p>MybatisPlus提供了自定义SQL功能，可以让我们利用Wrapper生成查询条件，再结合Mapper.xml编写SQL</p></li><li><p>```java<br>@Test<br>void testCustomWrapper() {</p><pre><code>// 1.准备自定义查询条件List&lt;Long&gt; ids = List.of(1L, 2L, 4L);QueryWrapper&lt;User&gt; wrapper = new QueryWrapper&lt;User&gt;().in(&quot;id&quot;, ids);// 2.调用mapper的自定义方法，直接传递WrapperuserMapper.deductBalanceByIds(200, wrapper);</code></pre><p>}</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 然后在UserMapper中自定义SQL</span><br><span class="line"></span><br><span class="line">  ```java</span><br><span class="line">  public interface UserMapper extends BaseMapper&lt;User&gt; &#123;</span><br><span class="line">      @Select(&quot;UPDATE user SET balance = balance - #&#123;money&#125; $&#123;ew.customSqlSegment&#125;&quot;)</span><br><span class="line">      void deductBalanceByIds(@Param(&quot;money&quot;) int money, @Param(&quot;ew&quot;) QueryWrapper&lt;User&gt; wrapper);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="2-2-2-多表关联"><a href="#2-2-2-多表关联" class="headerlink" title="2.2.2 多表关联"></a>2.2.2 多表关联</h4><ul><li><p>利用Wrapper中自定义条件结合自定义SQL来实现多表查询的效果。</p></li><li><p>基于mybtis</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;queryUserByIdAndAddr&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.itheima.mp.domain.po.User&quot;</span>&gt;</span></span><br><span class="line">      SELECT *</span><br><span class="line">      FROM user u</span><br><span class="line">      INNER JOIN address a ON u.id = a.user_id</span><br><span class="line">      WHERE u.id</span><br><span class="line">      <span class="tag">&lt;<span class="name">foreach</span> <span class="attr">collection</span>=<span class="string">&quot;ids&quot;</span> <span class="attr">separator</span>=<span class="string">&quot;,&quot;</span> <span class="attr">item</span>=<span class="string">&quot;id&quot;</span> <span class="attr">open</span>=<span class="string">&quot;IN (&quot;</span> <span class="attr">close</span>=<span class="string">&quot;)&quot;</span>&gt;</span></span><br><span class="line">          #&#123;id&#125;</span><br><span class="line">      <span class="tag">&lt;/<span class="name">foreach</span>&gt;</span></span><br><span class="line">      AND a.city = #&#123;city&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>使用wrapper</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testCustomJoinWrapper</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 1.准备自定义查询条件</span></span><br><span class="line">    QueryWrapper&lt;User&gt; wrapper = <span class="keyword">new</span> <span class="title class_">QueryWrapper</span>&lt;User&gt;()</span><br><span class="line">            .in(<span class="string">&quot;u.id&quot;</span>, List.of(<span class="number">1L</span>, <span class="number">2L</span>, <span class="number">4L</span>))</span><br><span class="line">            .eq(<span class="string">&quot;a.city&quot;</span>, <span class="string">&quot;北京&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.调用mapper的自定义方法</span></span><br><span class="line">    List&lt;User&gt; users = userMapper.queryUserByWrapper(wrapper);</span><br><span class="line"></span><br><span class="line">    users.forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="2-3-Service接口"><a href="#2-3-Service接口" class="headerlink" title="2.3 Service接口"></a>2.3 Service接口</h3><ul><li>MybatisPlus不仅提供了BaseMapper，还提供了通用的Service接口及默认实现，封装了一些常用的service模板方法。</li><li>通用接口为<code>IService</code>默认实现为 <code>ServiceImpl</code>,其中封装的方法可以分为以下几类：<ul><li><code>save</code>：新增</li><li><code>remove</code>：删除</li><li><code>update</code>：更新</li><li><code>get</code>：查询单个结果</li><li><code>list</code>：查询集合结果</li><li><code>count</code>：计数</li><li><code>page</code>：分页查询</li></ul></li><li><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/MybatisPlus.assets/image-20231018213623619.png" alt="image-20231018213623619"></li></ul><h4 id="2-3-1-基本用法"><a href="#2-3-1-基本用法" class="headerlink" title="2.3.1 基本用法"></a>2.3.1 基本用法</h4><ul><li><p>由于<code>Service</code>中经常需要定义与业务有关的自定义方法，因此我们不能直接使用<code>IService</code>，而是自定义<code>Service</code>接口，然后继承<code>IService</code>以拓展方法。同时，让自定义的<code>Service实现类</code>继承<code>ServiceImpl</code>，这样就不用自己实现<code>IService</code>中的接口了。</p></li><li><p>首先，定义<code>IUserService</code>，继承<code>IService</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">IUserService</span> <span class="keyword">extends</span> <span class="title class_">IService</span>&lt;User&gt; &#123;</span><br><span class="line">    <span class="comment">// 拓展自定义方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>然后，编写<code>UserServiceImpl</code>类，继承<code>ServiceImpl</code>，实现<code>UserService</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">extends</span> <span class="title class_">ServiceImpl</span>&lt;UserMapper, User&gt; <span class="keyword">implements</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="2-3-2-Lambda"><a href="#2-3-2-Lambda" class="headerlink" title="2.3.2 Lambda"></a>2.3.2 Lambda</h4><ul><li><p><code>IService</code>中还提供了Lambda功能来简化我们的复杂查询及更新功能</p></li><li><p>原来UserController中的条件查询</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/list&quot;)</span></span><br><span class="line"><span class="meta">@ApiOperation(&quot;根据id集合查询用户&quot;)</span></span><br><span class="line"><span class="keyword">public</span> List&lt;UserVO&gt; <span class="title function_">queryUsers</span><span class="params">(UserQuery query)</span>&#123;</span><br><span class="line">    <span class="comment">// 1.组织条件</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> query.getName();</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">status</span> <span class="operator">=</span> query.getStatus();</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">minBalance</span> <span class="operator">=</span> query.getMinBalance();</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">maxBalance</span> <span class="operator">=</span> query.getMaxBalance();</span><br><span class="line">    LambdaQueryWrapper&lt;User&gt; wrapper = <span class="keyword">new</span> <span class="title class_">QueryWrapper</span>&lt;User&gt;().lambda()</span><br><span class="line">            .like(username != <span class="literal">null</span>, User::getUsername, username)</span><br><span class="line">            .eq(status != <span class="literal">null</span>, User::getStatus, status)</span><br><span class="line">            .ge(minBalance != <span class="literal">null</span>, User::getBalance, minBalance)</span><br><span class="line">            .le(maxBalance != <span class="literal">null</span>, User::getBalance, maxBalance);</span><br><span class="line">    <span class="comment">// 2.查询用户</span></span><br><span class="line">    List&lt;User&gt; users = userService.list(wrapper);</span><br><span class="line">    <span class="comment">// 3.处理vo</span></span><br><span class="line">    <span class="keyword">return</span> BeanUtil.copyToList(users, UserVO.class);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Service中对<code>LambdaQueryWrapper</code>和<code>LambdaUpdateWrapper</code>的用法进一步做了简化。我们无需自己通过<code>new</code>的方式来创建<code>Wrapper</code>，而是直接调用<code>lambdaQuery</code>和<code>lambdaUpdate</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/list&quot;)</span></span><br><span class="line"><span class="meta">@ApiOperation(&quot;根据id集合查询用户&quot;)</span></span><br><span class="line"><span class="keyword">public</span> List&lt;UserVO&gt; <span class="title function_">queryUsers</span><span class="params">(UserQuery query)</span>&#123;</span><br><span class="line">    <span class="comment">// 1.组织条件</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> query.getName();</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">status</span> <span class="operator">=</span> query.getStatus();</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">minBalance</span> <span class="operator">=</span> query.getMinBalance();</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">maxBalance</span> <span class="operator">=</span> query.getMaxBalance();</span><br><span class="line">    <span class="comment">// 2.查询用户</span></span><br><span class="line">    List&lt;User&gt; users = userService.lambdaQuery()</span><br><span class="line">            .like(username != <span class="literal">null</span>, User::getUsername, username)</span><br><span class="line">            .eq(status != <span class="literal">null</span>, User::getStatus, status)</span><br><span class="line">            .ge(minBalance != <span class="literal">null</span>, User::getBalance, minBalance)</span><br><span class="line">            .le(maxBalance != <span class="literal">null</span>, User::getBalance, maxBalance)</span><br><span class="line">            .list();</span><br><span class="line">    <span class="comment">//最后的.one()返回最多一个结果，.list()返回集合， .count()返回计数结果</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 3.处理vo</span></span><br><span class="line">    <span class="keyword">return</span> BeanUtil.copyToList(users, UserVO.class);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>需求新增：如果扣减后余额为0，则将用户status修改为冻结状态（2</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deductBalance</span><span class="params">(Long id, Integer money)</span> &#123;</span><br><span class="line">    <span class="comment">// 1.查询用户</span></span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> getById(id);</span><br><span class="line">    <span class="comment">// 2.校验用户状态</span></span><br><span class="line">    <span class="keyword">if</span> (user == <span class="literal">null</span> || user.getStatus() == <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;用户状态异常！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 3.校验余额是否充足</span></span><br><span class="line">    <span class="keyword">if</span> (user.getBalance() &lt; money) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;用户余额不足！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 4.扣减余额 update tb_user set balance = balance - ?</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">remainBalance</span> <span class="operator">=</span> user.getBalance() - money;</span><br><span class="line">    lambdaUpdate()</span><br><span class="line">            .set(User::getBalance, remainBalance) <span class="comment">// 更新余额</span></span><br><span class="line">            .set(remainBalance == <span class="number">0</span>, User::getStatus, <span class="number">2</span>) <span class="comment">// 动态判断，是否更新status</span></span><br><span class="line">            .eq(User::getId, id)</span><br><span class="line">            .eq(User::getBalance, user.getBalance()) <span class="comment">// 乐观锁</span></span><br><span class="line">            .update();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="2-3-4-批量新增"><a href="#2-3-4-批量新增" class="headerlink" title="2.3.4 批量新增"></a>2.3.4 批量新增</h4><ul><li><p>比for循环一个一个插入快很多</p></li><li><p><code>MybatisPlus</code>的批处理是基于<code>PrepareStatement</code>的预编译模式，然后批量提交，最终在数据库执行时还是会有多条insert语句，逐条插入数据。</p></li><li><p>修改项目中的application.yml文件，在jdbc的url后面添加参数<code>&amp;rewriteBatchedStatements=true</code>:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  datasource:</span><br><span class="line">    url: jdbc:mysql://127.0.0.1:3306/mp?useUnicode=true&amp;characterEncoding=UTF-8&amp;autoReconnect=true&amp;serverTimezone=Asia/Shanghai&amp;rewriteBatchedStatements=true</span><br><span class="line">    driver-class-name: com.mysql.cj.jdbc.Driver</span><br><span class="line">    username: root</span><br><span class="line">    password: MySQL123</span><br></pre></td></tr></table></figure></li><li><p>性能将进一步提升</p></li></ul><h2 id="三-扩展功能"><a href="#三-扩展功能" class="headerlink" title="三 扩展功能"></a>三 扩展功能</h2><h3 id="3-1-代码生成器"><a href="#3-1-代码生成器" class="headerlink" title="3.1 代码生成器"></a>3.1 代码生成器</h3><ul><li>idea安装<code>MyBatisPlus</code>插件，按步骤填写参数即可</li></ul><h3 id="3-2-静态工具"><a href="#3-2-静态工具" class="headerlink" title="3.2 静态工具"></a>3.2 静态工具</h3><ul><li>静态工具类 <code>Db</code><ul><li>一些静态方法与<code>Iservice</code>中的方法签名基本一致</li></ul></li></ul><h3 id="3-3-逻辑删除"><a href="#3-3-逻辑删除" class="headerlink" title="3.3 逻辑删除"></a>3.3 逻辑删除</h3><ul><li><p>删除的时候并没有真正的删除</p></li><li><p>步骤</p><ul><li><p>在实体类中添加一个<code>deleted</code>字段</p></li><li><p>在<code>application.yml</code>中配置逻辑删除字段：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">mybatis-plus:</span></span><br><span class="line">  <span class="attr">global-config:</span></span><br><span class="line">    <span class="attr">db-config:</span></span><br><span class="line">      <span class="attr">logic-delete-field:</span> <span class="string">deleted</span> <span class="comment"># 全局逻辑删除的实体字段名(since 3.3.0,配置后可以忽略不配置步骤2)</span></span><br><span class="line">      <span class="attr">logic-delete-value:</span> <span class="number">1</span> <span class="comment"># 逻辑已删除值(默认为 1)</span></span><br><span class="line">      <span class="attr">logic-not-delete-value:</span> <span class="number">0</span> <span class="comment"># 逻辑未删除值(默认为 0)</span></span><br></pre></td></tr></table></figure></li><li><p>执行删除操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testDeleteByLogic</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 删除方法与以前没有区别</span></span><br><span class="line">    addressService.removeById(<span class="number">59L</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/MybatisPlus.assets/image-20231018222956813.png" alt="image-20231018222956813"></p></li></ul></li></ul><h3 id="3-4-通用枚举"><a href="#3-4-通用枚举" class="headerlink" title="3.4 通用枚举"></a>3.4 通用枚举</h3><ul><li><p>我们一般会定义一个枚举，做业务判断的时候就可以直接基于枚举做比较。但是我们数据库采用的是<code>int</code>类型，对应的PO也是<code>Integer</code>。因此业务操作时必须手动把<code>枚举</code>与<code>Integer</code>转换，非常麻烦。</p></li><li><p>解决</p><ul><li><p>定义枚举</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">UserStatus</span> &#123;</span><br><span class="line">    NORMAL(<span class="number">1</span>, <span class="string">&quot;正常&quot;</span>),</span><br><span class="line">    FREEZE(<span class="number">2</span>, <span class="string">&quot;冻结&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@EnumValue</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> value;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String desc;</span><br><span class="line"></span><br><span class="line">    UserStatus(<span class="type">int</span> value, String desc) &#123;</span><br><span class="line">        <span class="built_in">this</span>.value = value;</span><br><span class="line">        <span class="built_in">this</span>.desc = desc;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>使用 <code>@EnumValue</code>标记枚举属性的值</p></li><li><p>配置枚举处理器（在yaml文件中）</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">mybatis-plus:</span></span><br><span class="line">  <span class="attr">configuration:</span></span><br><span class="line">    <span class="attr">default-enum-type-handler:</span> <span class="string">com.baomidou.mybatisplus.core.handlers.MybatisEnumTypeHandler</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="3-4-JSON类型处理器"><a href="#3-4-JSON类型处理器" class="headerlink" title="3.4 JSON类型处理器"></a>3.4 JSON类型处理器</h3><ul><li><p>数据表中有一个类型为json类型的字段info的时候</p></li><li><p>步骤</p><ul><li><p>定义实体UserInfo对应那个info对象</p></li><li><p>使用类型处理器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@TableField(typeHandler = JacksonTypeHandler.class)</span></span><br><span class="line"><span class="keyword">private</span> UserInfo info;</span><br></pre></td></tr></table></figure></li><li><p>在类上开启resultMap自动转换</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@TableName(Value=&quot;user&quot;, autoResultMap = true)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line"><span class="keyword">private</span> Long id;</span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line"><span class="meta">@TableField(typeHandler = JacksonTypeHandler.class)</span></span><br><span class="line"><span class="keyword">private</span> UserInfo info;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h2 id="四-插件功能"><a href="#四-插件功能" class="headerlink" title="四 插件功能"></a>四 插件功能</h2><h2 id="4-1-分页插件"><a href="#4-1-分页插件" class="headerlink" title="4.1 分页插件"></a>4.1 分页插件</h2><ul><li><p>新建配置类，在其中定一个bean</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MybatisConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> MybatisPlusInterceptor <span class="title function_">mybatisPlusInterceptor</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 初始化核心插件</span></span><br><span class="line">        <span class="type">MybatisPlusInterceptor</span> <span class="variable">interceptor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MybatisPlusInterceptor</span>();</span><br><span class="line">        <span class="comment">// 添加分页插件</span></span><br><span class="line">        interceptor.addInnerInterceptor(<span class="keyword">new</span> <span class="title class_">PaginationInnerInterceptor</span>(DbType.MYSQL));</span><br><span class="line">        <span class="comment">// 还可以继续添加其他插件</span></span><br><span class="line">        <span class="keyword">return</span> interceptor;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>分页API</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testPageQuery</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 1.分页查询，new Page()的两个参数分别是：页码、每页大小</span></span><br><span class="line">    Page&lt;User&gt; p = userService.page(<span class="keyword">new</span> <span class="title class_">Page</span>&lt;&gt;(<span class="number">2</span>, <span class="number">2</span>));</span><br><span class="line">    <span class="comment">// 2.总条数</span></span><br><span class="line">    System.out.println(<span class="string">&quot;total = &quot;</span> + p.getTotal());</span><br><span class="line">    <span class="comment">// 3.总页数</span></span><br><span class="line">    System.out.println(<span class="string">&quot;pages = &quot;</span> + p.getPages());</span><br><span class="line">    <span class="comment">// 4.数据</span></span><br><span class="line">    List&lt;User&gt; records = p.getRecords();</span><br><span class="line">    records.forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>其中<code>Page</code>的常见API</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">pageNo</span> <span class="operator">=</span> <span class="number">1</span>, pageSize = <span class="number">5</span>;</span><br><span class="line"><span class="comment">// 分页参数</span></span><br><span class="line">Page&lt;User&gt; page = Page.of(pageNo, pageSize);</span><br><span class="line"><span class="comment">// 排序参数, 通过OrderItem来指定</span></span><br><span class="line">page.addOrder(<span class="keyword">new</span> <span class="title class_">OrderItem</span>(<span class="string">&quot;balance&quot;</span>, <span class="literal">false</span>));</span><br><span class="line"></span><br><span class="line">userService.page(page);</span><br></pre></td></tr></table></figure></li></ul><h2 id="4-2-通用分页实体"><a href="#4-2-通用分页实体" class="headerlink" title="4.2 通用分页实体"></a>4.2 通用分页实体</h2><h4 id="4-2-1-比较规范的用户分页查询接口"><a href="#4-2-1-比较规范的用户分页查询接口" class="headerlink" title="4.2.1 比较规范的用户分页查询接口"></a>4.2.1 比较规范的用户分页查询接口</h4><ul><li><p>请求方式：GET</p></li><li><p>请求路径：<code>/users/page</code></p></li><li><p>请求参数：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;pageNo&quot;</span><span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;pageSize&quot;</span><span class="punctuation">:</span> <span class="number">5</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;sortBy&quot;</span><span class="punctuation">:</span> <span class="string">&quot;balance&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;isAsc&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;o&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;status&quot;</span><span class="punctuation">:</span> <span class="number">1</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure></li><li><p>返回值</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;total&quot;</span><span class="punctuation">:</span> <span class="number">100006</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;pages&quot;</span><span class="punctuation">:</span> <span class="number">50003</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;list&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="number">1685100878975279298</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;username&quot;</span><span class="punctuation">:</span> <span class="string">&quot;user_9****&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;info&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;age&quot;</span><span class="punctuation">:</span> <span class="number">24</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;intro&quot;</span><span class="punctuation">:</span> <span class="string">&quot;英文老师&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;gender&quot;</span><span class="punctuation">:</span> <span class="string">&quot;female&quot;</span></span><br><span class="line">            <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;status&quot;</span><span class="punctuation">:</span> <span class="string">&quot;正常&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;balance&quot;</span><span class="punctuation">:</span> <span class="number">2000</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="4-2-2-步骤"><a href="#4-2-2-步骤" class="headerlink" title="4.2.2 步骤"></a>4.2.2 步骤</h4><ul><li><p>定义三个实体</p><ul><li><p><code>UserQuery</code>：分页查询条件的实体，包含分页、排序参数、过滤条件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EqualsAndHashCode(callSuper = true)</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@ApiModel(description = &quot;用户查询条件实体&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserQuery</span> <span class="keyword">extends</span> <span class="title class_">PageQuery</span> &#123;</span><br><span class="line">    <span class="meta">@ApiModelProperty(&quot;用户名关键字&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="meta">@ApiModelProperty(&quot;用户状态：1-正常，2-冻结&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Integer status;</span><br><span class="line">    <span class="meta">@ApiModelProperty(&quot;余额最小值&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Integer minBalance;</span><br><span class="line">    <span class="meta">@ApiModelProperty(&quot;余额最大值&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Integer maxBalance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@ApiModel(description = &quot;分页查询实体&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PageQuery</span> &#123;</span><br><span class="line">    <span class="meta">@ApiModelProperty(&quot;页码&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Integer pageNo;</span><br><span class="line">    <span class="meta">@ApiModelProperty(&quot;页码&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Integer pageSize;</span><br><span class="line">    <span class="meta">@ApiModelProperty(&quot;排序字段&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String sortBy;</span><br><span class="line">    <span class="meta">@ApiModelProperty(&quot;是否升序&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Boolean isAsc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>PageDTO</code>：分页结果实体，包含总条数、总页数、当前页数据</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@ApiModel(description = &quot;分页结果&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PageDTO</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="meta">@ApiModelProperty(&quot;总条数&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Long total;</span><br><span class="line">    <span class="meta">@ApiModelProperty(&quot;总页数&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Long pages;</span><br><span class="line">    <span class="meta">@ApiModelProperty(&quot;集合&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;T&gt; list;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>UserVO</code>：用户页面视图实体</p></li></ul></li><li><p>开发接口：在<code>UserController</code>中定义分页查询用户的接口</p></li></ul><link rel="stylesheet" href="https://cdn1.tianli0.top/gh/zhheo/Post-Abstract-AI@0.15.2/tianli_gpt.css"><script>let tianliGPT_postSelector = '#post #article-container';let tianliGPT_key = 'c9b7741d290063ab872e';</script><script src="https://cdn1.tianli0.top/gh/zhheo/Post-Abstract-AI@0.15.2/tianli_gpt.js"></script>]]></content>
      
      
      <categories>
          
          <category> 中间件/框架 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java中级 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SSM</title>
      <link href="/posts/54284.html"/>
      <url>/posts/54284.html</url>
      
        <content type="html"><![CDATA[<h1 id="Ⅰ-Spring"><a href="#Ⅰ-Spring" class="headerlink" title="Ⅰ Spring"></a>Ⅰ Spring</h1><ul><li><p>核心</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/SSM.assets/image-20230914211135926.png" alt="image-20230914211135926"></p></li></ul><h2 id="一-Ioc"><a href="#一-Ioc" class="headerlink" title="一 Ioc"></a>一 Ioc</h2><h3 id="1-1-概念"><a href="#1-1-概念" class="headerlink" title="1.1 概念"></a>1.1 概念</h3><ul><li><p>IOC（Inversion Of Control）控制反转</p></li><li><p>使用对象的时候，由主动new产生对象转为外部提供对象，此过程的对象创建控制权由程序转移到<strong>外部</strong>，这个思想称为控制反转</p></li><li>Spring提供了一个容器，称为<strong>Ioc容器</strong>，用来充当Ioc思想中的“外部”</li><li>被创建或者管理的对象在Ioc容器中统一称为<strong>Bean</strong></li><li>DI(Dependecy Injection)<strong>依赖注入</strong>：在容器中建立Bean与Bean之间的依赖关系的整个过程称为依赖注入</li><li>目标：<strong>充分解耦</strong></li><li>最终效果：使用对象的时候不仅可以直接从Ioc容器中获取，并且获取到的Bean已经绑定了所有的依赖关系</li></ul><h3 id="1-2-IOC-demo"><a href="#1-2-IOC-demo" class="headerlink" title="1.2 IOC demo"></a>1.2 IOC demo</h3><ul><li>maven中导入spring坐标 spring-context</li><li>在xml文件中配置bean<ul><li><code>&lt;bean id = &quot;bookDao123&quot; class=&quot;com.itheima.dao.impl.BookDaoImpl&quot;/&gt;</code><ul><li>id为给bean起的名字</li><li>class属性表示给bean定义类型（是实现类而不是接口）</li></ul></li></ul></li><li>获取IoC容器<ul><li><code>ApplicationContext ctx = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);</code><ul><li>applicationContext. xml是上一步的配置文件</li></ul></li></ul></li><li>获取bean <ul><li><code>BookDao bookDao = (BookDao) ctx.getBean(&quot;bookDao123&quot;);</code></li></ul></li></ul><h3 id="1-3-DI-demo"><a href="#1-3-DI-demo" class="headerlink" title="1.3 DI demo"></a>1.3 DI demo</h3><ul><li><p>分析</p><ul><li>基于IoC管理bean</li><li>Service中使用new的形式创建Dao对象不再保留（为了解耦）</li><li>Service中需要的Dao对象如何进入到Service中（提供方法）</li><li>Service和Dao之间的关系如何描述（by配置文件）</li></ul></li><li><p>删除上一个demo中new的方式创建对象</p></li><li><p>在xml中配置Service和Dao的关系</p><ul><li><p>```xml<br><bean id = "bookService" class="com.itheima.service.impl.BookServiceImpl"></p><pre><code>&lt;!-- 配置Service和Dao的关系 --&gt;&lt;property name=&quot;bookDao&quot; ref=&quot;bookDao123&quot;/&gt;</code></pre><p>&lt;/bean&gt;</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  - property表示配置当前的bean属性</span><br><span class="line"></span><br><span class="line">  - name表示配置哪一个具体的属性（就是BookServiceImpl这个类的属性值的名称，里面 `private BookDao123 bookDao ` ）</span><br><span class="line"></span><br><span class="line">  - ref表示参照哪一个bean  </span><br><span class="line"></span><br><span class="line">### 1.4 Bean</span><br><span class="line"></span><br><span class="line">#### 1.4.1 bean配置</span><br><span class="line"></span><br><span class="line">-  默认单例模式</span><br><span class="line">  - `&lt;bean id = &quot;bookDao123&quot; class=&quot;com.itheima.dao.impl.BookDaoImpl&quot; scope=&quot;prototype&quot;/&gt;`</span><br><span class="line">    - scope默认为singleton（单例）</span><br><span class="line">  - 为什么？高效</span><br><span class="line">  - 适合交给容器管理的bean</span><br><span class="line">    - 表现层、业务层、数据层、工具对象</span><br><span class="line">  - 不适合的</span><br><span class="line">    - 封装实体的域对象</span><br><span class="line">- 多命名方式</span><br><span class="line"></span><br><span class="line">#### 1.4.2 bean实例化</span><br><span class="line"></span><br><span class="line">- 方式一：本质上是对象，使用**无参构造**方法创建，故需要提供无参构造方法</span><br><span class="line"></span><br><span class="line">- **如何看报错**：从下往上看，第一行是连着下面的所有提示</span><br><span class="line"></span><br><span class="line">- 方式二：使用静态工厂初始化对象（使用较少，以前用的多）</span><br><span class="line"></span><br><span class="line">  - `&lt;bean id = &quot;orderDao&quot; class=&quot;com.itheima.factory.OrderDaoFactory&quot; factory-method=&quot;getOrderDao&quot;/&gt;`</span><br><span class="line">  - `OrderDaoFactory`类是工厂类，里面提供了一个静态方法`getOrderDao()`new了一个对象</span><br><span class="line"></span><br><span class="line">- 方式三：使用实例工厂初始化对象（了解）</span><br><span class="line"></span><br><span class="line">  - `&lt;bean id = &quot;userFactory&quot; class=&quot;com.itheima.factory.UserDaoFactory&quot;/&gt;`</span><br><span class="line">  - `&lt;bean id = &quot;userDao&quot; factory-method=&quot;getUserDao&quot; factory-bean=&quot;userFactory&quot;&gt;`</span><br><span class="line">  -  第一行先创建了工厂的实例对象</span><br><span class="line">  - 第二行使用`userFactory`工厂对象的`getUserDao`方法创建了对象</span><br><span class="line">  - 实际上userFactory没什么意义（只是创建了调用了他的创建对象的方法）</span><br><span class="line"></span><br><span class="line">- 方法四：改良方法三（框架们用的很多）</span><br><span class="line"></span><br><span class="line">  - 创建一个工厂bean引入接口FactoryBean</span><br><span class="line"></span><br><span class="line">    ```java</span><br><span class="line">    public class UserDaoFactoryBean implements FactoryBean&lt;UserDao&gt;&#123;</span><br><span class="line">    public UserDao getObject() throws Exception &#123;</span><br><span class="line">            return new UserDaoImpl();</span><br><span class="line">        &#125;</span><br><span class="line">        public Class&lt;?&gt; getObjectType()&#123;</span><br><span class="line">            return UserDao.class;</span><br><span class="line">        &#125;</span><br><span class="line">        public boolean isSingleton()&#123;</span><br><span class="line">            return false;//false表示非单例，true表示单例，通常都是单例的</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li><p>配置bean</p><p><code>&lt;bean id = &quot;userDao&quot; class=&quot;com.itheima.factory.UserDaoFactoryBean&quot;&gt;</code></p></li></ul></li></ul><h4 id="1-4-3-bean的生命周期"><a href="#1-4-3-bean的生命周期" class="headerlink" title="1.4.3 bean的生命周期"></a>1.4.3 bean的生命周期</h4><ul><li><p>配置bean的初始化、销毁时候的方法</p><ul><li>```xml<br><bean id = "bookDao123" class="com.itheima.dao.impl.BookDaoImpl" init-method="initm" destroy-method="destroym"/><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  - 其中`initm`和`destroym`为类中定义的方法</span><br><span class="line">  - 改进，实现类继承`initializingBean`和`DisposableBean`两个接口，然后实现`afterPropertiesSet`和`destroy`方法，配置文件中就不要init-method和destroy-method了</span><br><span class="line"></span><br><span class="line">- 生命周期</span><br><span class="line"></span><br><span class="line">  - 初始化容器</span><br><span class="line">    - 创建对象（分配内存）</span><br><span class="line">    - 执行构造方法</span><br><span class="line">    - 执行属性注入（set操作）</span><br><span class="line">    - **执行bean初始化方法**</span><br><span class="line">  - 使用bean</span><br><span class="line">  - 关闭/销毁容器（手工关闭/注册关闭钩子）</span><br><span class="line">    - **执行bean的销毁方法**</span><br><span class="line"></span><br><span class="line">### 1.5 DI</span><br><span class="line"></span><br><span class="line">#### 1.5.1 简介</span><br><span class="line"></span><br><span class="line">- 向一个类中传递数据的方式：普通方法（set）和构造方法</span><br><span class="line">- 注入数据种类：引用类型和简单类型</span><br><span class="line">- DI方式（四种）</span><br><span class="line">  - setter注入：简单类型/引用类型</span><br><span class="line">  - 构造器注入：简单类型/引用类型 </span><br><span class="line"></span><br><span class="line">#### 1.5.2 setter注入引用类型</span><br><span class="line"></span><br><span class="line">![image-20230914224440089](https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/SSM.assets/image-20230914224440089.png)</span><br><span class="line"></span><br><span class="line">- 如果有多个属性就写多行`&lt;property&gt;`标签</span><br><span class="line"></span><br><span class="line">#### 1.5.3 setter注入简单类型</span><br><span class="line"></span><br><span class="line">- 在对象中定义简单类型（int、String等）并生成set方法</span><br><span class="line">- 在配置文件中同样是`&lt;property&gt;`标签，只不过ref变为 `value=&quot;&quot;`</span><br><span class="line"></span><br><span class="line">#### 1.5.4 构造器注入</span><br><span class="line"></span><br><span class="line">- 配置文件中</span><br><span class="line"></span><br><span class="line">```xml</span><br><span class="line">&lt;bean id = &quot;bookService&quot; class=&quot;com.itheima.dao.impl.bookServiceImpl&quot;&gt;</span><br><span class="line">    &lt;constructor-arg name=&quot;bookDao&quot; ref=&quot;bookDao123&quot;&gt; </span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure></li></ul></li><li><p><code>name</code>中的名字是构造方法中形参的名字（<strong>会导致耦合度较高的问题</strong>）</p><ul><li>解决方案：用type来代替name，但是会导致多个同类型的参数无法分配的问题；用index代替name，也有一点问题</li></ul></li><li><code>ref</code> 是配置文件中bean的id</li><li>如果是简单类型则<code>ref</code>变为<code>value</code></li></ul><h4 id="1-5-5-怎么选"><a href="#1-5-5-怎么选" class="headerlink" title="1.5.5  怎么选"></a>1.5.5  怎么选</h4><ul><li>强制依赖使用构造器注入，使用setter注入有概率不进行注入导致null对象出现</li><li>可选依赖使用setter注入</li><li>Spring倡导使用构造器，第三方框架内部多数采用构造器注入</li><li>自己开发的模块推荐setter注入</li></ul><h4 id="1-5-6-自动装配"><a href="#1-5-6-自动装配" class="headerlink" title="1.5.6 自动装配"></a>1.5.6 自动装配</h4><ul><li>IoC容器根据bean所依赖的资源在容器中自动查找并注入到bean的过程称为自动装配</li><li>方式：按类型（常用）、按名称、按构造方法<ul><li>用于引用类型的依赖注入</li></ul></li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span> = <span class="string">&quot;bookDao123&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.dao.impl.BookDaoImpl&quot;</span> <span class="attr">autowire</span>=<span class="string">&quot;byType&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><ul><li>注意：上述方法需要先在类中设置set方法</li><li><code>byType</code>改为<code>byName</code>就是按名称<ul><li>按名称必须保障容器中具有指定名称的bean，因变量与配置耦合，不推荐使用</li></ul></li><li>自动装配优先级低于setter注入与构造器注入，同时出现的时候自动装配配置失效</li></ul><h4 id="1-5-7-集合注入"><a href="#1-5-7-集合注入" class="headerlink" title="1.5.7 集合注入"></a>1.5.7 集合注入</h4><ul><li>list、set、map、properties</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span> = <span class="string">&quot;bookDao123&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.dao.impl.BookDaoImpl&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;myList&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>100<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>200<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span> = <span class="string">&quot;...&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;mySet&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">set</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>man<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>yi<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;myMap&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">map</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">&quot;country&quot;</span> <span class="attr">value</span>=<span class="string">&quot;china&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">&quot;city&quot;</span> <span class="attr">value</span>=<span class="string">&quot;changsha&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">map</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;myProperty&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">props</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">props</span> <span class="attr">key</span>=<span class="string">&quot;country&quot;</span>&gt;</span>china<span class="tag">&lt;/<span class="name">props</span>&gt;</span> </span><br><span class="line">            <span class="tag">&lt;<span class="name">props</span> <span class="attr">key</span>=<span class="string">&quot;city&quot;</span>&gt;</span>changsha<span class="tag">&lt;/<span class="name">props</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;/<span class="name">props</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="1-6-加载properties文件"><a href="#1-6-加载properties文件" class="headerlink" title="1.6 加载properties文件"></a>1.6 加载properties文件</h3><ul><li><p>xml文件头开命名空间（灰色的三行，直接copy然后beans换为context）</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/SSM.assets/image-20230915105033303.png" alt="image-20230915105033303"></p></li><li><p>使用context空间加载properties文件</p></li></ul><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/SSM.assets/image-20230915105158137.png" alt="image-20230915105158137"></p><ul><li>使用properties的数据（通过<code>$&#123;&#125;</code>引用外部properties中的值）</li></ul><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/SSM.assets/image-20230915105233506.png" alt="image-20230915105233506"></p><ul><li>注意<ul><li>加载多个properties 在第二步的时候location后面加逗号连接，也可以写为<code>*.properties</code>或者 <code>classpath:*.properties</code>（推荐使用第二种）<ul><li>最佳为<code>classpath*:*.properties</code>区别是这个还可以加载导入的jar包里面的properties</li></ul></li></ul></li></ul><h3 id="1-7-容器总结"><a href="#1-7-容器总结" class="headerlink" title="1.7 容器总结"></a>1.7 容器总结</h3><ul><li><p>加载容器</p><ul><li><p>类路径加载（常用）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Applicationcontext</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;applicationContext.xml&quot;</span>);</span><br></pre></td></tr></table></figure></li><li><p>文件系统加载</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Applicationcontext</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileSystemXmlApplicationContext</span>(<span class="string">&quot;绝对路径&quot;</span>)</span><br></pre></td></tr></table></figure></li></ul></li><li><p>获取bean，三种方式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">BookDao</span> <span class="variable">bookDao</span> <span class="operator">=</span> (BookDao) ctx.getBean(<span class="string">&quot;bookDao&quot;</span>);</span><br><span class="line"><span class="type">BookDao</span> <span class="variable">bookDao</span> <span class="operator">=</span> ctx.getBean(<span class="string">&quot;bookDao&quot;</span>, BookDao.class);</span><br><span class="line"><span class="type">BookDao</span> <span class="variable">bookDao</span> <span class="operator">=</span> ctx.getBean(BookDao.class);</span><br></pre></td></tr></table></figure></li><li><p><code>Beanfactory</code>是IoC容器的顶层接口，初始化的时候加载的bean延迟加载</p></li><li><p><code>Applicationcontext</code>接口是Spring的核心接口，初始化的时候bean立即加载</p><ul><li><code>ClassPathXmlApplicationContext</code>和<code>FileSystemXmlApplicationContext</code>是其常用的初始化类</li></ul></li><li><p>bean相关的标签</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span></span></span><br><span class="line"><span class="tag"><span class="attr">id</span> = <span class="string">&quot;&quot;</span>       <span class="attr">bean的id</span></span></span><br><span class="line"><span class="tag"><span class="attr">name</span> = <span class="string">&quot;&quot;</span>   <span class="attr">bean的别名</span></span></span><br><span class="line"><span class="tag"><span class="attr">class</span> = <span class="string">&quot;&quot;</span>   <span class="attr">bean的类型</span>，<span class="attr">静态工厂类</span>，<span class="attr">FactoryBean类</span></span></span><br><span class="line"><span class="tag"><span class="attr">scope</span> = <span class="string">&quot;&quot;</span>   <span class="attr">控制bean实例数量</span></span></span><br><span class="line"><span class="tag"><span class="attr">init-method</span> = <span class="string">&quot;&quot;</span>   <span class="attr">生命周期初始化方法</span></span></span><br><span class="line"><span class="tag"><span class="attr">destroy-method</span> = <span class="string">&quot;&quot;</span>    <span class="attr">生命周期销毁方法</span></span></span><br><span class="line"><span class="tag"><span class="attr">autowoire</span> = <span class="string">&quot;&quot;</span>   <span class="attr">自动装配类型</span></span></span><br><span class="line"><span class="tag"><span class="attr">factory-method</span> = <span class="string">&quot;&quot;</span>    <span class="attr">bean工厂方法</span>，<span class="attr">应用于静态工厂或实例工厂</span></span></span><br><span class="line"><span class="tag"><span class="attr">factory-bean</span> = <span class="string">&quot;&quot;</span>   <span class="attr">实例工厂bean</span></span></span><br><span class="line"><span class="tag"><span class="attr">lazy-init</span> = <span class="string">&quot;&quot;</span>   <span class="attr">控制bean延迟加载</span></span></span><br><span class="line"><span class="tag">/&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="1-8-注解开发"><a href="#1-8-注解开发" class="headerlink" title="1.8 注解开发"></a>1.8 注解开发</h3><h4 id="1-8-1-注解开发定义bean"><a href="#1-8-1-注解开发定义bean" class="headerlink" title="1.8.1 注解开发定义bean"></a>1.8.1 注解开发定义bean</h4><ul><li>使用<code>@component</code>定义Bean</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@component(&quot;bookDao&quot;)</span><span class="comment">//指定了bean的名称为bookDao</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookDapImpl</span> <span class="keyword">implements</span> <span class="title class_">BooDao</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>核心配置文件中通过组件扫描加载bean</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.itheima&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>Spring提供了三个衍生注解<ul><li><code>@Service</code>、<code>@Repository</code>、<code>@Controller</code></li><li>分别表示业务层、数据层、表现层（为了方便阅读，功能都是一样的）</li></ul></li></ul><h4 id="1-8-2-纯注解开发定义bean"><a href="#1-8-2-纯注解开发定义bean" class="headerlink" title="1.8.2 纯注解开发定义bean"></a>1.8.2 纯注解开发定义bean</h4><ul><li><p>Spring3.0新功能</p></li><li><p>使用配置类代替配置文件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(&quot;com.itheima&quot;)</span></span><br><span class="line"><span class="comment">//或者</span></span><br><span class="line"><span class="meta">@ComponentScan(&#123;&quot;com.itheima.service&quot;, &quot;com.itheima.dao&quot;&#125;)</span></span><br><span class="line"><span class="comment">//因为有些bean可能不能加载</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringConfig</span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>@Configuration</code> ：表示该类为配置类 </li><li><code>@ComponentScan</code>：表示需要扫描的路径</li></ul></li><li><p>加载使用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ApplicationContext</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>(SpringConfig.class)</span><br></pre></td></tr></table></figure></li></ul><h4 id="1-8-3-bean管理"><a href="#1-8-3-bean管理" class="headerlink" title="1.8.3 bean管理"></a>1.8.3 bean管理</h4><ul><li>单例与否<ul><li>在类上添加注解 <code>@Scope(&quot;singleton&quot;)</code></li></ul></li><li>初始化方法：`PostConstruct</li><li>销毁前方法：<code>@reDestroy</code></li></ul><h4 id="1-8-4-依赖注入—自动装配"><a href="#1-8-4-依赖注入—自动装配" class="headerlink" title="1.8.4 依赖注入—自动装配"></a>1.8.4 依赖注入—自动装配</h4><ul><li><p>属性前加注解 <code>@Autowired</code></p><ul><li><p>使用的是反射注入，所以不用set方法</p></li><li><p>如果是简单类型就用 <code>@Value(&quot;值&quot;)</code></p></li><li><p>如果简单类型引用的是配置文件的值</p><ul><li><p>```java<br>@Configuration<br>@ComponentScan(“com.itheima”)<br>@PropertySource({“jdbc.properties”, “user.properties”})// 配置文件清单 不能用*.properties<br>public class SpringConfig {</p><p>}</p><p>//类的定义<br>@Repository(“bookDao”)<br>public class BookDaoIml implements BookDao {</p><pre><code>@Value(&quot;$&#123;name&#125;&quot;)//引入配置文件中的属性值private String name;</code></pre><p>}</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#### 1.8.5 第三方bean管理</span><br><span class="line"></span><br><span class="line">- 第三方bean管理</span><br><span class="line"></span><br><span class="line">  - ```java</span><br><span class="line">    @Configuration</span><br><span class="line">    @Import(&#123;JdbcConfig.class, ...&#125;)//3 导入配置类</span><br><span class="line">    public class SpringConfig &#123;</span><br><span class="line">       </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    // 0 新建一个配置类（也可以写在主配置类SpringConfig中，但是bean多了不好管理）</span><br><span class="line">    public class JdbcConfig &#123;</span><br><span class="line">        </span><br><span class="line">        @Value(&quot;driver&quot;)// 4 引入外部配置文件中的简单类型数据</span><br><span class="line">        private String driver;</span><br><span class="line">        @Value(&quot;url&quot;)</span><br><span class="line">        private String url;</span><br><span class="line">        @Value(&quot;userName&quot;)</span><br><span class="line">        private String userName;</span><br><span class="line">        @Value(&quot;password&quot;)</span><br><span class="line">        private String password;</span><br><span class="line">        </span><br><span class="line">        // 1 定义一个方法获得要管理的对象</span><br><span class="line">        // 2 添加@Bean表示当前方法的返回值是一个bean</span><br><span class="line">        @Bean</span><br><span class="line">        public DataSource dataSource(BookDao bookdao)&#123;</span><br><span class="line">            </span><br><span class="line">            System.out.println(bookdao.name);// 5 引用类型数据的自动装配</span><br><span class="line">            </span><br><span class="line">            DruidDataSource ds = new DruidDataSource();</span><br><span class="line">            ds.setDriverClassName(driver);</span><br><span class="line">            ds.setUrl(url);</span><br><span class="line">            ds.setUsername(userName);</span><br><span class="line">            ds.setPassword(password);</span><br><span class="line">            return ds;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul></li><li><p>第三方bean依赖注入（上段代码第4、5点）</p></li></ul><h3 id="1-9-注解总结"><a href="#1-9-注解总结" class="headerlink" title="1.9 注解总结"></a>1.9 注解总结</h3><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/SSM.assets/image-20230916143320550.png" alt="image-20230916143320550"></p><h2 id="二-框架整合"><a href="#二-框架整合" class="headerlink" title="二 框架整合"></a>二 框架整合</h2><h3 id="2-1-Spring整合MyBatis"><a href="#2-1-Spring整合MyBatis" class="headerlink" title="2.1 Spring整合MyBatis"></a>2.1 Spring整合MyBatis</h3><ul><li>（项目Spring_MyBatis）</li></ul><h4 id="2-1-1-MyBatis核心步骤"><a href="#2-1-1-MyBatis核心步骤" class="headerlink" title="2.1.1 MyBatis核心步骤"></a>2.1.1 MyBatis核心步骤</h4><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/SSM.assets/image-20230916144055956.png" alt="image-20230916144055956"></p><ul><li>主要就是SqlSessionFactory对象</li></ul><h4 id="2-1-2-整合步骤"><a href="#2-1-2-整合步骤" class="headerlink" title="2.1.2 整合步骤"></a>2.1.2 整合步骤</h4><ul><li><p>新建一个MybatisConfig类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MybatisConfig</span> &#123;</span><br><span class="line">    <span class="comment">//定义bean，SqlSessionFactoryBean，用于产生SqlSessionFactory对象</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> SqlSessionFactoryBean <span class="title function_">sqlSessionFactory</span><span class="params">(DataSource dataSource)</span>&#123;</span><br><span class="line">        <span class="type">SqlSessionFactoryBean</span> <span class="variable">ssfb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SqlSessionFactoryBean</span>();</span><br><span class="line">        ssfb.setTypeAliasesPackage(<span class="string">&quot;com.itheima.domain&quot;</span>);<span class="comment">//设置类型别名的包</span></span><br><span class="line">        ssfb.setDataSource(dataSource); <span class="comment">// 设置数据库</span></span><br><span class="line">        <span class="keyword">return</span> ssfb;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//定义bean，返回MapperScannerConfigurer对象</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> MapperScannerConfigurer <span class="title function_">mapperScannerConfigurer</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">MapperScannerConfigurer</span> <span class="variable">msc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MapperScannerConfigurer</span>();</span><br><span class="line">        msc.setBasePackage(<span class="string">&quot;com.itheima.dao&quot;</span>); <span class="comment">// 设置扫描的包</span></span><br><span class="line">        <span class="keyword">return</span> msc;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="2-2-Spring整合JUnit"><a href="#2-2-Spring整合JUnit" class="headerlink" title="2.2 Spring整合JUnit"></a>2.2 Spring整合JUnit</h3><ul><li>在Maven配置文件中导入JUnit坐标</li><li><p>基本固定三步如下</p></li><li><p>```java<br>@RunWith(SpringJUnit4ClassRunner.class)//1 指定类运行器<br>@ContextConfiguration(classes = SpringConfig.class)//2 指定Spring配置类<br>public class AccountServiceTest {</p><pre><code>@AutoWired//3 自动装配beanprivate AccountService accountService;@Testpublic void testFindById()&#123;     System.out.println(accountService.findById(1));   &#125;</code></pre><p>}</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">## 三  AOP</span><br><span class="line"></span><br><span class="line">### 3.1 概念</span><br><span class="line"></span><br><span class="line">- AOP（Aspect Oriented Programming）：面向切面编程，一种编程范式，指导开发者如何组织程序结构</span><br><span class="line">- 作用：在不惊动原始设计的基础上为其进行功能增强</span><br><span class="line">- Spring理念：无入侵式编程</span><br><span class="line"></span><br><span class="line">### 3.2 AOP概念</span><br><span class="line"></span><br><span class="line">- 连接点（JoinPoint）：程序执行过程中的任意位置，粒度为执行方法、抛出异常、设置变量等</span><br><span class="line">  - 在Spring AOP中，理解为方法的执行</span><br><span class="line">- 切入点（Pointcut）：匹配连接点的式子</span><br><span class="line">  - 在Spring AOP中，一个切入点可以只描述一个具体的方法，也可以匹配多个方法</span><br><span class="line">    - 一个具体方法：com.itheima.dao包下单BookDao接口中的无形参无返回值的save方法</span><br><span class="line">    - 匹配多个方法：所有的save方法，所有的get开头的方法，所有以Dao结尾的接口方法，所有带有一个参数的方法</span><br><span class="line">- 通知（Adcive）：在切入点处执行的操作，也就是共性功能</span><br><span class="line">  - 在Spring AOP中功能最终以方法的形式呈现</span><br><span class="line">- 通知类：定义通知的类</span><br><span class="line">- 切面（Aspect）：描述通知于切入点的对应关系</span><br><span class="line"></span><br><span class="line">### 3.3 AOP demo</span><br><span class="line"></span><br><span class="line">-  开发模式：XML或者注解</span><br><span class="line"></span><br><span class="line">- 思路分析</span><br><span class="line"></span><br><span class="line">  - 1 导入坐标</span><br><span class="line"></span><br><span class="line">    - aspectjweaver</span><br><span class="line">    - spring-context</span><br><span class="line"></span><br><span class="line">  - 2 制作连接点方法（原始操作，Dao接口与实现类）</span><br><span class="line"></span><br><span class="line">  - 3 制作共性功能（通知类与通知）</span><br><span class="line"></span><br><span class="line">    - 创建一个新的类</span><br><span class="line"></span><br><span class="line">    - ```java</span><br><span class="line">      @Component   //Spring会扫描它当作一个bean</span><br><span class="line">      @Aspect      //告诉Spring这是一个AOP</span><br><span class="line">      public class MyAdvice &#123;</span><br><span class="line">          @Pointcur(&quot;execution(void com.itheima.dao.BookDao.update())&quot;)// 4 切入点定义</span><br><span class="line">          private void pt()&#123;&#125;</span><br><span class="line">          </span><br><span class="line">          @Before(&quot;pt()&quot;)// 5 绑定切入点与通知的关系</span><br><span class="line">      public void method()&#123;</span><br><span class="line">      //方法体</span><br><span class="line">      &#125;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure><ul><li><p>在Spring配置类中添加注解 @EnableAspectJAutoProxy</p></li><li><p>```java<br>@Configuration<br>@ComponentScan(“com.itheima”)<br>@EnableAspectJAutoProxy<br>public class SpringConfig {<br>}</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  - 4 定义切入点</span><br><span class="line"></span><br><span class="line">  - 5 绑定切入点与通知关系</span><br><span class="line"></span><br><span class="line">  - 结果：运行 `com.itheima.dao.BookDao.update()`的方法的时候在执行完update的内容前会额外执行MyAdvice中的`method()`的内容</span><br><span class="line"></span><br><span class="line">### 3.4 AOP工作流程</span><br><span class="line"></span><br><span class="line">- Spring容器启动</span><br><span class="line">- 读取所有切面配置中的切入点</span><br><span class="line">- 初始化bean，判定bean对应的类中的方法是否匹配到任意切入点</span><br><span class="line">  - 匹配失败，创建对象</span><br><span class="line">  - 匹配成功，创建原始对象（目标对象）的代理对象</span><br><span class="line">- 获取bean执行方法</span><br><span class="line">  - 获取bean，调用方法并执行，完成操作</span><br><span class="line">  - 获取的bean是代理对象的时候，根据代理对象的运行模式运行原始方法与增强的内容，完成操作</span><br><span class="line">- **AOP本质：代理模式**</span><br><span class="line"></span><br><span class="line">### 3.5 AOP切入点表达式</span><br><span class="line"></span><br><span class="line">- 切入点：要进行增强的方法</span><br><span class="line"></span><br><span class="line">- 切入点表达式：要进行增强的方法的描述方式</span><br><span class="line"></span><br><span class="line">- 切入点表达式标准格式：</span><br><span class="line"></span><br><span class="line">  - `动作关键字（访问修饰符 返回值 包名.类/接口名.方法名(参数) 异常名）`</span><br><span class="line">  - `execution(void com.itheima.dao.BookDao.update())`</span><br><span class="line">  - 动作关键字：描述切入点的行为动作，如execution表示执行到指定切入点</span><br><span class="line">  - 访问修饰符：public,private等，可以省略</span><br><span class="line">  - 异常名：方法中定义抛出的指定异常，可以省略</span><br><span class="line"></span><br><span class="line">- 可以使用通配符描述切入点，快速描述</span><br><span class="line"></span><br><span class="line">  - `*`：单个独立的任意符号，可以独立出现，也可以作为前缀或者后缀匹配符</span><br><span class="line"></span><br><span class="line">    - `execution(public * com.itheima.*.UserService.find*(*))`：</span><br><span class="line"></span><br><span class="line">      匹配 com.itheima下的任意包的UserService类或接口中所有find开头的带一个参数的方法</span><br><span class="line"></span><br><span class="line">  - `..`：多个连续的任意符号，可以独立出现，常用于简化包名与参数的书写</span><br><span class="line"></span><br><span class="line">    - `execution(public User com..UserService.findById(..))`：</span><br><span class="line"></span><br><span class="line">      匹配com包下任意包中的UserService类或接口中所有名称为findById的方法</span><br><span class="line"></span><br><span class="line">  - `+`：专用于匹配子类类型</span><br><span class="line"></span><br><span class="line">- 规范</span><br><span class="line"></span><br><span class="line">  ![image-20230917231842486](https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/SSM.assets/image-20230917231842486.png)</span><br><span class="line"></span><br><span class="line">### 3.6 AOP通知类型</span><br><span class="line"></span><br><span class="line">- AOP通知类型：前置通知、后置通知、环绕通知（重点）、返回后通知、抛出异常后通知</span><br><span class="line"></span><br><span class="line">  - 前置通知：`@Before()`</span><br><span class="line"></span><br><span class="line">  - 后置通知：`@After()`</span><br><span class="line"></span><br><span class="line">  - 环绕通知：`@Aroud()`（功能最强大）</span><br><span class="line"></span><br><span class="line">    - ```java</span><br><span class="line">      @Aroud(&quot;pt()&quot;)</span><br><span class="line">      public Object aroud(ProccdingJoinPoint pjp)&#123;</span><br><span class="line">      //前置操作</span><br><span class="line">          </span><br><span class="line">      Object ret = pjp.proceed();</span><br><span class="line">          </span><br><span class="line">      //后置操作</span><br><span class="line">          </span><br><span class="line">          return ret;//这里的ret是原始方法的返回值，如果原始方法是void就不需要return</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>返回后通知：<code>@AfterReturning()</code></p></li><li><p>抛出异常后通知：<code>@AfterThrowing()</code></p></li></ul></li></ul><h3 id="3-7-案例：测试业务曾接口万次执行效率"><a href="#3-7-案例：测试业务曾接口万次执行效率" class="headerlink" title="3.7 案例：测试业务曾接口万次执行效率"></a>3.7 案例：测试业务曾接口万次执行效率</h3><ul><li>需求：任意业务层接口执行均可显示其执行效率（执行时长）</li><li>分析：<ul><li>业务功能：分别获取前后执行的系统时间后取差值</li><li>通知类型选择环绕通知</li></ul></li></ul><h3 id="3-8-AOP通知获取数据"><a href="#3-8-AOP通知获取数据" class="headerlink" title="3.8 AOP通知获取数据"></a>3.8 AOP通知获取数据</h3><ul><li>获取切入点方法的参数<ul><li>JoinPoint：适用于前置、后置、返回后、抛出异常后通知</li><li>ProccdingJoinPoint：适用于环绕通知</li></ul></li><li>获取切入点方法返回值<ul><li>返回后通知</li><li>环绕通知</li></ul></li><li>获取切入点方法运行异常信息<ul><li>环绕通知</li><li>抛出异常后通知</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span>   </span><br><span class="line"><span class="meta">@Aspect</span>     </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyAdvice</span> &#123;</span><br><span class="line">    <span class="meta">@Pointcur(&quot;execution(* com.itheima.dao.BookDao.findName(..))&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">pt</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Before(&quot;pt()&quot;)</span><span class="comment">// 获取切入点方法的参数，同时@After、@Aroud也可以用</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">(JoinPoint jp)</span> &#123;</span><br><span class="line">        Object[] args = jp.getArgs();</span><br><span class="line">        System.out.println(Arrays.toString(args);<span class="comment">//会打印切入点方法的输入参数</span></span><br><span class="line">                           </span><br><span class="line">args[<span class="number">0</span>] = <span class="number">666</span>;<span class="comment">//在这里可以修改传入参数的值，保证程序的正确运行</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//ProccdingJoinPoint是继承自JoinPoint，所以也可以获取输入参数</span></span><br><span class="line">                           </span><br><span class="line">                           </span><br><span class="line">    <span class="meta">@AfterReturning(&quot;pt()&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterReturning</span><span class="params">(Object ret)</span>&#123;</span><br><span class="line">        System.out.println(Arrays.toString(ret);<span class="comment">//获取切入点方法返回值</span></span><br><span class="line">    &#125;</span><br><span class="line">                         </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-9-AOP总结"><a href="#3-9-AOP总结" class="headerlink" title="3.9 AOP总结"></a>3.9 AOP总结</h3><ul><li>是一种编程范式。为了在不惊动原始设计的方法上对功能进行增强</li><li>核心概念<ul><li>代理：SpringAOP核心本质是代理模式</li><li>连接点：SpringAOP中，理解为任意方法的执行</li><li>切入点：匹配连接点的式子，也是具有共性功能的方法描述</li><li>通知：若干个方法的共性功能，在切入点处执行，最终体现为一个方法</li><li>切面：描述通知与切入点的对应关系</li><li>目标对象：被代理的原始对象成为目标对象</li></ul></li></ul><h2 id="四-事务"><a href="#四-事务" class="headerlink" title="四 事务"></a>四 事务</h2><h3 id="4-1-Spring事务简介"><a href="#4-1-Spring事务简介" class="headerlink" title="4.1 Spring事务简介"></a>4.1 Spring事务简介</h3><ul><li>事务作用：在数据层保障一系列的数据库操作同成功同失败</li><li>Spring事务的作用：在数据层或者业务层保障一系列的数据库操作同成功同失败</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">PlatformTransactionManager</span>&#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">commit</span><span class="params">(TransactionStatus status)</span> <span class="keyword">throws</span> TransactionException;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">rollback</span><span class="params">(TransactionStatus status)</span> <span class="keyword">throws</span> TransactionException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-2-银行转账"><a href="#4-2-银行转账" class="headerlink" title="4.2 银行转账"></a>4.2 银行转账</h3><ul><li><p>需求：A账户减钱，B账户加钱</p></li><li><p>分析</p><ul><li>数据层提供基础操作，指定账户减钱(outMoney)，指定账户加钱(inMoney)</li><li>业务层提供转账操作(transfer)，调用加钱与加钱操作</li><li>提供两个账户和操作金额执行转账操作</li><li>基于Spring整合MaBatis环境搭建上述操作</li></ul></li><li><p>步骤</p><ul><li><p>设置事务管理器（是jdbc的）</p><ul><li>```java<br>@Bean<br>public PlatformTransactionManager transactionManager(DataSource dataSource){<pre><code>DataSourceTransactionManager transactionManager = new DataSourceTransactionManager()   transactionManager.setDataSource(dataSource);return transactionManager</code></pre>}<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 在transfer方法上添加注解 `@Transactional`开启事务（在接口中加比较规范）</span><br><span class="line"></span><br><span class="line">- 在Spring配置文件中添加注解，开启事务驱动</span><br><span class="line"></span><br><span class="line">  - ```</span><br><span class="line">    @EnableTransactionManagement</span><br></pre></td></tr></table></figure></li></ul></li></ul></li></ul><h3 id="4-3-Spring事务"><a href="#4-3-Spring事务" class="headerlink" title="4.3 Spring事务"></a>4.3 Spring事务</h3><ul><li><p>事务角色</p><ul><li>事务管理员：发起事务方，在Spring中通常指开启事务的方法</li><li>事务协调员：加入事务方，在Spring中通常指数据层方法，也可以是业务层方法</li></ul></li><li><p>相关配置：在注解上开启</p><ul><li><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/SSM.assets/image-20230919203352637.png" alt="image-20230919203352637"></p></li><li><p>eg: </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transactional(readOnly=&quot;true&quot;, timeout=-1, rollBackFor&#123;IOException.class&#125;)</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>事务传播行为</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/SSM.assets/image-20230919204618495.png" alt="image-20230919204618495"></p></li></ul><h1 id="Ⅱ-SpringMVC"><a href="#Ⅱ-SpringMVC" class="headerlink" title="Ⅱ SpringMVC"></a>Ⅱ SpringMVC</h1><h2 id="一简介"><a href="#一简介" class="headerlink" title="一简介"></a>一简介</h2><h3 id="1-1-概述"><a href="#1-1-概述" class="headerlink" title="1.1 概述"></a>1.1 概述</h3><ul><li><p>SpringMVC技术与Servlet技术功能等同，均属于web层开发技术</p></li><li><p>SpringMVC是一种基于Java实现的MVC模型单独轻量级Web框架（表现层）</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/SSM.assets/image-20230919210256287.png" alt="image-20230919210256287"></p></li><li><p>是做表现层的，之前的Servlet技术也是表现层的技术，但是SpringMVC更简洁</p></li></ul><h3 id="1-2-demo"><a href="#1-2-demo" class="headerlink" title="1.2 demo"></a>1.2 demo</h3><ul><li><p>导入坐标</p><ul><li><code>spring-webmvc</code></li></ul></li><li><p>创建SpringMVC控制器类（等同于Servlet功能）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserControlller</span> &#123;</span><br><span class="line"><span class="meta">@RequestMapping(&quot;/save&quot;)</span><span class="comment">//访问路径</span></span><br><span class="line"><span class="meta">@ResponseBody</span><span class="comment">//返回内容作为响应内容</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">save</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>初始化SpringMVC环境（同Spring环境）设定SpringMVC加载对应的bean</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(&quot;com.itheima.controller&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringConfig</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>初始化Servlet容器，加载SpringMVC环境，并设置SpringMVC技术处理的请求</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/SSM.assets/image-20230919213334716.png" alt="image-20230919213334716"></p></li><li><p>总结：</p><ul><li>一次性工作<ul><li>创建工程，设置服务器，加载工程</li><li>导入坐标</li><li>创建web容器启动类，加载SpringMVC配置，并设置SpringMVC请求拦截路径</li><li>SpringMVC核心配置类（设置配置类，扫描controller包，加载Controller包控制器bean）</li></ul></li><li>多次工作<ul><li>定义处理请求的控制器类</li><li>定义处理请求的控制器方法，并配置映射路径（@RequestMapping）与返回的json数据@ResponseBody</li></ul></li></ul></li></ul><h3 id="1-3-demo工作流程分析"><a href="#1-3-demo工作流程分析" class="headerlink" title="1.3 demo工作流程分析"></a>1.3 demo工作流程分析</h3><ul><li><p>启动服务器初始化过程</p><ul><li>服务器启动，执行ServletContainerInitConfig类，初始化web容器</li><li>执行createServletApplicationContext方法，创建WebApplicationContext对象</li><li>加载SpringMvcConfig</li><li>执行@ComponentScan加载bean</li><li>加载UserController,每个@ResponseBody名称对应一个具体的方法</li><li>执行getServletMappings方法，定义所有请求都通过SpringMVC</li></ul><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/SSM.assets/image-20230919215722107.png" alt="image-20230919215722107"></p></li><li><p>单次请求的过程</p><ul><li>发送请求localhost/save</li><li>web容器发现所有请求都经过SpringMVC，将请求交给SpringMVC处理</li><li>解析请求路径/save</li><li>由/save匹配执行对应的方法save()</li><li>执行save()</li><li>检测到有@ResponseBody直接将save方法的返回值作为响应体返回给请求方</li></ul></li></ul><h3 id="1-4-bean的加载控制"><a href="#1-4-bean的加载控制" class="headerlink" title="1.4 bean的加载控制"></a>1.4 bean的加载控制</h3><ul><li>加载Spring控制的bean的时候，排除SpringMVC的bean<ul><li>方式一：Spring加载的bean设定范围为精确范围（常用）</li><li>方式二：排除controller包（Spring boot有用）</li><li>不区分两者，加载到同一容器</li></ul></li></ul><h3 id="1-5-PostMan简介"><a href="#1-5-PostMan简介" class="headerlink" title="1.5 PostMan简介"></a>1.5 PostMan简介</h3><ul><li>是一款功能强大的网页调试与发送网页HTTP请求的Chrome插件</li><li>作用：用于进行接口测试</li><li>使用：<ul><li>注册登录</li><li>创建工作空间</li><li>发起请求测试结果</li></ul></li></ul><h2 id="二-请求与响应"><a href="#二-请求与响应" class="headerlink" title="二 请求与响应"></a>二 请求与响应</h2><h3 id="2-1-请求映射路径"><a href="#2-1-请求映射路径" class="headerlink" title="2.1 请求映射路径"></a>2.1 请求映射路径</h3><ul><li><p>团队多人开发的时候，每个人设置不同的请求路径，冲突问题如何解决</p><ul><li><p>规范命名</p></li><li><p>定义两层@RequestMapping</p><ul><li>第一层在类上@RequestMapping</li><li>第二层在方法上@RequestMapping</li></ul><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/SSM.assets/image-20230919223005854.png" alt="image-20230919223005854"></p></li></ul></li></ul><h3 id="2-2-请求参数"><a href="#2-2-请求参数" class="headerlink" title="2.2 请求参数"></a>2.2 请求参数</h3><h4 id="2-2-1-请求方式"><a href="#2-2-1-请求方式" class="headerlink" title="2.2.1 请求方式"></a>2.2.1 请求方式</h4><ul><li><p>Get请求</p><ul><li><p><code>localhost:8080/commonparam?name=zhangsan&amp;age=15</code></p></li><li><p>```java<br>@RequestMapping(“/commonparam”)<br>@ResponseBody<br>public String method(String name, int age){</p><pre><code>//方法体</code></pre><p>}</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- Post请求</span><br><span class="line"></span><br><span class="line">#### 2.2.2 参数种类</span><br><span class="line"></span><br><span class="line">- 普通参数：url地址传参，如果请求参数与形参不一致，形参前加注解</span><br><span class="line"></span><br><span class="line">  ```java</span><br><span class="line">  @RequestMapping(&quot;/commonparam&quot;)</span><br><span class="line">  @ResponseBody</span><br><span class="line">  public String method(@RequestParam(&quot;username&quot;) String name, int age)&#123;</span><br><span class="line">      //方法体</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>POJO参数：请求参数名与形参对象属性名相同，定义POJO类型形参即可接收参数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/pojoParam&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">method</span><span class="params">(User user)</span>&#123;</span><br><span class="line">    <span class="comment">//方法体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>嵌套POJO参数：POJO对象中包含POJO对象，则请求参数名与形参对象属性名相同，按照对象层次结构关系即可接收嵌套POJO属性参数</p></li><li><p>数组参数：请求参数名与形参对象属性名相同且请求参数为多个，定义数组类型形参即可接收参数</p></li><li><p>集合保存普通参数：请求参数名与形参集合对象名相同且请求参数为多个，@RequestParam绑定参数关系</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/listParam&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">listParam</span><span class="params">(<span class="meta">@RequestParam</span> List&lt;String&gt; likes)</span>&#123;</span><br><span class="line">    <span class="comment">//方法体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="2-2-3-请求参数传递json数据"><a href="#2-2-3-请求参数传递json数据" class="headerlink" title="2.2.3 请求参数传递json数据"></a>2.2.3 请求参数传递json数据</h4><ul><li><p>步骤</p><ul><li><p>maven导入坐标</p></li><li><p>在postman中定义发送json请求</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/SSM.assets/image-20230920225550371.png" alt="image-20230920225550371"></p></li><li><p>Spring配置类上面添加注解<code>@EnableWebMvc</code>开启json转换为对象的功能</p></li><li><p>在形参前面加入注解 @RequestBody</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/listParamForJson&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">listParam</span><span class="params">(<span class="meta">@RequestBody</span> List&lt;String&gt; likes)</span>&#123;</span><br><span class="line">    <span class="comment">//方法体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>关键是<code>@RequestBody</code>注解</p></li></ul><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/SSM.assets/image-20230920230201329.png" alt="image-20230920230201329"></p><h4 id="2-2-4-日期类数据"><a href="#2-2-4-日期类数据" class="headerlink" title="2.2.4 日期类数据"></a>2.2.4 日期类数据</h4><ul><li><p><code>@DateTimeFormat(pattern=&quot;yyyy-MM-dd&quot;)</code></p></li><li><p><code>@DateTimeFormat(pattern=&quot;yyyy/MM/dd HH:MM:ss&quot;)</code>  可以自定义格式，根据请求参数的格式来设置</p></li><li><p>也有一个默认的格式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/dataParam&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">dataParam</span><span class="params">(<span class="meta">@DateTimeFormat(pattern=&quot;yyyy-MM-dd&quot;)</span> Date date)</span>&#123;</span><br><span class="line">    <span class="comment">//方法体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="2-3-响应json数据"><a href="#2-3-响应json数据" class="headerlink" title="2.3 响应json数据"></a>2.3 响应json数据</h3><h4 id="2-3-1-响应页面"><a href="#2-3-1-响应页面" class="headerlink" title="2.3.1 响应页面"></a>2.3.1 响应页面</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/toJumpPage&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">toJumpPage</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;page.jsp&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-3-2-响应数据"><a href="#2-3-2-响应数据" class="headerlink" title="2.3.2 响应数据"></a>2.3.2 响应数据</h4><ul><li><p>文本数据</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/toText&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">toText</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;response text&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>json数据</p><ul><li><p>POJO对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/toJsonPOJO&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> User <span class="title function_">toJsonPOJO</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">    <span class="keyword">return</span> user;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>返回对象会自动转为json数据</p></li><li><p>POJO集合：返回对象改为返回集合即可</p></li></ul></li><li><p>关键是 <code>@ResponseBody</code>注解，可以将返回值自动转为json数据进行响应</p></li></ul><h2 id="三-REST风格"><a href="#三-REST风格" class="headerlink" title="三 REST风格"></a>三 REST风格</h2><h3 id="3-1-简介"><a href="#3-1-简介" class="headerlink" title="3.1 简介"></a>3.1 简介</h3><ul><li><p>REST（Representational State Transfer），表现形式状态转换</p><ul><li>传统风格<ul><li><code>http://localhost/user/getById?id=1</code></li><li><code>http://localhost/user/saveUser</code></li></ul></li><li>REST风格<ul><li><code>http://localhost/user/1</code></li><li><code>http://localhost/user</code></li></ul></li></ul></li><li><p>优点：</p><ul><li>隐藏资源访问行为，无法通过地址得知对资源是何种操作</li><li>书写简化</li></ul></li><li><p>风格</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/SSM.assets/image-20230920232530706.png" alt="image-20230920232530706"></p></li><li><p>路径+请求方式 ==&gt; 一个资源的访问行为</p></li><li><p>根据REST风格对资源进行访问称为RESTful</p></li></ul><h3 id="3-2-RESTful-demo"><a href="#3-2-RESTful-demo" class="headerlink" title="3.2 RESTful demo"></a>3.2 RESTful demo</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(value = &quot;/users&quot;,method = RequestMethod.POST)</span><span class="comment">// 指定post方式的请求</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">save</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;user save&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RequestMapping(value = &quot;/users/&#123;id&#125;&quot;,method = RequestMethod.DELETE)</span><span class="comment">// 可以动态传入参数</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">delete</span><span class="params">(<span class="meta">@PathVariable</span> Integer id)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;user delete&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>按照REST风格修改相关的请求方法</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/SSM.assets/image-20230920233357258.png" alt="image-20230920233357258"></p><ul><li><p>快速版， 简化注解</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/SSM.assets/image-20230920233657696.png" alt="image-20230920233657696"></p></li></ul><h3 id="3-3-restful-案例"><a href="#3-3-restful-案例" class="headerlink" title="3.3 restful 案例"></a>3.3 restful 案例</h3><p>rest_case项目</p><h2 id="四-SSM整合"><a href="#四-SSM整合" class="headerlink" title="四 SSM整合"></a>四 SSM整合</h2><h3 id="4-1-整合Spring、MyBatis、SpringMVC"><a href="#4-1-整合Spring、MyBatis、SpringMVC" class="headerlink" title="4.1 整合Spring、MyBatis、SpringMVC"></a>4.1 整合Spring、MyBatis、SpringMVC</h3><ul><li><code>com.itheima.config</code>目录下的配置类</li><li><code>pom.xml</code>导入坐标</li></ul><h3 id="4-2-功能模块开发"><a href="#4-2-功能模块开发" class="headerlink" title="4.2 功能模块开发"></a>4.2 功能模块开发</h3><ul><li><code>com.itheima.domain</code>下定义Book类</li><li><code>com.itheima.dao</code>下定义bookDao</li><li><code>com.itheima.service.impl</code>下定义方法接口并与相应实现类</li><li><code>com.itheima.controller</code>下定义BookController实现控制层逻辑</li></ul><h3 id="4-3-接口测试"><a href="#4-3-接口测试" class="headerlink" title="4.3 接口测试"></a>4.3 接口测试</h3><ul><li>在test中创建相应的类与方法进行测试 业务层</li></ul><h3 id="4-4-表现层与前端的接口"><a href="#4-4-表现层与前端的接口" class="headerlink" title="4.4. 表现层与前端的接口"></a>4.4. 表现层与前端的接口</h3><ul><li><p>前端接收数据格式——创建结果模型类，<strong>封装数据到data属性中</strong></p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/SSM.assets/image-20230924210602994.png" alt="image-20230924210602994"></p><p>但是无法确定某一个data是对应者什么操作</p></li><li><p>前端接收数据格式——<strong>封装操作到code属性中</strong></p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/SSM.assets/image-20230924210725312.png" alt="image-20230924210725312"></p><p>但是对于查询来说不知道查询是否成功</p></li><li><p>前端接收数据格式——<strong>封装特殊消息到message(msg)属性中</strong></p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/SSM.assets/image-20230924210959571.png" alt="image-20230924210959571"></p></li><li><p>设置统一数据返回结果类（Controller层）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Result</span> &#123;</span><br><span class="line"><span class="keyword">private</span> Object data;</span><br><span class="line"><span class="keyword">private</span> Integer code;</span><br><span class="line"><span class="keyword">private</span> String msg</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//注意：result类中的字段不是固定的，可以根据需求删减</span></span><br></pre></td></tr></table></figure><p>Controller中的方法的返回值设置为Result</p></li></ul><h3 id="4-5-异常处理"><a href="#4-5-异常处理" class="headerlink" title="4.5 异常处理"></a>4.5 异常处理</h3><ul><li><p>种类</p><ul><li>框架内部异常</li><li>数据层抛出异常：因外部服务器故障</li><li>业务层抛出异常：业务逻辑错误</li><li>表现层抛出异常：收集数据，校验数据等</li><li>工具类抛出异常</li></ul></li><li><p>一般写在<strong>表现层</strong>处理，其他层就往上抛（数据层-&gt;业务层-&gt;表现层），分类处理+AOP思想</p></li><li><p>异常处理器：集中统一的处理项目中的异常（）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.controller;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RestControllerAdvice</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProjectExceptionAdvice</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@ExceptionHandler(Exception.class)</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">doException</span><span class="params">(Exception e)</span> &#123;</span><br><span class="line">        <span class="comment">//自定义异常处理逻辑</span></span><br><span class="line">        System.out.println(e);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Result</span>(<span class="number">666</span>, <span class="literal">null</span>);<span class="comment">//返回错误提示结果给前端</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>项目异常处理方案</p></li></ul><h2 id="五-拦截器"><a href="#五-拦截器" class="headerlink" title="五 拦截器"></a>五 拦截器</h2><h3 id="5-1-概念"><a href="#5-1-概念" class="headerlink" title="5.1 概念"></a>5.1 概念</h3><ul><li><p>拦截器（Interceptor）是一种动态拦截方法调用的机制，在SpringMVC中动态拦截控制器方法的执行</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/SSM.assets/image-20230925201425828.png" alt="image-20230925201425828"></p></li><li><p>作用</p><ul><li>在指定的方法调用前后执行预先设定的代码</li><li>阻止原始方法的执行</li></ul></li><li><p>与过滤器的区别</p><ul><li>归属不同：Filter属于Servlet技术，Interceptor属于SpringMVC技术</li><li>拦截内容不同：Filter对所有访问进行增强，Interceptor仅针对SpringMVC的访问进行增强</li></ul></li></ul><h3 id="5-2-案例"><a href="#5-2-案例" class="headerlink" title="5.2 案例"></a>5.2 案例</h3><ul><li><p>在<code>com.itheima.controller.interceptor</code>包下创建<code>ProjectInterceptor</code>类继承接口<code>HandlerInterceptor</code>并重写方法（3个）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ConComponent</span> <span class="comment">// 让spring能够扫描到</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProjectInterceptor</span> <span class="keyword">implements</span> <span class="title class_">HandlerInterceptor</span>&#123;</span><br><span class="line">    <span class="comment">//preHandle postHandle afterComleption三种方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">preHandle</span><span class="params">(...)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;preHandle...&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;<span class="comment">//如果返回false执行完preHandle就不会执行另外两个了</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postHandle</span><span class="params">(...)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;postHandle...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterCompletion</span><span class="params">(...)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;afterCompletion...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>定义配置类，继承WenMvcConfigurationSupport，实现addInterceptor方法，并添加拦截器访问路径</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/SSM.assets/image-20230925204158055.png" alt="image-20230925204158055"></p></li><li><p>也可以直接在<code>SpringMvcConfig</code>配置类中继承<code>WebMvcConfigurer</code>并重新<code>addInterceptors</code>方法（<strong>但是侵入式较强</strong>）</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/SSM.assets/image-20230925204709765.png" alt="image-20230925204709765"></p></li><li><p>拦截器执行流程</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/SSM.assets/image-20230925205017238.png" alt="image-20230925205017238"></p></li></ul><h3 id="5-3-拦截器参数"><a href="#5-3-拦截器参数" class="headerlink" title="5.3 拦截器参数"></a>5.3 拦截器参数</h3><ul><li>前置处理<code>preHandle</code><ul><li><code>HttpServletRequest request</code>：请求对象</li><li><code>HttpServletResponse response</code>：响应对象</li><li><code>Object handler</code>：被调用的处理器对象，本质上是一个方法对象，对反射技术中的Method对象进行了再包装</li><li>返回值<ul><li>为false，被拦截的处理器将不再执行</li></ul></li></ul></li><li>后置处理<code>postHandle</code><ul><li>多了一个<code>ModelAndView modelAndView</code></li></ul></li><li>完成后处理<code>afterCompletion</code><ul><li>相对于<code>preHandle</code>多了一个<code>Exception ex</code></li></ul></li></ul><h3 id="5-4-拦截器工作流程分析"><a href="#5-4-拦截器工作流程分析" class="headerlink" title="5.4 拦截器工作流程分析"></a>5.4 拦截器工作流程分析</h3><ul><li><p>当配置多个拦截器的时候，形成拦截器链</p></li><li><p>拦截器的运行顺序参照拦截器添加顺序</p></li><li><p>当拦截器中出现对原始处理器的拦截，后面的拦截器均终止运行</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/SSM.assets/image-20230925210234869.png" alt="image-20230925210234869"></p></li></ul><h1 id="Ⅲ-Maven"><a href="#Ⅲ-Maven" class="headerlink" title="Ⅲ Maven"></a>Ⅲ Maven</h1><h2 id="一-分模块开发"><a href="#一-分模块开发" class="headerlink" title="一 分模块开发"></a>一 分模块开发</h2><ul><li>创建不同模块,dao,domain,等都可以拆开</li><li>通过maven指令安装模块到本地仓库(install)</li><li>团队内部开发需要发布模块功能到团队内部可共享的仓库中(<strong>私服</strong>)</li></ul><h2 id="二-依赖管理"><a href="#二-依赖管理" class="headerlink" title="二 依赖管理"></a>二 依赖管理</h2><ul><li>传递性:直接依赖与间接依赖</li><li><p>依赖传递冲突问题</p><ul><li>路径优先:当依赖中出现相同的资源时,层级越深,优先级越低</li><li>声明优先:当资源中相同层级被依赖时,配置顺序靠前的覆盖配置顺序靠后</li><li>特殊优先:当同级配置了相同资源的不同版本,后配置的覆盖先配置的</li></ul></li><li><p>可选依赖:对外隐藏依赖</p><ul><li>在pom中的dependency标签中添加optional标签,true表示隐藏依赖(别人不知道依赖了这个)</li></ul></li><li><p>排除依赖:主动断开依赖</p><ul><li>exclusion</li></ul></li></ul><h2 id="三-继承与聚合"><a href="#三-继承与聚合" class="headerlink" title="三 继承与聚合"></a>三 继承与聚合</h2><h3 id="3-1-聚合"><a href="#3-1-聚合" class="headerlink" title="3.1 聚合"></a>3.1 聚合</h3><ul><li>聚合:将多个模块组织成一个整体,同时进行项目构建的过程成为聚合</li><li>聚合工程:通常是一个不具有业务功能的空工程(有且仅有一个pom文件)</li><li>作用:使用聚合工程可以将多个工程编组,通过对聚合工程进行构建,实现对所包含的模块进行同步构建<ul><li>当工程中某个模块发生更新的时候,必须保障工程中与已更新的模块同步更新,此时使用聚合工程可以批量解决 </li></ul></li><li>聚合工程的构建<ul><li><strong>打包类型设置为pom</strong></li><li><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/SSM.assets/image-20230925220646122.png" alt="image-20230925220646122"></li><li>不用管模块的顺序,实际的时候会根据它们之间的相互关系自动设置构建顺序</li></ul></li></ul><h3 id="3-2-继承"><a href="#3-2-继承" class="headerlink" title="3.2 继承"></a>3.2 继承</h3><ul><li>继承:两个工程之间的关系,子工程可以继承父工程中的配置信息,常见于依赖关系的继承</li><li>作用<ul><li>简化配置</li><li>减少依赖冲突</li></ul></li><li>继承的定义<ul><li><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/SSM.assets/image-20230925221127695.png" alt="image-20230925221127695"></li></ul></li></ul><h2 id="四-属性"><a href="#四-属性" class="headerlink" title="四 属性"></a>四 属性</h2><ul><li><p>在pom中定义属性</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">spring.version</span>&gt;</span>5.2.10.RELEASE<span class="tag">&lt;/<span class="name">spring.version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>然后在坐标中的version标签中的版本改为 <code>$&#123;spring.version&#125;</code>,这样就不用一个一个更新版本了</p></li><li><p>配置文件加载属性</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/SSM.assets/image-20230925222549294.png" alt="image-20230925222549294"></p><ul><li>然后就可以使用<code>$&#123;...&#125;</code>来读取resources下的.propertise文件了</li></ul></li><li><p>版本管理</p><ul><li>工程版本<ul><li>SHAPSHOT（快照版本）<ul><li>项目开发过程中临时输出的版本，成为快照版本</li><li>快照版本会随着开发的进展不断更新</li></ul></li><li>RELEASE（发布版本）<ul><li>项目开发进入到里程碑后，向团队外部发布较为稳定的版本</li></ul></li></ul></li></ul></li></ul><h2 id="五-多环境配置与应用"><a href="#五-多环境配置与应用" class="headerlink" title="五 多环境配置与应用"></a>五 多环境配置与应用</h2><ul><li><p>maven提供配置多种环境的设定，帮助开发者使用过程中快速切换环境</p></li><li><p>pom文件中</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/SSM.assets/image-20230926201922374.png" alt="image-20230926201922374"></p></li><li><p>也可以执行 <code>maven install -P env_test</code> 就不用设置 <code>activation</code> 标签了</p><ul><li><code>mvn 指令 -P 环境定义id</code></li></ul></li><li>跳过测试<ul><li>应用场景<ul><li>功能更新中并且没有开发完毕</li><li>快速打包等</li></ul></li><li><code>mvn 指令 -D skipTest</code></li><li>或者配置插件,在pom中定义</li><li><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/SSM.assets/image-20230926203036479.png" alt="image-20230926203036479"></li></ul></li></ul><h2 id="六-私服"><a href="#六-私服" class="headerlink" title="六 私服"></a>六 私服</h2><h3 id="6-1-概念"><a href="#6-1-概念" class="headerlink" title="6.1 概念"></a>6.1 概念</h3><ul><li><p>是一台独立的服务器,用于解决团队内部的资源共享与资源同步问题</p></li><li><p>Nexus</p><ul><li>一款maven私服产品</li><li><code>https://help.sonatype.com/repomanager3/download</code></li></ul></li><li><p>分类</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/SSM.assets/image-20230926204827260.png" alt="image-20230926204827260"></p></li></ul><h3 id="6-2-本地资源访问私服配置"><a href="#6-2-本地资源访问私服配置" class="headerlink" title="6.2 本地资源访问私服配置"></a>6.2 本地资源访问私服配置</h3><ul><li><p>上传与下载的过程</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/SSM.assets/image-20230926205251592.png" alt="image-20230926205251592"></p></li><li><p>配置修改</p><ul><li>maven的setting文件中修改</li></ul></li></ul><h1 id="Ⅳ-SpringBoot"><a href="#Ⅳ-SpringBoot" class="headerlink" title="Ⅳ SpringBoot"></a>Ⅳ SpringBoot</h1><h2 id="一-demo"><a href="#一-demo" class="headerlink" title="一 demo"></a>一 demo</h2><h3 id="1-1-原始SpringMVC开发"><a href="#1-1-原始SpringMVC开发" class="headerlink" title="1.1 原始SpringMVC开发"></a>1.1 原始SpringMVC开发</h3><ul><li><p>配置依赖</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/SSM.assets/image-20230926210332728.png" alt="image-20230926210332728"></p></li><li><p>web配置</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/SSM.assets/image-20230926210401675.png" alt="image-20230926210401675"></p></li><li><p>SpringMvc配置</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/SSM.assets/image-20230926210432864.png" alt="image-20230926210432864"></p></li><li><p>至少一个controller类</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/SSM.assets/image-20230926210504763.png" alt="image-20230926210504763"></p></li></ul><h3 id="1-2-SpringBoot-Demo"><a href="#1-2-SpringBoot-Demo" class="headerlink" title="1.2 SpringBoot Demo"></a>1.2 SpringBoot Demo</h3><ul><li><p><code>05_springboot_demo</code></p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/SSM.assets/image-20230926214037232.png" alt="image-20230926214037232"></p></li><li><p>只定义了一个类</p></li><li><p>对比原始</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/SSM.assets/image-20230926214406563.png" alt="image-20230926214406563"></p></li><li><p>注意:基于idea开发springboot程序需要联网</p><ul><li>也可以在springboot官网创建,然后下载zip</li></ul></li></ul><h2 id="二-SpringBoot概述"><a href="#二-SpringBoot概述" class="headerlink" title="二 SpringBoot概述"></a>二 SpringBoot概述</h2><ul><li><p>设计目的是为了简化Spring应用的初始搭建以及开发过程</p></li><li><p>springboot项目快速启动</p><ul><li><p>项目打jar包(<strong>boot程序一般打jar包</strong>)</p></li><li><p>执行启动命令 <code>java -jar springboot.jar</code></p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/SSM.assets/image-20230926221042145.png" alt="image-20230926221042145"></p></li></ul></li><li><p>springboot程序优点</p><ul><li>自动配置</li><li>起步依赖(简化依赖配置)</li><li>辅助功能(内置服务器…)</li></ul></li><li><p>起步依赖</p><ul><li><p>starter</p><ul><li>springboot中常见项目名称,定义了当前项目使用的所有项目坐标,以达到<strong>减少依赖配置</strong>的目的</li></ul></li><li><p>parent</p><ul><li>所有springboot项目要继承的项目,定义了若干个坐标版本号(依赖管理,而非依赖),以达到<strong>减少依赖冲突</strong>的问题</li></ul></li></ul></li><li><p>辅助功能</p></li><li><p>排除tomcat服务器,使用jetty服务器</p><ul><li><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/SSM.assets/image-20230926222457600.png" alt="image-20230926222457600"></li></ul></li></ul><h2 id="三-配置文件"><a href="#三-配置文件" class="headerlink" title="三 配置文件"></a>三 配置文件</h2><ul><li><p>修改服务器端口</p><ul><li><p>默认是8080</p></li><li><p>方式一：resources目录下的 <code>application.properties</code>文件中 <code>server.port=80</code></p></li><li><p>方式二：resources目录下创建 <code>application.yml</code><strong>（主要用这种）</strong></p><ul><li><p>```yml<br>server:<br>  port: 80</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">    - 注意数据前需要加空格</span><br><span class="line"></span><br><span class="line">  - 方式三：resources目录下创建`application.yaml`</span><br><span class="line"></span><br><span class="line">    - 同上</span><br><span class="line"></span><br><span class="line">  - 三种冲突的话，优先级：`.properties` &gt; `.yml` &gt; `.yaml` </span><br><span class="line"></span><br><span class="line">- yaml</span><br><span class="line"></span><br><span class="line">  - YAML：（YAML Ain&#x27;t Markup Language），一种数据序列化格式</span><br><span class="line"></span><br><span class="line">  - 优点</span><br><span class="line"></span><br><span class="line">    - 易阅读、易与脚本语言交互、与数据为核心，重数据轻格式</span><br><span class="line"></span><br><span class="line">  - YAML文件扩展名</span><br><span class="line"></span><br><span class="line">    - .yml</span><br><span class="line">    - .yaml</span><br><span class="line"></span><br><span class="line">  - 语法</span><br><span class="line"></span><br><span class="line">    - 大小写敏感</span><br><span class="line">    - 属性层级关系使用多行描述，每行结尾使用冒号结束</span><br><span class="line">    - 使用缩进表示层级关系，同层级左侧对其，只允许使用空格（不允许tab）</span><br><span class="line">    - **属性值前面添加空格**</span><br><span class="line">    - #表示注释</span><br><span class="line"></span><br><span class="line">  - 数据读取</span><br><span class="line"></span><br><span class="line">    - 方式一：`@Value($&#123;一级属性名.二级属性名...&#125;)`</span><br><span class="line"></span><br><span class="line">      ![image-20230927210417992](https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/SSM.assets/image-20230927210417992.png)</span><br><span class="line"></span><br><span class="line">    - 方式二：`@AutoWired`一次性全部装配所有的属性</span><br><span class="line"></span><br><span class="line">      ```java</span><br><span class="line">      @AutoWired</span><br><span class="line">      private Environment enviroment;</span><br><span class="line">      </span><br><span class="line">      enviroment.getProperty(&quot;lesson&quot;);//返回SpringBoot</span><br></pre></td></tr></table></figure></li><li><p>方式三：<strong>（常用）</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;enterprise&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Enterprise</span> &#123;</span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line"><span class="keyword">private</span> Integer age;</span><br><span class="line"><span class="keyword">private</span> String tel;</span><br><span class="line"><span class="keyword">private</span> String[] subject; </span><br><span class="line">    <span class="comment">//会自动读取enterprise中的四个数据</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul></li><li><p>多环境开发配置</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/SSM.assets/image-20230927211807762.png" alt="image-20230927211807762"></p></li><li><p>多环境启动命令格式</p><ul><li><p>带参数启动SpringBoot</p><ul><li><p><code>java -jar springboot.jar --spring.profiles.active=test</code></p></li><li><p><code>java -jar springboot.jar --server.port=88</code></p></li><li><p><code>java -jar springboot.jar --server.port=88 --spring.profiles.active=test</code></p></li></ul></li></ul></li><li><p>配置文件分类</p></li></ul><h2 id="四-SpringBoot整合JUnit"><a href="#四-SpringBoot整合JUnit" class="headerlink" title="四 SpringBoot整合JUnit"></a>四 SpringBoot整合JUnit</h2><ul><li><p>spring整合JUnit</p><ul><li><p>设置运行器 -&gt; 加载环境 -&gt; 注入测试对象 -&gt; 测试功能</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/SSM.assets/image-20230927213922940.png" alt="image-20230927213922940"></p></li></ul></li><li><p>SpringBoot</p><ul><li><p>定义好所需要测试的类</p></li><li><p>```java<br>@SpringBootTest<br>class ApplicationTests {</p><pre><code>@Autowiredprivate BookService bookService;@Testpublic void saveTest() &#123;    bookService.save();&#125;</code></pre><p>}</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">    ![image-20230927220625953](https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/SSM.assets/image-20230927220625953.png)</span><br><span class="line"></span><br><span class="line">## 五 SpringBoot整合SSM</span><br><span class="line"></span><br><span class="line">- 整合Spring和SpringMVC均不需要，只需整合MyBatis</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 5.1 Spring整合MyBatis</span><br><span class="line"></span><br><span class="line">- SpringConfig</span><br><span class="line">  - 导入JdbcConfig</span><br><span class="line">  - 导入MyBatisConfig</span><br><span class="line">- JDBCConfig</span><br><span class="line">  - 定义数据源（加载properties）</span><br><span class="line">- MyBatisConfig</span><br><span class="line">  - 定义`SqlSessionFactoryBean`</span><br><span class="line">  - 定义映射配置</span><br><span class="line"></span><br><span class="line">### 5.2 SpringBoot整合MyBatis</span><br><span class="line"></span><br><span class="line">- 创建模块</span><br><span class="line"></span><br><span class="line">- yml中设置数据源</span><br><span class="line"></span><br><span class="line">  ![image-20230927224136784](https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/SSM.assets/image-20230927224136784.png)</span><br><span class="line"></span><br><span class="line">- 定义数据层接口与映射配置</span><br><span class="line"></span><br><span class="line">  ![image-20230927224213163](https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/SSM.assets/image-20230927224213163.png)</span><br><span class="line"></span><br><span class="line">- 测试类中注入dao接口，测试功能</span><br><span class="line"></span><br><span class="line">  ![image-20230927224238830](https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/SSM.assets/image-20230927224238830.png)</span><br><span class="line"></span><br><span class="line"># Ⅴ MyBatis Plus</span><br><span class="line">## 一 简介</span><br><span class="line"></span><br><span class="line">- 简称MP，是基于Mybatis框架基础上开发的增强型工具，旨在简化开发、提高效率</span><br><span class="line"></span><br><span class="line">### 1.1 SpringBoot整合Mybatis过程</span><br><span class="line"></span><br><span class="line">- 创建SpringBoot工程</span><br><span class="line"></span><br><span class="line">- 勾选配置使用的技术</span><br><span class="line"></span><br><span class="line">- 设置dataSource相关属性（JDBC参数）</span><br><span class="line"></span><br><span class="line">  ![image-20231016210817888](.(https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/SSM.assets/image-20231016210817888.png)</span><br><span class="line"></span><br><span class="line">- 定义数据层接口映射配置</span><br><span class="line"></span><br><span class="line">  ![image-20231016210853914](.(https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/SSM.assets/image-20231016210853914.png)</span><br><span class="line"></span><br><span class="line">### 1.2 SpringBoot整合Mybatis plus过程</span><br><span class="line"></span><br><span class="line">- 创建SpringBoot工程</span><br><span class="line"></span><br><span class="line">- 勾选配置使用的技术 （仅保留JDBC）</span><br><span class="line"></span><br><span class="line">- 手动添加起步依赖</span><br><span class="line"></span><br><span class="line">  ![image-20231016212322111](.(https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/SSM.assets/image-20231016212322111.png)</span><br><span class="line"></span><br><span class="line">- 设置Jdbc参数（application.yml），制作实体类与表结构</span><br><span class="line"></span><br><span class="line">- 与之不同的是定义数据层接口的时候继承BaseMapper</span><br><span class="line"></span><br><span class="line">  ```java</span><br><span class="line">  @Mapper</span><br><span class="line">  public interface UserDao extends BaseMapper&lt;User&gt; &#123;</span><br><span class="line">      </span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li></ul><p>不再需要写<code>@Select</code>等</p></li><li><p>测试</p><p><img src=".(https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/SSM.assets/image-20231016212043874.png" alt="image-20231016212043874">、</p></li></ul><h2 id="二-标准数据层开发"><a href="#二-标准数据层开发" class="headerlink" title="二 标准数据层开发"></a>二 标准数据层开发</h2><ul><li><p><img src=".(https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/SSM.assets/image-20231016212940985.png" alt="image-20231016212940985"></p></li><li><p>lombok</p><ul><li>一个java类库，提供了一堆注解，简化POJO实体类开发</li></ul><p><img src=".(https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/SSM.assets/image-20231016213905086.png" alt="image-20231016213905086"></p><ul><li>常用注解：<code>@Data</code><ul><li>为当前实体类在编译期设置对应的get/set方法，无参/全参构造方法，toString方法，hashCode方法，equals方法等</li></ul></li></ul></li><li><p>分页功能</p><ul><li><p>IPage类</p></li><li><p>```java<br>IPage page = new Page(1,2)//当前页码：1，每页2条<br>userDao.selectPage(page, null);</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">  ![image-20231016214532717](.(https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/SSM.assets/image-20231016214532717.png)</span><br><span class="line">  </span><br><span class="line">- 需要额外定义一个拦截器Bean</span><br><span class="line"></span><br><span class="line">  ```java</span><br><span class="line">  @Configuration</span><br><span class="line">  public class MpConfig &#123;</span><br><span class="line">  @Bean</span><br><span class="line">  pubic MybatisPlusInterceptor mpInterceptor()&#123;</span><br><span class="line">  //定义Mp拦截器</span><br><span class="line">  MybatisPlusInterceptor mpi = new MybatisPlusInterceptor();</span><br><span class="line">  //添加具体的拦截器</span><br><span class="line">  mpi.addInterInterceptor(new PaginationInnerInterceptor());</span><br><span class="line">  return mpi</span><br><span class="line">  &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h2 id="三-DQL控制"><a href="#三-DQL控制" class="headerlink" title="三 DQL控制"></a>三 DQL控制</h2><h3 id="3-1-条件查询方式"><a href="#3-1-条件查询方式" class="headerlink" title="3.1 条件查询方式"></a>3.1 条件查询方式</h3><ul><li><p>MybatisPlus将复杂的SQL查询条件进行了封装，使用编程的形式完成条件的组合查询</p></li><li><p>方式一：<code>QueryWrapper</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Mybatisplus02DqlApplicationTests</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserDao userDao;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">testGetAll</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">QueryWrapper</span> <span class="variable">qw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">QueryWrapper</span>();</span><br><span class="line">        qw.lt(<span class="string">&quot;age&quot;</span>,<span class="number">30</span>);</span><br><span class="line">qw.gt(<span class="string">&quot;age&quot;</span>, <span class="number">10</span>);<span class="comment">//大于10小于30</span></span><br><span class="line">        List&lt;User&gt; userList = userDao.selectList(qw);</span><br><span class="line">        System.out.println(userList);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>方式二：<code>QueryWrapper的基础上使用lambda</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Mybatisplus02DqlApplicationTests</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserDao userDao;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">testGetAll</span><span class="params">()</span>&#123;</span><br><span class="line">        QueryWrapper&lt;User&gt; qw = <span class="keyword">new</span> <span class="title class_">QueryWrapper</span>&lt;User&gt;();</span><br><span class="line">        qw.lambda().lt(User::getAge, <span class="number">10</span>);<span class="comment">//添加条件</span></span><br><span class="line">        List&lt;User&gt; userList = userDao.selectList(qw);</span><br><span class="line">        System.out.println(userList);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>方式三<code>LambdaQueryWrapper</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Mybatisplus02DqlApplicationTests</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserDao userDao;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">testGetAll</span><span class="params">()</span>&#123;</span><br><span class="line">        LambdaQueryWrapper&lt;User&gt; lqw = <span class="keyword">new</span> <span class="title class_">LambdaQueryWrapper</span>&lt;User&gt;();</span><br><span class="line">        lqw.lt(User::getAge, <span class="number">10</span>);</span><br><span class="line">        List&lt;User&gt; userList = userDao.selectList(lqw);</span><br><span class="line">        System.out.println(userList);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>null值处理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Mybatisplus02DqlApplicationTests</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserDao userDao;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">testGetAll</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//模拟页面传递过来的查询数据</span></span><br><span class="line">        <span class="type">UserQuery</span> <span class="variable">uq</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserQuery</span>();</span><br><span class="line">        uq.setAge(<span class="number">10</span>);</span><br><span class="line">        uq.setAge2(<span class="number">30</span>);</span><br><span class="line">        LambdaQueryWrapper&lt;User&gt; lqw = <span class="keyword">new</span> <span class="title class_">LambdaQueryWrapper</span>&lt;User&gt;();</span><br><span class="line">        lqw.lt(<span class="literal">null</span>!=uq.getAge2(),User::getAge, uq.getAge2());</span><br><span class="line">        lqw.gt(<span class="literal">null</span>!=uq.getAge(),User::getAge, uq.getAge());</span><br><span class="line">        List&lt;User&gt; userList = userDao.selectList(lqw);</span><br><span class="line">        System.out.println(userList);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="3-2-查询投影"><a href="#3-2-查询投影" class="headerlink" title="3.2 查询投影"></a>3.2 查询投影</h3><ul><li><p>使用lambda</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Mybatisplus02DqlApplicationTests</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserDao userDao;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">testGetAll</span><span class="params">()</span>&#123;</span><br><span class="line">        LambdaQueryWrapper&lt;User&gt; lqw = <span class="keyword">new</span> <span class="title class_">LambdaQueryWrapper</span>&lt;User&gt;();</span><br><span class="line">        lqw.select(User::getId,User::getName,User::getAge);</span><br><span class="line">        List&lt;User&gt; userList = userDao.selectList(lqw);</span><br><span class="line">        System.out.println(userList);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>手动指定查询字段</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Mybatisplus02DqlApplicationTests</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserDao userDao;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">testGetAll</span><span class="params">()</span>&#123;</span><br><span class="line">        QueryWrapper&lt;User&gt; lqw = <span class="keyword">new</span> <span class="title class_">QueryWrapper</span>&lt;User&gt;();</span><br><span class="line">        lqw.select(<span class="string">&quot;id&quot;</span>,<span class="string">&quot;name&quot;</span>,<span class="string">&quot;age&quot;</span>,<span class="string">&quot;tel&quot;</span>);</span><br><span class="line">        List&lt;User&gt; userList = userDao.selectList(lqw);</span><br><span class="line">        System.out.println(userList);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="3-3-字段映射与表名映射"><a href="#3-3-字段映射与表名映射" class="headerlink" title="3.3 字段映射与表名映射"></a>3.3 字段映射与表名映射</h3><ul><li><p>问题一：表字段与编码属性设计不同步</p><p><img src=".(https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/SSM.assets/image-20231016224202175.png" alt="image-20231016224202175"></p></li><li><p>问题二：编码中添加了数据库中未定义的属性</p><p><img src=".(https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/SSM.assets/image-20231016224312282.png" alt="image-20231016224312282"></p></li><li><p>问题三：采用了默认查询开放了更多的字段查看权限（比如密码）</p><p><img src=".(https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/SSM.assets/image-20231016224445721.png" alt="image-20231016224445721"></p></li><li><p>问题四：表名与编码开发设计不同步</p><p><img src=".(https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/SSM.assets/image-20231016224619205.png" alt="image-20231016224619205"></p></li></ul><h2 id="四-DML控制"><a href="#四-DML控制" class="headerlink" title="四 DML控制"></a>四 DML控制</h2><h3 id="4-1-增"><a href="#4-1-增" class="headerlink" title="4.1 增"></a>4.1 增</h3><ul><li>id生成策略控制<ul><li><code>@TableId</code></li><li><img src=".(https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/SSM.assets/image-20231016225723236.png" alt="image-20231016225723236"></li><li><img src=".(https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/SSM.assets/image-20231016225841407.png" alt="image-20231016225841407"></li><li>雪花算法生成id<ul><li><img src=".(https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/SSM.assets/image-20231016225947967.png" alt="image-20231016225947967"></li></ul></li><li></li></ul></li></ul><h3 id="4-2-删"><a href="#4-2-删" class="headerlink" title="4.2 删"></a>4.2 删</h3><ul><li><p>多条删除</p><p><img src=".(https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/SSM.assets/image-20231016230155184.png" alt="image-20231016230155184"></p><ul><li>多条查询：<code>selectBatchIds(list)</code></li></ul></li><li><p>逻辑删除</p></li></ul><h3 id="4-3-改"><a href="#4-3-改" class="headerlink" title="4.3 改"></a>4.3 改</h3><ul><li><p>乐观锁</p><ul><li>原理：表字段中添加一个version，在set的时候对version进行判断，与此同时version+1以防止并发错误</li></ul></li><li><p>实现：</p><ul><li><p>表中添加version字段</p></li><li><p>实体类中添加属性，加<code>@version</code>注解</p></li><li><p>在拦截器定义的bean中添加乐观锁拦截器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MpConfig</span> &#123;</span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line">pubic MybatisPlusInterceptor <span class="title function_">mpInterceptor</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="comment">//定义Mp拦截器</span></span><br><span class="line"><span class="type">MybatisPlusInterceptor</span> <span class="variable">mpi</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MybatisPlusInterceptor</span>();</span><br><span class="line"><span class="comment">//添加具体的拦截器</span></span><br><span class="line">mpi.addInterInterceptor(<span class="keyword">new</span> <span class="title class_">PaginationInnerInterceptor</span>());</span><br><span class="line">        <span class="comment">//添加乐观锁拦截器</span></span><br><span class="line">mpi.addInnerInterceptor(<span class="keyword">new</span> <span class="title class_">OptimisticLockerInnerInterceptor</span>());</span><br><span class="line"><span class="keyword">return</span> mpi;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h2 id="五-快速开发"><a href="#五-快速开发" class="headerlink" title="五 快速开发"></a>五 快速开发</h2><ul><li><p>代码生成器</p></li><li><p><code>AutoGenerator</code>类</p></li><li><pre><code class="lang-java">psvm()&#123;    AutoGenerator autoGenerator = new AutoGenerator();        //需要先定义DataSource对象    autoGenerator.setDataSource(dataSource);    //需先定义全局配置对象    autoGenerator.setGlobalConfig(globalConfig);&#125;</code></pre></li></ul><link rel="stylesheet" href="https://cdn1.tianli0.top/gh/zhheo/Post-Abstract-AI@0.15.2/tianli_gpt.css"><script>let tianliGPT_postSelector = '#post #article-container';let tianliGPT_key = 'c9b7741d290063ab872e';</script><script src="https://cdn1.tianli0.top/gh/zhheo/Post-Abstract-AI@0.15.2/tianli_gpt.js"></script>]]></content>
      
      
      <categories>
          
          <category> study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java高级 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Maven &amp; Mybatis</title>
      <link href="/posts/8947.html"/>
      <url>/posts/8947.html</url>
      
        <content type="html"><![CDATA[<h2 id="Maven"><a href="#Maven" class="headerlink" title="Maven"></a>Maven</h2><h3 id="一-Maven"><a href="#一-Maven" class="headerlink" title="一 Maven"></a>一 Maven</h3><h4 id="1-1-基本信息"><a href="#1-1-基本信息" class="headerlink" title="1.1 基本信息"></a>1.1 基本信息</h4><ul><li>Maven的本质是一个项目管理工具，将项目开发和管理过程抽象成一个项目模型（POM）</li><li>POM：项目对象模型</li><li><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/maven.assets/image-20220924105346240.png" alt="im"></li><li>作用：<ul><li>项目构建</li><li>依赖管理：方便快捷的管理项目依赖的资源（jar包），避免资源间的版本冲突问题</li><li>统一开发结构</li></ul></li></ul><h4 id="1-2-下载与安装"><a href="#1-2-下载与安装" class="headerlink" title="1.2 下载与安装"></a>1.2 下载与安装</h4><ul><li><p>环境配置</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/maven.assets/image-20220924110519385.png" alt="image-20220924110519385"></p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/maven.assets/image-20220924110548574.png" alt="image-20220924110548574"></p></li><li><p>cmd运行mvn显示</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/maven.assets/image-20220924110619232.png" alt="image-20220924110619232"></p><p>表示成功</p></li></ul><h4 id="1-3-基础概念"><a href="#1-3-基础概念" class="headerlink" title="1.3 基础概念"></a>1.3 基础概念</h4><ul><li>仓库：用于存储资源，包含各种jar包<ul><li><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/maven.assets/image-20220924110947329.png" alt="image-20220924110947329"></li><li>本地仓库</li><li>远程仓库<ul><li>私服：部门/公司范围内的存储资源的仓库<ul><li>私服不对外共享，保存知识产权</li></ul></li><li>中央仓库：MAVEN团队维护</li></ul></li></ul></li><li>坐标：用于描述仓库中资源的位置<ul><li>主要组成<ul><li>groupId：定义当前Maven项目隶属组织名称（通常是域名反写）</li><li>artifactId：定义当前Maven项目名称（通常是模块名称）</li><li>version：版本号</li><li>packaging：定义项目打包方式</li></ul></li><li><a href="https://mvnrepository.com">https://mvnrepository.com</a></li></ul></li><li>本地仓库配置<ul><li>默认在</li><li>&lt;img src=(<a href="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/maven.assets/image-20220924112323002.png">https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/maven.assets/image-20220924112323002.png</a>“  width=”300”  height = “150” /&gt;</li><li>修改：<ul><li>&lt;img src=(<a href="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/maven.assets/image-20220924112358368.png">https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/maven.assets/image-20220924112358368.png</a>“  width=”400”  height = “150” /&gt;</li><li>&lt;img src=(<a href="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/maven.assets/image-20220924112611231.png">https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/maven.assets/image-20220924112611231.png</a>“  width=”500”  height = “250” /&gt;</li></ul></li></ul></li><li>远程仓库配置<ul><li>修改位置（同样是在settings.xml中修改）</li><li>&lt;img src=(<a href="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/maven.assets/image-20220924114120426.png">https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/maven.assets/image-20220924114120426.png</a>“  width=”600”  height = “300” /&gt;</li></ul></li></ul><h3 id="二-Maven项目"><a href="#二-Maven项目" class="headerlink" title="二 Maven项目"></a>二 Maven项目</h3><h4 id="2-1-创建项目"><a href="#2-1-创建项目" class="headerlink" title="2.1 创建项目"></a>2.1 创建项目</h4><ul><li><p>目录结构</p><p>&lt;img src=(<a href="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/maven.assets/image-20220924115223250.png">https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/maven.assets/image-20220924115223250.png</a>“  width=”200”  height = “300” /&gt;</p><ul><li>resources放配置文件，java放源代码</li></ul></li><li><p>src同层目录下要创建一个pom.xml文件</p></li><li><p>maven项目构建命令</p><ul><li><code>mvn compile</code>：编译</li><li><code>mvn clean</code>：清理</li><li><code>mvn test</code>：测试</li><li><code>mvn package</code>：打包</li><li><code>mvn install</code>：安装到本地仓库</li></ul></li><li><p>插件创建工程</p><ul><li><p>创建工程</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mvn archetype:generate</span><br><span class="line">-DgroupId=&#123;project-packaging&#125;</span><br><span class="line">-DartifactId=&#123;project-name&#125;</span><br><span class="line">-DarchetypeArtifactId=maven-archetype-quickstart</span><br><span class="line">-DinteractiveMode=false</span><br></pre></td></tr></table></figure></li><li><p>创建java工程</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mvn archetype:generate -DgroupId=com.ithima -DartifactId=java-project -</span><br><span class="line">DarchetypeArtifactId=maven-archetype-quickstart -Dversion=0.0.1-snapshot -</span><br><span class="line">DinteractiveMode=false</span><br></pre></td></tr></table></figure></li><li><p>创建web工程</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mvn archetype:generate -DgroupId=com.ithima -DartifactId=web-project -</span><br><span class="line">DarchetypeArtifactId=maven-archetype-webapp -Dversion=0.0.1-snapshot -</span><br><span class="line">DinteractiveMode=false</span><br></pre></td></tr></table></figure></li></ul></li><li><p>IDEA</p></li></ul><h4 id="2-2-依赖管理"><a href="#2-2-依赖管理" class="headerlink" title="2.2 依赖管理"></a>2.2 依赖管理</h4><ul><li><p>依赖配置</p><ul><li><p>依赖指当前项目运行所需要的jar包，一个项目有多个依赖</p></li><li><p>```java</p><!-- 设置当前项目所依赖的所有jar包 --><p><dependencies></p><pre><code>&lt;!-- 设置具体的依赖 ——&gt;&lt;dependency&gt;  &lt;!-- 依赖所属群组 ——&gt;  &lt;groupId&gt;junit&lt;/groupId&gt;  &lt;!-- 依赖所属项目id ——&gt;  &lt;artifactId&gt;junit&lt;/artifactId&gt;  &lt;!-- 依赖版本号 ——&gt;  &lt;version&gt;3.8.1&lt;/version&gt;&lt;/dependency&gt;</code></pre><p>  &lt;/dependencies&gt;</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 依赖传递：A依赖了B、B依赖了C，则A可以直接使用C（间接依赖）</span><br><span class="line"></span><br><span class="line">  - 层级优先：当出现了冲突的时候，以层级确定优先级，层级浅的优先使用</span><br><span class="line">  - 声明优先：先声明的优先</span><br><span class="line"></span><br><span class="line">- 可选依赖：对外隐藏当前所依赖的资源</span><br><span class="line"></span><br><span class="line">  - 加一个 `&lt;optional&gt;true&lt;/optional&gt;`</span><br><span class="line"></span><br><span class="line">- 排除依赖：不想使用依赖的包所依赖的东西</span><br><span class="line"></span><br><span class="line">  - ```</span><br><span class="line">    &lt;exclusions&gt;</span><br><span class="line">    &lt;exclusion&gt;（添加所需要排除的坐标，不写版本，因为会排除所有的版本）&lt;/exclusion&gt;</span><br><span class="line">    &lt;exclusion&gt;&lt;/exclusion&gt;</span><br><span class="line">    &lt;exclusion&gt;&lt;/exclusion&gt;</span><br><span class="line">    &lt;/exclusions&gt;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>依赖范围：<scope>标签</p><ul><li>作用范围：主程序、测试程序范围、是否参与打包<ul><li><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/maven.assets/image-20220924171225097.png" alt="image-20220924171225097"></li></ul></li><li>依赖范围的传递性：带有依赖范围的资源在进行传递的时候，作用范围将受到影响</li></ul></li></ul><h3 id="三-生命周期与插件"><a href="#三-生命周期与插件" class="headerlink" title="三 生命周期与插件"></a>三 生命周期与插件</h3><h4 id="3-1-项目构建生命周期"><a href="#3-1-项目构建生命周期" class="headerlink" title="3.1 项目构建生命周期"></a>3.1 项目构建生命周期</h4><ul><li><p>maven构建生命周期描述的是一次构建过程中经历了多少个事件</p><ul><li>clean：清理工作<ul><li>pre-clean</li><li>clean</li><li>post-clean</li></ul></li><li>default：核心工作，例如编译、测试、打包、部署等<ul><li><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/maven.assets/image-20220924172153881.png" alt="image-20220924172153881"></li></ul></li><li>site：产生报告，发布站点等</li></ul></li></ul><h4 id="3-2-插件"><a href="#3-2-插件" class="headerlink" title="3.2 插件"></a>3.2 插件</h4><ul><li>插件与声明周期内的阶段绑定，在执行到对应生命周期时执行对应的插件功能</li><li>默认maven在各个生命周期上绑定有预设的功能</li><li>通过插件可以自定义其他功能</li></ul><h2 id="MyBatis"><a href="#MyBatis" class="headerlink" title="MyBatis"></a>MyBatis</h2><h3 id="一-hello-world"><a href="#一-hello-world" class="headerlink" title="一 hello world"></a>一 hello world</h3><ul><li><p>maven 3.6.3</p></li><li><p>jdk 1.8</p></li><li><p>mysql 5.1.3</p></li><li><p>junit 4.12</p></li><li><p>mybatis 3.5.7</p></li><li><p>log4j 1.2.17</p><hr><p>Maven xml配置文件如下</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.example<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>MyBatis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>jar<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">maven.compiler.source</span>&gt;</span>18<span class="tag">&lt;/<span class="name">maven.compiler.source</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">maven.compiler.target</span>&gt;</span>18<span class="tag">&lt;/<span class="name">maven.compiler.target</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- Mybatis核心 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.5.7<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- junit测试 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- MySQL驱动 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="1-2-创建Mybatis核心配置文件"><a href="#1-2-创建Mybatis核心配置文件" class="headerlink" title="1.2 创建Mybatis核心配置文件"></a>1.2 创建Mybatis核心配置文件</h4><ul><li><p>习惯上命名mybatis-config.xml，整合Spring后这个配置文件可以省略</p></li><li><p>用于配置连接数据库的环境以及MyBatis的全局配置信息</p></li><li><p>核心配置文件存放的位置是：src/main/resources目录下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span><br><span class="line">&lt;!DOCTYPE configuration</span><br><span class="line"> PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot;</span><br><span class="line"> &quot;https://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;</span><br><span class="line">&lt;configuration&gt;</span><br><span class="line">&lt;!-- 配置连接数据库的环境--&gt;</span><br><span class="line"> &lt;environments default=&quot;development&quot;&gt;</span><br><span class="line"> &lt;environment id=&quot;development&quot;&gt;</span><br><span class="line"> &lt;transactionManager type=&quot;JDBC&quot;/&gt;</span><br><span class="line">&lt;dataSource type=&quot;POOLED&quot;&gt;</span><br><span class="line"> &lt;property name=&quot;driver&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&gt;</span><br><span class="line">                &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/mybatis&quot;/&gt; 使用本地mysql中名为mybatis的数据库</span><br><span class="line">                &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt; 用户名</span><br><span class="line">                &lt;property name=&quot;password&quot; value=&quot;mysql&quot;/&gt; 密码</span><br><span class="line"> &lt;/dataSource&gt;</span><br><span class="line"> &lt;/environment&gt;</span><br><span class="line"> &lt;/environments&gt;</span><br><span class="line">&lt;!-- 引入映射文件--&gt;</span><br><span class="line">    &lt;mappers&gt;</span><br><span class="line">        &lt;mapper resource=&quot;mappers/UserMapper.xml&quot;/&gt;</span><br><span class="line">    &lt;/mappers&gt;</span><br><span class="line">&lt;/configuration&gt;</span><br></pre></td></tr></table></figure></li></ul><h4 id="1-3-创建mapper接口"><a href="#1-3-创建mapper接口" class="headerlink" title="1.3 创建mapper接口"></a>1.3 创建mapper接口</h4><ul><li>MyBatis中的mapper接口相当于以前的dao，但是区别在于mapper只是接口，不需要提供实现类</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> mybatis.mapper;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * User: ManYile</span></span><br><span class="line"><span class="comment"> * Date: 2022/10/27</span></span><br><span class="line"><span class="comment"> * Description: user类的mapper接口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserMapper</span> &#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 添加用户信息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">insertUser</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-4-创建MyBatis的映射文件"><a href="#1-4-创建MyBatis的映射文件" class="headerlink" title="1.4 创建MyBatis的映射文件"></a>1.4 创建MyBatis的映射文件</h4><ul><li><p>相关概念：ORM(Object Relationship Mapping)对象关系映射</p><ul><li>对象：java的实体类对象</li><li>关系：关系型数据库</li><li>映射：二者之间的对应关系</li></ul></li><li><p>Mapper文件命名规则：<code>表所对应的实体类的类名+Mapper.xml</code></p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/maven&amp;MyBatis.assets/image-20221027165834716.png" alt="image-20221027165834716"></p></li><li><p>两个一致：</p><ul><li>映射文件的namespace要和mapper接口的全类名保持一致；</li><li>映射文件中SQL语句的id要和mapper接口中的方法一致</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;mapper namespace=&quot;mybatis.mapper.UserMapper&quot;&gt; &lt;!--第一个一致--&gt;</span><br><span class="line">    &lt;!--insertUser()--&gt;</span><br><span class="line">    &lt;insert id=&quot;insertUser&quot;&gt;&lt;!--第二个一致--&gt;</span><br><span class="line">        insert into t_user values(null, &#x27;admin&#x27;, &#x27;123456&#x27;, &#x27;23&#x27;, &#x27;男&#x27;, &#x27;123456@qq.com&#x27;)</span><br><span class="line">    &lt;/insert&gt;</span><br><span class="line">    </span><br><span class="line">&lt;/mapper&gt;</span><br></pre></td></tr></table></figure></li></ul><h4 id="1-5-测试"><a href="#1-5-测试" class="headerlink" title="1.5 测试"></a>1.5 测试</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MybatisTest</span> &#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testMybatis</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">// 加载核心配置文件</span></span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> Resources.getResourceAsStream(<span class="string">&quot;mybatis-config.xml&quot;</span>);</span><br><span class="line">        <span class="comment">// 获取SqlsessionFactoryBuilder</span></span><br><span class="line">        <span class="type">SqlSessionFactoryBuilder</span> <span class="variable">sqlSessionFactoryBuilder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SqlSessionFactoryBuilder</span>();</span><br><span class="line">        <span class="comment">// 获取sqlSessionFactory</span></span><br><span class="line">        <span class="type">SqlSessionFactory</span> <span class="variable">sqlSessionFactory</span> <span class="operator">=</span> sqlSessionFactoryBuilder.build((is));</span><br><span class="line">        <span class="comment">// 获取SqlSession:代表java程序和数据库之间的会话</span></span><br><span class="line">        <span class="type">SqlSession</span> <span class="variable">sqlSession</span> <span class="operator">=</span> sqlSessionFactory.openSession(<span class="literal">true</span>);<span class="comment">//true表示自动commit</span></span><br><span class="line">        <span class="comment">// 获取Mapper接口对象</span></span><br><span class="line">        <span class="type">UserMapper</span> <span class="variable">mapper</span> <span class="operator">=</span> sqlSession.getMapper(UserMapper.class);<span class="comment">// 返回了UserMapper的实现类</span></span><br><span class="line">        <span class="comment">//测试功能</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> mapper.insertUser();</span><br><span class="line">        <span class="comment">// 提交事务</span></span><br><span class="line">        <span class="comment">//sqlSession.commit();</span></span><br><span class="line">        System.out.println(<span class="string">&quot;result:&quot;</span> + result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-6-加入log4j日志功能"><a href="#1-6-加入log4j日志功能" class="headerlink" title="1.6 加入log4j日志功能"></a>1.6 加入log4j日志功能</h4><ul><li><p>pom.xml加入依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>log4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>log4j<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.17<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>加入log4j的配置文件</p><ul><li>名称是log4j.xml，存放在<code>src/main/resources</code>目录下</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span><br><span class="line">&lt;!DOCTYPE log4j:configuration SYSTEM &quot;log4j.dtd&quot;&gt; </span><br><span class="line">    </span><br><span class="line">&lt;log4j:configuration xmlns:log4j=&quot;http://jakarta.apache.org/log4j/&quot;&gt;</span><br><span class="line">    &lt;appender name=&quot;STDOUT&quot; class=&quot;org.apache.log4j.ConsoleAppender&quot;&gt;</span><br><span class="line">        &lt;param name=&quot;Encodind&quot; value=&quot;UTF-8&quot;/&gt;</span><br><span class="line">        &lt;layout class=&quot;org.apache.log4j.PatternLayout&quot;&gt;</span><br><span class="line">            &lt;param name=&quot;ConversionPattern&quot; value=&quot;[%p][%d&#123;yy-MM-dd&#125;][%c]%m%n &quot;/&gt;</span><br><span class="line">        &lt;/layout&gt;</span><br><span class="line">    &lt;/appender&gt;</span><br><span class="line">    &lt;logger name=&quot;java.sql&quot;&gt;</span><br><span class="line">        &lt;level value=&quot;debug&quot; /&gt;</span><br><span class="line">    &lt;/logger&gt;</span><br><span class="line">    &lt;logger name=&quot;org.apache.ibatis&quot;&gt;</span><br><span class="line">        &lt;level value=&quot;info&quot; /&gt;</span><br><span class="line">    &lt;/logger&gt;</span><br><span class="line">    &lt;root&gt;</span><br><span class="line">        &lt;level value=&quot;debug&quot;/&gt;</span><br><span class="line">        &lt;appender-ref ref=&quot;STDOUT&quot;/&gt;</span><br><span class="line">    &lt;/root&gt;</span><br><span class="line">    </span><br><span class="line">&lt;/log4j:configuration&gt;</span><br></pre></td></tr></table></figure></li></ul><h4 id="1-7-删改查类似"><a href="#1-7-删改查类似" class="headerlink" title="1.7 删改查类似"></a>1.7 删改查类似</h4><ul><li>查询功能必须设置<code>resultType=&quot;mybatis.User&quot;</code>或者<code>resultMap</code></li></ul><h3 id="二-核心配置文件标签"><a href="#二-核心配置文件标签" class="headerlink" title="二 核心配置文件标签"></a>二 核心配置文件标签</h3><ul><li><p>environment：</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/maven&amp;MyBatis.assets/image-20221028104947356.png" alt="image-20221028104947356"></p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/maven&amp;MyBatis.assets/image-20221028105058724.png" alt="image-20221028105058724"></p></li><li><p>properties</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/maven&amp;MyBatis.assets/image-20221028105741318.png" alt="image-20221028105741318"></p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/maven&amp;MyBatis.assets/image-20221028105802283.png" alt="image-20221028105802283"></p></li></ul><ul><li><p>typeAliases(给类取别名)——不区分大小写</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/maven&amp;MyBatis.assets/image-20221028105922894.png" alt="image-20221028105922894"></p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/maven&amp;MyBatis.assets/image-20221028110038515.png" alt="image-20221028110038515"></p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/maven&amp;MyBatis.assets/image-20221028111118622.png" alt="image-20221028111118622"></p></li></ul><ul><li><p>mappers</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/maven&amp;MyBatis.assets/image-20221028111924668.png" alt="image-20221028111924668"></p></li></ul><h3 id="三-MyBatis获取参数值的方式"><a href="#三-MyBatis获取参数值的方式" class="headerlink" title="三 MyBatis获取参数值的方式"></a>三 MyBatis获取参数值的方式</h3><ul><li><p>idea中设置核心配置文件模板</p></li><li><p>idea中设置映射文件模板</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/maven&amp;MyBatis.assets/image-20221028150338764.png" alt="image-20221028150338764"></p></li><li><p>获取参数值的两种方式：(在映射文件中获取Mapper接口中的方法的输入参数，以此来拼接sql语句)</p><ul><li><p><code>$&#123;&#125;</code>:字符串拼接</p><ul><li>可能有sql注入</li></ul></li><li><p><code>#&#123;&#125;</code>:占位符赋值（推荐）（名称任意）</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/maven&amp;MyBatis.assets/image-20221028153709643.png" alt="image-20221028153709643"></p></li><li><p>MyBatis获取参数值的各种情况</p><ul><li><p>mapper接口方法中的参数为单个的自变量类型：两种方法都可以，但是要注意<code>$&#123;&#125;</code>的单引号问题</p></li><li><p>参数有多个(通过mybatis自动设置的map集合的键值访问)</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/maven&amp;MyBatis.assets/image-20221028154229102.png" alt="image-20221028154229102"></p><p>（param1和param2也可以）</p><p>同样的<code>$&#123;&#125;</code>需要加单引号</p></li><li><p>参数为map集合</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/maven&amp;MyBatis.assets/image-20221028154622626.png" alt="image-20221028154622626"></p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/maven&amp;MyBatis.assets/image-20221028154715640.png" alt="image-20221028154715640"></p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/maven&amp;MyBatis.assets/image-20221028154757938.png" alt="image-20221028154757938"></p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/maven&amp;MyBatis.assets/image-20221028154806995.png" alt="image-20221028154806995"></p><p>这样就可以用自己设置的键了</p></li><li><p>mapper接口中的方法的参数是一个实体类<img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/maven&amp;MyBatis.assets/image-20221028155045586.png" alt="image-20221028155045586"></p></li><li><p>使用<code>@param</code>注解命名参数（常用）</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/maven&amp;MyBatis.assets/image-20221028155814928.png" alt="image-20221028155814928"></p><ul><li><p>此时将参数放在一个map集合中</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/maven&amp;MyBatis.assets/image-20221028155745013.png" alt="image-20221028155745013"></p></li></ul></li></ul></li></ul></li></ul><h3 id="四-Mybatis各种查询功能"><a href="#四-Mybatis各种查询功能" class="headerlink" title="四 Mybatis各种查询功能"></a>四 Mybatis各种查询功能</h3><ul><li><p>查询多个结果应用集合存储</p></li><li><p>获取自增主键</p><ul><li><p><code>useGeneratedKeys=true</code>：设置当前标签中的sql使用了自增的id</p></li><li><p><code>keyProperty=&#39;id&#39;</code>：将自增的id</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/maven&amp;MyBatis.assets/image-20221029112441026.png" alt="image-20221029112441026"></p></li></ul></li><li><p>字段名和属性名不一致</p><ul><li><p>方法1：为字段起别名，保持和属性名的一致</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/maven&amp;MyBatis.assets/image-20221029135321071.png" alt="image-20221029135321071"></p><p>（表中字段为emp_name，类中对应empName，通过对字段起别名来保持和属性名一致）</p></li><li><p>方法2：设置mybatis-config.xml中的<code>settings</code>标签，将_映射为驼峰</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/maven&amp;MyBatis.assets/image-20221029135707059.png" alt=""></p></li><li><p>方法3：<code>resultMap</code>（resultType只能解决字段名和属性名相同的情况）</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/maven&amp;MyBatis.assets/image-20221029140032396.png" alt="image-20221029140032396"></p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/maven&amp;MyBatis.assets/image-20221029140101945.png" alt="image-20221029140101945"></p><p>注：</p><ul><li><p>主标签中的id是唯一标识，不能重复，type是设置映射关系中的实体类类型</p></li><li><p>子标签中的id设置主键映射，result设置普通字段的映射，所有的字段都需要设置，即使他们和属性中的名称一致</p></li><li>子标签中的property是实体类中属性，column是表中的字段</li></ul></li></ul></li><li><p>处理多对一映射关系</p><ul><li><p>方法1：级联属性赋值</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/maven&amp;MyBatis.assets/image-20221029141529020.png" alt="image-20221029141529020"></p></li><li><p>方法2：通过association：专门处理多对一的映射</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/maven&amp;MyBatis.assets/image-20221029141817073.png" alt="image-20221029141817073"></p><p>注：</p><ul><li>主标签中的property是需要处理多对的映射关系属性名，javaType是该属性的类型</li><li>子标签中的其他的类似</li></ul></li><li><p>方法3：分步查询（用的多）</p><ul><li><p>可以实现延迟加载</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/maven&amp;MyBatis.assets/image-20221029142822041.png" alt="image-20221029142822041"></p></li></ul></li></ul></li></ul><p>​    </p><p>​    </p><h3 id="五-自定义映射resultMap"><a href="#五-自定义映射resultMap" class="headerlink" title="五 自定义映射resultMap"></a>五 自定义映射resultMap</h3><ul><li>用于处理类中属性名和表中字段名不一致的情况</li></ul><p>​        </p><link rel="stylesheet" href="https://cdn1.tianli0.top/gh/zhheo/Post-Abstract-AI@0.15.2/tianli_gpt.css"><script>let tianliGPT_postSelector = '#post #article-container';let tianliGPT_key = 'c9b7741d290063ab872e';</script><script src="https://cdn1.tianli0.top/gh/zhheo/Post-Abstract-AI@0.15.2/tianli_gpt.js"></script>]]></content>
      
      
      <categories>
          
          <category> 中间件/框架 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java中级 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring</title>
      <link href="/posts/18155.html"/>
      <url>/posts/18155.html</url>
      
        <content type="html"><![CDATA[<h2 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h2><h3 id="一-概述"><a href="#一-概述" class="headerlink" title="一 概述"></a>一 概述</h3><h4 id="1-简介"><a href="#1-简介" class="headerlink" title="1 简介"></a>1 简介</h4><ul><li>轻量级开源JavaEE框架</li><li>解决企业应用开发</li><li>IOC控制反转：把创建对象的过程交给Spring处理</li><li>AOP面向切面：不修改源代码进行功能增强</li></ul><h4 id="2-特点"><a href="#2-特点" class="headerlink" title="2 特点"></a>2 特点</h4><ul><li>方便解耦</li><li>AOP编程支持</li><li>方便测试</li><li>方便集成框架</li><li>方便进行事务操作</li></ul><h4 id="3-Spring5-x"><a href="#3-Spring5-x" class="headerlink" title="3 Spring5.x"></a>3 Spring5.x</h4><h4 id="4-下载Spring"><a href="#4-下载Spring" class="headerlink" title="4  下载Spring"></a>4  下载Spring</h4><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/Spring.assets/image-20221115153400084.png" alt="image-20221115153400084"></p><p><a href="https://repo.spring.io/ui/native/release/org/springframework/spring/">https://repo.spring.io/ui/native/release/org/springframework/spring/</a></p><h4 id="5-Spring-demo"><a href="#5-Spring-demo" class="headerlink" title="5 Spring demo"></a>5 Spring demo</h4><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/Spring.assets/image-20221115154446807.png" alt="image-20221115154446807"></p><p>引入包-&gt;创建对象-&gt;xml注解</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/Spring.assets/image-20221115155337255.png" alt="image-20221115155337255"></p><h3 id="二-IOC容器"><a href="#二-IOC容器" class="headerlink" title="二 IOC容器"></a>二 IOC容器</h3><h4 id="0-概念"><a href="#0-概念" class="headerlink" title="0 概念"></a>0 概念</h4><ul><li>IOC：控制反转，把对象的创建和对象之间的调用过程交给Spring管理，目的是为了降低耦合度</li></ul><h4 id="1底层原理"><a href="#1底层原理" class="headerlink" title="1底层原理"></a>1底层原理</h4><ul><li><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/Spring.assets/image-20221115160629915.png" alt="image-20221115160629915"></p></li><li><p>耦合度较高，通过工厂模式降低耦合度：</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/Spring.assets/image-20221115160828185.png" alt="image-20221115160828185"></p></li><li><p>使用IOC再降低耦合度（UserDao变化了只需要修改xml配置）</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/Spring.assets/image-20221115161420841.png" alt="image-20221115161420841"></p></li></ul><h4 id="2-IOC接口"><a href="#2-IOC接口" class="headerlink" title="2 IOC接口"></a>2 IOC接口</h4><ul><li>IOC思想基于IOC容器实现，IOC容器底层就是对象工厂</li><li>Spring提供IOC容器实现的两种方式（两个接口）<ul><li>BeanFactory：IOC容器的实现，Spring的内部使用接口，不提供开发人员进行使用<ul><li>加载配置文件的时候不会创建对象，获取对象的时候才创建</li></ul></li><li>ApplicationContext：BeanFactory子接口，提供更多的功能，面向开发人员<ul><li>加载配置文件的时候就创建了对象</li></ul></li></ul></li></ul><h4 id="3-IOC操作Bean管理（基于XML）"><a href="#3-IOC操作Bean管理（基于XML）" class="headerlink" title="3 IOC操作Bean管理（基于XML）"></a>3 IOC操作Bean管理（基于XML）</h4><ul><li><p>Bean管理（指的是两个操作）</p><ul><li>Spring创建对象</li><li>Spring注入属性 </li></ul></li><li><p>Bean管理两种方式：基于xml和基于注解</p></li><li><p>基于xml创建对象</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/Spring.assets/image-20221115163651852.png" alt="image-20221115163651852"></p><ul><li>在Spring的配置文件中使用bean标签，在标签里面添加对应属性<ul><li>bean标签中的属性<ul><li><code>id</code>：唯一标识</li><li><code>class</code>：类的全路径</li><li><code>name</code>：和id类似，但是name中可以添加特殊字符（不用）</li></ul></li><li>创建对象的时候，默认执行无参构造</li></ul></li></ul></li><li><p>基于xml注入属性</p><ul><li><p>DI：依赖注入，就是注入属性</p></li><li><p>方式1：使用set方法</p><p>首先在类中定义相关属性的set方法，然后修改xml配置</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/Spring.assets/image-20221115164453292.png" alt="image-20221115164453292"></p></li><li><p>方式2：有参构造注入</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/Spring.assets/image-20221115164734935.png" alt="image-20221115164734935"></p></li><li><p>注入空值</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/Spring.assets/image-20221115165450375.png" alt="image-20221115165450375"></p></li><li><p>注入属性-外部bean</p><ul><li><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/Spring.assets/image-20221115165842807.png" alt="image-20221115165842807"></p></li><li><p>在xml中配置</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/Spring.assets/image-20221115170251160.png" alt="image-20221115170251160"></p></li></ul></li><li><p>注入属性-内部bean</p><ul><li><p>用于设置对象属性</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/Spring.assets/image-20221115181409184.png" alt="image-20221115181409184"></p></li></ul></li><li><p>级联赋值</p><ul><li><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/Spring.assets/image-20221115181654064.png" alt="image-20221115181654064"></li></ul></li><li><p>注入集合属性</p><ul><li><p>注入数组类型属性</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/Spring.assets/image-20221115182247748.png" alt="image-20221115182247748"></p></li><li><p>注入List类型属性</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/Spring.assets/image-20221115182301373.png" alt="image-20221115182301373"></p></li><li><p>注入Map集合类型属性 </p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/Spring.assets/image-20221115182320866.png" alt="image-20221115182320866"></p></li><li><p>集合中设置对象类型的值</p><ul><li><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/Spring.assets/image-20221115182906478.png" alt="image-20221115182906478"></li></ul></li><li><p>抽取出公共集合</p><ul><li><p>在Spring中引入名称空间util</p></li><li><p>使用util标签完成集合类型注入</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/Spring.assets/image-20221115183151408.png" alt="image-20221115183151408"></p></li></ul></li></ul></li></ul></li></ul><h4 id="3IOC操作Bean管理（FactoryBean）"><a href="#3IOC操作Bean管理（FactoryBean）" class="headerlink" title="3IOC操作Bean管理（FactoryBean）"></a>3IOC操作Bean管理（FactoryBean）</h4><ul><li>Spring有两种Bean：普通Bean和工厂Bean<ul><li>普通Bean：在配置文件中定义bean类型就是返回类型</li><li>工厂Bean：在配置文件中定义bean类型可以和返回类型不一样</li></ul></li><li>创建工厂Bean<ul><li>创建类，让这个类作为工厂bean，实现接口FactoryBean</li><li>实现接口的方法，在实现的方法中定义返回的bean类型</li></ul></li></ul><h4 id="5IOC操作Bean管理（Bean的作用域和生命周期）"><a href="#5IOC操作Bean管理（Bean的作用域和生命周期）" class="headerlink" title="5IOC操作Bean管理（Bean的作用域和生命周期）"></a>5IOC操作Bean管理（Bean的作用域和生命周期）</h4><ul><li>在Spring里面可以设置创建的bean实例是单实例还是多实例，Spring中默认的情况下，创建的bean是单实例对象</li><li>设置单实例和多实例<ul><li>bean标签中scope属性<ul><li>singleton，单实例（默认），加载xml配置文件的时候就创建了</li><li>prototype，多实例 ，每次调用的时候才创建</li><li>request</li><li>session</li></ul></li></ul></li><li>生命周期<ul><li>通过构造器创建bean实例（无参）</li><li>为bean中的属性设置，和对bean 的引用（调用set方法）</li><li>调用bean中初始化的方法（需要进行配置初始化方法）</li><li>bean可以使用</li><li>当容器关闭的时候，调用bean的销毁方法（需要进行配置销毁的方法）</li></ul></li></ul><h4 id="6IOC操作Bean管理（xml自动装配）（用的少）"><a href="#6IOC操作Bean管理（xml自动装配）（用的少）" class="headerlink" title="6IOC操作Bean管理（xml自动装配）（用的少）"></a>6IOC操作Bean管理（xml自动装配）（用的少）</h4><ul><li><p>根据指定装配规则，Spring自动将匹配的属性值进行注入</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/Spring.assets/image-20221116144850644.png" alt="image-20221116144850644"></p></li></ul><h4 id="7IOC操作Bean管理（外部属性文件）"><a href="#7IOC操作Bean管理（外部属性文件）" class="headerlink" title="7IOC操作Bean管理（外部属性文件）"></a>7IOC操作Bean管理（外部属性文件）</h4><ul><li><p>经常用在数据库配置中</p></li><li><p>直接配置数据库信息</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/Spring.assets/image-20221116145544939.png" alt="image-20221116145544939"></p><p>如果要修改则要改xml文件，很麻烦</p></li><li><p>通过引入外部属性文件配置数据库信息、</p><p>读取外部的propereties属性文件引入到Spring配置中</p><p>首先创建名称空间</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/Spring.assets/image-20221116145816650.png" alt="image-20221116145816650"></p><p>然后引入</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/Spring.assets/image-20221116145909039.png" alt="image-20221116145909039"></p></li></ul><h4 id="8IOC操作Bean管理（基于注解）"><a href="#8IOC操作Bean管理（基于注解）" class="headerlink" title="8IOC操作Bean管理（基于注解）"></a>8IOC操作Bean管理（基于注解）</h4><ul><li><p>注解是代码中特殊的标记，格式：<code>@注解名称(属性名称=属性值, 属性名称=属性值...)</code></p></li><li><p>目的：简化xml配置</p></li><li><p>Spring针对Bean管理中创建对象提供注解</p><ul><li><p><code>@Component</code></p></li><li><p><code>@Service</code></p></li><li><p><code>@Controller</code></p></li><li><p><code>@Repository</code></p><p>注：上面四个注解功能是一样的，都可以用来创建bean实例</p></li></ul></li><li><p>基于注解方式实现对象的创建</p><ul><li><p>引入依赖<img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/Spring.assets/image-20221116150827079.png" alt="image-20221116150827079"></p></li><li><p>开启组件扫描</p><ul><li><p>配置文件中引入名称空间</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/Spring.assets/image-20221116151120597.png" alt="image-20221116151120597"></p></li><li><p>开启组件扫描</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/Spring.assets/image-20221116151322552.png" alt="image-20221116151322552"></p></li></ul></li><li><p>创建类，在类上添加注解，注解中的value相当于bean中的id值</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/Spring.assets/image-20221116151520899.png" alt="image-20221116151520899"></p></li><li><p>注意</p><p>只扫描<code>@Controller</code></p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/Spring.assets/image-20221116152157953.png" alt="image-20221116152157953"></p><p>不扫描<code>@Controller</code></p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/Spring.assets/image-20221116152254012.png" alt="image-20221116152254012"></p></li></ul></li><li><p>基于注解实现属性的注入</p><ul><li><p>注解</p><ul><li><code>AutoWired</code>：根据属性类型进行自动装配</li><li><code>Qualifier</code>：根据属性名进行注入</li><li><code>Resource</code>：可以根据类型也可以根据名称</li><li><code>@Value</code>：普通注入</li></ul></li><li><p><code>AutoWired</code></p><ul><li><p>添加创建对象的注解（在类上面）</p></li><li><p>在service中注入dao对象，在service类型添加dao类型属性，在属性上使用注解</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/Spring.assets/image-20221116153014805.png" alt="image-20221116153014805"></p></li></ul></li></ul></li></ul><ul><li><p><code>Qualifier</code></p><ul><li><p>要和<code>AutoWired</code>一起使用，当接口有多个实现类的时候就需要根据指定的实现类的名称来注入了</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/Spring.assets/image-20221116153313011.png" alt="image-20221116153313011"></p></li></ul></li><li><p><code>Value</code></p><ul><li><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/Spring.assets/image-20221116153926755.png" alt="image-20221116153926755"></li></ul></li></ul><ul><li><p>完全注解开发（实际中用SpringBoot实现）</p><ul><li><p>创建配置类，替代xml配置文件</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/Spring.assets/image-20221116154410047.png" alt="image-20221116154410047"></p></li><li><p>编写测试方法</p><ul><li>加载配置类-&gt;获得相关类-&gt;实现方法</li></ul><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/Spring.assets/image-20221116154522734.png" alt="image-20221116154522734"></p></li></ul></li></ul><h3 id="三-AOP"><a href="#三-AOP" class="headerlink" title="三 AOP"></a>三 AOP</h3><h4 id="0-概念-1"><a href="#0-概念-1" class="headerlink" title="0 概念"></a>0 概念</h4><ul><li><p>AOP-面向切面编程</p></li><li><p>目的：降低耦合度 ，隔离代码中的各个部分，不修改源代码实现功能的添加</p></li><li><p>底层原理：动态代理</p><ul><li><p>有接口，使用JDK动态代理</p><ul><li><p>创建接口实现类的代理对象来增强实现类的功能</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/Spring.assets/image-20221118092906018.png" alt="image-20221118092906018"></p></li><li><p>使用Proxy类中的方法 <code>newProxyInstance</code></p><ul><li>三个参数：ClassLoader类加载器，类的接口（支持多个），InvocationHandler（实现这个接口创建代理对象）</li></ul></li><li><p>步骤</p><ul><li><p>创建接口<img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/Spring.assets/image-20221118093906419.png" alt="image-20221118093906419"></p></li><li><p>接口实现类<img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/Spring.assets/image-20221118094119498.png" alt="image-20221118094119498"></p></li><li><p>使用Proxy创建接口代理对象</p><ul><li>主要是实现InvocationHandler中的invoke方法，也就是增强的部分</li></ul></li></ul></li></ul></li></ul></li></ul><ul><li><p>没有接口，使用CGLIB动态代理</p><ul><li><p>创建当前类子类的代理对象</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/Spring.assets/image-20221118093106899.png" alt="image-20221118093106899"></p></li></ul></li></ul><ul><li><p>术语：</p><ul><li>连接点：可以被增强的方法</li><li>切入点：实际被增强的方法</li><li><p>通知（增强）：</p><ul><li>实际增强的逻辑部分称为通知（增强）</li><li>通知的多种类型<ul><li>前置通知</li><li>后置通知</li><li>环绕通知</li><li>异常通知</li><li>最终通知</li></ul></li></ul></li><li><p>切面：是一个动作——把通知用到切入点的动作</p></li></ul></li></ul><h4 id="1-AOP操作"><a href="#1-AOP操作" class="headerlink" title="1 AOP操作"></a>1 AOP操作</h4><ul><li><p>Spring框架一般都是基于AspectJ实现AOP操作</p><ul><li><p>Aspect J不是Spring的组成，独立于AOP框架，一般AspectJ和Spring一起使用进行AOP</p></li><li><p>基于xml和基于注解的实现</p></li><li><p>依赖</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/Spring.assets/image-20221118100659244.png" alt="image-20221118100659244"></p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/Spring.assets/image-20221118100726328.png" alt="image-20221118100726328"></p></li><li><p>切入点表达式</p><ul><li>作用：知道对哪个类的哪个方法增强</li><li>语法结构<ul><li><code>execution([权限修饰符][返回类型][类全路径][方法名称]([参数列表]))</code><ul><li>例如: <code>execution(* com.atguigu.dao.Bookdao.add(..))</code><ul><li>*表示所有的修饰符，返回类型为void省略不写（空格代替）</li></ul></li><li><code>execution(* com.atguigu.dao.Bookdao.*(..))</code><ul><li>对所有方法增强</li></ul></li></ul></li></ul></li></ul></li></ul></li><li><p>AspectJ操作（基于注解）</p><ul><li><p>创建类，定义方法<img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/Spring.assets/image-20221118101733440.png" alt="image-20221118101733440"></p></li><li><p>创建增强类（编写增强逻辑）  <img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/Spring.assets/image-20221118101743279.png" alt="image-20221118101743279"></p></li><li><p>进行通知的配置</p><ul><li><p>在Spring的配置文件中开启注解扫描</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/Spring.assets/image-20221118102108410.png" alt="image-20221118102108410"></p></li><li><p>使用注解创建User和UserProxy对象</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/Spring.assets/image-20221118102206580.png" alt="image-20221118102206580"></p></li><li><p>在增强类上面添加注解 <code>@Aspect</code></p><ul><li>UserProxy上面</li></ul></li><li><p>在Spring配置文件中开启生成代理对象</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/Spring.assets/image-20221118102257053.png" alt="image-20221118102257053"></p></li></ul></li><li><p>配置不同类型的通知</p><ul><li><p>在增强类里面，作为通知方法上添加通知类型</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/Spring.assets/image-20221118102701435.png" alt="image-20221118102701435"></p></li></ul></li><li><p>注：</p><ul><li><p>共同切入点抽取，在通知的value那里设置</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/Spring.assets/image-20221118103753199.png" alt="image-20221118103753199"></p></li><li><p>多个增强类对同一个方法的增强，设置增强优先级</p><ul><li><p>在增强类上面加注解 <code>@Order(数字类型值)</code>，值越小优先级越高 </p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/Spring.assets/image-20221118104026922.png" alt="image-20221118104026922"></p></li></ul></li></ul></li></ul></li></ul><ul><li><p>AspectJ操作（基于xml）</p><ul><li><p>一般用的注解，配置文件比较麻烦</p></li><li><p>创建两个类，增强类和被增强类，创建方法</p></li><li><p>在Spring配置文件中创建两个类对象</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/Spring.assets/image-20221118104323885.png" alt="image-20221118104323885"></p></li><li><p>在Spring配置文件中配置切入点</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/Spring.assets/image-20221118104521709.png" alt="image-20221118104521709"></p></li></ul></li></ul><h3 id="四-JdbcTemplate"><a href="#四-JdbcTemplate" class="headerlink" title="四 JdbcTemplate"></a>四 JdbcTemplate</h3><h4 id="0概念"><a href="#0概念" class="headerlink" title="0概念"></a>0概念</h4><ul><li>Spring对Jdbc封装，使用JdbcTemplate方便实现对数据操作</li></ul><h4 id="1-准备工作"><a href="#1-准备工作" class="headerlink" title="1 准备工作"></a>1 准备工作</h4><ul><li><p>引入依赖</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/Spring.assets/image-20221122113216760.png" alt="image-20221122113216760"></p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/Spring.assets/image-20221122113237732.png" alt="image-20221122113237732"></p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/Spring.assets/image-20221122113250336.png" alt="image-20221122113250336">事务</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/Spring.assets/image-20221122113257205.png" alt="image-20221122113257205">整合其他框架（如Mybatis)</p></li><li><p>在Spring配置文件中配置数据库连接池</p></li><li><p>配置JdbcTemplate对象，注入DataSource</p></li></ul><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/Spring.assets/image-20221122113724253.png" alt="image-20221122113724253"></p><ul><li>创建service类，创建dao类，在dao类注入jdbctemplate</li></ul><h4 id="2-操作数据库"><a href="#2-操作数据库" class="headerlink" title="2 操作数据库"></a>2 操作数据库</h4><ul><li><p>对数据库表创建实体类  </p></li><li><p>编写service和dao</p><ul><li><p>在dao进行数据库添加操作</p><p><code>JdbcTemplate.update(String sql, Object... args)</code></p><p>​    第二个参数为可变参数</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/Spring.assets/image-20221122142304680.png" alt="image-20221122142304680"></p></li><li><p>删改调用的函数也是一样的</p></li><li><p>查询</p><ul><li><p>返回值</p><ul><li><code>JdbcTemplate.queryForObject(String sql, Class&lt;T&gt; requiredType)</code><ul><li>requiredType:返回类型的class</li></ul></li></ul></li><li><p>返回对象</p><ul><li><p><code>JdbcTemplate.queryForObject(String sql, RowMapper&lt;T&gt; rowMapper, Object...args)</code></p><ul><li>rowMapper：RowMapper是接口，返回不同类型数据，使用这个接口的实现类完成数据的封装（BeanPropertyRowMapper）</li><li>requiredType：sql语句的值</li></ul><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/Spring.assets/image-20221122144003682.png" alt="image-20221122144003682"></p></li></ul></li><li><p>返回集合(注意方法名和前两个不一样)</p><ul><li><p><code>JdbcTemplate.query(String sql, RowMapper&lt;T&gt; rowMapper, Object...args)</code></p><ul><li>rowMapper：RowMapper是接口，返回不同类型数据，使用这个接口的实现类完成数据的封装（BeanPropertyRowMapper）</li><li>requiredType：sql语句的值</li></ul><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/Spring.assets/image-20221122144356188.png" alt="image-20221122144356188"></p></li></ul></li></ul></li></ul></li><li><p>批量添加操作</p><ul><li><p><code>JdbcTemplate.batchUpdate(String sql, List&lt;Object[]&gt; batchArgs)</code></p><ul><li>batchArgs：List集合，添加多条记录</li></ul><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/Spring.assets/image-20221122144806370.png" alt="image-20221122144806370"></p><p>底层会遍历batchArgs数组，分别执行sql语句实现批量的添加</p></li></ul></li><li><p>批量修改删除操作（同添加）</p></li></ul><h3 id="五-事务"><a href="#五-事务" class="headerlink" title="五 事务"></a>五 事务</h3><h4 id="0-概念-2"><a href="#0-概念-2" class="headerlink" title="0 概念"></a>0 概念</h4><ul><li><p>Spring5 特性</p></li><li><p>事务是数据库操作最基本单元，逻辑上一组操作，要么都成功，如果一个失败则所有操作都失败。</p></li><li><p>事务的四大特性（ACID）</p><ul><li>原子性：操作不可分割（要么都成功或者都失败）</li><li>一致性：操作前后总量不变</li><li>隔离性：多人操作不干涉</li><li>持久性</li></ul></li><li><p>银行转账</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/Spring.assets/image-20221129091229198.png" alt="image-20221129091229198"></p><p>可能在转账过程中出现异常导致一方减钱一方不变，这时候需要进行异常判断并进行事务的回滚</p></li></ul><h4 id="1-Spring事务"><a href="#1-Spring事务" class="headerlink" title="1 Spring事务"></a>1 Spring事务</h4><ul><li>一般添加到service层中（业务逻辑层）</li><li><p>在Spring中的事务管理</p><ul><li>编程式事务管理（一般不用）</li><li>声明式事务管理</li></ul></li><li><p>声明式事务管理</p><ul><li>基于xml配置文件方式</li><li>基于注解方式</li></ul></li><li><p>在Spring进行声明式事务管理，底层使用AOP</p></li><li><p>Spring事务管理API</p><ul><li><p>提供一个接口，代表事务管理器，这个接口针对不同的框架实现不同的实现类</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/Spring.assets/image-20221129092606010.png" alt="image-20221129092606010"></p></li></ul></li></ul><h4 id="2-事务操作（注解声明式事务管理）"><a href="#2-事务操作（注解声明式事务管理）" class="headerlink" title="2 事务操作（注解声明式事务管理）"></a>2 事务操作（注解声明式事务管理）</h4><ul><li><p>Spring配置文件中创建事务管理器并注入数据源</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/Spring.assets/image-20221129092847231.png" alt="image-20221129092847231"></p></li><li><p>引入名称空间</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/Spring.assets/image-20221129092934677.png" alt="image-20221129092934677"></p></li><li><p>开启事务注解</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/Spring.assets/image-20221129093004986.png" alt="image-20221129093004986"></p></li><li><p>在service类上面（或者在service类里面的方法上面）添加事务注解</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/Spring.assets/image-20221129093108158.png" alt="image-20221129093108158"></p><p><code>@Transactional</code>：在类上面则这个类所有的方法都添加了事务，在方法上面就只有该方法添加了事务</p></li><li><p>参数说明</p><ul><li><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/Spring.assets/image-20221129093347328.png" alt="image-20221129093347328"></p></li><li><p><code>Propagation</code>：事务的传播行为</p></li><li><p><code>Isolation</code>：隔离级别</p><ul><li><p>事务有三个读问题：脏读、不可重复读、虚（幻）读</p><ul><li>脏读：一个未提交事务读取到另一个未提交事务的数据</li><li>不可重复读：一个未提交事务读取到另一个提交事务修改数据</li><li>虚读：一个未提交事务读取到另一个提交事务添加数据</li></ul></li><li><p>解决方式：通过设置事务的隔离级别解决读问题</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/Spring.assets/image-20221129095436660.png" alt="image-20221129095436660"></p></li></ul></li><li><p><code>timeout</code>：超时时间</p><ul><li>事务需要在一定时间内进行提交，如果不提交则回滚</li><li>默认值是-1，设置时间以秒未单位计算</li></ul></li><li><p><code>readonly</code>：是否只读</p><ul><li>默认值false，表示可以增删改查</li><li>设为true后只能查询</li></ul></li><li><p><code>rollbackFor</code>：回滚</p><ul><li>设置出现哪些异常进行事务回滚</li></ul></li><li><p><code>noRollbackFor</code>：不回滚</p><ul><li>设置出现哪些异常不进行事务回滚</li></ul></li></ul></li></ul><h4 id="3-事务操作（xml方式）"><a href="#3-事务操作（xml方式）" class="headerlink" title="3 事务操作（xml方式）"></a>3 事务操作（xml方式）</h4><ul><li><p>step1 配置事务管理器</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/Spring.assets/image-20221129095636370.png" alt="image-20221129095636370"></p></li><li><p>step2 配置通知</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/Spring.assets/image-20221129095738033.png" alt="image-20221129095738033"></p></li><li><p>step3 配置切入点和切面</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/Spring.assets/image-20221129095901665.png" alt="image-20221129095901665"></p></li></ul><h4 id="4-事务操作（完全注解开发）"><a href="#4-事务操作（完全注解开发）" class="headerlink" title="4 事务操作（完全注解开发）"></a>4 事务操作（完全注解开发）</h4><ul><li><p>step1 编写配置类</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/Spring.assets/image-20221129100352748.png" alt="image-20221129100352748"></p><p>1.1 在里面创建数据库连接池</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/Spring.assets/image-20221129100453686.png" alt="image-20221129100453686"></p><p>1.2 创建jdbcTemplate对象</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/Spring.assets/image-20221129100615531.png" alt="image-20221129100615531"></p><p>1.3 创建事务管理器</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/Spring.assets/image-20221129100643066.png" alt="image-20221129100643066"></p></li><li><p>step2 测试</p></li></ul><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/Spring.assets/image-20221129100736397.png" alt="image-20221129100736397"></p><link rel="stylesheet" href="https://cdn1.tianli0.top/gh/zhheo/Post-Abstract-AI@0.15.2/tianli_gpt.css"><script>let tianliGPT_postSelector = '#post #article-container';let tianliGPT_key = 'c9b7741d290063ab872e';</script><script src="https://cdn1.tianli0.top/gh/zhheo/Post-Abstract-AI@0.15.2/tianli_gpt.js"></script>]]></content>
      
      
      <categories>
          
          <category> study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java高级 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaWeb</title>
      <link href="/posts/60206.html"/>
      <url>/posts/60206.html</url>
      
        <content type="html"><![CDATA[<h2 id="JavaWeb"><a href="#JavaWeb" class="headerlink" title="JavaWeb"></a>JavaWeb</h2><h3 id="一-数据库"><a href="#一-数据库" class="headerlink" title="一 数据库"></a>一 数据库</h3><h4 id="1-1-mysql"><a href="#1-1-mysql" class="headerlink" title="1.1 mysql"></a>1.1 mysql</h4><ul><li>数据库管理系统（DBMS）</li><li>关系型数据库：由多张互连的二维表组成的数据库<ul><li>优点：易维护；使用通用的sql语言操作；数据存储在磁盘，安全</li></ul></li></ul><h4 id="1-2-sql语法"><a href="#1-2-sql语法" class="headerlink" title="1.2 sql语法"></a>1.2 sql语法</h4><ul><li><p>结构化查询语言(Structured Query Language)</p></li><li><p>注释：单行：<code>#</code>        多行：<code>/* */</code></p></li><li><p>DDL：操作数据库、表等</p><ul><li>查询：<code>show database 数据库名</code></li><li>创建：<code>create database if not exists 数据库名</code></li><li>删除：<code>drop database if exists 数据库名</code></li><li>使用：<code>select database() //查询当前使用的数据库</code> ; <code>use 数据库名</code></li></ul></li><li><p>DML：对表数据进行增删改</p><ul><li><p>创建表：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> 表名(</span><br><span class="line">字段名<span class="number">1</span> 数据类型<span class="number">1</span>,</span><br><span class="line">字段名<span class="number">2</span> 数据类型<span class="number">2</span>,</span><br><span class="line">...</span><br><span class="line">字段名n 数据类型n</span><br><span class="line">);</span><br></pre></td></tr></table></figure></li><li><p>数据类型</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/javaweb.assets/image-20230103120833176.png" alt="image-20230103120833176"></p></li><li><p>删除表： <code>DROP TABLE 表名</code></p></li><li><p>修改表：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 表名 RENAME <span class="keyword">TO</span> 新表名;</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 表名 <span class="keyword">ADD</span> 列名 数据类型;</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 表名 MODIFY 列名 新数据类型;</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 表名 CHANGE 列名 新列名 新数据类型;</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 表名 <span class="keyword">DROP</span> 列名;</span><br></pre></td></tr></table></figure></li><li><p>增加数据</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> 表名(列<span class="number">1</span>,列<span class="number">2.</span>..) <span class="keyword">values</span>(值<span class="number">1</span>,值<span class="number">2.</span>..),(值<span class="number">1</span>,值<span class="number">2.</span>..),(值<span class="number">1</span>,值<span class="number">2.</span>..)...;</span><br></pre></td></tr></table></figure></li><li><p>修改数据</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> 表名 <span class="keyword">set</span> ... <span class="keyword">where</span> 条件;</span><br><span class="line">eg: <span class="keyword">update</span> stu <span class="keyword">set</span> name <span class="operator">=</span> &quot;张三&quot; <span class="keyword">where</span> id <span class="operator">=</span> &quot;1&quot;;</span><br></pre></td></tr></table></figure></li><li><p>删除</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> 表名 [<span class="keyword">where</span> 条件];</span><br></pre></td></tr></table></figure></li></ul></li><li><p>DQL：对表中数据查询</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line">字段列表(<span class="keyword">as</span>)</span><br><span class="line"><span class="keyword">FROM</span> </span><br><span class="line">表名列表</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">条件列表(between...and...;<span class="keyword">or</span>;<span class="keyword">and</span>;<span class="keyword">in</span>(...);<span class="keyword">is</span> <span class="keyword">null</span>;<span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">null</span>;<span class="keyword">like</span>)</span><br><span class="line"><span class="comment">-- 模糊查询like通配符：&quot;-&quot;：一个字符 &quot;%&quot;：多个字符</span></span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span></span><br><span class="line">分组字段</span><br><span class="line"><span class="comment">-- 聚合函数：count(列名) max(列名) min(列名) sum(列名) avg(列名)</span></span><br><span class="line">eg: <span class="keyword">select</span> sex <span class="built_in">avg</span>(math) <span class="keyword">from</span> stu <span class="keyword">where</span> math <span class="operator">&gt;</span> <span class="number">70</span> <span class="keyword">group</span> <span class="keyword">by</span> sex;</span><br><span class="line"><span class="keyword">HAVING</span></span><br><span class="line">分组后条件</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span></span><br><span class="line">排序字段(<span class="keyword">asc</span>:升序;<span class="keyword">desc</span>:降序;) eg:.... <span class="keyword">ORDER</span> <span class="keyword">BY</span> math <span class="keyword">asc</span>,english <span class="keyword">desc</span>;</span><br><span class="line">LIMIT</span><br><span class="line">分页限定(起始索引,分页条数)</span><br><span class="line">eg: <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> stu limit <span class="number">0</span>, <span class="number">3</span>;</span><br></pre></td></tr></table></figure></li><li><p>DCL：对数据库进行权限控制</p></li></ul><h4 id="1-3-约束"><a href="#1-3-约束" class="headerlink" title="1.3 约束"></a>1.3 约束</h4><ul><li><p>作用于列，用于限制列中数据</p></li><li><p>非空约束 <code>NOT NULL</code></p></li><li><p>唯一约束 <code>UNIQUE</code></p></li><li><p>主键约束 <code>PRIMARY KEY</code>：非空且唯一</p></li><li><p>检查约束 <code>CHECK</code></p></li><li><p>默认约束 <code>DEFAULT</code>：若没有值则制定默认值</p></li><li><p>外键约束 <code>FOREIGN KEY</code>：让两个表的数据建立连接，保证数据完整</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">主表：部门id表</span></span><br><span class="line"><span class="comment">从表：员工表</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 创建表时添加约束</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> 表名(</span><br><span class="line">...</span><br><span class="line">    [<span class="keyword">CONSTRAINT</span>] [外键名] <span class="keyword">FOREIGN</span> KEY(外键列名) <span class="keyword">REFERENCES</span> 主表(主表名称)   </span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 建表完后添加外键</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 名 <span class="keyword">ADD</span> <span class="keyword">CONSTRAINT</span> 外键名 <span class="keyword">FOREIGN</span> KEY(外键字段名) <span class="keyword">REFERENCES</span> 主表(主表名称)  </span><br><span class="line"></span><br><span class="line"><span class="comment">-- 删除外键</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 表名 <span class="keyword">DROP</span> <span class="keyword">FOREIGN</span> KEY 外键名称</span><br></pre></td></tr></table></figure></li></ul><h4 id="1-3-数据库设计"><a href="#1-3-数据库设计" class="headerlink" title="1.3 数据库设计"></a>1.3 数据库设计</h4><ul><li>表关系<ul><li>一对一</li><li>一对多：在多的一方建立外键指向一的部分的主键（在员工中建立外键指向部门主键）</li><li>多对多：通过建立一个中间表，里面有至少两个外键关联两个多表的主键</li></ul></li></ul><h4 id="1-3-多表查询"><a href="#1-3-多表查询" class="headerlink" title="1.3 多表查询"></a>1.3 多表查询</h4><ul><li><p>从多张表中查询数据</p></li><li><p>连接查询</p><ul><li><p>内连接：相当于查询AB交集数据</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 隐式内连接</span></span><br><span class="line"><span class="keyword">SELECT</span> 字段列表 <span class="keyword">FROM</span> 表<span class="number">1</span>,表<span class="number">2.</span>.. <span class="keyword">WHERE</span> 条件;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 显式内连接</span></span><br><span class="line"><span class="keyword">SELECT</span> 字段列表 <span class="keyword">FROM</span> 表<span class="number">1</span> [<span class="keyword">INNER</span>] <span class="keyword">JOIN</span> 表<span class="number">2</span> <span class="keyword">ON</span> 条件;</span><br></pre></td></tr></table></figure></li></ul></li></ul><ul><li><p>外连接：</p><ul><li>左外连接：相当于查询A表所有数据和交集部分</li><li>右外连接：相当于查询B表所有数据和交集部分</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 左外连接</span></span><br><span class="line"><span class="keyword">SELECT</span> 字段列表 <span class="keyword">FROM</span> 表<span class="number">1</span> <span class="keyword">LEFT</span> [<span class="keyword">OUTER</span>] <span class="keyword">JOIN</span> 表<span class="number">2</span> <span class="keyword">ON</span> 条件;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 右外连接</span></span><br><span class="line"><span class="keyword">SELECT</span> 字段列表 <span class="keyword">FROM</span> 表<span class="number">1</span> <span class="keyword">RIGHT</span> [<span class="keyword">OUTER</span>] <span class="keyword">JOIN</span> 表<span class="number">2</span> <span class="keyword">ON</span> 条件;</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>子查询</p><ul><li>嵌套查询</li></ul></li></ul><h4 id="1-3-事务"><a href="#1-3-事务" class="headerlink" title="1.3 事务"></a>1.3 事务</h4><ul><li>一组数据库操作命令</li><li>要么同时成功，要么同时失败</li><li>开启事务（begin）-提交事务（commit）-回滚事务（rollback）</li><li>四大特性<ul><li>原子性</li><li>一致性</li><li>隔离性</li><li>持久性</li></ul></li></ul><h3 id="二-JDBC"><a href="#二-JDBC" class="headerlink" title="二 JDBC"></a>二 JDBC</h3><ul><li><p>Java DataBase Connectivity：用java语言操作关系型数据库的API</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/javaweb.assets/image-20230104122043751.png" alt="image-20230104122043751"></p></li></ul><h4 id="2-1-JDBC简介"><a href="#2-1-JDBC简介" class="headerlink" title="2.1 JDBC简介"></a>2.1 JDBC简介</h4><ul><li>sun公司定义的一套操作数据库接口</li><li>注册驱动<ul><li><code>Class.forName(&quot;com.mysql.jdbc.Driver&quot;);//mysql 5之后不需要写了</code></li></ul></li><li>获取连接<ul><li><code>Connection conn = DriverManager.getConnection(url, username, password)</code></li></ul></li><li>定义sql语句</li><li>获取执行sql对象<ul><li><code>Statrment stmt = conn.createStatement()</code></li></ul></li><li>执行sql<ul><li><code>int count = stmt.executeUpdate(sql)</code></li></ul></li><li>处理返回结果</li><li>释放资源<ul><li><code>stmt.close();conn.close();</code></li></ul></li></ul><h4 id="2-2-API"><a href="#2-2-API" class="headerlink" title="2.2 API"></a>2.2 API</h4><ul><li><p>DriverManager</p><ul><li>注册驱动 <code>registerDriver()</code></li><li>获取数据库连接 <code>getConnection(...)</code></li></ul></li><li><p>Connection</p><ul><li>进行连接</li></ul></li><li><p>Statement</p><ul><li>执行sql语句</li></ul></li><li><p>ResultSet</p><ul><li><p>结果集对象封装了DQL查询语句的结果</p></li><li><p><code>next()</code>：光标向前移动一行，判断是否为有效行，返回true/false</p></li><li><p><code>getXxx(参数)</code>:Xxx为数据类型（int/String…）获取数据</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(re.next())&#123;</span><br><span class="line">    <span class="comment">//获取数据</span></span><br><span class="line">    re.getXxx(参数);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>PreparedStatement</p><ul><li><p>继承Statement</p></li><li><p>预编译Sql语句并执行：防止sql注入；效率更高（只进行一次检查sql语法和编译sql，Statement每次都要检查-编译-执行）</p></li><li><p>原理：对特殊字符进行了转义；进行了预编译功能（需要手动开启<code>useServerPrepStmts = true</code>）</p></li><li><p>使用</p><ul><li><p>获取PreperedStatement对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;select * from user where username = ? and password = ?&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过Connection对象获取并传入对应的sql语句</span></span><br><span class="line"><span class="type">PreparedStatement</span> <span class="variable">pstmt</span> <span class="operator">=</span> conn.prepareStatement(sql);</span><br></pre></td></tr></table></figure></li><li><p>设置参数值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setXxx(参数<span class="number">1</span>,参数<span class="number">2</span>);<span class="comment">//参数1为?的索引，从1开始</span></span><br></pre></td></tr></table></figure></li><li><p>执行sql语句</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">executeUpdate();</span><br><span class="line">executeQuery();</span><br></pre></td></tr></table></figure></li></ul></li></ul></li></ul><h4 id="2-3-数据库连接池"><a href="#2-3-数据库连接池" class="headerlink" title="2.3 数据库连接池"></a>2.3 数据库连接池</h4><ul><li><p>是一个容器，负责分配、管理数据库连接（Connection）</p></li><li><p>优点：资源重用，提升系统响应速度，避免数据库连接遗漏</p></li><li><p>标准接口：<code>DataSource</code></p><ul><li>sun公司提供，由第三方实现</li><li>功能：获取连接 <code>Connection getConnection()</code></li></ul></li><li><p>常用的数据库连接池</p><ul><li>DBCP</li><li>C3P0</li><li>Druid</li></ul></li><li><p>Druid使用</p><ul><li><p>导入jar包 </p></li><li><p>定义配置文件</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/javaweb.assets/image-20230104131827792.png" alt="image-20230104131827792"></p></li><li><p>加载配置文件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Properties</span> <span class="variable">prop</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">prop.load(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;地址&quot;</span>))</span><br></pre></td></tr></table></figure></li><li><p>获取数据库连接池对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">DataSource</span> <span class="variable">datesource</span> <span class="operator">=</span> DruidDataSourceFactory.createDataSource(prop);</span><br></pre></td></tr></table></figure></li><li><p>获取连接</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> datasource.getConnection();</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="三-Maven"><a href="#三-Maven" class="headerlink" title="三 Maven"></a>三 Maven</h3><h4 id="3-1-简介"><a href="#3-1-简介" class="headerlink" title="3.1 简介"></a>3.1 简介</h4><ul><li>用于管理和构建java项目的工具，功能：<ul><li>提供一套标准化项目结构</li><li>提供了一套标准化的构建流程（编译、测试、打包、发布）</li><li>提供了一套依赖管理机制</li></ul></li><li><a href="./maven&amp;MyBatis.md">Maven笔记</a></li></ul><h3 id="四-MyBatis"><a href="#四-MyBatis" class="headerlink" title="四 MyBatis"></a>四 MyBatis</h3><h4 id="4-1简介"><a href="#4-1简介" class="headerlink" title="4.1简介"></a>4.1简介</h4><ul><li>负责讲数据保存到数据库的那一层代码</li><li>JavaEE三层结构：表现层、业务层、持久层</li><li>解决JDBC的问题<ul><li>硬编码<ul><li>注册驱动、获取连接</li><li>SQL语句</li></ul></li><li>操作繁琐<ul><li>手动设置参数</li><li>手动封装结果集</li></ul></li></ul></li><li><a href="https://mybatis.org/mybatis-3/zh/getting-started.html">官网链接</a></li><li><a href="./maven&amp;MyBatis.md">MyBatis笔记</a></li></ul><h4 id="4-2-demo步骤"><a href="#4-2-demo步骤" class="headerlink" title="4.2 demo步骤"></a>4.2 demo步骤</h4><ul><li><p>创建user表，添加数据</p></li><li><p>创建模块，导入坐标</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>x.x.x<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>编写Mybatis核心配置文件</p></li><li><p>编写sql映射文件</p></li><li><p>编码</p><ul><li>定义pojo类</li><li>加载核心配置文件，获取SqlSessionFactory对象</li><li>获取SqlSession对象，执行SQL语句</li><li>释放资源</li></ul></li></ul><h3 id="五-HTML-amp-CSS-amp-JavaScript"><a href="#五-HTML-amp-CSS-amp-JavaScript" class="headerlink" title="五 HTML&amp;CSS&amp;JavaScript"></a>五 HTML&amp;CSS&amp;JavaScript</h3><h4 id="4-1-简介"><a href="#4-1-简介" class="headerlink" title="4.1 简介"></a>4.1 简介</h4><ul><li>HTML(Hyper Text Markup Language)：超文本标记语言</li><li>W3C标准<ul><li>结构：HTML</li><li>表现：CSS</li><li>行为：JavaScript</li></ul></li></ul><h4 id="4-2-HTML入门"><a href="#4-2-HTML入门" class="headerlink" title="4.2 HTML入门"></a>4.2 HTML入门</h4><ul><li><p>基础标签（不区分大小写）</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">--</span> <span class="attr">h6</span>&gt;</span>：标题</span><br><span class="line"><span class="tag">&lt;<span class="name">font</span>&gt;</span>：字体</span><br><span class="line"><span class="tag">&lt;<span class="name">b</span>&gt;</span>：加粗</span><br><span class="line"><span class="tag">&lt;<span class="name">i</span>&gt;</span>：斜体</span><br><span class="line"><span class="tag">&lt;<span class="name">u</span>&gt;</span>：下划线</span><br><span class="line"><span class="tag">&lt;<span class="name">center</span>&gt;</span>：剧中</span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>：定义段落</span><br><span class="line"><span class="tag">&lt;<span class="name">br</span>&gt;</span>：定义拆行</span><br><span class="line"><span class="tag">&lt;<span class="name">hr</span>&gt;</span>：水平线</span><br></pre></td></tr></table></figure></li><li><p>图片、音频、视频标签</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span>&gt;</span>：图片</span><br><span class="line">src：定义图片url</span><br><span class="line">height：定义高度</span><br><span class="line">尺寸单位：px(像素)、百分比</span><br><span class="line">width：定义宽度</span><br><span class="line"><span class="tag">&lt;<span class="name">audio</span>&gt;</span>：音频</span><br><span class="line">src(MP3、WAV、OGG)</span><br><span class="line">controls：显示播放控件</span><br><span class="line"><span class="tag">&lt;<span class="name">video</span>&gt;</span>：视频</span><br><span class="line">src(MP4、WebM、OGG)</span><br><span class="line">controls</span><br></pre></td></tr></table></figure></li><li><p>超链接标签</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span>&gt;</span></span><br><span class="line">href：制定访问资源的url</span><br><span class="line">target：制定资源打开方式</span><br><span class="line">_self：默认值，在当前页面打开</span><br><span class="line">_blank：在空白页面打开</span><br></pre></td></tr></table></figure></li><li><p>列表标签</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ol</span>&gt;</span>：有序列表</span><br><span class="line"><span class="tag">&lt;<span class="name">type</span>&gt;</span>：标号格式(一般不用，在CSS中修改)</span><br><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span>：列表项</span><br><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span>：无序列表</span><br><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span>：列表项</span><br></pre></td></tr></table></figure></li><li><p>表格标签</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span>&gt;</span>：border(边框)、width、cellspacing(单元格之间的空白)</span><br><span class="line"><span class="tag">&lt;<span class="name">tr</span>&gt;</span>：行 aligh(对齐方式)</span><br><span class="line"><span class="tag">&lt;<span class="name">td</span>&gt;</span>：单元格 rowspan(规定单元格横跨的行数) colspan(...列数)</span><br><span class="line"><span class="tag">&lt;<span class="name">th</span>&gt;</span>：表头（加粗的）</span><br></pre></td></tr></table></figure></li><li><p>表单标签</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span>&gt;</span>  </span><br><span class="line">action(规定提交表单的时候向何处发送数据，url) </span><br><span class="line">    method(规定发送表单数据的方式)</span><br><span class="line">    get：浏览器会将数据直接附在表单的action URL之后，大小由限制(请求会拼接在URL后面所以长度有限制)</span><br><span class="line">    post：浏览器会将数据放到http请求消息体中，大小无限制</span><br><span class="line"><span class="tag">&lt;<span class="name">input</span>&gt;</span>：定义表单项，通过type属性设置输入形式</span><br><span class="line">    type属性:text、password、radio(单选)、checkbox(复选)、file、hidden(隐藏的输入字段)、submit、reset、button</span><br><span class="line"><span class="tag">&lt;<span class="name">label</span>&gt;</span>：为表单定义标注</span><br><span class="line"><span class="tag">&lt;<span class="name">select</span>&gt;</span>：定义下拉列表</span><br><span class="line"><span class="tag">&lt;<span class="name">option</span>&gt;</span>：定义下拉列表选择项</span><br><span class="line"><span class="tag">&lt;<span class="name">textarea</span>&gt;</span>：定义文本域</span><br><span class="line"></span><br><span class="line">eg：</span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;#&quot;</span> <span class="attr">method</span>=<span class="string">&quot;get&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="4-3-CSS入门"><a href="#4-3-CSS入门" class="headerlink" title="4.3 CSS入门"></a>4.3 CSS入门</h4><ul><li><p>CSS（Cascading Style Sheet）控制网页表现</p></li><li><p>CSS导入方式</p><ul><li><p>内联样式（用的少）</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="selector-tag">div</span> style=&quot;<span class="attribute">color</span>:red<span class="string">&quot;&gt;Hello CS&lt;/div&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>内部样式</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;style type=&quot;text/css&quot;&gt;</span><br><span class="line"><span class="selector-tag">div</span>&#123;</span><br><span class="line"><span class="attribute">color</span>:red;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure></li><li><p>外部样式</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;link rel=&quot;stylesheet&quot; href=&quot;demo<span class="selector-class">.css</span>&quot;&gt;</span><br><span class="line"></span><br><span class="line">demo<span class="selector-class">.css</span>中</span><br><span class="line"><span class="selector-tag">div</span>&#123;</span><br><span class="line">    <span class="attribute">color</span>:red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>CSS选择器：选取需要设置样式的元素（标签）</p><ul><li>元素选择器 <code>元素名称&#123;color:red&#125;</code></li><li>id选择器 <code>#id属性值&#123;color:red&#125;</code></li><li>类选择器 <code>.class属性值&#123;color:red&#125;</code></li></ul></li><li><p>CSS属性</p></li></ul><h4 id="4-4-JavaScript入门"><a href="#4-4-JavaScript入门" class="headerlink" title="4.4 JavaScript入门"></a>4.4 JavaScript入门</h4><ul><li><p>跨平台、面向对象的脚本语言（不需要编译），来控制网页行为，使网页可以交互</p></li><li><p>JavaScript引入方式</p><ul><li>内部脚本：将JS定义在HTML中<ul><li>一般把脚本放在文档底部，加快执行速度</li></ul></li><li>外部脚本：定义在外部JS中 <code>&lt;script src=&quot;....js&quot;&gt;&lt;/script&gt;</code><ul><li>注意：外部脚本不能包含<code>&lt;script&gt;</code>标签；这个时候在html中<code>&lt;script&gt;</code>标签不能自闭合</li></ul></li></ul></li><li><p>基础语法</p><ul><li><p>分号可有可无，区分大小写</p></li><li><p>注释和java一样</p></li><li><p>{}表示代码块</p></li><li><p>输出语句</p><ul><li><code>window.alert()</code>：写入警告框</li><li><code>document.wirte()</code>：写入html输出</li><li><code>console.log()</code>：写入浏览器控制台</li></ul></li><li><p>变量</p><ul><li><p><code>var</code>来声明变量，可以存放不同类型的值</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> test = <span class="number">20</span>;</span><br><span class="line">test = <span class="string">&quot;张三&quot;</span></span><br></pre></td></tr></table></figure></li><li><p><code>var</code>的作用域</p><ul><li><p>全局变量，在代码块中定义，在代码块外面仍然可以访问</p></li><li><p>可以重复定义</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> test = <span class="number">20</span></span><br><span class="line"><span class="keyword">var</span> test = <span class="number">30</span><span class="string">`</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p><code>let</code>定义的具有局部作用域的性质</p></li><li><p><code>const</code>表示常量</p></li></ul></li><li><p>数据类型</p><ul><li>使用 <code>typeof 名称</code>可以获取类型</li><li>原始类型<ul><li>number</li><li>string</li><li>boolean</li><li>null</li><li>undefined</li></ul></li><li>引用类型</li></ul></li><li><p>运算符：和java类似</p></li><li><p>流程控制语句：同java</p></li><li><p>函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> 名称(参数<span class="number">1</span>, 参数<span class="number">2</span>, ...)&#123;<span class="comment">//形参不需要写类型</span></span><br><span class="line"><span class="comment">//执行的代码</span></span><br><span class="line">    <span class="keyword">return</span> ...;<span class="comment">//也可以不return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="attr">eg</span>:</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">a,b</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> result = <span class="title function_">add</span>(<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line"><span class="keyword">let</span> result1 = <span class="title function_">add</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>);<span class="comment">//也是可以的</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>Array对象</p><ul><li>定义：<code>var 名 = new Array(元素列表)</code>或者 <code>var 名 = [元素列表]</code></li><li>访问：<code>arr[索引]</code></li><li>注：类似于java的集合，长度、类型都可以改变</li><li>方法<ul><li><code>arr.length</code></li><li><code>arr.push()//添加</code></li><li><code>arr.splice()//删除</code></li></ul></li></ul></li><li><p>String对象</p><ul><li>定义 ： <code>var 名 = new String(..)</code>或者 <code>var 名 = ...</code></li><li>属性方法参考手册</li></ul></li><li><p>自定义对象</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var 名 = &#123;</span><br><span class="line">属性名1:属性值1,</span><br><span class="line">属性名2:属性值2,</span><br><span class="line">...</span><br><span class="line">函数名:function(形参)&#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>BOM对象</p><ul><li>Browser Object Model ：浏览器对象模型</li><li>JavaScript将浏览器的各个组成部分封装为对象</li><li>组成<ul><li>Window：浏览器窗口对象<ul><li>可以直接使用，省略”Window.” 比如：<code>alert(&quot;abc&quot;)</code></li></ul></li><li>Navigator：浏览器对象</li><li>Screen：屏幕对象</li><li>History：历史记录对象<ul><li><code>window.history.方法()</code> （也可以省略window）</li></ul></li><li>Location：地址栏对象<ul><li>同理</li><li><code>location.href</code>属性</li></ul></li></ul></li></ul></li><li><p>DOM对象</p><ul><li>Document Object Model：文档对象模型</li><li>将标记语言的各个组成部分封装为对象</li><li>组成<ul><li>Document：整个文档对象</li><li>Element：元素对象</li><li>Attribute：属性对象</li><li>Text：文本对象</li><li>Comment：注释对象</li></ul></li><li>通过DOM可以修改HTML中的内容：修改内容、样式等</li></ul></li><li><p>事件监听</p><ul><li><p>事件绑定</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方式1 通过html标签中的事件属性进行绑定</span></span><br><span class="line">&lt;input type=<span class="string">&quot;button&quot;</span> onclick=<span class="string">&#x27;on()&#x27;</span>&gt;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">on</span>(<span class="params"></span>)&#123;</span><br><span class="line"><span class="comment">//执行语句</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//方式2 通过DOM元素属性绑定(推荐)</span></span><br><span class="line">&lt;input type=<span class="string">&quot;button&quot;</span> id=<span class="string">&quot;btn&quot;</span>&gt;</span><br><span class="line">    </span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;btn&quot;</span>).<span class="property">onclick</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="comment">//执行语句</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>正则表达式</p><ul><li><p>定义了字符串的组成规则</p></li><li><p>定义</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/^/</span>w&#123;<span class="number">6</span>,<span class="number">12</span>&#125;$/;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> reg = <span class="keyword">new</span> <span class="title class_">RegExp</span>(<span class="string">&quot;^//w&#123;6,12&#125;$&quot;</span>)</span><br></pre></td></tr></table></figure></li><li><p>方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">test</span>(str)<span class="comment">//返回true/false</span></span><br></pre></td></tr></table></figure></li><li><p>语法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">^表示开始</span><br><span class="line">$表示结束</span><br><span class="line">[]  代表某个范围内的单个字符，如[0-9]</span><br><span class="line">.代表任意单个字符，除了换行和行结束符</span><br><span class="line">/w  代表单词字符：字母、数字、下划线。相当于[A-Za-z0-9_]</span><br><span class="line">/d  代表数字字符，相当于[0-9]</span><br><span class="line">+   至少一个</span><br><span class="line">*   零个或多个</span><br><span class="line">?   零个或一个</span><br><span class="line">&#123;x&#125; x个</span><br><span class="line">&#123;m,&#125;至少m个</span><br><span class="line">&#123;m,n&#125;至少m，至多n个</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="六-Web核心"><a href="#六-Web核心" class="headerlink" title="六 Web核心"></a>六 Web核心</h3><h4 id="6-1-javaWeb"><a href="#6-1-javaWeb" class="headerlink" title="6.1 javaWeb"></a>6.1 javaWeb</h4><ul><li>用java技术解决相关web互联网领域的技术栈</li><li>B/S架（Browser/Server）：浏览器/服务器架构</li><li>静态资源：HTML、CSS、JavaScript、图片等，负责静态展示</li><li>动态资源：Servlet、JSP等，负责动态展示</li><li>技术栈：数据库、HTML、CSS、JavaScript、HTTP协议、Servlet、Tomcat web服务器</li></ul><h4 id="6-2-HTTP"><a href="#6-2-HTTP" class="headerlink" title="6.2 HTTP"></a>6.2 HTTP</h4><ul><li><p>Hyper Text Transfer Protocol：超文本传输协议，规定了浏览器和服务器之前数据传输的规则</p></li><li><p>特点：</p><ul><li>基于TCP协议：面向连接、安全</li><li>基于请求-响应模型的：一次请求一次响应</li><li>HTTP协议是无状态的协议：对事务处理没有记忆，每次请求-响应都是独立的<ul><li>缺点：多次请求不能数据共享（Java中使用会话技术——Cookie、Session来解决这个问题）</li><li>优点：速度快</li></ul></li></ul></li><li><p>请求数据格式</p><ul><li><p>请求行：请求数据的第一行，其中GET表示请求方式，/表示请求资源路径，HTTP/1.1表示协议版本</p></li><li><p>请求头：第二行开始，格式为：key：value形式</p><ul><li>Host：表示请求主机名</li><li>User-Agent：浏览器版本</li><li>Accept：表示浏览器能接收的资源类型，如text/<em>，image/ </em>或者 <em>/ </em>表示所有</li><li>Accept-Language</li><li>Accept-Encoding：表示浏览器支持的压缩形式</li></ul></li><li><p>请求体：POST请求最后一部分，存放请求参数</p><ul><li>请求体和请求头之间有一个空行隔开</li><li>如 <code>username=superbaby&amp;password=123456</code></li></ul><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/javaweb.assets/image-20230107110032154.png" alt="image-20230107110032154"></p></li></ul></li><li><p>响应数据格式</p><ul><li><p>响应行：第一行</p><ul><li>HTTP1.1表示协议版本，200表示响应状态码，OK表示状态码描述</li><li>响应状态码<ul><li>1xx：响应中</li><li>2xx：成功<ul><li>200：OK</li></ul></li><li>3xx：重定向</li><li>4xx：客户端错误<ul><li>404：URL有误</li></ul></li><li>5xx：服务器错误<ul><li>500：去看日志</li></ul></li></ul></li></ul></li><li><p>响应头：第二行开始，格式为key：value</p><ul><li>Content-Type</li><li>Content-Length</li><li>Content-Encoding</li><li>Content-Control</li></ul></li><li><p>响应体：最后一行，存放响应数据</p><ul><li>和响应头有一个空行隔开</li></ul><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/javaweb.assets/image-20230107111021673.png" alt="image-20230107111021673"></p></li></ul></li></ul><h4 id="6-3-Web服务器"><a href="#6-3-Web服务器" class="headerlink" title="6.3 Web服务器"></a>6.3 Web服务器</h4><ul><li><p>是一个应用程序，对HTTP协议的操作进行封装，使得程序员不必直接对协议进行操作，主要功能是“提供网上信息浏览服务”</p><ul><li>作用：封装HTTP，部署Web项目到服务器中</li></ul></li><li><p>Tomcat：Apache软件基金会的一个核心项目，支持Servlet/JSP少量javaEE规范</p><ul><li>也称为Web容器，Servlet需要依赖Tomcat才能运行</li></ul></li><li>JavaEE：java企业版，包含13项技术规范：JDBC、JNDI、EJB、RMI、JSP、Servlet、XML、JMS、Java IDL、JTS、JTA、Java Mail、JAF</li><li>tomcat安装<ul><li>bin</li><li>conf：配置</li><li>lib：依赖</li><li>logs：日志</li><li>webapps：项目目录</li><li>关闭：<ul><li>直接x掉黑窗（强制关闭，不推荐）</li><li>ctrl+c（推荐）</li><li>bin/shutdown.bat：正常关闭（麻烦）</li></ul></li></ul></li></ul><h4 id="6-4-Tomcat使用"><a href="#6-4-Tomcat使用" class="headerlink" title="6.4 Tomcat使用"></a>6.4 Tomcat使用</h4><ul><li><p>配置</p><ul><li><p>修改启动端口号：conf/server.xml，HTTP协议默认80，如果修改为了80，则不需要再输入端口号</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/javaweb.assets/image-20230107120017713.png" alt="image-20230107120017713"></p></li><li><p>端口号冲突：找到对应程序关闭</p></li><li>启动窗口一闪而过：检查Java环境变量配置</li></ul></li><li><p>部署</p><ul><li>项目放在webapps文件夹中<ul><li>一般打包为war包（会自动解压）</li></ul></li></ul></li><li><p>MavenWeb项目</p><ul><li><p>开发中的项目</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/javaweb.assets/image-20230107120600600.png" alt="image-20230107120600600"></p><ul><li>WEB-INF放的web的配置文件</li></ul></li><li><p>部署的javaweb项目：开发完成可以部署的项目</p><ul><li><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/javaweb.assets/image-20230107120706938.png" alt="image-20230107120706938"></li></ul></li><li><p>maven项目中要在pom.xml中添加打包方式： <code>&lt;packaging&gt;war&lt;/packaging&gt;</code>或者jar</p></li></ul></li></ul><ul><li><p>idea中启动项目集成到tomcat并启动</p><ul><li><p>方式一：添加tomcat</p></li><li><p>方式二：pom.xml中添加tomcat导入坐标</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--build标签下 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!--tomcat插件 --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.tomcat.maven<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>tomcat7-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后右键run maven -tomcat7:run</p></li></ul></li></ul><h3 id="七-Servlet"><a href="#七-Servlet" class="headerlink" title="七 Servlet"></a>七 Servlet</h3><h4 id="7-1-简介"><a href="#7-1-简介" class="headerlink" title="7.1 简介"></a>7.1 简介</h4><ul><li>java提供的一种动态web资源开发技术</li><li>javaEE规范之一，就是一个接口，以后定义Servlet类实现Servlet接口，由web服务器运行</li></ul><h4 id="7-2-demo"><a href="#7-2-demo" class="headerlink" title="7.2 demo"></a>7.2 demo</h4><ul><li><p>创建web项目，导入servlet依赖坐标</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>javax.servlet-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>创建：定义一个类，实现Servlet接口，并重写接口中所有的方法，并在service方法中输入一句话</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServletDemo1</span> <span class="keyword">implements</span> <span class="title class_">Servlet</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">service</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>配置：在类上使用 <code>@WebServlet</code>注解，配置改Servlet访问路径</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WebServlet(&quot;/demo1&quot;)</span></span><br></pre></td></tr></table></figure></li><li><p>访问：启动Tomcat，浏览器输入URL，访问servlet</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:<span class="comment">//localhost:8080/tomcat-dome1/demo1</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="7-3-执行流程，生命周期"><a href="#7-3-执行流程，生命周期" class="headerlink" title="7.3 执行流程，生命周期"></a>7.3 执行流程，生命周期</h4><ul><li><code>localhost:8080</code>访问web服务器(tomcat)，<code>tomcat-dome1</code>访问项目 <code>/demo1</code>访问类，在tomcat中自动创建Servlet类对象</li><li>生命周期<ul><li>加载和实例化：默认情况当Servlet第一次被访问时，由容器创建Servlet对象</li><li>初始化：创建后调用Servlet对象的init()方法</li><li>请求处理：每次请求Servlet时，容器都会调用Servlet的service()方法</li><li>服务终止：关闭服务器/释放内存时，调用destroy()方法</li></ul></li></ul><h4 id="7-4-方法介绍"><a href="#7-4-方法介绍" class="headerlink" title="7.4 方法介绍"></a>7.4 方法介绍</h4><ul><li><p>初始化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">init</span><span class="params">(ServletConfig config)</span></span><br></pre></td></tr></table></figure></li><li><p>提供服务</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">service</span><span class="params">(ServletRequest req, ServletResponse res)</span></span><br></pre></td></tr></table></figure></li><li><p>销毁</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">deatroy</span><span class="params">()</span></span><br></pre></td></tr></table></figure></li><li><p>获取ServletConfig对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ServletConfig <span class="title function_">getServletConfig</span><span class="params">()</span></span><br></pre></td></tr></table></figure></li><li><p>获取Servlet信息</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String <span class="title function_">getServletInfo</span><span class="params">()</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="7-5-体系结构"><a href="#7-5-体系结构" class="headerlink" title="7.5 体系结构"></a>7.5 体系结构</h4><ul><li><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/javaweb.assets/image-20230107125724266.png" alt="image-20230107125724266"></li><li>继承HttpServlet，重写doGet和doPost方法(就可以不用重写Servlet这么多方法了)</li></ul><h4 id="7-6-urlPattern配置"><a href="#7-6-urlPattern配置" class="headerlink" title="7.6 urlPattern配置"></a>7.6 urlPattern配置</h4><ul><li><p>一个servlet可以配置多个urlPattern</p><p><code>@WebServlet(&quot;/demo1&quot;, &quot;/demo2&quot;...)</code></p></li><li><p>urlPattern匹配规则</p><ul><li>精确匹配：<code>@WebServlet(&quot;/demo1&quot;, &quot;/demo2&quot;...)</code></li><li>目录匹配：<code>@WebServlet(&quot;/demo1/*&quot;)</code></li><li>扩展名匹配：<code>@WebServlet(&quot;*.do&quot;)</code></li><li>任意匹配：<code>@WebServlet(&quot;/&quot;)</code>或<code>@WebServlet(&quot;/*&quot;)</code></li></ul></li></ul><h3 id="八-Request-amp-Response"><a href="#八-Request-amp-Response" class="headerlink" title="八 Request&amp;Response"></a>八 Request&amp;Response</h3><h4 id="8-1-简介"><a href="#8-1-简介" class="headerlink" title="8.1 简介"></a>8.1 简介</h4><ul><li><p>request：设置请求数据</p><ul><li><p>继承体系</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/javaweb.assets/image-20230109103639307.png" alt="image-20230109103639307"></p></li><li><p>使用request对象，查阅javaee api的HttpServlerRequest接口</p></li></ul></li><li><p>response：设置响应数据</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/javaweb.assets/image-20230109113010646.png" alt="image-20230109113010646"></p></li></ul><h4 id="8-2-Request"><a href="#8-2-Request" class="headerlink" title="8.2 Request"></a>8.2 Request</h4><ul><li><p>获取请求数据</p><ul><li><p>请求行</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/javaweb.assets/image-20230109104101484.png" alt="image-20230109104101484"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String <span class="title function_">getMethod</span><span class="params">()</span>;<span class="comment">//获取请求方式</span></span><br><span class="line">String <span class="title function_">getContextPath</span><span class="params">()</span>;<span class="comment">//获取虚拟目录(项目访问路径)</span></span><br><span class="line">StringBuffer <span class="title function_">getRequestURL</span><span class="params">()</span>;<span class="comment">//获取URL(统一资源定位符)长的</span></span><br><span class="line">String <span class="title function_">getRequestURI</span><span class="params">()</span>;<span class="comment">//获取URL(统一资源标识符)短的</span></span><br><span class="line">String <span class="title function_">getQueryString</span><span class="params">()</span>;<span class="comment">//获取请求参数(GET方式)</span></span><br></pre></td></tr></table></figure><p>结果：</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/javaweb.assets/image-20230109105720146.png" alt="image-20230109105720146"></p></li><li><p>请求头</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String <span class="title function_">getHeader</span><span class="params">(String name)</span></span><br></pre></td></tr></table></figure></li><li><p>请求体 <code>username=zhangsan&amp;hobby=1&amp;hobby=2</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ServletInputStream <span class="title function_">getInputStream</span><span class="params">()</span>;<span class="comment">//获取字节输入流</span></span><br><span class="line">BufferReader <span class="title function_">getReader</span><span class="params">()</span>;<span class="comment">//获取字符输入流（POST方式，和getQueryString相对应）</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>使用通用的方式获取请求参数</p><ul><li>```java<br>Map<String, String[]> getParameterMap();//获取所有参数Map集合<br>String[] getParameterValues(Stirng name);//根据参数名取值<br>String getParameter(String name);//同上<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">    ![image-20230109110717875](https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/javaweb.assets/image-20230109110717875.png)</span><br><span class="line"></span><br><span class="line">- 中文乱码</span><br><span class="line"></span><br><span class="line">  - POST：（底层是流获取参数）`requests.setCharacterEnconding(&quot;UTF-8&quot;)`</span><br><span class="line"></span><br><span class="line">  - GET：（底层是字符串获取参数）</span><br><span class="line"></span><br><span class="line">    - 乱码原理</span><br><span class="line"></span><br><span class="line">    ![image-20230109111549537](https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/javaweb.assets/image-20230109111549537.png)</span><br><span class="line"></span><br><span class="line">    - URL编码</span><br><span class="line"></span><br><span class="line">      - 将字符串按编码方式转为二进制</span><br><span class="line"></span><br><span class="line">      - 每个字节转为2个16进制并在前面加上%</span><br><span class="line"></span><br><span class="line">        ![image-20230109111802261](https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/javaweb.assets/image-20230109111802261.png)</span><br><span class="line"></span><br><span class="line">    - 解决方式</span><br><span class="line"></span><br><span class="line">      - 将URL解码后再转换为字节数据（编码）</span><br><span class="line"></span><br><span class="line">      - 将字节数据转为字符串（解码）</span><br><span class="line"></span><br><span class="line">        ```java</span><br><span class="line">        Byte[] bytes = username.getBytes(StandardCharsets.ISO_8859_1);</span><br><span class="line">        </span><br><span class="line">        username = new String(bytes, StandardCharsets.UTF_8);</span><br><span class="line">        </span><br><span class="line">        //一行代码</span><br><span class="line">        new String(username.getBytes(&quot;ISO-8859-1&quot;), &quot;UTF-8&quot;);</span><br></pre></td></tr></table></figure></li></ul></li><li><p>请求转发</p><ul><li><p>一种在服务器内部的资源跳转方式</p></li><li><p><code>req.getRequestDispatcher(&quot;资源B路径&quot;).forward(req, resp);</code></p></li><li><p>共享数据</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">setAttribute</span><span class="params">(String name, Object o)</span>;<span class="comment">//存储数据到request域中</span></span><br><span class="line">Object <span class="title function_">getAttribute</span><span class="params">(String name)</span>;<span class="comment">//获取</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">removeAttribute</span><span class="params">(String name)</span>;/删除</span><br></pre></td></tr></table></figure></li></ul></li></ul><h4 id="8-3-Response"><a href="#8-3-Response" class="headerlink" title="8.3 Response"></a>8.3 Response</h4><ul><li><p>响应数据</p><ul><li><p>响应行</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">setStatus</span><span class="params">(<span class="type">int</span> sc)</span>;<span class="comment">//设置相应状态码</span></span><br></pre></td></tr></table></figure></li><li><p>响应头</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">setHeader</span><span class="params">(String name, String value)</span>;<span class="comment">//设置相应键值对</span></span><br></pre></td></tr></table></figure></li><li><p>响应体</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PrintWriter <span class="title function_">getWriter</span><span class="params">()</span>;<span class="comment">//获取字符输出流</span></span><br><span class="line">ServletOutPutStream <span class="title function_">getOutPutStream</span><span class="params">()</span>;<span class="comment">//获取字节输出流</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>重定向</p><ul><li><p>一种资源跳转方式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">resp.setStatus(<span class="number">302</span>);</span><br><span class="line">resp.setHeader(<span class="string">&quot;location&quot;</span>, <span class="string">&quot;资源B路径&quot;</span>);</span><br><span class="line"></span><br><span class="line">response.sendRedirect(<span class="string">&quot;资源b路径&quot;</span>);<span class="comment">//简化写法</span></span><br></pre></td></tr></table></figure></li><li><p>资源路径问题</p><ul><li>明确路径给谁使用<ul><li>浏览器用（浏览器发出的请求）：需要加虚拟目录（项目访问路径）</li><li>服务器用（服务器发出的请求）：不需要</li></ul></li></ul></li></ul></li><li><p>响应字符数据</p><ul><li><p>```java<br>PrintWriter writer = resp.getWriter();//通过Response对象获取字符输出流，不需要关闭，response释放后自动关闭</p><p>writer.write(“aaa”);//写数据</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 中文乱码问题</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>resp.setContentType(“text/html;charset=utf-8”);</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 响应字节数据</span><br><span class="line"></span><br><span class="line">  - 读取文件</span><br><span class="line"></span><br><span class="line">    ```java</span><br><span class="line">    FileInputStream fis = new FileInputStream(&quot;url&quot;);</span><br></pre></td></tr></table></figure></li><li><p>获取response字节输出流</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ServletOutPutStream</span> <span class="variable">os</span> <span class="operator">=</span> response.getOutPutStream();</span><br></pre></td></tr></table></figure></li><li><p>完成流的copy</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">byte</span>[] buff = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line"><span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>((len = fis.read(buff)) != -<span class="number">1</span>)&#123;</span><br><span class="line">os.write(buff, <span class="number">0</span>, len);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fis.close();</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="九-JSP"><a href="#九-JSP" class="headerlink" title="九 JSP"></a>九 JSP</h3><h4 id="9-1-简介"><a href="#9-1-简介" class="headerlink" title="9.1 简介"></a>9.1 简介</h4><ul><li>java Server Pages：java服务端页面</li><li>一种动态技术，既可以定义html、js、css等静态内容，又可以定义java代码的动态内容</li><li>jsp = html + java</li><li>作用：简化开发，避免了在servlet中直接输出html标签</li></ul><h4 id="9-2-入门"><a href="#9-2-入门" class="headerlink" title="9.2 入门"></a>9.2 入门</h4><ul><li>maven中导入坐标<ul><li><code>&lt;scope&gt;provided&lt;/scope&gt;</code>和servlet一样</li></ul></li><li>创建jsp文件</li><li>编写html和java代码</li></ul><h4 id="9-3-原理"><a href="#9-3-原理" class="headerlink" title="9.3 原理"></a>9.3 原理</h4><ul><li>本质上是一个servlet，用out.write输出java代码</li></ul><h4 id="9-4-JSP脚本"><a href="#9-4-JSP脚本" class="headerlink" title="9.4 JSP脚本"></a>9.4 JSP脚本</h4><ul><li><p>用于在页面内定义java代码</p></li><li><p>分类</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;%...%&gt;：内容会直接放到_jspService()方法中</span><br><span class="line">&lt;%=...%&gt;：内容会放到out.print()中，作为out.print()的参数</span><br><span class="line">&lt;%!...%&gt;：内容会放到_jspService()方法之外，被类直接包含</span><br></pre></td></tr></table></figure></li><li><p>上面三个标签可以截断，自由组合</p></li></ul><h4 id="9-5-JSP缺点"><a href="#9-5-JSP缺点" class="headerlink" title="9.5 JSP缺点"></a>9.5 JSP缺点</h4><ul><li>书写麻烦，特别是复杂页面，阅读麻烦</li><li>复杂度高。，运行依赖各种环境：JRE、JSP容器、JavaEE</li><li>占内存，调式困难</li><li>解决：逻辑处理放在Servlet中，JSP只负责获取数据，遍历展现</li><li>逐渐退出舞台 ==&gt; Servlet + html + Ajax（主流）<ul><li>发展： Servlet ==&gt; JSP ==&gt; Servlert + JSP ==&gt; Servlet + html + Ajax</li></ul></li></ul><h4 id="9-6-EL表达式"><a href="#9-6-EL表达式" class="headerlink" title="9.6 EL表达式"></a>9.6 EL表达式</h4><ul><li><p>Expression Language 表达式语言，用于简化JSP页面内的java代码</p></li><li><p>主要功能：获取数据</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$&#123;expression&#125;:获取域中存储的key作为brands的数据</span><br></pre></td></tr></table></figure></li><li><p>javaweb四大域对象：</p><ul><li>page：当前页面有效</li><li>request：当前请求有效</li><li>session：当前会话有效</li><li>application：当前应用有效</li></ul><p>el表达式从上到下依次寻找，找到为止</p></li></ul><h4 id="9-7-JSTL标签"><a href="#9-7-JSTL标签" class="headerlink" title="9.7 JSTL标签"></a>9.7 JSTL标签</h4><ul><li>Jsp Standard Tag Library：JSP标准签库，使用标签取代jsp页面上的java代码</li></ul><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/javaweb.assets/image-20230111115932511.png" alt="image-20230111115932511"></p><ul><li><p>快速入门</p><ul><li><p>导入坐标：jstl和standard</p></li><li><p>在jsp页面顶部上引入jstl标签</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ taglib prefix=<span class="string">&quot;c&quot;</span> uri=<span class="string">&quot;http://java.sun.com/jsp/jstl/core&quot;</span> %&gt;</span><br></pre></td></tr></table></figure></li><li><p>使用</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;c:<span class="type">if</span> <span class="variable">test</span> <span class="operator">=</span> <span class="string">&quot;逻辑表达式&quot;</span>&gt;</span><br><span class="line">test为<span class="literal">true</span>执行</span><br><span class="line">&lt;/c:<span class="keyword">if</span>&gt;</span><br><span class="line"></span><br><span class="line">&lt;c:forEach items=<span class="string">&quot;被遍历的容器&quot;</span> <span class="keyword">var</span>=<span class="string">&quot;遍历产生的临时变量&quot;</span> varStatus=<span class="string">&quot;遍历状态对象&quot;</span>&gt;</span><br><span class="line">遍历操作</span><br><span class="line">&lt;/c:forEach&gt;</span><br><span class="line"></span><br><span class="line">&lt;c:forEach begin=<span class="string">&quot;0&quot;</span> end=<span class="string">&quot;10&quot;</span> step=<span class="string">&quot;1&quot;</span> <span class="keyword">var</span>=<span class="string">&quot;i&quot;</span>&gt; <span class="comment">//普通for循环</span></span><br><span class="line">遍历操作</span><br><span class="line">&lt;/c:forEach&gt;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h4 id="9-8-MVC模式和三层架构"><a href="#9-8-MVC模式和三层架构" class="headerlink" title="9.8 MVC模式和三层架构"></a>9.8 MVC模式和三层架构</h4><ul><li><p>MVC模式是一种分层开发模式</p><ul><li><p>M：model，业务模型，处理业务</p></li><li><p>V：view，视图，页面展示</p></li><li><p>C：controller，控制器，处理请求，调用模型和视图</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/javaweb.assets/image-20230111121528138.png" alt="image-20230111121528138"></p></li></ul></li><li><p>MVC优点</p><ul><li>职责单一</li><li>分工协作</li><li>利于组件重利用</li></ul></li><li><p>三层架构</p><ul><li>表现层<ul><li>接收请求，封装数据，调用业务逻辑层，响应数据</li></ul></li><li>业务逻辑层<ul><li>对业务逻辑的封装，组合数据访问数据层中的基本功能</li></ul></li><li>数据访问层<ul><li>对数据库的CRUD</li></ul></li></ul><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/javaweb.assets/image-20230111121743935.png" alt="image-20230111121743935"></p></li><li><p>MVC和三层架构</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/javaweb.assets/image-20230111121854788.png" alt="image-20230111121854788"></p></li></ul><h3 id="十-会话跟踪技术"><a href="#十-会话跟踪技术" class="headerlink" title="十 会话跟踪技术"></a>十 会话跟踪技术</h3><h4 id="10-1-简介"><a href="#10-1-简介" class="headerlink" title="10.1 简介"></a>10.1 简介</h4><ul><li>会话：用户打开浏览器，访问web服务器资源，会话建立，直到有一方断开连接，会话结束，在一次会话中可以包含多次请求和响应。</li><li><p>会话跟踪：一种维护浏览器状态的方法，服务器需要识别多次请求是否来自同一个浏览器，以便在同一次会话的多次请求间<strong>共享数据</strong></p></li><li><p>HTTP协议是无状态的（保证了每次请求速度快），每次浏览器向服务器请求时，服务器都会将该请求是为新的请求，因此需要会话跟踪技术来实现会话内数据共享</p></li><li>实现方式：<ul><li>客户端会话跟踪技术：Cookie</li><li>服务端会话跟踪技术：Session</li></ul></li></ul><h4 id="10-2-Cookie"><a href="#10-2-Cookie" class="headerlink" title="10.2 Cookie"></a>10.2 Cookie</h4><ul><li><p>基本使用</p><ul><li><p>Cookie：客户端会话技术，将数据保存到客户端，以后每次请求都携带Cookie数据进行访问</p></li><li><p>创建对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Cookie</span> <span class="variable">cookie</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cookie</span>(<span class="string">&quot;key&quot;</span>, <span class="string">&quot;value&quot;</span>);</span><br></pre></td></tr></table></figure></li><li><p>发送Cookie到客户端：使用respondse对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">response.addCookie(cookie);</span><br></pre></td></tr></table></figure></li><li><p>获取客户端携带的所有cookie，使用request对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cookie[] cookies = request.getCookies()</span><br></pre></td></tr></table></figure></li><li><p>遍历数组，获取每一个Cookie对象</p></li><li><p>使用Cookie对象方法获取数据</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cookie.getName();</span><br><span class="line">cookie.geyValue();</span><br></pre></td></tr></table></figure></li></ul></li><li><p>原理</p><ul><li>原理：基于HTTP协议<ul><li>响应头：set-cookie</li><li>请求头：cookie</li></ul></li></ul></li><li><p>使用细节</p><ul><li>默认情况下，cookie是存放在浏览器内存中，当浏览器关闭，内存释放，则cookie被销毁<ul><li><code>setMaxAge(int seconds)</code>：设置cookie存活时间<ul><li>正数：写入硬盘，到时间后自动删除</li><li>负数：默认值，浏览器关闭则自动关闭</li><li>零：删除对应cookie</li></ul></li></ul></li><li>cookie不能直接存储中文<ul><li>转码 <code>URLEncoder.encode(value, &quot;UTF-8&quot;)</code> </li><li>之后获取再解码 <code>URLDecoder.decode(value, &quot;UTF-8&quot;)</code></li></ul></li></ul></li></ul><h4 id="10-3-Session"><a href="#10-3-Session" class="headerlink" title="10.3 Session"></a>10.3 Session</h4><ul><li><p>基本使用</p><ul><li><p>Session：服务端会话跟踪技术：将数据保存到服务端</p><ul><li>javaEE提供http接口，实现一次会话的多次请求间数据共享功能</li></ul></li><li><p>获取对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">HttpSession</span> <span class="variable">session</span> <span class="operator">=</span> request.getSession();</span><br></pre></td></tr></table></figure></li><li><p>Session对象功能：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">setAttribute</span><span class="params">(String name, Object o)</span>;<span class="comment">//存储数据到session域中</span></span><br><span class="line">Object <span class="title function_">getAttribute</span><span class="params">(String name)</span>;<span class="comment">//根据key获取值</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">removeAttribute</span><span class="params">(String name)</span>;<span class="comment">//根据key删除值</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>原理</p><ul><li>session实现是基于cookie的</li></ul></li><li><p>使用细节</p><ul><li><p>session钝化、活化</p><ul><li>服务器重启后，session中的数据是否存在？</li><li>钝化：在服务器正常关闭后，tomcat会自动将session数据写入硬盘的文件中</li><li>活化：再次启动服务器后，从文件中加载数据到session中</li></ul></li><li><p>session销毁</p><ul><li><p>默认情况下，无操作，30分钟自动销毁</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">session-config</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">session-timeout</span>&gt;</span>30<span class="tag">&lt;/<span class="name">session-timeout</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">session-config</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>调用Session对象的 <code>invalidate()</code>方法</p></li></ul></li></ul></li></ul><h4 id="10-4-小结"><a href="#10-4-小结" class="headerlink" title="10.4 小结"></a>10.4 小结</h4><ul><li>区别：<ul><li>存储位置：cookie客户端，session服务端</li><li>安全性：session安全</li><li>数据大小：cookie最大3kb，session无限制</li><li>存储时间：cookie可长期存储，session默认30min</li><li>服务器性能：session占用服务器资源</li></ul></li></ul><h3 id="十一-Filter"><a href="#十一-Filter" class="headerlink" title="十一 Filter"></a>十一 Filter</h3><h4 id="11-1-简介"><a href="#11-1-简介" class="headerlink" title="11.1 简介"></a>11.1 简介</h4><ul><li><p>Filter表示过滤器，是javaWeb三大组件之一（Servlet、Filter、Listener）</p></li><li><p>可以对资源的请求拦截下来，从而实现一些统一的功能</p></li><li><p>过滤器一般完成一些通用的操作，入：权限控制、统一编码处理、敏感字符处理等</p><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/javaweb.assets/image-20230115103618290.png" alt="image-20230115103618290"></p></li></ul><h4 id="11-2-快速入门"><a href="#11-2-快速入门" class="headerlink" title="11.2 快速入门"></a>11.2 快速入门</h4><ul><li><p>定义类，实现Filter接口，并重写所有方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WebFilter(&quot;/*&quot;)</span><span class="comment">//拦截路径</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FilterTest</span> <span class="keyword">implements</span> <span class="title class_">Filter</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">(FilterConfig filterConfig)</span> <span class="keyword">throws</span> ServletException &#123;</span><br><span class="line">        Filter.<span class="built_in">super</span>.init(filterConfig);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doFilter</span><span class="params">(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain)</span> <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;filter exec&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        chain.foFilter(servletRequest, servletResponse);<span class="comment">//放行</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span> &#123;</span><br><span class="line">        Filter.<span class="built_in">super</span>.destroy();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>配置Filter拦截资源路径：在类上定义<code>@WebFilter</code>注解</p></li><li><p>在doFilter中输出一句话，并放行</p></li></ul><h4 id="11-3-执行流程"><a href="#11-3-执行流程" class="headerlink" title="11.3 执行流程"></a>11.3 执行流程</h4><ul><li><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/javaweb.assets/image-20230115104610374.png" alt="image-20230115104610374"></li><li>放行前response没有数据，所以一般放行前处理request，放行后处理response数据</li></ul><h4 id="11-4-Filter拦截路径"><a href="#11-4-Filter拦截路径" class="headerlink" title="11.4 Filter拦截路径"></a>11.4 Filter拦截路径</h4><ul><li><p>路径</p><ul><li>拦截具体资源：<code>/index.jsp</code></li><li>目录拦截：<code>/user/*</code></li><li>后缀名拦截：<code>*.jsp</code></li><li>拦截所有：<code>*/</code></li></ul></li><li><p>过滤器链</p><ul><li>按照过滤器的字符串排序来确定执行顺序</li></ul><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/javaweb.assets/image-20230115105231568.png" alt="image-20230115105231568"></p></li></ul><h4 id="11-5-Listener"><a href="#11-5-Listener" class="headerlink" title="11.5 Listener"></a>11.5 Listener</h4><ul><li>在类前加入 <code>@WebListener</code>注解</li></ul><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/javaweb.assets/image-20230115110129375.png" alt="image-20230115110129375"></p><h3 id="十二-AJAX"><a href="#十二-AJAX" class="headerlink" title="十二 AJAX"></a>十二 AJAX</h3><h4 id="12-1-简介"><a href="#12-1-简介" class="headerlink" title="12.1 简介"></a>12.1 简介</h4><ul><li>Asynchronous JavaScript And XML：异步的JavaScript和XML</li><li>作用：<ul><li>和服务器进行数据交换：通过Ajax可以给服务器发送请求，并获取服务器响应的数据<ul><li>可以替换JSP ==&gt; HTML + AJAX</li></ul></li><li>异步通信：在不重新加载整个页面的情况下，与服务器进行数据交换并更新部分网页的技术，如：联想搜索…</li></ul></li></ul><h4 id="12-2-快速入门"><a href="#12-2-快速入门" class="headerlink" title="12.2 快速入门"></a>12.2 快速入门</h4><ul><li><p>编写AjaxServlet，并使用response输出字符串</p></li><li><p>创建XMLHttpRequest对象：用于和服务器交换数据</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> xhr;</span><br><span class="line"><span class="keyword">if</span> (<span class="variable language_">window</span>.<span class="property">XMLHttpRequest</span>)&#123;</span><br><span class="line">  <span class="comment">// IE7+, Firefox, Chrome, Opera, Safari 浏览器执行代码</span></span><br><span class="line">  xhr = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">// IE6, IE5 浏览器执行代码</span></span><br><span class="line">  xhr = <span class="keyword">new</span> <span class="title class_">ActiveXObject</span>(<span class="string">&quot;Microsoft.XMLHTTP&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>向服务器发送请求</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">xhr.<span class="title function_">open</span>(<span class="string">&quot;GET&quot;</span>, <span class="string">&quot;url&quot;</span>, <span class="literal">true</span>);<span class="comment">//true是异步，false是同步，默认异步，所以一般不写第三个参数，url写绝对路径</span></span><br><span class="line">xhr.<span class="title function_">send</span>();</span><br></pre></td></tr></table></figure></li><li><p>获取服务器的响应数据</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">xhr.<span class="property">onreadystatechange</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(xhr.<span class="property">readyState</span> == <span class="number">4</span> &amp;&amp; xhr.<span class="property">status</span> == <span class="number">200</span>)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(xhr.<span class="property">responseText</span>); <span class="comment">// responseText获取字符串形式的响应数据  responseXML获取XML形式的响应数据</span></span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/javaweb.assets/image-20230115111841101.png" alt="image-20230115111841101"></p></li></ul><h4 id="12-3-Axios异步框架"><a href="#12-3-Axios异步框架" class="headerlink" title="12.3 Axios异步框架"></a>12.3 Axios异步框架</h4><ul><li><p>对原生的Ajax进行封装</p></li><li><p>引入axios的js文件</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=<span class="string">&quot;js/axios-0.18.0.js&quot;</span>&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure></li><li><p>使用axios发送请求，并获取响应结果</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">axios</span>(&#123;</span><br><span class="line"><span class="attr">method</span>:<span class="string">&quot;get&quot;</span></span><br><span class="line"><span class="attr">url</span>:<span class="string">&quot;...&quot;</span></span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params">resp</span>)&#123;</span><br><span class="line"><span class="title function_">alert</span>(resp.<span class="property">data</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">   <span class="title function_">axios</span>(&#123;   </span><br><span class="line"><span class="attr">method</span>:<span class="string">&quot;get&quot;</span></span><br><span class="line">   <span class="attr">url</span>:<span class="string">&quot;...&quot;</span></span><br><span class="line">   <span class="attr">data</span>:<span class="string">&quot;...&quot;</span></span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params">resp</span>)&#123;</span><br><span class="line"><span class="title function_">alert</span>(resp.<span class="property">data</span>)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li></ul><h4 id="12-4-JSON"><a href="#12-4-JSON" class="headerlink" title="12.4 JSON"></a>12.4 JSON</h4><ul><li>JavaScript Object Notation：javaScript对象表示方法</li><li><p>由于语法简单，层次结构鲜明，现多用于作为数据载体，在网络中进行数据传输</p><ul><li>​    <img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/javaweb.assets/image-20230115113807410.png" alt="image-20230115113807410"></li></ul></li><li><p>基础语法</p><ul><li><p>定义</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> 变量名 = &#123;<span class="string">&quot;key1&quot;</span>:value1,</span><br><span class="line"> <span class="string">&quot;key2&quot;</span>:value2,</span><br><span class="line"> ...</span><br><span class="line"> &#125;;</span><br></pre></td></tr></table></figure></li><li><p>value数据类型</p><ul><li>数字</li><li>字符串(双引号中)</li><li>逻辑值（true/false）</li><li>数组(方括号中)</li><li>对象(花括号中)</li><li>null</li></ul></li><li><p>获取数据</p><ul><li><code>变量名.key</code></li></ul></li></ul></li><li><p>与java对象的转换</p><ul><li><p>Fastjson：阿里巴巴提供的一个java语言编写的高性能功能完善的json库，是目前java语言中最快的json库，实现java和json字符串的相互转换</p></li><li><p>引入坐标</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>fastjson<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.66<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>java对象转json</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">jsonStr</span> <span class="operator">=</span> JSON.toJSONString(obj)</span><br></pre></td></tr></table></figure></li><li><p>json字符串转java对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> JSON.parseObject(jsonStr, User.class)</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="十三-VUE"><a href="#十三-VUE" class="headerlink" title="十三 VUE"></a>十三 VUE</h3><h4 id="13-1-简介"><a href="#13-1-简介" class="headerlink" title="13.1 简介"></a>13.1 简介</h4><ul><li>一套前端框架，免除javaScript中的DOM操作，简化书写</li><li>基于MVVM(Model-View-ViewModel)思想，实现数据的双向绑定，将编程重点放到数据上<ul><li>MVC只能实现模型到视图的单向展示（模型变了数据不会跟着马上变，要自己写操作）</li></ul></li></ul><h4 id="13-2-快速入门"><a href="#13-2-快速入门" class="headerlink" title="13.2 快速入门"></a>13.2 快速入门</h4><ul><li><p>新建html页面，引入Vue.js文件</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">scirpt</span> <span class="attr">src</span>=<span class="string">&quot;js/vue.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>在js代码区域创建Vue核心对象，进行数据绑定</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span><br><span class="line"><span class="attr">el</span>:<span class="string">&quot;#app&quot;</span>,<span class="comment">//设置vue的作用范围是id为app的标签包裹的内容</span></span><br><span class="line"><span class="title function_">data</span>(<span class="params"></span>)&#123;</span><br><span class="line"><span class="keyword">return</span>&#123;</span><br><span class="line">username;<span class="string">&quot;&quot;</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li><p>编写视图</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=<span class="string">&quot;app&quot;</span>&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;username&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">&#123;&#123;username&#125;&#125;</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br></pre></td></tr></table></figure></li></ul><h4 id="13-3-常用指令"><a href="#13-3-常用指令" class="headerlink" title="13.3 常用指令"></a>13.3 常用指令</h4><ul><li><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/javaweb.assets/image-20230115121419248.png" alt="image-20230115121419248"></li></ul><h4 id="13-4-生命周期"><a href="#13-4-生命周期" class="headerlink" title="13.4 生命周期"></a>13.4 生命周期</h4><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/javaweb.assets/image-20230115122231479.png" alt="image-20230115122231479"></p><ul><li>mounted：挂载完成，vue初始化成功，html页面渲染成功<ul><li>发送异步请求，加载数据</li></ul></li></ul><h3 id="十四-Element"><a href="#十四-Element" class="headerlink" title="十四 Element"></a>十四 Element</h3><h4 id="14-1-简介"><a href="#14-1-简介" class="headerlink" title="14.1 简介"></a>14.1 简介</h4><ul><li>饿了么公司前端开发团队提供的一套基于vue的网络组件库，用于快速构建网页</li></ul><h4 id="14-2-快速入门"><a href="#14-2-快速入门" class="headerlink" title="14.2 快速入门"></a>14.2 快速入门</h4><ul><li><p>引入Element的css、js文件和Vue.js</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- import Vue before Element --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://unpkg.com/vue/dist/vue.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- import JavaScript --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://unpkg.com/element-ui/lib/index.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- import css --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">href</span>=<span class="string">&quot;https://unpkg.com/element-ui/lib/theme-chalk/index.css&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>创建vue核心对象</p></li><li><p>官网cv代码</p></li></ul><h3 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h3><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/javaweb.assets/image-20230118122647606.png" alt="image-20230118122647606"><em>**</em></p><link rel="stylesheet" href="https://cdn1.tianli0.top/gh/zhheo/Post-Abstract-AI@0.15.2/tianli_gpt.css"><script>let tianliGPT_postSelector = '#post #article-container';let tianliGPT_key = 'c9b7741d290063ab872e';</script><script src="https://cdn1.tianli0.top/gh/zhheo/Post-Abstract-AI@0.15.2/tianli_gpt.js"></script>]]></content>
      
      
      <categories>
          
          <category> study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>多线程与反射</title>
      <link href="/posts/19451.html"/>
      <url>/posts/19451.html</url>
      
        <content type="html"><![CDATA[<h2 id="多线程与反射"><a href="#多线程与反射" class="headerlink" title="多线程与反射"></a>多线程与反射</h2><h2 id="A-多线程"><a href="#A-多线程" class="headerlink" title="A 多线程"></a>A 多线程</h2><h3 id="一-线程"><a href="#一-线程" class="headerlink" title="一 线程"></a>一 线程</h3><h4 id="1-1-程序、进程、线程"><a href="#1-1-程序、进程、线程" class="headerlink" title="1.1 程序、进程、线程"></a>1.1 程序、进程、线程</h4><ul><li>线程：独立执行的路径</li><li>线程会带来额外的开销，如CPU调度的时间，并发控制开销</li><li><p>线程开启了没有马上执行，由CPU进行调度</p></li><li><p>注：很多的多线程是模的，真正的多线程用的是多个CPU，很多都是切换的比较快看起来像多线程</p></li></ul><h4 id="1-2-线程创建"><a href="#1-2-线程创建" class="headerlink" title="1.2 线程创建"></a>1.2 线程创建</h4><ul><li><p>继承Thread类</p><ol><li><p>自定义线程类继承Thread</p></li><li><p>重写run方法</p></li><li><p>调用start方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">sout(<span class="string">&quot;new Thread&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    psvm()&#123;</span><br><span class="line">        <span class="type">TestThread</span> <span class="variable">test</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TestThread</span>();</span><br><span class="line">        test.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ol></li></ul><ul><li><p>实现Runnable接口</p><ol><li><p>定义类实现Runnable接口</p></li><li><p>重写run方法</p></li><li><p>执行线程需要丢入的runnable接口实现类，调用start方法</p><p>龟兔赛跑：Thread_Study/code/Race.java</p></li></ol></li><li><p>实现Callable接口</p><ol><li>实现Callable接口，需要返回值类型</li><li>重新call方法</li><li>创建目标对象</li><li>创建执行服务</li><li>提交执行</li><li>获取结果</li><li>关闭服务</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestCallable</span> <span class="keyword">implements</span> <span class="title class_">Callable</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Boolean <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;</span><br><span class="line">        <span class="type">TestCallable</span> <span class="variable">testCallable</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TestCallable</span>();</span><br><span class="line">        <span class="comment">//创建执行服务</span></span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">ser</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">3</span>);</span><br><span class="line">        <span class="comment">//提交执行</span></span><br><span class="line">        Future&lt;Boolean&gt; r1 = ser.submit(testCallable);</span><br><span class="line">        <span class="comment">//获取结果</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">rs1</span> <span class="operator">=</span> r1.get();</span><br><span class="line">        <span class="comment">//关闭服务</span></span><br><span class="line">        ser.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="二-其他知识"><a href="#二-其他知识" class="headerlink" title="二 其他知识"></a>二 其他知识</h3><ul><li>静态代理模式<ul><li>真实对象和代理对象都要实现同一个接口</li><li>代理对象要代理真实角色</li><li>好处：代理对象可以做很多真实对象做不了的事情，真实对象专注做自己的事情</li></ul></li><li>Lamda表达式<ul><li>前提是只有一行代码的情况下才能简化为一行，如果不是则不能去掉括号</li><li>前提是接口为函数式接口</li><li>多个参数也可以去掉参数类型，要去就都去掉</li></ul></li></ul><h3 id="三-线程状态与方法"><a href="#三-线程状态与方法" class="headerlink" title="三 线程状态与方法"></a>三 线程状态与方法</h3><h4 id="3-1-线程状态"><a href="#3-1-线程状态" class="headerlink" title="3.1 线程状态"></a>3.1 线程状态</h4><ul><li>新生</li><li>就绪</li><li>阻塞</li><li>运行</li><li>死亡</li></ul><h4 id="3-2-线程方法"><a href="#3-2-线程方法" class="headerlink" title="3.2 线程方法"></a>3.2 线程方法</h4><ul><li><code>setPriority(int newPriority)</code></li><li><code>static void sleep(long millis)</code></li><li><code>void join():线程终止</code></li><li><code>static void yield():暂停当前正在执行的线程，并执行其他线程</code></li><li><code>void interrupt():中断线程，别用这个方式</code></li><li><code>boolean isAlive():测试线程是否处于活动状态</code></li></ul><h4 id="3-3-线程停止"><a href="#3-3-线程停止" class="headerlink" title="3.3 线程停止"></a>3.3 线程停止</h4><ul><li>不建议使用stop方法停止线程，让线程正常停止（利用次数、使用标志位）</li></ul><h4 id="3-4-线程休眠"><a href="#3-4-线程休眠" class="headerlink" title="3.4 线程休眠"></a>3.4 线程休眠</h4><ul><li><p><code>sleep()</code></p></li><li><p>指定的是毫秒</p></li><li>存在异常<code>InterruptedException</code></li><li>sleep时间到达之后进入就绪状态</li><li>可以模拟网络延时</li><li>每个对象都有一个锁，sleep不会释放锁</li></ul><h4 id="3-5-线程礼让"><a href="#3-5-线程礼让" class="headerlink" title="3.5 线程礼让"></a>3.5 线程礼让</h4><ul><li><p><code>yield()</code></p></li><li><p>定义：让当前正在执行的线程停止，但不阻塞</p></li><li>将线程从运行状态转为就绪状态</li><li>让CPU重新调度，礼让不一定成功，看CPU心情</li></ul><h4 id="3-6-线程强制执行"><a href="#3-6-线程强制执行" class="headerlink" title="3.6 线程强制执行"></a>3.6 线程强制执行</h4><ul><li><p><code>join()</code></p></li><li><p>join合并线程，待此线程执行完成后，再执行其他线程，其他线程阻塞（插队）</p></li></ul><h4 id="3-7-观察线程状态"><a href="#3-7-观察线程状态" class="headerlink" title="3.7 观察线程状态"></a>3.7 观察线程状态</h4><ul><li><p><code>Thread.getState()</code></p></li><li><p>值：NEW、RUNNABLE、BLOCKED、WAITING、TIME_WAITING、TERMINATED<code>(Thread.State类型)</code></p></li></ul><h4 id="3-8-线程的优先级"><a href="#3-8-线程的优先级" class="headerlink" title="3.8 线程的优先级"></a>3.8 线程的优先级</h4><ul><li>用数字表示1-10，越大越高，大多数的时候是优先级高的先跑</li><li><code>getPriority() setPriority(int i)</code></li><li>先设置优先级再<code>start()</code></li></ul><h4 id="3-9-守护线程"><a href="#3-9-守护线程" class="headerlink" title="3.9 守护线程"></a>3.9 守护线程</h4><ul><li><p><code>threadName.setDaemon(true)</code></p></li><li><p>默认为false</p></li><li>线程分为用户线程和守护线程</li><li>虚拟机必须确保用户线程执行完毕</li><li>虚拟机不用等待守护线程执行完毕</li><li>如后台记录操作日志、监控内存、垃圾回收等待</li></ul><h3 id="四-线程同步"><a href="#四-线程同步" class="headerlink" title="四 线程同步"></a>四 线程同步</h3><ul><li><p>多线程操作同一个资源（并发）</p></li><li><p>线程同步其实就是一种等待机制，多个需要同时访问同一个对象的线程进入对象的等待池形成队列，等待前面的线程使用完毕，下一个线程再使用</p></li><li><p>形成条件：队列和锁</p></li><li><p>锁机制：synchronized</p><ul><li>一个线程持有的锁会导致其他所有需要这个锁的线程挂起</li><li>多线程竞争下加锁、释放锁会导致比较多的上下文切换和调度延时，引擎性能问题</li><li>如果一个优先级高的线程等待一个优先级第的线程释放锁，会导致优先级倒置，引起性能问题</li></ul></li><li><p>三大不安全案例</p><ul><li><u>Thread_Study/code/D1_UnsafeBuyTicket.java</u>：买票</li><li><u>Thread_Study/code/D2_UnsafeBank.java</u>：取钱</li><li><u>Thread_Study/code/D3_UnsafeList.java</u>：list</li></ul></li><li><p>同步方法及同步块</p><ul><li>synchronized关键字<ul><li>synchronized方法 <code>pubic synchronized void method(int args)&#123;&#125;</code></li><li>synchronized块</li></ul></li><li>synchronized方法控制对对象的访问，每个对象对应一把锁，每个synchronized方法都必须获得调用该方法的对象的锁才能执行，否则线程会阻塞，方法一旦执行，就独占该锁，直到该方法返回才释放锁，后面被阻塞的线程才能获得这个锁，继续执行<ul><li>缺陷：若一个大的方法申明为synchronized将会影响效率</li></ul></li><li>synchronized同步块<ul><li><code>synchronized(Obj)&#123;&#125;</code> ： 锁住的对象是变化的量</li><li>Obj称为同步监视器<ul><li>Obj可以是任何对象，但是推荐使用共享资源作为同步监视器</li><li>同步方法中无需指定同步监视器，因为同步方法的同步监视器就是this，就是这个对象本身，或者是class（反射）</li></ul></li><li>同步监视过程<ol><li>第一个线程访问，锁同步监视器，执行其中代码</li><li>第二个线程访问，发现同步监视器被锁定，无法访问</li><li>第一个线程访问完毕，解锁同步监视器</li><li>第二个线程访问，发现同步监视器没有锁，然后锁定并访问</li></ol></li></ul></li></ul></li><li><p><code>CopyOnWriteArrayList</code>(JUC并发包中)</p></li><li></li></ul><h3 id="五-锁与线程通信"><a href="#五-锁与线程通信" class="headerlink" title="五 锁与线程通信"></a>五 锁与线程通信</h3><h4 id="5-1-死锁"><a href="#5-1-死锁" class="headerlink" title="5.1 死锁"></a>5.1 死锁</h4><ul><li>产生死锁的四个必要条件<ul><li>互斥条件：一个资源每次只能被一个进程使用</li><li>请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放</li><li>不剥夺条件：进程已获得的资源，在未使用完之前，不能强行剥夺</li><li>循环等待条件：若干进程之间形成一种头尾相接的循环等待资源关系</li></ul></li><li>避免其中一个即可避免死锁的产生</li><li>lock锁<ul><li>JDK5.0</li><li><code>ReentrantLock</code>类（可重入锁）实现了Lock接口</li><li>Lock是显式锁（手动开启和关闭锁）synchronized是隐式锁，出了作用域自动释放</li><li>Lock只有代码块锁，synchronized有代码块和方法锁</li><li>使用Lock锁，JVM将花费较少的时间来调度线程，性能更好，并且具有更好的拓展性（提供更多的子类）</li><li>优先使用顺序：<ul><li>Lock &gt; 同步代码块(已经进入了方法体，分配了相应资源) &gt; 同步方法（方法体之外）</li></ul></li></ul></li></ul><h4 id="5-2-线程协作（生duiy产者消费者模式）"><a href="#5-2-线程协作（生duiy产者消费者模式）" class="headerlink" title="5.2 线程协作（生duiy产者消费者模式）"></a>5.2 线程协作（生duiy产者消费者模式）</h4><ul><li>对于生产者，没有生产产品之前，要通知消费者等待，生产之后又要通知消费者消费</li><li>对于消费者，消费后要通知生产者已经消费结束，需要生产新的产品</li><li>在这个模式中，仅有synchronized是不够的<ul><li>synchronized可阻止并发更新一个共享资源，实现了同步</li><li>synchronized不能用来实现不同线程之间的消息传递（通信）</li></ul></li><li>几个方法<ul><li><code>wait()</code></li><li><code>wait(long timeout)</code></li><li><code>notify()</code></li><li><code>notifyAll()</code></li></ul></li><li>解决方式1<ul><li>并发协作模型 “生产者/消费者模式” ——&gt; 管程法<ul><li>生产者负责生产数据</li><li>消费者负责处理数据</li><li>缓冲区：消费者不能直接使用生产者的数据</li></ul></li></ul></li><li>解决方式2<ul><li>并发协作模型 “生产者/消费者模式” ——&gt; 信号灯法</li></ul></li></ul><h4 id="5-3-线程池"><a href="#5-3-线程池" class="headerlink" title="5.3 线程池"></a>5.3 线程池</h4><ul><li>避免了频繁的创建和销毁线程</li><li>便于管理、提高响应速度</li><li>JDK5.0 <code>ExecutorService</code> 和<code>Executors</code><ul><li><code>ExecutorService</code>：真正的线程池，常见子类ThreadPoolExecutor<ul><li><code>viod execute(Runnable command)：执行任务，无返回值</code></li><li><code>&lt;T&gt; Future&lt;T&gt; submit(Callable&lt;T&gt; task)：执行任务，有返回值，用来执行Callable</code></li><li><code>void shutdown()：关闭连接池</code></li></ul></li><li><code>Executors</code>：工具类，线程池的工厂类，用于创建并返回不同类型的线程池</li></ul></li></ul><h2 id="B-反射"><a href="#B-反射" class="headerlink" title="B 反射"></a>B 反射</h2><h3 id="一-反射"><a href="#一-反射" class="headerlink" title="一 反射"></a>一 反射</h3><h4 id="1-1-反射"><a href="#1-1-反射" class="headerlink" title="1.1 反射"></a>1.1 反射</h4><ul><li><p>反射机制：将类的各个部分封装为其他对象</p></li><li><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/多线程与反射.assets/image-20220918144836712.png" alt="image-20220918144836712"></p></li><li><p>优点</p><ul><li><p>在程序的运行过程中操作这些对象</p></li><li><p>可以解耦，提高程序的可扩展性</p></li></ul></li></ul><h4 id="1-2-获取字节码class类的三个方式"><a href="#1-2-获取字节码class类的三个方式" class="headerlink" title="1.2 获取字节码class类的三个方式"></a>1.2 获取字节码class类的三个方式</h4><ul><li><p><code>Class.forName(“全类名”)</code>：将字节码文件加载进内存</p><ul><li>多用于配置文件，将类名定义在配置对象中，读取文件加载类</li></ul></li><li><p><code>类名.class</code>：通过类名的属性class获得</p><ul><li>多用于参数的传递</li></ul></li><li><p><code>对象.getClass()</code>：object类中定义</p><ul><li>多用于对象的获取字节码方式</li></ul><p>​    注：同一个class文件（字节码文件）在一次程序运行过程中只加载一次，不论通过哪一种方式获取的class对象都是同一个。</p></li></ul><h4 id="1-3-使用class对象"><a href="#1-3-使用class对象" class="headerlink" title="1.3 使用class对象"></a>1.3 使用class对象</h4><ul><li><p>获取功能</p><ul><li><p>获取成员变量</p><ul><li><p><code>Field[] getFields()</code></p><ul><li>获取public修饰的</li></ul></li><li><p><code>Field getField(String name)</code></p></li><li><p><code>Field[] getDeclaredFields()</code></p><ul><li><p>不考虑修饰符</p></li><li><p>若访问了非public，则需要在访问前设置忽略安全访问</p><p><code>fieldName.setAccessible(true);//暴力反射</code></p></li></ul></li><li><p><code>Field getDeClaredFields(String name)</code></p></li></ul></li><li><p>获取构造方法</p><ul><li><code>Constructor&lt;?&gt;[] getConstructors()</code></li><li><code>Constructor&lt;T&gt; getConstructor(类&lt;?&gt;... parameterTypes)</code></li><li><code>Constructor&lt;T&gt; getDeclaredConstructor(类&lt;?&gt;... parameterTypes)</code></li><li><code>Constructor&lt;?&gt;[] getDeclaredConstructors()</code></li></ul></li><li><p>获取成员方法</p><ul><li><code>Method[] getMethods()</code></li><li><code>Method getMethod(String name, 类&lt;?&gt;... parameterTypes)</code></li><li><code>Method[] getDeclaredMethods()</code></li><li><code>Method getDeclaredMethod(String name, 类&lt;?&gt;... parameterTypes)</code></li></ul></li><li><p>获取类名</p><ul><li><code>String getName()</code></li></ul></li></ul></li><li><p>Field：成员变量</p><ul><li>get set</li><li>忽略访问权限修饰符的安全检查：<code>setAccessible(true);//暴力反射</code></li></ul></li><li><p>Constructor：构造方法</p><ul><li>创建对象：<code>ConstructorName.newInstance(Object... initargs)</code></li><li>若使用空参构造方法创建对象，则可以简化操作：<code>Class对象的newInstance</code></li></ul></li><li><p>Method</p><ul><li>执行方法：<code>methodName.invoke(Object obj, Object... args)</code></li></ul></li></ul><h4 id="1-4-反射案例"><a href="#1-4-反射案例" class="headerlink" title="1.4 反射案例"></a>1.4 反射案例</h4><ul><li><p>写一个框架，不该变该类的任何代码实现创建任意类，执行任意方法(改变配置文件)</p><ul><li>实现：<ul><li>配置文件</li><li>反射</li></ul></li><li>步骤：<ul><li>将需要创建的对象的全类名和需要执行的方法定义在配置文件中</li><li>在程序中加载读取配置文件</li><li>使用反射技术来加载类文件进内存</li><li>创建对象</li><li>执行方法</li></ul></li></ul></li><li><p>配置文件pro.properties文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">className = cn.itcast.domain.Person</span><br><span class="line">methodName = eat</span><br></pre></td></tr></table></figure></li><li><p>ReflectTest.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1 加载配置文件</span></span><br><span class="line"><span class="comment">//1.1 创建properties对象</span></span><br><span class="line"><span class="type">Properties</span> <span class="variable">pro</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line"><span class="comment">//1.2 加载配置文件，转换为一个集合</span></span><br><span class="line"><span class="comment">//1.2.1 获取class目录下的配置文件</span></span><br><span class="line"><span class="type">ClassLoader</span> <span class="variable">classLoader</span> <span class="operator">=</span> ReflectTest.class.getClassLoader();</span><br><span class="line"><span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> classLoader.getResoureAsStream(<span class="string">&quot;pro.properties&quot;</span>)</span><br><span class="line">pro.load(is); </span><br><span class="line"><span class="comment">//2 获取配置文件中定义的数据</span></span><br><span class="line"><span class="type">String</span> <span class="variable">className</span> <span class="operator">=</span> pro.getProperties(<span class="string">&quot;className&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">methodName</span> <span class="operator">=</span> pro.getProperties(<span class="string">&quot;methodName&quot;</span>);</span><br><span class="line"><span class="comment">//3 加载类进内存</span></span><br><span class="line"><span class="type">Class</span> <span class="variable">cls</span> <span class="operator">=</span> class.forName(className);</span><br><span class="line"><span class="comment">//4 创建对象</span></span><br><span class="line"><span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> cls.newInstance();</span><br><span class="line"><span class="comment">//5 获取方法对象</span></span><br><span class="line"><span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> cls.getMethod(methodName);</span><br><span class="line">method.invoke(obj);</span><br></pre></td></tr></table></figure></li></ul>   <link rel="stylesheet" href="https://cdn1.tianli0.top/gh/zhheo/Post-Abstract-AI@0.15.2/tianli_gpt.css"><script>let tianliGPT_postSelector = '#post #article-container';let tianliGPT_key = 'c9b7741d290063ab872e';</script><script src="https://cdn1.tianli0.top/gh/zhheo/Post-Abstract-AI@0.15.2/tianli_gpt.js"></script>]]></content>
      
      
      <categories>
          
          <category> study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构与算法</title>
      <link href="/posts/40445.html"/>
      <url>/posts/40445.html</url>
      
        <content type="html"><![CDATA[<h2 id="数据结构与算法"><a href="#数据结构与算法" class="headerlink" title="数据结构与算法"></a>数据结构与算法</h2><h3 id="0725-一-队列、链表"><a href="#0725-一-队列、链表" class="headerlink" title="0725 一 队列、链表"></a>0725 一 队列、链表</h3><h4 id="1-1-线性结构和非线性结构"><a href="#1-1-线性结构和非线性结构" class="headerlink" title="1.1 线性结构和非线性结构"></a>1.1 线性结构和非线性结构</h4><ul><li>线性结构<ul><li>特点：一对一</li><li>顺序结构存储（数组）和链式存储结构（链表）</li><li>线性结构常见的有：数组、队列、链表和栈</li></ul></li><li>非线性结构：<ul><li>二维数组，多维数组，广义表，树结构，图结构</li></ul></li></ul><h4 id="1-2-稀疏数组和队列"><a href="#1-2-稀疏数组和队列" class="headerlink" title="1.2 稀疏数组和队列"></a>1.2 稀疏数组和队列</h4><ul><li><p>稀疏数组定义：当一个数组中大部分元素为０，或者为同一个值的数组时，可以使用稀疏数组来保存该数组。</p></li><li><p>稀疏数组的处理方法：</p><ol><li>记录数组一共有几行几列，有多少个不同的值（第一个数据）</li><li>把具有不同值的元素的行列及值记录在一个小规模的数组中，从而缩小程序的规模<ol><li><img src="/TyporaImg/数据结构与算法.assets/image-20220725135327143.png" alt="image-20220725135327143"></li></ol></li></ol></li><li><p><u><em>稀疏数组和二维数组的转换练习：day0725/sparseArray.java</em></u></p></li><li>队列定义：队列是一个有序列表，可以用数组或是链表来实现。<ul><li>特点：先进先出，三个参数 <code>maxSize,front,rear</code></li><li>因为队列的输出、输入是分别从前后端来处理，因此需要两个变<strong>量</strong> front及rear分别记录队列前后端的下标，front 会随着数据输出而改变，而 rear则是随着数据输入而改变<ul><li><img src="/TyporaImg/数据结构与算法.assets/image-20220725135257863.png" alt="image-20220725135257863"></li><li>front指向队列第一个元素的前一位，rear指向队列的最后一位</li></ul></li><li>当front==rear时，队列为空，当rear==maxSize时，队列满</li><li>采用环形队列以优化队列<ul><li>调整：front指向队列的第一个元素，front初始值为0，rear指向队列的最后一个元素的后一位，rear初始值也为0</li><li>队列满条件： <code>(rear+1) % maxSize == front</code></li><li>队列空条件：<code>rear == front</code></li><li>队列中有效数据的个数： <code>(rear - front + maxSize) % maxSize//其实就是rear-front的绝对值</code></li></ul></li></ul></li></ul><h4 id="1-3-单向链表"><a href="#1-3-单向链表" class="headerlink" title="1.3 单向链表"></a>1.3 单向链表</h4><ul><li><p>链表是有序的列表，是以节点的方式来存储,是链式存储。</p></li><li><p>每个节点包含 data 域， next 域：指向下一个节点。链表分带头节点的链表和没有头节点的链表</p><ul><li><img src="/TyporaImg/数据结构与算法.assets/image-20220725151129673.png" alt="image-20220725151129673"></li></ul></li></ul><ul><li><p><u><em>单链表的定义：day0725/singleLinkedListDemo.java</em></u></p></li><li><p>增：<u><em>按顺序插入节点：day0725/singleLinkedListDemo.java</em></u>其中的<code>addByOrder</code>方法</p></li><li><p>修改节点 <code>update</code>方法</p></li><li><p>删除节点 <code>delete</code>方法；被删除的节点，将不会有其他引用指向，将被垃圾回收</p></li><li><p>获取链表倒数第k个元素：</p><ol><li><p>接收head和index</p></li><li><p>先从头到尾遍历，得到总长度size</p></li><li><p>遍历得到第size-index个元素，则为倒数第k个元素</p><p>注：对index检验其是否合理</p></li></ol></li><li><p>单链表的反转：<code>reverse</code>方法</p><ol><li>定义一个节点<code>reverseHead</code>为反转后的头</li><li>从头到尾遍历原链表，每遍历一个就将其取出，放在新链表最前端(类似于指定位置插入元素)</li><li>原链表中的元素<code>head.next = reverseHead.next</code>  </li></ol></li><li><p>从尾到头打印链表</p><ul><li>方法1：先将单链表反转再打印，但是这样做会破坏单链表的结构</li><li>方法2：利用栈，将各个节点压入到栈内，利用栈先进后出的特点实现逆序打印 <code>java.util.Stack类</code></li></ul></li></ul><h4 id="1-4-双向链表"><a href="#1-4-双向链表" class="headerlink" title="1.4 双向链表"></a>1.4 双向链表</h4><ul><li>单向链表的查找方向只有一个，而双向链表可以向前或者向后查找。</li><li>单向链表不能自我删除，需要靠辅助节点 ，而双向链表，则可以自我删除，所以前面我们单链表删除时节点，总是找到temp,temp是待删除节点的前一个节点</li><li>结构：多了一个pre指向前一个节点</li><li>遍历：和单链表一样，只是可以向前或者向后 </li><li>增：<ol><li>找到最后一个节点</li><li><code>temp.next = newNode;</code></li><li><code>newNode.pre = temp;</code></li></ol></li><li>删：<ol><li>直线找到要删除的节点</li><li><code>temp.pre.next = temp.next;//temp为要删除的节点</code></li><li><code>temp.next.pre = temp.pre;</code></li></ol></li><li>改：和单向链表一样</li><li><u><em>增删改查的代码实现：day0725/DoubleLinkedListDemo.java</em></u></li></ul><h4 id="1-5-单向环形问题和约瑟夫问题"><a href="#1-5-单向环形问题和约瑟夫问题" class="headerlink" title="1.5 单向环形问题和约瑟夫问题"></a>1.5 单向环形问题和约瑟夫问题</h4><ul><li><p>约瑟夫问题</p><p><img src="/TyporaImg/数据结构与算法.assets/image-20220725195717002.png" alt="image-20220725195717002"></p></li><li><p>构建一个单向的环形链表思路</p><ol><li>先创建第一个节点，让first指向该节点，并形成环形</li><li>后面每创建一个新的节点，就把该节点加入已有的环形链表中</li></ol></li><li><p>遍历：</p><ol><li>让第一个辅助指针（变量） <code>curBoy</code>指向first节点</li><li>然后通过while循环遍历该环形链表 <code>curBoy.next == first</code>结束</li></ol></li><li><p>约瑟夫问题的实现</p><ul><li><p>创建一个辅助指针helper，事先指向环形链表的最后这个节点</p></li><li><p>当小孩报数的时候，让first和helper指针同时移动m-1次</p></li><li><p>这个时候将first指向的小孩节点出圈，</p><p><code>first = first.next;</code></p><p><code>hleper.next = first;</code></p><p>原来first指向的节点就没有任何用，就会被回收</p></li></ul></li></ul><h3 id="0726-二-栈、前中后缀表达式、排序"><a href="#0726-二-栈、前中后缀表达式、排序" class="headerlink" title="0726 二  栈、前中后缀表达式、排序"></a>0726 二  栈、前中后缀表达式、排序</h3><h4 id="2-1-栈（Stack）"><a href="#2-1-栈（Stack）" class="headerlink" title="2.1 栈（Stack）"></a>2.1 栈（Stack）</h4><ul><li><p>先入后出</p></li><li><p>栈(stack)是限制线性表中元素的插入和删除<strong>只能在线性表的同一端</strong>进行的一种特殊线性表。允许插入和删除的一端，为变化的一端，称为<strong>栈顶</strong>(Top)，另一端为固定的一端，称为<strong>栈底</strong>(Bottom)。</p></li><li><p>出栈（pop）和入栈（push）</p></li><li><p>应用</p><ul><li>子程序的调用：在跳往子程序前，会先将下个指令的地址存到堆栈中，直到子程序执行完后再将地址取出，以回到原来的程序中</li><li>处理递归调用：和子程序的调用类似，只是除了储存下一个指令的地址外，也将参数、区域变量等数据存入堆栈中</li><li>表达式的转换</li><li>二叉树的遍历</li><li>图形的深度优先(depth一first)搜索法</li></ul></li><li><p>栈的数组实现</p><ul><li>定义一个top表示栈顶，初始化为-1</li><li>入栈操作：当有数据加入的时候，<code>top++;stack[top] = data;</code></li><li>出栈操作：<code>int value = stack[top];top--;return value;</code>    </li></ul></li><li><p>栈实现综合计算器：<u><em>使用栈完成一个表达式的结果：day0726/Calculator.java</em></u> <code>//有括号不行</code></p><ol><li><p>两个栈：数栈（存放数字）和符号栈（存放运算符）</p></li><li><p>创建一个index指针遍历表达式 <code>//String str = &quot;3+2*6-2&quot;;</code></p></li><li><p>如果是一个数字，就直接加入到数栈中</p></li><li><p>如果是一个符号，分为两种情况</p><ul><li>当前符号栈为空，则直接加入到符号栈中</li><li>当前符号栈非空，进行比较：<ul><li>当前符号的优先级&lt;=栈中的操作符，就从数栈中pop出两个数字，从符号栈中pop出一个符号进行运算，将得到的结果入数栈，然后将当前操作符入符号栈</li><li>当前符号的优先级&gt;栈中的操作符，则直接入栈</li></ul></li></ul></li><li><p>当表达式扫描完毕，就顺序从数栈和符号栈中pop出相应的数和符号并运算</p><p>​            注：数栈中依次pop出ab连个数字，符号栈中pop出xxx运算符，则结果为<code>bxxxa</code></p></li><li><p>最后数栈中只有一个结果，即表达式的结果</p><p>注：对于多位数的处理：判断下一个数字是否为运算符。如果是则加入，如果不是则进行拼接，然后下一步循环的时候再对下下个字符进行判断处理</p></li></ol></li></ul><h4 id="2-2-前缀、中缀、后缀表达式"><a href="#2-2-前缀、中缀、后缀表达式" class="headerlink" title="2.2 前缀、中缀、后缀表达式"></a>2.2 前缀、中缀、后缀表达式</h4><ul><li><p>前缀表达式又称波兰式，<strong>前缀表达式的运算符位于操作数之前</strong></p><p><code>(3+4)×5-6 对应的前缀表达式就是 -×+3456</code></p></li><li><p>前缀表达式求值：从右至左扫描表达式，遇到数字时，将数字压入堆栈，遇到运算符时，弹出栈顶的两个数，用运算符对它们做相应的计算（栈顶元素 和 次顶元素），并将结果入栈；重复上述过程直到表达式最左端，最后运算得出的值即为表达式的结果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//(3+4)×5-6 对应的前缀表达式就是 -×+3456, 针对前缀表达式求值步骤如下</span></span><br><span class="line"><span class="number">1.</span>从右至左扫描，将<span class="number">6</span>、<span class="number">5</span>、<span class="number">4</span>、<span class="number">3</span>压入堆栈</span><br><span class="line"><span class="number">2.</span>遇到+运算符，因此弹出<span class="number">3</span>和<span class="number">4</span>（<span class="number">3</span>为栈顶元素，<span class="number">4</span>为次顶元素），计算出<span class="number">3</span>+<span class="number">4</span>的值，得<span class="number">7</span>，再将<span class="number">7</span>入栈</span><br><span class="line"><span class="number">3.</span>接下来是×运算符，因此弹出<span class="number">7</span>和<span class="number">5</span>，计算出<span class="number">7</span>×<span class="number">5</span>=<span class="number">35</span>，将<span class="number">35</span>入栈</span><br><span class="line"><span class="number">4.</span>最后是-运算符，计算出<span class="number">35</span>-<span class="number">6</span>的值，即<span class="number">29</span>，由此得出最终结果</span><br></pre></td></tr></table></figure></li><li><p>中缀表达式：就是<strong>常见的运算表达式</strong>，如(3+4)×5-6</p><p>但是计算机不易识别，一般会转换为其他的表达式来处理（常转为后缀表达式）</p></li><li><p>后缀表达式：又称<strong>逆波兰表达式</strong>,与前缀表达式相似，只是运算符位于操作数之后</p><p><code>(3+4)×5-6 对应的后缀表达式就是34+5×6–</code></p><p><img src="/TyporaImg/数据结构与算法.assets/image-20220726145733439.png" alt="image-20220726145733439"></p></li><li><p>后缀表达式求值：<strong>从左至右</strong>扫描表达式，遇到数字时，将数字压入堆栈，遇到运算符时，弹出栈顶的两个数，用运算符对它们做相应的计算（次顶元素 和 栈顶元素），并将结果入栈；重复上述过程直到表达式最右端，最后运算得出的值即为表达式的结果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//(3+4)×5-6 对应的后缀表达式就是 34+5×6-, 针对后缀表达式求值步骤如下</span></span><br><span class="line"><span class="number">1.</span>从左至右扫描，将<span class="number">3</span>和<span class="number">4</span>压入堆栈；</span><br><span class="line"><span class="number">2.</span>遇到+运算符，因此弹出<span class="number">4</span>和<span class="number">3</span>（<span class="number">4</span>为栈顶元素，<span class="number">3</span>为次顶元素），计算出<span class="number">3</span>+<span class="number">4</span>的值，得<span class="number">7</span>，再将<span class="number">7</span>入栈；</span><br><span class="line"><span class="number">3.</span>将<span class="number">5</span>入栈；</span><br><span class="line"><span class="number">4.</span>接下来是×运算符，因此弹出<span class="number">5</span>和<span class="number">7</span>，计算出<span class="number">7</span>×<span class="number">5</span>=<span class="number">35</span>，将<span class="number">35</span>入栈；</span><br><span class="line"><span class="number">5.</span>将<span class="number">6</span>入栈；</span><br><span class="line"><span class="number">6.</span>最后是-运算符，计算出<span class="number">35</span>-<span class="number">6</span>的值，即<span class="number">29</span>，由此得出最终结果</span><br></pre></td></tr></table></figure></li><li><p>逆波兰计算机实现：<u><em>day0726/PolandNatation.java</em></u> </p></li><li><p>中缀表达式转后缀表达式:代码实现在<code>PolandNatation.java</code>的<code>toInfixExpressionList</code>方法中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>初始化两个栈：运算符栈s1和储存中间结果的栈s2；</span><br><span class="line"><span class="number">2.</span>从左至右扫描中缀表达式；</span><br><span class="line"><span class="number">3.</span>遇到操作数时，将其压s2；</span><br><span class="line"><span class="number">4.</span>遇到运算符时，比较其与s1栈顶运算符的优先级：</span><br><span class="line"><span class="number">4.1</span> 如果s1为空，或栈顶运算符为左括号“(”，则直接将此运算符入栈；</span><br><span class="line"><span class="number">4.2</span> 否则，若优先级比栈顶运算符的高，也将运算符压入s1；</span><br><span class="line"><span class="number">4.3</span> 否则，将s1栈顶的运算符弹出并压入到s2中，再次转到(<span class="number">4.1</span>)与s1中新的栈顶运算符相比较；</span><br><span class="line"><span class="number">5.</span>遇到括号时：</span><br><span class="line">    <span class="number">5.1</span> 如果是左括号“(”，则直接压入s1</span><br><span class="line">    <span class="number">5.2</span> 如果是右括号“)”，则依次弹出s1栈顶的运算符，并压入s2，直到遇到左括号为止，此时将这一对括号丢弃</span><br><span class="line"><span class="number">6.</span>重复步骤<span class="number">2</span>至<span class="number">5</span>，直到表达式的最右边</span><br><span class="line"><span class="number">7.</span>将s1中剩余的运算符依次弹出并压入s2</span><br><span class="line"><span class="number">8.</span>依次弹出s2中的元素并输出，结果的逆序即为中缀表达式对应的后缀表达式</span><br></pre></td></tr></table></figure><p><img src="/TyporaImg/数据结构与算法.assets/image-20220726153126279.png" alt="image-20220726153126279"></p></li></ul><h4 id="2-3-递归（Recursion）的调用场景"><a href="#2-3-递归（Recursion）的调用场景" class="headerlink" title="2.3 递归（Recursion）的调用场景"></a>2.3 递归（Recursion）的调用场景</h4><ul><li>递归解决的问题：8皇后问题 , 汉诺塔, 阶乘问题, 迷宫问题, 球和篮子的问题(google编程大赛)</li><li>各种算法中也会使用到递归，比如快排，归并排序，二分查找，分治算法等.</li><li>将用栈解决的问题—&gt;递归代码比较简洁</li><li><p>递归的原则</p><ul><li>执行一个方法时，就创建一个新的受保护的独立空间(栈空间)</li><li>方法的局部变量是独立的，不会相互影响, 比如n变量</li><li>如果方法中使用的是引用类型变量(比如数组)，就会共享该引用类型的数据.</li><li>递归必须向退出递归的条件逼近，否则就是无限递归,出现StackOverflowError，死龟了:)</li><li>当一个方法执行完毕，或者遇到return，就会返回，遵守谁调用，就将结果返回给谁，同时当方法执行完毕或者返回时，该方法也就执行完毕</li></ul></li><li><p>递归的内存 </p><p><img src="/TyporaImg/数据结构与算法.assets/image-20220726164350390.png" alt="image-20220726164350390"></p></li><li><p>八皇后问题：</p><p>在8×8格的国际象棋上摆放八个皇后，使其不能互相攻击，即：<strong>任意两个皇后都不能处于同一行、同一列或同一斜线上，问有多少种摆法</strong>。</p><p>​            思路：</p><ul><li>第一个皇后先放第一行第一列</li><li>第二个皇后放在第二行第一列、然后判断是否OK， 如果不OK，继续放在第二列、第三列、依次把所有列都放完，找到一个合适</li><li>继续第三个皇后，还是第一列、第二列……直到第8个皇后也能放在一个不冲突的位置，算是找到了一个正确解</li><li><p>当得到一个正确解时，在栈回退到上一个栈时，就会开始回溯，即将第一个皇后，放到第一列的所有正确解，全部得到.</p></li><li><p>然后回头继续第一个皇后放第二列，后面继续循环执行 1,2,3,4的步骤 </p></li></ul></li></ul><ul><li><p>八皇后问题实现：<u><em>day0726/Queue8.java</em></u> </p><p>说明:理论上应该创建一个二维数组来表示棋盘，但是实际上可以通过算法，用一个一维数组即可解决问题. arr[8] = {0 , 4, 7, 5, 2, 6, 1, 3} //对应arr 下标 表示第几行，即第几个皇后，arr[i] = val , val 表示第i+1个皇后，放在第i+1行的第val+1列</p></li></ul><h4 id="2-4-排序算法"><a href="#2-4-排序算法" class="headerlink" title="2.4 排序算法"></a>2.4 排序算法</h4><ul><li><img src="/TyporaImg/数据结构与算法.assets/image-20220726195248769.png" alt="image-20220726195248769"></li><li>直接插入、简单选择、冒泡比较常用</li></ul><h4 id="2-5-算法的时间复杂度"><a href="#2-5-算法的时间复杂度" class="headerlink" title="2.5 算法的时间复杂度"></a>2.5 算法的时间复杂度</h4><ul><li>度量一个程序(算法)执行时间的两种方法<ul><li>事后统计的方法</li><li>事前估算的方法</li></ul></li><li>时间频度：一个算法中的语句执行次数称为语句频度或时间频度。记为<code>T(n)</code></li><li><p>一般情况下，算法中的基本操作语句的重复执行次数是问题规模n的某个函数，用<code>T(n)</code>表示，若有某个辅助函数<code>f(n)</code>，使得当n趋近于无穷大时，<code>T(n)/f(n)</code> 的极限值为不等于零的常数，则称<code>f(n)</code>是<code>T(n)</code>的同数量级函数。记作 <code>T(n)=O(f(n))</code>，称<code>O(f(n))</code> 为算法的渐进时间复杂度，简称时间复杂度</p><ul><li>注：T(n) 不同，但时间复杂度可能相同。 如：<code>T(n)=n²+7n+6</code> 与 <code>T(n)=3n²+2n+2</code> 它们的T(n) 不同，但时间复杂度相同，都为O(n²)。</li><li>计算方法：<ol><li>用常数1代替运行时间中的所有加法常数 T(n)=n²+7n+6 =&gt; T(n)=n²+7n+1</li><li>修改后的运行次数函数中，只保留最高阶项 T(n)=n²+7n+1 =&gt; T(n) = n²</li><li>去除最高阶项的系数 T(n) = n² =&gt; T(n) = n² =&gt; O(n²)</li></ol></li></ul></li><li><p><img src="/TyporaImg/数据结构与算法.assets/image-20220726200251872.png" alt="image-20220726200251872"></p></li><li><p>常见时间复杂度</p><ul><li><p>常数阶<code>O(1)</code>:无论代码执行了多少行，只要是没有循环等复杂结构，那这个代码的时间复杂度就都是O(1)</p></li><li><p>对数阶<code>O(log2n)</code>:</p><p><img src="/TyporaImg/数据结构与算法.assets/image-20220726200456805.png" alt="image-20220726200456805"></p></li><li><p>线性阶<code>O(n)</code>:for循环里面的代码会执行n遍，因此它消耗的时间是随着n的变化而变化的，因此这类代码都可以用O(n)来表示它的时间复杂度</p></li><li><p>线性对数阶 <code>O(nlogN)</code>:线性对数阶<code>O(nlogN)</code> 其实非常容易理解，将时间复杂度为<code>O(logn)</code>的代码循环N遍的话（while套在for循环里面）那么它的时间复杂度就是 <code>n * O(logN)</code>，也就是了<code>O(nlogN)</code></p></li><li><p>平方阶<code>O(n2)</code>:将<code>O(n)</code>内代码嵌套一遍（两个for循环）</p></li><li><p>立方阶、k次方阶：相当于k个for循环嵌套</p></li></ul></li><li><p>常见排序算法的时间复杂度</p><p><img src="/TyporaImg/数据结构与算法.assets/image-20220726201016842.png" alt="image-20220726201016842"></p></li></ul><h4 id="2-6-算法空间复杂度"><a href="#2-6-算法空间复杂度" class="headerlink" title="2.6 算法空间复杂度"></a>2.6 算法空间复杂度</h4><ul><li><p>一个算法的空间复杂度(Space Complexity)定义为该算法所耗费的存储空间，它也是问题规模n的函数。</p><p>在做算法分析时，<strong>主要讨论的是时间复杂度</strong>。从用户使用体验上看，更看重的程序执行的速度。一些缓存产品(redis, memcache)和算法(基数排序)本质就是用空间换时间。</p></li></ul><h4 id="2-7-冒泡排序"><a href="#2-7-冒泡排序" class="headerlink" title="2.7 冒泡排序"></a>2.7 冒泡排序</h4><ul><li>通过对待排序序列从前向后（从下标较小的元素开始）,依次比较相邻元素的值，若发现逆序则交换，使值较大的元素逐渐从前移向后部，就象水底下的气泡一样逐渐向上冒。</li><li>冒泡排序的实现：<u><em>day0726/BubbleSort.java</em></u> </li><li>冒泡排序的优化：因为排序的过程中，各元素不断接近自己的位置，如果一趟比较下来没有进行过交换，就说明序列有序，因此要在排序过程中设置一个标志flag判断元素是否进行过交换。从而减少不必要的比较。</li></ul><h4 id="2-8-选择排序"><a href="#2-8-选择排序" class="headerlink" title="2.8 选择排序"></a>2.8 选择排序</h4><ul><li><p>选择式排序也属于内部排序法，是从欲排序的数据中，按指定的规则选出某一元素，再依规定交换位置后达到排序的目的。</p><p>比如第一次选出最小的和第一个元素交换位置，第二次再选出剩下的最小的和第二个元素交换位置，以此类推</p></li><li><p>冒泡排序的实现：<u><em>day0726/SelectSort.java</em></u> </p></li></ul><h3 id="0727-三-排序、查找、哈希表"><a href="#0727-三-排序、查找、哈希表" class="headerlink" title="0727 三 排序、查找、哈希表"></a>0727 三 排序、查找、哈希表</h3><h4 id="3-1-插入排序"><a href="#3-1-插入排序" class="headerlink" title="3.1 插入排序"></a>3.1 插入排序</h4><ul><li><p>把n个待排序的元素看成为一个有序表和一个无序表，开始时有序表中只包含一个元素，无序表中包含有n-1个元素，排序过程中每次从无序表中取出第一个元素，把它的排序码依次与有序表元素的排序码进行比较，将它插入到有序表中的适当位置，使之成为新的有序表。</p></li><li><p>思路图</p><p><img src="/TyporaImg/数据结构与算法.assets/image-20220727090206460.png" alt="image-20220727090206460"></p></li><li><p>插入排序的实现：<u><em>day0726/InsertSort.java</em></u> </p></li><li><p>插入排序的缺陷：当（从小到大排）插入的数较小，需要遍历的次数多，会导致插入排序的时间增加</p></li><li><p>希尔排序（缩小增量排序）：希尔排序是把记录按下标的一定增量分组，对每组使用直接插入排序算法排序；随着增量逐渐减少，每组包含的关键词越来越多，当增量减至1时，整个文件恰被分成一组，算法便终止</p><p><img src="/TyporaImg/数据结构与算法.assets/image-20220727092644327.png" alt="image-20220727092644327"></p><p>希尔排序的实现(里面有交换式和移位式)：<u><em>day0726/SheelSort.java</em></u> </p></li></ul><h4 id="3-2-快速排序"><a href="#3-2-快速排序" class="headerlink" title="3.2 快速排序"></a>3.2 快速排序</h4><ul><li>是对冒泡排序的一种改进</li><li>思想：通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列</li><li><img src="/TyporaImg/数据结构与算法.assets/image-20220727141201553.png" alt="image-20220727141201553"></li><li>快速排序的实现：<u><em>day0726/QuickSort.java</em></u> </li></ul><h4 id="3-3-归并排序"><a href="#3-3-归并排序" class="headerlink" title="3.3 归并排序"></a>3.3 归并排序</h4><ul><li><p>分而治之</p></li><li><p><img src="/TyporaImg/数据结构与算法.assets/image-20220727155649005.png" alt="image-20220727155649005"></p></li><li><p>重点为“治”的过程：将两个有序子序列合并为一个有序序列</p><p><img src="/TyporaImg/数据结构与算法.assets/image-20220727155805235.png" alt="image-20220727155805235"></p></li></ul><h4 id="3-4-基数排序（桶排序）"><a href="#3-4-基数排序（桶排序）" class="headerlink" title="3.4 基数排序（桶排序）"></a>3.4 基数排序（桶排序）</h4><ul><li><p>基数排序是桶排序的扩展</p></li><li><p>基本思想：将所有待比较数值统一为同样的数位长度，数位较短的数前面补零。然后，从最低位开始，依次进行一次排序。这样从最低位排序一直到最高位排序完成以后, 数列就变成一个有序序列</p></li><li><p>过程：</p><p><img src="/TyporaImg/数据结构与算法.assets/image-20220727181029645.png" alt="image-20220727181029645"></p><p><img src="/TyporaImg/数据结构与算法.assets/image-20220727181036126.png" alt="image-20220727181036126"></p><p><img src="/TyporaImg/数据结构与算法.assets/image-20220727181043233.png" alt="image-20220727181043233"></p></li><li><p>基数排序的实现：<u><em>day0726/RadixSort.java</em></u></p></li><li><p>说明：</p><ul><li>基数排序是对传统桶排序的扩展，速度很快</li><li>基数排序是经典的空间换时间的方式，占用内存很大, 当对海量数据排序时，容易造成 <code>OutOfMemoryError</code> 。</li><li>有负数的数组，我们不用基数排序来进行排序,如果要支持负数，参考:<a href="https://code.i-harness.com/zh-CN/q/e98fa9">https://code.i-harness.com/zh-CN/q/e98fa9</a></li><li>基数排序时稳定的。[注:假定在待排序的记录序列中，存在多个具有相同的关键字的记录，若经过排序，这些记录的相对次序保持不变，即在原序列中，r[i]=r[j]，且r[i]在r[j]之前，而在排序后的序列中，r[i]仍在r[j]之前，则称这种排序算法是稳定的；否则称为不稳定的]</li></ul></li></ul><h4 id="3-5-常用排序算法对比"><a href="#3-5-常用排序算法对比" class="headerlink" title="3.5 常用排序算法对比"></a>3.5 常用排序算法对比</h4><p><img src="/TyporaImg/数据结构与算法.assets/image-20220727181531794.png" alt="image-20220727181531794"></p><h4 id="3-6-查找算法"><a href="#3-6-查找算法" class="headerlink" title="3.6 查找算法"></a>3.6 查找算法</h4><ul><li><p>常用查找</p><ul><li>顺序(线性)查找</li><li>二分查找/折半查找 </li><li>插值查找</li><li>斐波那契查找</li></ul></li><li><p>顺序（线性）查找：就是遍历搜索查找，直到找到想要的返回值 3.7 二分查找‘</p></li><li><p>二分查找：对于有序数组而言，每次从中间分开找 <code>mid = (left+right)/2</code>(向下取整)，直到得到想要的值</p><ul><li>结束递归的条件：找到了想要的值；递归完了整个数组 <code>left &gt; right</code></li><li>二分查找的实现：<u><em>day0726/BinartSearch.java</em></u></li></ul></li><li><p>插值查找：插值查找算法类似于二分查找，不同的是插值查找每次从<code>自适应mid</code>处开始查找</p><p><img src="/TyporaImg/数据结构与算法.assets/image-20220727195757725.png" alt="image-20220727195757725"></p><p>注：</p><ul><li><code>low</code>为<code>left</code>,<code>high</code>为<code>right</code>,<code>key</code>为待查找值</li><li>对于数据量较大，关键字分布比较均匀的查找表来说，采用插值查找速度较快。</li><li>数据分布不均匀的情况下，该方法不一定比折半查找要好</li></ul></li><li><p>斐波那契查找（黄金分隔法）：</p><ul><li>斐波那契数列：<code>F[k]=F[k-1]+F[k-2]</code></li><li>斐波那契查找原理与前两种相似，仅仅改变了中间结点（mid）的位置，mid不再是中间或插值得到，而是位于黄金分割点附近，即<code>mid=low+F(k-1)-1</code></li><li>但顺序表长度n不一定刚好等于F[k]-1，所以需要将原来的顺序表长度n增加至F[k]-1。这里的k值只要能使得F[k]-1恰好大于或等于n即可，由以下代码得到,顺序表长度增加后，新增的位置（从n+1到F[k]-1位置），都赋为n位置的值即可。</li><li>斐波那契查找的实现：<u><em>day0726/FibonacciSearch.java</em></u></li></ul></li></ul><h4 id="3-7-哈希表"><a href="#3-7-哈希表" class="headerlink" title="3.7 哈希表"></a>3.7 哈希表</h4><ul><li><p>散列表（Hash table，也叫哈希表），是根据关键码值(Key value)而直接进行访问的数据结构。也就是说，它通过把关键码值映射到表中一个位置来访问记录，以加快查找的速度。这个映射函数叫做散列函数，存放记录的数组叫做散列表。</p></li><li><p>形式：数组+链表或者数组+二叉树</p></li><li><p>使用链表实现哈希表，该链表不带表头（即第一个数据就存放员工信息）</p></li><li><p>使用哈希表来实现增删改查：<u><em>day0726/HashTabDemo.java</em></u></p><p><img src="/TyporaImg/数据结构与算法.assets/image-20220727204428888.png" alt="image-20220727204428888"></p></li></ul><h3 id="0728-四-二叉树、堆、赫夫曼树"><a href="#0728-四-二叉树、堆、赫夫曼树" class="headerlink" title="0728 四 二叉树、堆、赫夫曼树"></a>0728 四 二叉树、堆、赫夫曼树</h3><h4 id="4-1-树结构"><a href="#4-1-树结构" class="headerlink" title="4.1 树结构"></a>4.1 树结构</h4><ul><li><p>常见数据结构特点：</p><ul><li>数组：优点：通过下标方式访问元素，速度快。对于有序数组，还可使用二分查找提高检索速度。<pre><code>         缺点：如果要检索具体某个值，或者插入值(按一定顺序)会整体移动，效率较低</code></pre></li><li>链式存储：优点：在一定程度上对数组存储方式有优化(比如：插入一个数值节点，只需要将插入节点，链接到链表中即可， 删除效率也很好)。<pre><code>          缺点：在进行检索时，效率仍然较低，比如(检索某个值，需要从头节点开始遍历) </code></pre></li><li>树存储：能提高数据存储，读取的效率, 比如利用 二叉排序树(Binary Sort Tree)，既可以保证数据的检索速度，同时也可以保证数据的插入，删除，修改的速度。</li></ul></li><li><p>树结构示意图：</p><p><img src="/TyporaImg/数据结构与算法.assets/image-20220728113952388.png" alt="image-20220728113952388"></p></li></ul><h4 id="4-2-二叉树"><a href="#4-2-二叉树" class="headerlink" title="4.2 二叉树"></a>4.2 二叉树</h4><ul><li><p>每个节点最多只能有两个子节点的一种形式称为二叉树</p></li><li><p>二叉树的子节点分为左节点和右节点</p></li><li><p>如果该二叉树的所有叶子节点都在最后一层，并且<code>结点总数= 2^n -1</code> , n 为层数，则我们称为满二叉树</p></li><li><p>如果该二叉树的所有叶子节点都在最后一层或者倒数第二层，而且最后一层的叶子节点在左边连续，倒数第二层的叶子节点在右边连续，我们称为完全二叉树</p><p><img src="/TyporaImg/数据结构与算法.assets/image-20220728115216390.png" alt="image-20220728115216390"></p></li><li><p>二叉树的遍历方式：前序、中序、后序遍历</p><ul><li><p>前序遍历：<strong>先输出父节点</strong>，再遍历左子树和右子树</p></li><li><p>中序遍历：先遍历左子树，<strong>再输出父节点</strong>，再遍历右子树</p></li><li><p>后序遍历：先遍历左子树，再遍历右子树，<strong>最后输出父节点</strong></p><p>注：看输出父节点的顺序，就确定是前序，中序还是后序</p></li></ul><p><img src="/TyporaImg/数据结构与算法.assets/image-20220728115651031.png" alt="image-20220728115651031"></p><p>二叉树节点遍历的实现：<u><em>day0728/BinaryTreeDemo.java</em></u></p></li><li><p>二叉树值的前中后序查找：<u><em>day0728/BinaryTreeDemo.java</em></u></p><p><img src="/TyporaImg/数据结构与算法.assets/image-20220728122246724.png" alt="image-20220728122246724"></p></li><li><p>删除：<u><em>day0728/BinaryTreeDemo.java</em></u></p><p><img src="/TyporaImg/数据结构与算法.assets/image-20220728123929107.png" alt="image-20220728123929107"></p></li></ul><h4 id="4-3-顺序存储二叉树"><a href="#4-3-顺序存储二叉树" class="headerlink" title="4.3 顺序存储二叉树"></a>4.3 顺序存储二叉树</h4><ul><li><p><img src="/TyporaImg/数据结构与算法.assets/image-20220728125820234.png" alt="image-20220728125820234"></p></li><li><p>代码实现：<u><em>day0728/ArrBinaryTreeDemo.java</em></u></p></li></ul><h4 id="4-4-线索化二叉树"><a href="#4-4-线索化二叉树" class="headerlink" title="4.4 线索化二叉树"></a>4.4 线索化二叉树</h4><ul><li><p>线索化二叉树的提出</p><p><img src="/TyporaImg/数据结构与算法.assets/image-20220728131356202.png" alt="image-20220728131356202"></p></li><li><p>思路分析</p><p><img src="/TyporaImg/数据结构与算法.assets/image-20220728131410325.png" alt="image-20220728131410325"></p></li><li><p>不同的遍历方式会产生不同的线索二叉树（前序遍历产生前序线索二叉树）</p></li><li><p>代码实现：<u><em>day0728/ThreadedBinaryTreeDemo.java</em></u></p></li></ul><h4 id="4-5-堆排序"><a href="#4-5-堆排序" class="headerlink" title="4.5 堆排序"></a>4.5 堆排序</h4><ul><li><p>堆排序是利用堆这种数据结构而设计的一种排序算法，堆排序是一种选择排序<strong>，</strong>它的最坏、最好平均时间复杂度均为O(nlogn)，它也是不稳定排序。</p></li><li><p>一般用数组来表示堆，下标为 i 的结点的父结点下标为<code>(i-1)/2</code>；其左右子结点分别为 <code>(2i + 1)、(2i + 2)</code></p></li><li><p>堆是具有以下性质的完全二叉树：每个结点的值都大于或等于其左右孩子结点的值，称为大顶堆, 注意 : 没有要求结点的左孩子的值和右孩子的值的大小关系。<code>arr[i] &gt;= arr[2*i+1] &amp;&amp; arr[i] &gt;= arr[2*i+2]</code></p></li><li><p>每个结点的值都小于或等于其左右孩子结点的值，称为小顶堆 <code>arr[i] &lt;= arr[2*i+1] &amp;&amp; arr[i] &lt;= arr[2*i+2]</code></p></li><li><p>堆排序的思想：</p><ul><li><p>将待排序序列构造成一个大顶堆</p></li><li><p>此时，整个序列的最大值就是堆顶的根节点</p></li><li><p>将其与末尾元素进行交换，此时末尾就为最大值。</p></li><li><p>然后将剩余n-1个元素重新构造成一个堆，这样会得到n个元素的次小值。如此反复执行，便能得到一个有序序列了。</p><video src="D:/javase_study/堆排序.mp4"></video></li></ul></li><li><p>代码实现：<u><em>day0728/HeapSort.java</em></u></p></li></ul><h4 id="4-6-赫夫曼树"><a href="#4-6-赫夫曼树" class="headerlink" title="4.6 赫夫曼树"></a>4.6 赫夫曼树</h4><ul><li><p>给定n个权值作为n个叶子结点，构造一棵二叉树，若该树的带权路径长度(wpl)达到最小，称这样的二叉树为最优二叉树，也称为哈夫曼树(Huffman Tree), 还有的书翻译为霍夫曼树。</p></li><li><p>赫夫曼树是带权路径长度最短的树，权值较大的结点离根较近。</p></li><li><p>两个概念：</p><ul><li>路径和路径长度：在一棵树中，从一个结点往下可以达到的孩子或孙子结点之间的通路，称为路径。通路中分支的数目称为路径长度。若规定根结点的层数为1，则从根结点到第L层结点的路径长度为L-1</li><li>结点的权及带权路径长度：若将树中结点赋给一个有着某种含义的数值，则这个数值称为该结点的权。结点的带权路径长度为：从根结点到该结点之间的路径长度与该结点的权的乘积</li><li><p>树的带权路径长度：树的带权路径长度规定为所有叶子结点的带权路径长度之和，记为WPL(weighted path length) ,权值越大的结点离根结点越近的二叉树才是最优二叉树。</p></li><li><p><img src="/TyporaImg/数据结构与算法.assets/image-20220728164457138.png" alt="image-20220728164457138"></p></li></ul></li><li><p>赫夫曼树的构造：</p><ol><li>从小到大进行排序, 将每一个数据，每个数据都是一个节点 ， 每个节点可以看成是一颗最简单的二叉树</li><li>取出根节点权值最小的两颗二叉树 </li><li>组成一颗新的二叉树, 该新的二叉树的根节点的权值是前面两颗二叉树根节点权值的和 </li><li>再将这颗新的二叉树，以根节点的权值大小 再次排序， 不断重复 1-2-3-4 的步骤，直到数列中，所有的数据都被处理，就得到一颗赫夫曼树</li></ol></li><li>赫夫曼树的构建代码实现：<u><em>day0728/HuffmanTree.java</em></u></li></ul><h4 id="4-7-赫夫曼编码"><a href="#4-7-赫夫曼编码" class="headerlink" title="4.7 赫夫曼编码"></a>4.7 赫夫曼编码</h4><ul><li><p>赫夫曼编码也翻译为 哈夫曼编码(Huffman Coding)，又称霍夫曼编码，是一种编码方式, 属于一种程序算法</p></li><li><p>赫夫曼编码是赫哈夫曼树在电讯通信中的经典的应用之一</p></li><li><p>赫夫曼编码广泛地用于数据文件压缩。其压缩率通常在20%-90%之间</p></li><li><p>赫夫曼码是可变字长编码(VLC)的一种。Huffman于1952年提出一种编码方法，称之为最佳编码</p></li><li><p>通讯领域编码的三种方式：</p><ul><li>定长编码</li><li>变长编码</li><li>赫夫曼编码</li></ul></li><li><p>赫夫曼编码过程：</p><p><img src="/TyporaImg/数据结构与算法.assets/image-20220728171943682.png" alt="image-20220728171943682"></p><p><img src="/TyporaImg/数据结构与算法.assets/image-20220728172035669.png" alt="image-20220728172035669"></p></li><li><p>赫夫曼编码实现文件压缩：<u><em>day0728/huffmanCode</em></u></p></li></ul><h3 id="0729-五-赫夫曼编码的数据压缩和解压、二叉排序树"><a href="#0729-五-赫夫曼编码的数据压缩和解压、二叉排序树" class="headerlink" title="0729 五 赫夫曼编码的数据压缩和解压、二叉排序树"></a>0729 五 赫夫曼编码的数据压缩和解压、二叉排序树</h3><h4 id="5-1-数据解压"><a href="#5-1-数据解压" class="headerlink" title="5.1 数据解压"></a>5.1 数据解压</h4><ul><li>编码的逆操作</li><li>赫夫曼编码实现文件解压：<u><em>day0728/huffmanCode</em></u></li><li>赫夫曼编码实现文件压缩与解压：<u><em>day0728/huffmanCode</em></u></li></ul><h4 id="5-2-赫夫曼编码压缩文件注意事项"><a href="#5-2-赫夫曼编码压缩文件注意事项" class="headerlink" title="5.2 赫夫曼编码压缩文件注意事项"></a>5.2 赫夫曼编码压缩文件注意事项</h4><ul><li>如果文件本身就是经过压缩处理的，那么使用赫夫曼编码再压缩效率不会有明显变化, 比如视频,ppt 等等文件</li><li>赫夫曼编码是按字节来处理的，因此可以处理所有的文件(二进制文件、文本文件)</li><li>如果一个文件中的内容，重复的数据不多，压缩效果也不会很明显</li></ul><h4 id="5-2-二叉排序树（BST）"><a href="#5-2-二叉排序树（BST）" class="headerlink" title="5.2 二叉排序树（BST）"></a>5.2 二叉排序树（BST）</h4><ul><li><p>使用数组、链表在查询和增删都各有优缺，用二叉排序树更好</p></li><li><p>二叉排序树BST: (Binary Sort(Search) Tree), 对于二叉排序树的任何一个非叶子节点，要求左子节点的值比当前节点的值小，右子节点的值比当前节点的值大。</p><p>注：如果有相同的值，可以将该节点放在左子节点或右子节点</p><p><img src="/TyporaImg/数据结构与算法.assets/image-20220729191918057.png" alt="image-20220729191918057"></p></li><li><p>二叉排序树的创建和遍历：<u><em>day0729/BinarySortTreeDemo.java</em></u></p></li><li><p>二叉树的删除</p><ul><li><p>删除叶子节点 (比如：2, 5, 9, 12)</p><ol><li>找到targetNode</li><li>找到targetNode的父节点parent</li><li>确定targetNode是parent的左子节点还是右子节点</li><li>根据前面的情况删除</li></ol></li><li><p>删除只有一颗子树的节点 (比如：1)</p><ol><li><p>找到targetNode和parent</p></li><li><p>确定targetNode是parent的左子节点还是右子节点</p></li><li><p>确定targetNode的子节点是左子节点还是右子节点</p></li><li><p>若targetNode有左子节点</p><ul><li>targetNode为parent的左子节点：<code>parent.left = targetNode.left</code> </li><li>targetNode为parent的右子节点：<code>parent.right= targetNode.left</code> </li></ul></li><li><p>若targetNode有右子节点</p><ul><li>targetNode为parent的左子节点：<code>parent.left = targetNode.right</code> </li><li>targetNode为parent的右子节点：<code>parent.right= targetNode.right</code> </li></ul></li></ol></li><li><p>删除有两颗子树的节点（比如：7, 3，10 ）</p><ol><li>找到targetNode和parent</li><li>确定targetNode是parent的左子节点还是右子节点</li><li>从targetNode的右子树找到最小的节点或者左子树最大的节点</li><li>用一个临时变量将最小节点的值保存</li><li>删除最小节点</li><li><code>targetNode.value = temp</code></li></ol></li></ul></li></ul><h3 id="0730-六-AVL树、多路查找树、图、常用十算法"><a href="#0730-六-AVL树、多路查找树、图、常用十算法" class="headerlink" title="0730 六 AVL树、多路查找树、图、常用十算法"></a>0730 六 AVL树、多路查找树、图、常用十算法</h3><h4 id="6-1-平衡二叉树（AVL树）"><a href="#6-1-平衡二叉树（AVL树）" class="headerlink" title="6.1 平衡二叉树（AVL树）"></a>6.1 平衡二叉树（AVL树）</h4><ul><li><p>BST的缺点</p><p><img src="/TyporaImg/数据结构与算法.assets/image-20220730141131882.png" alt="image-20220730141131882"></p></li><li><p>平衡二叉树也叫平衡二叉搜索树（Self-balancing binary search tree）又被称为AVL树， 可以保证查询效率较高</p></li><li><p>特点：它是一 棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。平衡二叉树的常用实现方法有红黑树、AVL（算法）、替罪羊树、Treap、伸展树等。</p><p><img src="/TyporaImg/数据结构与算法.assets/image-20220730141442032.png" alt="image-20220730141442032"></p><p>（前两个是AVL树，第三个不是，因为高度差为2）</p></li><li><p>构建平衡二叉树</p><p>：<u><em>day0730/AVLTreeDemo.java</em></u></p><ul><li><p>左旋转</p><ul><li>```java<br>//创建新节点，值为当前节点的值<br>//把新的节点的左子树设为当前节点的左子树<br>//把新节点的右子树设为当前节点的右子树的左子树<br>//把当前节点的值换成右子树的值<br>//把当前节点的右子树设置成右子树的右子树<br>//把当前节点的左子树设为新的节点<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">    ![image-20220730141952800](/TyporaImg/数据结构与算法.assets/image-20220730141952800.png)</span><br><span class="line"></span><br><span class="line">  - 右旋转</span><br><span class="line"></span><br><span class="line">    ![image-20220730142147504](/TyporaImg/数据结构与算法.assets/image-20220730142147504.png)</span><br><span class="line"></span><br><span class="line">  - 双旋转：某些情况下，单旋转不能完成平衡二叉树的转换</span><br><span class="line"></span><br><span class="line">    1. 当符合右旋转条件时</span><br><span class="line"></span><br><span class="line">    2. 如果左子树的右子树大于它的左子树高度</span><br><span class="line"></span><br><span class="line">    3. 先对这个节点的左节点进行左旋转</span><br><span class="line"></span><br><span class="line">    4. 再对当前节点进行右旋转</span><br><span class="line"></span><br><span class="line">       ![image-20220730151113211](/TyporaImg/数据结构与算法.assets/image-20220730151113211.png)</span><br><span class="line"></span><br><span class="line">#### 6.2 多路查找树</span><br><span class="line"></span><br><span class="line">- 二叉树的问题：当节点较多的时候：</span><br><span class="line"></span><br><span class="line">  - 多次I/O操作读取</span><br><span class="line">  - 高度变高导致速度降低</span><br><span class="line"></span><br><span class="line">- 引入多叉树：</span><br><span class="line"></span><br><span class="line">  - 如2-3树、2-3-4树</span><br><span class="line"></span><br><span class="line">    ![image-20220730182350142](/TyporaImg/数据结构与算法.assets/image-20220730182350142.png)</span><br><span class="line"></span><br><span class="line">  - B树</span><br><span class="line"></span><br><span class="line">- 2-3树</span><br><span class="line"></span><br><span class="line">  - 最简单 B树</span><br><span class="line"></span><br><span class="line">  - 特点：</span><br><span class="line"></span><br><span class="line">    - 2-3树的所有叶子节点都在同一层.(只要是B树都满足这个条件)</span><br><span class="line">    - 有两个子节点的节点叫二节点，二节点要么没有子节点，要么有两个子节点</span><br><span class="line">    - 有三个子节点的节点叫三节点，三节点要么没有子节点，要么有三个子节点</span><br><span class="line">    - 2-3树是由二节点和三节点构成的树</span><br><span class="line"></span><br><span class="line">  - 2-3树的构建过程</span><br><span class="line"></span><br><span class="line">    - 插入数据的规则：当不满足前三个特点的时候，就需要拆，先向上拆，如果上层满，则拆本层，拆后仍需要满足上面三个条件。</span><br><span class="line"></span><br><span class="line">      ![image-20220730183836147](/TyporaImg/数据结构与算法.assets/image-20220730183836147.png)</span><br><span class="line"></span><br><span class="line">      ![image-20220730183925033](/TyporaImg/数据结构与算法.assets/image-20220730183925033.png)</span><br><span class="line"></span><br><span class="line">- B树</span><br><span class="line"></span><br><span class="line">  - B-tree树即B树，B即Balanced，平衡的意思。有人把B-tree翻译成B-树，容易让人产生误解。会以为B-树是一种树，而B树又是另一种树。实际上，B-tree就是指的B树。</span><br><span class="line"></span><br><span class="line">  - B树的阶：节点的最多子节点个数。比如2-3树的阶是3，2-3-4树的阶是4</span><br><span class="line"></span><br><span class="line">  - B树的搜索，从根结点开始，对结点内的关键字（有序）序列进行二分查找，如果命中则结束，否则进入查询关键字所属范围的儿子结点；重复，直到所对应的儿子指针为空，或已经是叶子结点</span><br><span class="line"></span><br><span class="line">  - 关键字集合分布在整颗树中, 即叶子节点和非叶子节点都存放数据.</span><br><span class="line"></span><br><span class="line">  - 搜索有可能在非叶子结点结束</span><br><span class="line"></span><br><span class="line">  - 其搜索性能等价于在关键字全集内做一次二分查找</span><br><span class="line"></span><br><span class="line">    ![image-20220730184218884](/TyporaImg/数据结构与算法.assets/image-20220730184218884.png)</span><br><span class="line"></span><br><span class="line">- B+树</span><br><span class="line"></span><br><span class="line">  - 是B树的变体</span><br><span class="line"></span><br><span class="line">  - 所有数据都只在叶子节点中</span><br><span class="line"></span><br><span class="line">  - 所有关键字都出现在叶子结点的链表中（即数据只能在叶子节点[也叫稠密索引]），且链表中的关键字(数据)恰好是有序的。</span><br><span class="line"></span><br><span class="line">  - 非叶子结点相当于是叶子结点的索引（稀疏索引），叶子结点相当于是存储（关键字）数据的数据层</span><br><span class="line"></span><br><span class="line">  - 更适合文件索引系统</span><br><span class="line"></span><br><span class="line">  - B树和B+树各有自己的应用场景，不能说B+树完全比B树好，反之亦然.</span><br><span class="line"></span><br><span class="line">    ![image-20220730184405939](/TyporaImg/数据结构与算法.assets/image-20220730184405939.png)</span><br><span class="line"></span><br><span class="line">- B*树</span><br><span class="line"></span><br><span class="line">  - 是B+树的变体</span><br><span class="line"></span><br><span class="line">  - B树定义了非叶子结点关键字个数至少为(2/3)M，即块的最低使用率为2/3，而B+树的块的最低使用率为B+树的1/2。（这里M是它的度：节点的度指的是结点拥有的子树的数目。. 而整棵树的度指的是树中结点的最大的度）</span><br><span class="line"></span><br><span class="line">  - 从第1个特点我们可以看出，B*树分配新结点的概率比B+树要低，空间使用率更高</span><br><span class="line"></span><br><span class="line">    ![image-20220730184936013](/TyporaImg/数据结构与算法.assets/image-20220730184936013.png)</span><br><span class="line"></span><br><span class="line">#### 6.3 图</span><br><span class="line"></span><br><span class="line">- 线性表局限于一个直接前驱和一个直接后继的关系，树也只能有一个直接前驱也就是父节点，当我们需要表示多对多的关系时， 这里我们就用到了图</span><br><span class="line"></span><br><span class="line">- 图是一种数据结构，其中结点可以具有零个或多个相邻元素。两个结点之间的连接称为边。 结点也可以称为顶点</span><br><span class="line"></span><br><span class="line">- 常用概念：</span><br><span class="line"></span><br><span class="line">  - 顶点（vertex）</span><br><span class="line">  - 边（edge）</span><br><span class="line">  - 路径</span><br><span class="line">  - 无向图与有向图</span><br><span class="line">  - 带权图</span><br><span class="line"></span><br><span class="line">- 图的表示方式：</span><br><span class="line"></span><br><span class="line">  - 二维数组（邻接矩阵）</span><br><span class="line"></span><br><span class="line">    ![image-20220730185855050](/TyporaImg/数据结构与算法.assets/image-20220730185855050.png)</span><br><span class="line"></span><br><span class="line">  - 链表（邻接表）</span><br><span class="line"></span><br><span class="line">    - 邻接矩阵需要为每个顶点都分配n个边的空间，其实有很多边都是不存在,会造成空间的一定损失</span><br><span class="line">    - 邻接表的实现只关心存在的边，不关心不存在的边。因此没有空间浪费，邻接表由数组+链表组成![image-20220730185955246](/TyporaImg/数据结构与算法.assets/image-20220730185955246.png)</span><br><span class="line"></span><br><span class="line">- 图的创建和代码实现：&lt;u&gt;*day0730/Graph.java*&lt;/u&gt;</span><br><span class="line"></span><br><span class="line">#### 6.4 图的深度优先遍历算法（DFS: Depth First Search）</span><br><span class="line"></span><br><span class="line">- 从初始访问结点出发，初始访问结点可能有多个邻接结点，深度优先遍历的策略就是首先访问第一个邻接结点，然后再以这个被访问的邻接结点作为初始结点，访问它的第一个邻接结点， 可以这样理解：每次都在访问完当前结点后首先访问当前结点的第一个邻接结点</span><br><span class="line">- 我们可以看到，这样的访问策略是优先往纵向挖掘深入，而不是对一个结点的所有邻接结点进行横向访问</span><br><span class="line">- 步骤：</span><br><span class="line">  1. 访问初始结点v，并标记结点v为已访问。</span><br><span class="line">  2. 查找结点v的第一个邻接结点w。</span><br><span class="line">  3. 若w存在，则继续执行4，如果w不存在，则回到第1步，将从v的下一个结点继续。</span><br><span class="line">  4. 若w未被访问，对w进行深度优先遍历递归（即把w当做另一个v，然后进行步骤abc）。</span><br><span class="line">  5. 查找结点v的w邻接结点的下一个邻接结点，转到步骤3。</span><br><span class="line">- 代码实现：&lt;u&gt;*day0730/Graph.java*&lt;/u&gt;</span><br><span class="line"></span><br><span class="line">####  6.5 图的广度优先遍历算法(BFS: Broad First Search) </span><br><span class="line"></span><br><span class="line">- 类似于一个分层搜索的过程，广度优先遍历需要使用一个队列以保持访问过的结点的顺序，以便按这个顺序来访问这些结点的邻接结点</span><br><span class="line">- 步骤</span><br><span class="line">  1. 访问初始结点v并标记结点v为已访问。</span><br><span class="line">  2. 结点v入队列</span><br><span class="line">  3. 当队列非空时，继续执行，否则算法结束。</span><br><span class="line">  4. 出队列，取得队头结点u。</span><br><span class="line">  5. 查找结点u的第一个邻接结点w。</span><br><span class="line">  6. 若结点u的邻接结点w不存在，则转到步骤3；否则循环执行以下三个步骤：</span><br><span class="line">     - 6.1 若结点w尚未被访问，则访问结点w并标记为已访问。  </span><br><span class="line">     - 6.2 结点w入队列 </span><br><span class="line">     - 6.3 查找结点u的继w邻接结点后的下一个邻接结点w，转到步骤6。</span><br><span class="line">- 代码实现：&lt;u&gt;*day0730/Graph.java*&lt;/u&gt;</span><br><span class="line"></span><br><span class="line">#### 6.6 常用十算法 1二分查找算法（非递归）</span><br><span class="line"></span><br><span class="line">- 二分查找法只适用于从有序的数列中进行查找(比如数字和字母等)，将数列排序后再进行查找</span><br><span class="line">- 二分查找法的运行时间为对数时间O(㏒₂n) ，即查找到需要的目标位置最多只需要㏒₂n步，假设从[0,99]的队列(100个数，即n=100)中寻到目标数30，则需要查找步数为㏒₂100 , 即最多需要查找7次( 2^6 &lt; 100 &lt; 2^7)</span><br><span class="line">- 代码实现：&lt;u&gt;*Algorithm/BinarySearchNoRecur.java*&lt;/u&gt;</span><br><span class="line"></span><br><span class="line">#### 6.7 常用十算法 2分治算法</span><br><span class="line"></span><br><span class="line">- 分治法是一种很重要的算法。字面上的解释是“分而治之”，就是把一个复杂的问题分成两个或更多的相同或相似的子问题，再把子问题分成更小的子问题……直到最后子问题可以简单的直接求解，原问题的解即子问题的解的合并。这个技巧是很多高效算法的基础，如排序算法(快速排序，归并排序)，傅立叶变换(快速傅立叶变换)……</span><br><span class="line"></span><br><span class="line">- 经典问题：二分搜索、大整数乘法、棋盘覆盖、合并排序、快速排序、线性时间选择、最接近点对问题、循环赛日程表、汉诺塔</span><br><span class="line"></span><br><span class="line">- 分治算法设计模式</span><br><span class="line"></span><br><span class="line">  ```java</span><br><span class="line">  if |P|≤n0</span><br><span class="line">     then return(ADHOC(P))</span><br><span class="line">  //将P分解为较小的子问题 P1 ,P2 ,…,Pk</span><br><span class="line">  for i←1 to k</span><br><span class="line">  do yi ← Divide-and-Conquer(Pi)   递归解决Pi</span><br><span class="line">  T ← MERGE(y1,y2,…,yk)   合并子问题</span><br><span class="line">  return(T)</span><br></pre></td></tr></table></figure></li></ul></li></ul></li><li><p>代码实现哈诺塔问题：<u><em>Algorithm/Hanoitower.java</em></u></p><p><img src="/TyporaImg/数据结构与算法.assets/image-20220730203935359.png" alt="image-20220730203935359"></p></li></ul><h4 id="6-8-动态规划算法"><a href="#6-8-动态规划算法" class="headerlink" title="6.8 动态规划算法"></a>6.8 动态规划算法</h4><ul><li><p>动态规划(Dynamic Programming)算法的核心思想是：将大问题划分为小问题进行解决，从而一步步获取最优解的处理算法</p></li><li><p>动态规划算法与分治算法类似，其基本思想也是将待求解问题分解成若干个子问题，先求解子问题，然后从这些子问题的解得到原问题的解。</p></li><li><p>与分治法不同的是，适合于用动态规划求解的问题，经分解得到子问题往往不是互相独立的。 ( 即下一个子阶段的求解是建立在上一个子阶段的解的基础上，进行进一步的求解 )</p></li><li><p>动态规划可以通过填表的方式来逐步推进，得到最优解</p></li><li><p>01背包问题实现：<u><em>Algorithm/KnapsackProblem.java</em></u></p><p>思路：每次遍历到的第i个物品，根据w[i]和v[i]来确定是否需要将该物品放入背包中。即对于给定的n个物品，设v[i]、w[i]分别为第i个物品的价值和重量，C为背包的容量。再令v[i][j]表示在前i个物品中能够装入容量为j的背包中的最大价值。则我们有下面的结果：</p><ul><li><p>v[i][0]=v[0][j]=0; //表示填入表第一行和第一列是0</p></li><li><p>当w[i]&gt; j 时：v[i][j]=v[i-1][j]   // 当准备加入新增的商品的容量大于当前背包的容量时，就直接使用上一个单元格的装入策略</p></li><li><p>当j&gt;=w[i]时： v[i][j]=max{v[i-1][j], v[i]+v[i-1][j-w[i]]}  // 当准备加入的新增的商品的容量小于等于当前背包的容量,</p><p>装入的方式:<br>v[i-1][j]： 就是上一个单元格的装入的最大值<br>v[i] : 表示当前商品的价值<br>v[i-1][j-w[i]] ： 装入i-1商品，到剩余空间j-w[i]的最大值<br>当j&gt;=w[i]时： v[i][j]=max{v[i-1][j], v[i]+v[i-1][j-w[i]]} : </p></li></ul><p><img src="/TyporaImg/数据结构与算法.assets/image-20220730210931369.png" alt="image-20220730210931369"></p><p>另一种理解方式：</p><p><img src="/TyporaImg/数据结构与算法.assets/image-20220730211647928.png" alt="image-20220730211647928"></p><p>最优解的回溯：</p><p><img src="/TyporaImg/数据结构与算法.assets/image-20220731093245107.png" alt="image-20220731093245107"></p></li></ul><h3 id="0731-五-常用十算法"><a href="#0731-五-常用十算法" class="headerlink" title="0731 五 常用十算法"></a>0731 五 常用十算法</h3><h4 id="5-1-KMP算法"><a href="#5-1-KMP算法" class="headerlink" title="5.1 KMP算法"></a>5.1 KMP算法</h4><ul><li>查找字符产出现的最早位置</li><li>暴力匹配算法</li><li>KMP算法解释：<a href="https://www.cnblogs.com/zzuuoo666/p/9028287.html">https://www.cnblogs.com/zzuuoo666/p/9028287.html</a></li><li><a href="http://www.ruanyifeng.com/blog/2013/05/Knuth%E2%80%93Morris%E2%80%93Pratt_algorithm.html(简版">http://www.ruanyifeng.com/blog/2013/05/Knuth%E2%80%93Morris%E2%80%93Pratt_algorithm.html(简版</a>)</li><li>主要是部分匹配表的推算</li><li>KMP算法实现：<u><em>Algorithm/KMP.java</em></u></li></ul><h4 id="5-2-贪心算法"><a href="#5-2-贪心算法" class="headerlink" title="5.2 贪心算法"></a>5.2 贪心算法</h4><ul><li><p>贪婪算法(贪心算法)是指在对问题进行求解时，在每一步选择中都采取最好或者最优(即最有利)的选择，从而希望能够导致结果是最好或者最优的算法</p></li><li><p>贪婪算法所得到的结果不一定是最优的结果(有时候会是最优解)，但是都是相对近似(接近)最优解的结果</p></li><li><p>贪心算法应用：广播台集合覆盖</p><p><img src="/TyporaImg/数据结构与算法.assets/image-20220731114816388.png" alt="image-20220731114816388"></p><ol><li>遍历所有的广播电台, 找到一个覆盖了最多未覆盖的地区的电台(此电台可能包含一些已覆盖的地区，但没有关系） </li><li>将这个电台加入到一个集合中(比如ArrayList), 想办法把该电台覆盖的地区在下次比较时去掉。</li><li>重复第1步直到覆盖了全部的地区</li></ol></li></ul><p>​                    代码实现：<u><em>Algorithm/Greedy.java</em></u></p><h4 id="5-3-普利姆算法"><a href="#5-3-普利姆算法" class="headerlink" title="5.3 普利姆算法"></a>5.3 普利姆算法</h4><ul><li><p><img src="/TyporaImg/数据结构与算法.assets/image-20220731120825787.png" alt="image-20220731120825787"></p></li><li><p>修路问题本质就是最小生成树（MST）问题</p></li><li><p>最小生成树(Minimum Cost Spanning Tree)：</p><ul><li>给定一个带权的无向连通图,如何选取一棵生成树,使树上所有边上权的总和为最小,这叫最小生成树 </li><li>N个顶点，一定有N-1条边</li><li>包含全部顶点</li><li>N-1条边都在图中</li><li>求最小生成树的算法主要是普里姆算法和克鲁斯卡尔算法</li></ul></li><li><p>Prim算法介绍：</p><ol><li><p>设G=(V,E)是连通网，T=(U,D)是最小生成树，V,U是顶点集合，E,D是边的集合 </p></li><li><p>若从顶点u开始构造最小生成树，则从集合V中取出顶点u放入集合U中，标记顶点v的visited[u]=1</p></li><li><p>若集合U中顶点ui与集合V-U中的顶点vj之间存在边，则寻找这些边中权值最小的边，但不能构成回路，将顶点vj加入集合U中，将边（ui,vj）加入集合D中，标记visited[vj]=1</p></li><li><p>重复步骤②，直到U与V相等，即所有顶点都被标记为访问过，此时D中有n-1条边</p><p><a href="http://c.biancheng.net/algorithm/prim.html">http://c.biancheng.net/algorithm/prim.html</a></p></li></ol></li><li><p>代码实现：<u><em>Algorithm/Prim.java</em></u></p></li></ul><h4 id="5-4-克鲁斯卡尔算法：http-c-biancheng-net-algorithm-kruskal-html"><a href="#5-4-克鲁斯卡尔算法：http-c-biancheng-net-algorithm-kruskal-html" class="headerlink" title="5.4 克鲁斯卡尔算法：http://c.biancheng.net/algorithm/kruskal.html"></a>5.4 克鲁斯卡尔算法：<a href="http://c.biancheng.net/algorithm/kruskal.html">http://c.biancheng.net/algorithm/kruskal.html</a></h4><ul><li><p>思路：按照权值从小到大的顺序选择n-1条边，并保证这n-1条边不构成回路</p></li><li><p>具体做法：首先构造一个只含n个顶点的森林，然后依权值从小到大从连通网中选择边加入到森林中，并使森林中不产生回路，直至森林变成一棵树为止</p></li><li><p>实现克鲁斯卡尔算法的难点在于“如何判断一个新边是否会和已选择的边构成环路”</p><p>选择加入的边的两个顶点不能指向同一个终点，否则将构成回路</p></li><li><p>代码实现：<u><em>Algorithm/Kruskal.java</em></u></p></li></ul><h4 id="5-5-迪杰斯特拉算法"><a href="#5-5-迪杰斯特拉算法" class="headerlink" title="5.5 迪杰斯特拉算法"></a>5.5 迪杰斯特拉算法</h4><ul><li><p>迪杰斯特拉(Dijkstra)算法是典型最短路径算法，用于计算一个结点到其他结点的最短路径。 它的主要特点是以起始点为中心向外层层扩展(广度优先搜索思想)，直到扩展到终点为止。</p></li><li><p>算法过程：</p><ol><li>设置出发顶点为v，顶点集合V{v1,v2,vi…}，v到V中各顶点的距离构成距离集合Dis，Dis{d1,d2,di…}，Dis集合记录着v到图中各顶点的距离(到自身可以看作0，v到vi距离对应为di)</li><li>从Dis中选择值最小的di并移出Dis集合，同时移出V集合中对应的顶点vi，此时的v到vi即为最短路径</li><li>更新Dis集合，更新规则为：比较v到V集合中顶点的距离值，与v通过vi到V集合中顶点的距离值，保留值较小的一个(同时也应该更新顶点的前驱节点为vi，表明是通过vi到达的)</li><li>重复执行两步骤，直到最短路径顶点为目标顶点即可结束</li></ol><p><a href="https://zhuanlan.zhihu.com/p/346558578">https://zhuanlan.zhihu.com/p/346558578</a></p></li><li><p>代码实现：<u><em>Algorithm/Dijkstra.java</em></u></p></li></ul><h4 id="5-6-弗洛伊德算法-Floyd"><a href="#5-6-弗洛伊德算法-Floyd" class="headerlink" title="5.6 弗洛伊德算法(Floyd)"></a>5.6 弗洛伊德算法(Floyd)</h4><ol><li><p>弗洛伊德算法(Floyd)计算图中各个顶点之间的最短路径</p></li><li><p>迪杰斯特拉算法用于计算图中某一个顶点到其他顶点的最短路径。</p></li><li><p><strong>弗洛伊德算法</strong> VS <strong>迪杰斯特拉算法</strong>：迪杰斯特拉算法通过选定的被访问顶点，求出从出发访问顶点到其他顶点的最短路径；弗洛伊德算法中每一个顶点都是出发访问点，所以需要将每一个顶点看做被访问顶点，求出从每一个顶点到其他顶点的最短路径。</p></li><li><p>思路:</p><ol><li><p>设置顶点vi到顶点vk的最短路径已知为Lik，顶点vk到vj的最短路径已知为Lkj，顶点vi到vj的路径为Lij，则vi到vj的最短路径为：min((Lik+Lkj),Lij)，vk的取值为图中所有顶点，则可获得vi到vj的最短路径</p></li><li><p>至于vi到vk的最短路径Lik或者vk到vj的最短路径Lkj，是以同样的方式获得</p><p>主要是维护DP两张表（距离表，前驱关系表）</p></li></ol><p><img src="/TyporaImg/数据结构与算法.assets/image-20220731160421005.png" alt="image-20220731160421005"></p><p><img src="/TyporaImg/数据结构与算法.assets/image-20220731160431219.png" alt="image-20220731160431219"></p><p>代码实现：<u><em>Algorithm/Floyd.java</em></u></p><h4 id="5-7-骑士周游问题"><a href="#5-7-骑士周游问题" class="headerlink" title="5.7 骑士周游问题"></a>5.7 骑士周游问题</h4></li></ol><ul><li><p><img src="/TyporaImg/数据结构与算法.assets/image-20220731162306379.png" alt="image-20220731162306379"></p></li><li><p>分析：</p><ul><li>马踏棋盘问题(骑士周游问题)实际上是图的深度优先搜索(DFS)的应用。</li><li>如果使用回溯（就是深度优先搜索）来解决，假如马儿踏了53个点，如图：走到了第53个，坐标（1,0），发现已经走到尽头，没办法，那就只能回退了，查看其他的路径，就在棋盘上不停的回溯…… </li></ul></li><li><p>思路：</p><ul><li><img src="/TyporaImg/数据结构与算法.assets/image-20220731162614425.png" alt="image-20220731162614425"></li></ul></li></ul><link rel="stylesheet" href="https://cdn1.tianli0.top/gh/zhheo/Post-Abstract-AI@0.15.2/tianli_gpt.css"><script>let tianliGPT_postSelector = '#post #article-container';let tianliGPT_key = 'c9b7741d290063ab872e';</script><script src="https://cdn1.tianli0.top/gh/zhheo/Post-Abstract-AI@0.15.2/tianli_gpt.js"></script>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java基础 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>javase</title>
      <link href="/posts/20250.html"/>
      <url>/posts/20250.html</url>
      
        <content type="html"><![CDATA[<h2 id="JAVASE-STUDY"><a href="#JAVASE-STUDY" class="headerlink" title="JAVASE_STUDY"></a>JAVASE_STUDY</h2><h3 id="0703-一-基础"><a href="#0703-一-基础" class="headerlink" title="0703 一 基础"></a>0703 一 基础</h3><h4 id="1-1-JDK-JRE-JVM关系"><a href="#1-1-JDK-JRE-JVM关系" class="headerlink" title="1.1 JDK JRE JVM关系"></a>1.1 JDK JRE JVM关系</h4><p><img src="TyporaImg/javaSE笔记.assets/image-20220703112143738.png" alt="image-20220703112143738"></p><p>(jdk安装环境不带中文和空格)</p><h4 id="1-2-JAVA编译过程"><a href="#1-2-JAVA编译过程" class="headerlink" title="1.2 JAVA编译过程"></a>1.2 JAVA编译过程</h4><p>源程序(.java) -&gt; 编译器 -&gt; java字节码文件(.class) -&gt; JVM运行</p><p><code>public class HelloWorld &#123;    public static void main(String[] args)&#123;        System.out.println(&quot;Hello,World!&quot;);    &#125;&#125;</code></p><p>cmd</p><p><code>D:/&gt;javac HelloWorld.java</code>  &lt;- 编译生成.class文件</p><p><code>D:/&gt;java HelloWorld</code> &lt;- 运行</p><h4 id="1-3-关键字、标识符"><a href="#1-3-关键字、标识符" class="headerlink" title="1.3 关键字、标识符"></a>1.3 关键字、标识符</h4><p>标识符：26个字母、10个数字、美元符号$和下划线_   (不以数字开头，不能是关键字)</p><p>命名规则：</p><ul><li>类名：首字母大写，后面每个单词首字母大写（HelloWorld）</li><li>变量名：首字母小写，后面每个字母首字母大写（helloWorld）</li><li>方法名：同变量名</li></ul><h4 id="1-4-常量与变量"><a href="#1-4-常量与变量" class="headerlink" title="1.4 常量与变量"></a>1.4 常量与变量</h4><p>常量：</p><ul><li><p>字符串常量：用双引号引起来的（”abc”）</p></li><li><p>整数常量：（2）</p></li><li><p>浮点数常量：（2.5）</p></li><li><p>字符常量：单引号（’a’、’中’）</p></li><li><p>布尔常量：（true、false）</p></li><li><p>空常量：（null）</p></li></ul><p>变量：</p><ul><li>创建：数据类型 变量名称 = 数据值;</li><li>注意事项：名称不重复；对于float或者long，字母后缀F和L不能丢</li></ul><h4 id="1-5-基本数据类型和引用数据类型"><a href="#1-5-基本数据类型和引用数据类型" class="headerlink" title="1.5 基本数据类型和引用数据类型"></a>1.5 基本数据类型和引用数据类型</h4><p>  基本数据类型（4类8种）</p><ul><li><p>整数型：byte（1字节）、short（2字节）、int（4字节）、long（8字节）</p></li><li><p>浮点型：float（4字节）、double（近似值，非精确值）</p></li><li><p>字符型：char</p></li><li><p>布尔型：boolean</p></li><li><p>注：并不是字节越大表示的数字范围越大，float就比long类型表示的数字范围大</p></li></ul><p>引用数据类型</p><ul><li>字符串</li><li>数组</li><li>类</li><li>接口 </li><li>Lambda</li></ul><p>注：对于引用类型，==是地址值的比较，对于基本类型，==是数值的比较</p><h4 id="1-6-数据类型转换"><a href="#1-6-数据类型转换" class="headerlink" title="1.6 数据类型转换"></a>1.6 数据类型转换</h4><ul><li><p>自动类型转换（隐式）</p></li><li><p>强制类型转换（显式）：范围小的类型 变量名 = （范围小的类型）范围大的数据 -&gt; int num = (int) 100L;</p><p>​        精度损失、数据溢出</p></li><li><p>byte、short、char它们之间进行加减乘除的时候会自动转换为int类型</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">byte</span> <span class="variable">b1</span> <span class="operator">=</span> <span class="number">40</span>;</span><br><span class="line"><span class="type">byte</span> <span class="variable">b2</span> <span class="operator">=</span> <span class="number">40</span>;</span><br><span class="line"><span class="type">short</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="number">50</span>;</span><br><span class="line"><span class="type">char</span> <span class="variable">c1</span> <span class="operator">=</span> <span class="string">&#x27;A&#x27;</span></span><br><span class="line"><span class="type">int</span> <span class="variable">i1</span> <span class="operator">=</span> b1 + b2;</span><br><span class="line"><span class="type">int</span> <span class="variable">i2</span> <span class="operator">=</span> b1 + s1;</span><br><span class="line"><span class="type">int</span> <span class="variable">i3</span> <span class="operator">=</span> b1 + c1; <span class="comment">// =105</span></span><br></pre></td></tr></table></figure><h4 id="1-7-ASCII编码"><a href="#1-7-ASCII编码" class="headerlink" title="1.7 ASCII编码"></a>1.7 ASCII编码</h4></li></ul><p>​        (American Standard Code for Information Interchange,美国信息交换标准代码)        </p><p>​        码表：<a href="http://c.biancheng.net/c/ascii/">http://c.biancheng.net/c/ascii/</a></p><p>​        Unicode码表：万国码。数字和符号的对照关系，开头0-127和ASCII一样，从128开始有更多的字符</p><h4 id="1-8-运算符"><a href="#1-8-运算符" class="headerlink" title="1.8 运算符"></a>1.8 运算符</h4><ul><li>算数运算符：+、-、*、/、%(取模)、++、—</li></ul><p>​                    注：前++是先+1再被使用，后++是先使用再+1</p><ul><li><p>赋值运算符号：基本赋值运算符（=）、复合赋值运算符（+=、-=、*=、/=、%=）</p><pre><code>      注：复合赋值运算符含有强制转换</code></pre></li><li><p>比较运算符：==、&gt;、&lt;、&gt;=、&lt;=、!=</p></li><li><p>逻辑运算符：&amp;&amp;、||、!</p><pre><code>注：&amp;&amp;和||具有短路效应，若左边可以得到判断结果，则不执行右边，具有节省性能的作用</code></pre></li><li>三元运算符： 变量类型 = 条件判断 ？ 表达式A  : 表达式B;（true执行A，false执行B）</li></ul><h4 id="1-9-方法"><a href="#1-9-方法" class="headerlink" title="1.9 方法"></a>1.9 方法</h4><p>方法的定义：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> 方法名称()&#123;</span><br><span class="line">    方法体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法的调用：</p><p>​    <code>方法名称（参数）</code></p><h4 id="1-10-Jshell"><a href="#1-10-Jshell" class="headerlink" title="1.10 Jshell"></a>1.10 Jshell</h4><p>java 9更新</p><p>cmd -&gt; 输入jshell即可</p><h3 id="0704-二-结构及方法"><a href="#0704-二-结构及方法" class="headerlink" title="0704 二 结构及方法"></a>0704 二 结构及方法</h3><h4 id="2-1-顺序结构"><a href="#2-1-顺序结构" class="headerlink" title="2.1 顺序结构"></a>2.1 顺序结构</h4><h4 id="2-2-选择结构"><a href="#2-2-选择结构" class="headerlink" title="2.2 选择结构"></a>2.2 选择结构</h4><ul><li><p>if 语句</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(关系表达式<span class="number">1</span>)&#123;</span><br><span class="line">    语句体<span class="number">1</span>;</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(关系表达式<span class="number">2</span>)&#123;</span><br><span class="line">    语句体<span class="number">2</span>;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    语句体<span class="number">3</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ul><li>switch语句</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span>(表达式)&#123;</span><br><span class="line">     <span class="keyword">case</span> 常量<span class="number">1</span>:</span><br><span class="line">        语句体<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">     <span class="keyword">case</span> 常量<span class="number">2</span>:</span><br><span class="line">        语句体<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">     ...</span><br><span class="line">     <span class="keyword">default</span>:</span><br><span class="line">        语句体n+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>switch后面小括号当中只能是下列数据类型：</p><p>​        基本数据类型：byte/short/char/int</p><p>​        引用数据类型：String字符串、enum枚举</p><h4 id="2-3-循环结构"><a href="#2-3-循环结构" class="headerlink" title="2.3 循环结构"></a>2.3 循环结构</h4><ul><li>for循环</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(初始化语句;条件判断;步进语句)&#123;</span><br><span class="line">    循环体;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>while循环</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">初始化语句;</span><br><span class="line"><span class="keyword">while</span>(条件判断)&#123;</span><br><span class="line">    循环体;</span><br><span class="line">    步进语句;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>do-while循环</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">初始化语句;</span><br><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line">    循环体;</span><br><span class="line">    步进表达式;</span><br><span class="line">&#125;<span class="keyword">while</span>(条件判断);<span class="comment">//&lt;-------有一个分号 </span></span><br></pre></td></tr></table></figure><ul><li><p>三者的区别：</p><p>do-while 至少会执行一次，前两者可能执行0次就跳出;</p><p>for 循环的变量在括号内定义，出了循环不能使用，后两者出了循环还可以使用;</p><p>确定次数一般用for，否则一般用while，很少用do-while;</p></li></ul><h4 id="2-4-循环控制"><a href="#2-4-循环控制" class="headerlink" title="2.4 循环控制"></a>2.4 循环控制</h4><ul><li>break         直接结束整个循环</li><li>continue   立刻跳过当前循环，进行下一次循环</li></ul><h4 id="2-5-IDEA"><a href="#2-5-IDEA" class="headerlink" title="2.5 IDEA"></a>2.5 IDEA</h4><ul><li>项目结构：Project（项目）—-&gt;Module（模块）—-&gt;Package（包）</li><li>一些快捷键：<ul><li>alt+/ ：自动补全代码</li><li>alt+enter：自动修复代码</li><li>ctrl+Y：删一行</li><li>ctrl+D：加一行</li><li>ctrl+alt+L：格式化</li><li>ctrl+/：注释一行</li></ul></li><li>Debug<ul><li>f8：逐行执行</li><li>f7：进入方法中</li><li>shift+f8：跳出方法</li><li>f9跳到下一个断点</li><li>ctrl + f2：退出debug</li></ul></li></ul><h4 id="2-6-方法定义及调用及方法的重载"><a href="#2-6-方法定义及调用及方法的重载" class="headerlink" title="2.6 方法定义及调用及方法的重载"></a>2.6 方法定义及调用及方法的重载</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">修饰符 返回值类型 方法名称（参数类型 参数名称, ...)&#123;</span><br><span class="line">    方法体</span><br><span class="line">    <span class="keyword">return</span> 返回值;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>return的作用：停止当前方法；将返回值还给调用处</p><p>方法的三种调用方法：</p><ul><li>单独调用：方法名（参数）</li><li>打印调用：</li><li>赋值调用：数据类型 变量名称 = 方法名称（参数）;</li></ul><p>方法重载的情况</p><ul><li>方法的参数个数不同</li><li>方法的参数类型不同</li><li>参数的多类型顺序不同</li><li>注：方法重载与参数名称无关；与返回值类型无关</li></ul><h3 id="0705-三-数组、变量"><a href="#0705-三-数组、变量" class="headerlink" title="0705 三 数组、变量"></a>0705 三 数组、变量</h3><h4 id="3-1-数组简介"><a href="#3-1-数组简介" class="headerlink" title="3.1 数组简介"></a>3.1 数组简介</h4><ul><li><p>数组是一种容器，可以同时存放多个数据值</p></li><li><p>特点：是一种引用数据类型；数组之中的多个数据类型必须一致；数组的长度在程序运行期间不可改变。</p></li><li><p>数组的初始化</p><ul><li>动态初始化（指定长度）</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">数据类型[] 数组名称 = <span class="keyword">new</span> 数据类型[数组长度];</span><br></pre></td></tr></table></figure><ul><li>静态初始化（指定内容）</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">数据类型[] 数组名称 = <span class="keyword">new</span> 数据类型[]&#123;元素<span class="number">1</span>, 元素<span class="number">2</span>, ...&#125;;</span><br><span class="line">数据类型[] 数组名称 = &#123;元素<span class="number">1</span>, 元素<span class="number">2</span>, ...&#125;;<span class="comment">//也可以省略一些</span></span><br></pre></td></tr></table></figure></li><li><p>数组的访问：数组名称[索引];      &lt;—从0开始访问</p></li></ul><h4 id="3-2-JAVA内存划分"><a href="#3-2-JAVA内存划分" class="headerlink" title="3.2 JAVA内存划分"></a>3.2 JAVA内存划分</h4><ul><li><p>划分为5个部分：</p><ul><li><p>栈（stack）：存放方法的局部变量，一旦出了作用域立刻从栈中消失</p></li><li><p>堆（Heap）：凡是new出来的都在堆内存中，堆内存中都有一个地址值（16进制）</p><p>​            若为整数默认为0；浮点数默认为0.0；字符默认为’/u0000’；布尔默认为false；引用类型默认为null</p></li><li><p>方法区（Method Area）：储存.class相关信息，包含方法的信息</p></li><li><p>本地方法栈（Native Method Stack）：与操作系统相关</p></li><li><p>寄存器（pc Register）：与CPU相关</p></li></ul></li><li><p>一个数组的内存图</p></li></ul><p><img src="TyporaImg/javaSE笔记.assets/image-20220705111140801.png" alt="image-20220705111140801"></p><ul><li>两个引用指向同一个数组</li></ul><p><img src="TyporaImg/javaSE笔记.assets/image-20220705112141784.png" alt="image-20220705112141784"></p><h4 id="3-3-数组常见问题"><a href="#3-3-数组常见问题" class="headerlink" title="3.3 数组常见问题"></a>3.3 数组常见问题</h4><ul><li>索引越界 —&gt; ArrayIndexOutOfBoundsException </li><li>空指针异常 —&gt; NullPointException —&gt; 创建数组的时候补上new</li></ul><h4 id="3-4-数组常用"><a href="#3-4-数组常用" class="headerlink" title="3.4 数组常用"></a>3.4 数组常用</h4><ul><li><p>获取数组长度 ：<code>数组名称.length</code>  数组一但创建，长度不可改变</p></li><li><p>遍历数组：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; array.length;i++)&#123;</span><br><span class="line">    数组操作</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>idea里面可以直接array.fori</p></li></ul><h4 id="3-5-面向对象的思想"><a href="#3-5-面向对象的思想" class="headerlink" title="3.5 面向对象的思想"></a>3.5 面向对象的思想</h4><ul><li><p>类与对象：对象是类的实体，类是对象的模板 </p></li><li><p>类的定义：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClassName</span>&#123;</span><br><span class="line">    <span class="comment">//成员变量</span></span><br><span class="line">    <span class="comment">//类方法，成员方法没有static</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注：成员变量直接定义在类当中，在方法外面；</p><p>​        成员方法不要写static关键字（加了static后作用域只能用于代码本身了）。</p></li><li><p>一个对象的内存图</p><p><img src="TyporaImg/javaSE笔记.assets/image-20220705125914306.png" alt="image-20220705125914306"></p></li><li><p>两个引用指向一个对象的内存图</p><p><img src="TyporaImg/javaSE笔记.assets/image-20220705130722445.png" alt="image-20220705130722445"></p></li><li><p>使用对象类型作为方法的参数</p><p><img src="TyporaImg/javaSE笔记.assets/image-20220705131811594.png" alt="image-20220705131811594"></p><p>注意：当对象作为参数输入的时候，传递的是一个地址值，所以在方法内修改</p></li><li><p>使用对象类型作为方法的返回值</p><p><img src="TyporaImg/javaSE笔记.assets/image-20220705132352427.png" alt="image-20220705132352427"></p><p>注意：当一个对象作为方法的返回值的时候，返回值其实是对象的地址值</p></li></ul><h4 id="3-6-局部变量和成员变量"><a href="#3-6-局部变量和成员变量" class="headerlink" title="3.6 局部变量和成员变量"></a>3.6 局部变量和成员变量</h4><ul><li>定义位置不一样。局部变量在方法内部定义，成员变量在外部定义；                       </li><li>作用范围不一样。局部变量出了方法就不能用了，成员变量在整个类通用； </li><li>默认值不一样。局部变量无默认值，成员变量有，规则和数组一样；<ul><li>内存位置不一样。局部变量在栈中，成员变量在堆中；</li></ul></li><li>生命周期不一样。局部变量随着方法进栈诞生，随着方法出栈消失，成员变量随着对象创建诞生，随着对象被垃圾回收而消失。</li></ul><h4 id="3-7-面向对象的三大特性"><a href="#3-7-面向对象的三大特性" class="headerlink" title="3.7 面向对象的三大特性"></a>3.7 面向对象的三大特性</h4><ul><li>封装：方法就是一种封装；private也是一种封装</li><li>继承：继承是多态的前提，没有继承就没有多态</li><li>多态</li></ul><h4 id="3-8-private和this关键字"><a href="#3-8-private和this关键字" class="headerlink" title="3.8 private和this关键字"></a>3.8 private和this关键字</h4><ul><li><p>使用了private修饰，本类之外就不能直接访问了（定义getset方法可以间接访问）</p></li><li><p>当方法的局部变量和类的成员变量重名的时候，根据就就近原则，优先使用局部变量</p><p>所以当要访问本类中的成员变量，需要使用this关键字：<code>this.成员变量名</code></p><p>注：谁调用方法，谁就是this</p></li></ul><h4 id="3-9-构造方法"><a href="#3-9-构造方法" class="headerlink" title="3.9 构造方法"></a>3.9 构造方法</h4><ul><li><p>用于创建对象，当使用new创建对象的时候，就是在调用构造方法</p><p><code>public 类名称(参数类型 参数名称)&#123;方法体&#125;</code></p></li><li><p>注：</p><ul><li>构造方法名称必须和所在的类名称完全一样包括大小写</li><li>无返回值，也不写void</li><li>构造方法不能return</li><li>如果没有构造方法，则编译器会自动生成一个构造方法，没有参数什么也不做</li><li>一旦编写了至少一个构造方法，则编译器不自动生成构造方法</li><li>构造方法可以进行重载</li></ul></li></ul><h4 id="3-10-定义一个标准的类"><a href="#3-10-定义一个标准的类" class="headerlink" title="3.10 定义一个标准的类"></a>3.10 定义一个标准的类</h4><ul><li>所用成员变量都用private修饰</li><li>为每一个成员变量编写一对getter/setter方法</li><li>编写一个无参数构造方法</li><li>编写一个全参数构造方法</li></ul><p>这样一个标准的类也叫Java Bean</p><h3 id="0706-四-对象、字符串"><a href="#0706-四-对象、字符串" class="headerlink" title="0706 四 对象、字符串"></a>0706 四 对象、字符串</h3><h4 id="4-1-API"><a href="#4-1-API" class="headerlink" title="4.1 API"></a>4.1 API</h4><ul><li>Application Programming Interface</li><li>引用类的步骤：导包-&gt;创建-&gt;使用     同一个包下不需要导包，java.lang目录下也不需要导包</li><li><u><em>Scanner练习：day0705/Scanner_test.java</em></u>：键盘输入两数字求和</li></ul><h4 id="4-2-匿名对象"><a href="#4-2-匿名对象" class="headerlink" title="4.2 匿名对象"></a>4.2 匿名对象</h4><ul><li>匿名对象就是只有右边的对象，没有左边的名字和赋值运算符 </li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Person</span>().name = <span class="string">&quot;jack&quot;</span>  <span class="comment">//标准的是 Person p = new Person()，然后再调用.name()方法</span></span><br></pre></td></tr></table></figure><ul><li>匿名对象只能使用唯一的一次，下次再用不得不再创建一个新的对象</li><li>使用建议：如果确定有一个对象只需要使用唯一的一次，就可以创建匿名对象</li><li>匿名对象作为方法参数和返回值</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">method(<span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in));<span class="comment">//System.in为InputStream类</span></span><br></pre></td></tr></table></figure><h4 id="4-3-Random类"><a href="#4-3-Random类" class="headerlink" title="4.3 Random类"></a>4.3 Random类</h4><h4 id="4-4-对象数组与ArrayList"><a href="#4-4-对象数组与ArrayList" class="headerlink" title="4.4 对象数组与ArrayList"></a>4.4 对象数组与ArrayList</h4><ul><li>ArrayList的长度可以改变而数组长度不能改变</li><li>ArrayList有一个<E>表示泛型，泛型只能是引用类型，不能是基本类型（因为基本数据类型没有地址值），如果要用到基本数据类型，可以用它对应的包装类</li><li>对于ArrayList打印的是内容而不是地址值</li><li>常用方法：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span>;</span><br><span class="line"><span class="keyword">public</span> E <span class="title function_">get</span><span class="params">(<span class="type">int</span> index)</span>;</span><br><span class="line"><span class="keyword">public</span> E <span class="title function_">remove</span><span class="params">(<span class="type">int</span> index)</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span></span><br></pre></td></tr></table></figure><ul><li><u><em>ArrayList练习：day0705/ArrayList_test.java</em></u></li></ul><h4 id="4-5-字符串"><a href="#4-5-字符串" class="headerlink" title="4.5 字符串"></a>4.5 字符串</h4><ul><li><p>字符串特点：</p><ul><li>字符串内容永不可改变（一些看起来修改了字符串的方法其实是相当于创建了一个新的字符串）</li><li>正因为不可改变，所以字符串是可以共享的</li><li>字符串效果上相当于是char[]字符数组，但是底层原理是byte[]字节数组</li></ul></li><li><p>字符串的创建（常见3+1种）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>();<span class="comment">//创建空白字符串，不含内容</span></span><br><span class="line"><span class="type">char</span>[] array1 = &#123;<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;C&#x27;</span>&#125;;</span><br><span class="line"><span class="type">byte</span>[] array2 = &#123;<span class="number">97</span>, <span class="number">98</span>, <span class="number">99</span>&#125;;</span><br><span class="line"><span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="type">char</span>[] array1);<span class="comment">//根据字符数组创建对应的字符串</span></span><br><span class="line"><span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="type">byte</span>[] array2);<span class="comment">//根据字节数组的内容创建对应字符串--&gt;是abc</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>;<span class="comment">//直接创建，虽然没有new，但是它也是字符串对象</span></span><br></pre></td></tr></table></figure></li><li><p>字符串的常量池：程序中直接写上的双引号字符串，就在字符串常量池中。（在堆中）</p><ul><li>对于引用类型，==是地址值的比较，对于基本类型，==是数值的比较</li></ul></li></ul><p><img src="TyporaImg/javaSE笔记.assets/image-20220706135822547.png" alt="image-20220706135822547"></p><ul><li><p>字符串的比较相关方法</p><ul><li><p>==是对地址值的比较，如果要进行内容的比较，用</p><p><code>public boolean equals(Object obj)</code></p><p>推荐<code>&quot;abc&quot;.equals(str)</code>而不是<code>str.equals(&quot;abc&quot;)</code>（常量放前面变量放后面防止空指针异常）</p></li><li><p><code>public int length()</code></p></li><li><p><code>public String concat(String str)</code>拼接</p></li><li><p><code>public char charAt(int index)</code>获取指定索引位置的单个字符串</p></li><li><p><code>public int indexOf(String str)</code>查找字符串首次出现的索引位置，若没有则返回-1</p></li><li><p><code>public String subString(int index)</code>;<code>public String subStirng(int begin, int end)</code>截取index之后的字符串以及[begin,end)的字符串</p></li></ul></li><li><p>字符串的相关转换方法</p><ul><li><code>public char[] toCharArray()</code>将当前字符串拆分为字符数组作为返回值</li><li><code>public byte[] getBytes()</code>获得当前字符串底层的字节数组（IO流中用较多）</li><li><code>public String replace(CharSequence oldString, CharSequence newString)</code>将所有出现的老字符串替换为新字符串，返回替换之后的结果新字符串</li></ul></li><li><p>字符串的分割</p><ul><li><code>public String[] split(String regex)</code>按照参数的规则，将字符串切分为若干部分</li><li>注：split方法的参数其实是一个正则表达式，若要按照英文的”.”分，应该写”//.”</li></ul></li></ul><h4 id="4-5-static关键字"><a href="#4-5-static关键字" class="headerlink" title="4.5 static关键字"></a>4.5 static关键字</h4><ul><li><p>一旦使用了static关键字，那么这样的内容不再属于对象自己，而属于类，凡是本类的对象，都共享同一份</p></li><li><p>static修饰成员变量</p><ul><li>多个对象共享，如果有一个对象改变了这个变量，则全部对象的这个变量都会改变</li></ul></li><li><p>static修饰方法，一旦修饰了就为静态方法</p><ul><li><p>如果没有static关键字，必须创建对象然后通过对象使用</p></li><li><p>对于静态方法来说，可以通过对象名调用（不推荐），也可以直接通过类名来调用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Myclass</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Myclass</span>();</span><br><span class="line">obj.method.Static();<span class="comment">//通过对象名调用方法（编译之后也会被javac翻译为类名.静态方法）</span></span><br><span class="line">Myclass.methodStatic();<span class="comment">//直接通过类名来调用方法</span></span><br></pre></td></tr></table></figure></li><li><p>无论是成员变量还是成员方法，若有了static，都推荐使用类名称调用</p></li><li><p>对于本类的静态方法，可以省略类名称</p></li><li><p>注意：</p><ol><li>静态不能直接访问非静态。（原因：在内存中先有静态，后有的非静态）</li><li>静态方法不能使用this关键字。（因为静态是直接通过类名调用的）</li></ol></li></ul></li><li><p>静态static的内存图</p><p><img src="TyporaImg/javaSE笔记.assets/image-20220706144028767.png" alt="image-20220706144028767"></p></li><li><p>静态代码块</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> class 类名称()&#123;</span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        <span class="comment">//静态代码块内容</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>当第一次用到本类的时候，静态代码块执行唯一的一次 </li><li>由于静态总是优先于非静态执行，所以静态代码块比构造方法先执行</li><li>典型用途：一次性对静态成员变量进行赋值</li></ul></li></ul><h4 id="4-6-数组工具类-Arrays"><a href="#4-6-数组工具类-Arrays" class="headerlink" title="4.6 数组工具类 Arrays"></a>4.6 数组工具类 Arrays</h4><ul><li>java.util.Arrays是一个与数组相关的工具类，里面提供了大量的静态方法，用于实现数组的常见操作</li><li><code>public static String toString(数组)</code>：将参数变为字符串（按默认格式：[元素1，元素2，元素3，…]）</li><li><code>public static void sort(数组)</code>：升序排列 <ul><li>如果是数字，升序</li><li>如果是字符串，默认字母升序</li><li>如果是自定义类型，则这个自定义类型需要有Comparable或者Comparator接口的支持</li></ul></li><li><u><em>Arrays练习：day0706/Arrays_test.java</em></u>：对随机字符串进行升序排序并倒序打印</li></ul><h4 id="4-7-Math类"><a href="#4-7-Math类" class="headerlink" title="4.7 Math类"></a>4.7 Math类</h4><p>常见方法</p><ul><li><code>public static double abs(double num)</code>绝对值</li><li><code>public static double ceil(double num)</code>向上取整（floor为向下取整）</li><li><code>public static long round(double num)</code>四舍五入</li><li><code>Math.PI</code></li><li><u><em>Math练习：day0706/Math_test.java</em></u>：计算两个数之间的整数个数</li></ul><h3 id="0707-五-继承、抽象、接口、多态"><a href="#0707-五-继承、抽象、接口、多态" class="headerlink" title="0707 五 继承、抽象、接口、多态"></a>0707 五 继承、抽象、接口、多态</h3><h4 id="5-1-继承"><a href="#5-1-继承" class="headerlink" title="5.1 继承"></a>5.1 继承</h4><ul><li><p>共性抽取，父类也叫基类、超类，子类也可以叫派生类</p></li><li><p>定义父类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> class 父类名称()&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义子类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> class 子类名称 extends 父类名称()&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>继承中成员变量的特点：在父子类继承关系中，如果成员变量重名，则创建子类对象的时候，有两种访问方法：</p><ul><li>直接通过子类对象访问（等号左边是谁则优先是谁，没有则向上找——优先子类的变量）</li><li>间接通过成员方法访问（方法属于谁，就优先用谁，没有则向上找——优先本类的变量）</li></ul></li><li><p>区分子类方法中重名的三种变量</p><ol><li>局部变量：直接写</li><li>本类的成员变量：this.成员变量名</li><li>父类的成员变量：super.成员变量名</li></ol></li><li><p>继承中成员方法的访问特点：</p><p>在父子类继承关系中，创建子类对象，访问成员方法的规则：创建的对象是谁，就优先用谁，没有则向上找</p></li><li><p>继承中方法的重写(覆盖/覆写)：继承中方法的名称一样，参数列表也一样</p><ul><li><p>重写(override):方法名称、参数列表都一样；重载(Overload):方法名称一样、参数列表不一样</p></li><li><p>创建的子类对象，则优先用子类的方法</p></li><li><p>注意事项：</p><ul><li><p>必须保证父子类方法的名称相同，参数列表相同。</p><p><code>@Override</code>写在方法前面，用来检验是不是有效的正确覆盖重写（也可以不写）</p></li><li><p>子类方法的返回值必须小于等于父类方法的返回值范围（比如父类为object，子类可以为String）</p></li><li><p>子类方法的权限必须大于等于父类方法的权限修饰符</p><p>public &gt; protected &gt; (default) &gt; private   （default代表什么都不写）</p></li></ul></li></ul></li><li><p>设计原则：对于已经使用的类，尽量不去修改，而是写一个新类，即继承</p></li><li><p>继承中构造方法的访问特点：</p><ul><li><p>子类构造方法中有一个默认的super()调用，所以一定是先调用父类的构造，再调用子类的构造</p></li><li><p>子类构造方法必须调用父类的构造方法，不写则默认super()</p></li><li><p>子类构造可以通过super()关键字来调用父类重载构造</p></li><li><p>super的父类构造调用，必须是子类构造方法的第一个语句</p></li></ul></li><li><p>继承的三大特点：</p><ul><li>单继承：只有一个父类</li><li>多级继承</li><li>一个父类可以有多个子类</li></ul></li></ul><h4 id="5-2-super、this关键字"><a href="#5-2-super、this关键字" class="headerlink" title="5.2 super、this关键字"></a>5.2 super、this关键字</h4><ul><li><p>super关键字</p><ul><li>在子类的成员方法中，访问父类的成员变量</li><li>在子类的成员方法中，访问父类的成员方法</li><li>在子类的构造方法中，方法父类的构造方法</li></ul></li><li><p>this关键字</p><ul><li>在本类的成员方法中，访问本类的成员变量</li><li>在本类的成员方法中，访问本类另一个成员方法（不能是构造方法！）</li><li>在本类的构造方法中，访问本类的另一个构造方法（此时this的调用也必须是构造方法的第一个语句，所以super和this不能同时使用）</li></ul></li><li><p>super、this图解</p><p><img src="TyporaImg/javaSE笔记.assets/image-20220707112203251.png" alt="image-20220707112203251"></p></li></ul><h4 id="5-3-抽象"><a href="#5-3-抽象" class="headerlink" title="5.3 抽象"></a>5.3 抽象</h4><ul><li><p>抽象方法：加上abstract关键字，然后去掉大括号，直接分号结束</p><p>抽象方法所在的类必须是抽象类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Animal</span>&#123;<span class="comment">//抽象类定义</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>;<span class="comment">//抽象方法定义</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">normalMethod</span><span class="params">()</span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>如何使用抽象方法：</p><ol><li>不能直接创建抽象类对象</li><li>必须用一个子类来继承抽象父类</li><li>覆盖重写(实现)：去掉abstract关键字，然后补上大括号</li><li>创建子类进行使用</li></ol></li><li><p>注意事项：</p><ul><li>抽象类不能直接创建对象</li><li>抽象类中可以有构造方法，初是提供子类创建对象时，始化父类成员使用的</li><li>抽象类中，不一定有抽象方法，但是有抽象方法的类必定是抽象类</li><li>抽象类的子类，必须重写抽象父类中所有的抽象方法，否则编译无法通过，否则该子类也是抽象类，也要用abstract修饰</li></ul></li><li><p><u><em>抽象练习：day0707/MainRedPacket.java</em></u>：发红包案例</p></li></ul><h4 id="5-4-接口"><a href="#5-4-接口" class="headerlink" title="5.4 接口"></a>5.4 接口</h4><ul><li><p>接口：一种公共的规范标准，引用数据类型，最重要的内容就是其中的抽象方法</p></li><li><p>接口的定义:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> interface 接口名称&#123;</span><br><span class="line">    <span class="comment">//接口内容</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注：换成了关键字interface之后，编译生成的字节码文件仍然是：.java —-&gt; .class</p><p>接口可以包含：</p><ol><li>常量(java 7)</li><li>抽象方法(java 7)</li><li>默认方法(java 8)</li><li>静态方法(java 8)</li><li>私有方法(java 9)</li></ol></li><li><p>接口的抽象方法定义</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> 返回值类型 方法名称(参数列表);</span><br></pre></td></tr></table></figure><p>注：修饰符必须是 public和abstract，这两者可以省略但不能改变</p></li><li><p>接口的使用：接口不能直接使用，必须有一个“实现类”来“实现”：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> class 实现类名称 implements 接口名称&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注：接口中的抽象方法必须全部覆盖重写，创建实现类对象再使用</p><p>​        若没有覆盖全部的抽象方法，则该类也必须为抽象方法</p></li><li><p>接口默认方法的定义与使用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">default</span> 返回值类型 方法名称(参数列表)&#123;</span><br><span class="line">    方法体;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注：接口中的默认方法可以解决接口升级的问题（当接口中新加了抽象方法后，之前定义的实现类还需要 一一更改，默认方法可以防止这样的情况产生）</p><ul><li>接口的默认方法可以通过接口的实现类直接调用</li><li>接口的默认方法也可以被接口的实现类覆盖重写</li></ul></li><li><p>接口静态方法的定义与使用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> 返回值类 方法名称(参数列表)&#123;</span><br><span class="line">    方法体;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注：</p><ul><li>不能通过接口实现类的对象来调用接口当中的静态方法</li><li>正确用法：通过接口的名称直接调用静态方法，格式：<code>接口名称.静态方法名(参数)</code></li></ul></li><li><p>接口私有方法的定义和使用</p><ul><li>普通私有方法：解决多个默认方法之间的重复代码问题</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> 返回值类型 方法名称(参数列表)&#123;</span><br><span class="line">    方法体;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>静态私有方法：解决多个静态方法之间的重复代码问题</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> 返回值类型 方法名称(参数列表)&#123;</span><br><span class="line">    方法体;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>接口常量的定义和使用</p><ul><li><p>定义:<code>public static final 数据类型 常量名称 = 数据值;</code></p></li><li><p>注:</p><ul><li>可以省略<code>public static final</code>但是不写效果也一样</li><li>必须进行赋值,且不可改</li><li>常量名称全用大写</li></ul></li></ul></li><li><p>接口使用注意事项:</p><ul><li>接口没有静态代码块或者构造方法</li><li>一个类的直接父类是唯一的,但是一个类可以同时实现多个接口</li></ul></li></ul><h4 id="5-5-继承父类并实现多个接口"><a href="#5-5-继承父类并实现多个接口" class="headerlink" title="5.5 继承父类并实现多个接口"></a>5.5 继承父类并实现多个接口</h4><ul><li>格式:</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> class 类名称 extends 父名称 implements 接口<span class="number">1</span>,接口<span class="number">2</span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>注:<ul><li>如果多个接口中出现了同名的抽象方法,则只需要重写一个就好了</li><li>如果实现类没有覆盖重写所有接口的所有抽象方法,则该类必须是抽象类</li><li>如果实现类所实现的多个接口中,存在重复的默认方法,则该实现类一定要对冲突的默认方法进行重写</li><li>一个类如果直接父类当中的方法和接口中的默认方法产生冲突,则优先用父类当中的方法</li></ul></li></ul><h4 id="5-6-接口之间的多继承"><a href="#5-6-接口之间的多继承" class="headerlink" title="5.6 接口之间的多继承"></a>5.6 接口之间的多继承</h4><ul><li><p>类与类单继承的,直接父类就一个;</p><p>类与接口之间是多实现的,一个类可以实现多个接口;</p><p>接口与接口之间是多继承的</p></li><li><p>多个父接口的方法重复,没关系</p><p>多个父接口的默认方法重复,那么子接口必须进行默认方法的覆盖重写,而且要带着default关键字</p></li></ul><h4 id="5-7-多态"><a href="#5-7-多态" class="headerlink" title="5.7 多态"></a>5.7 多态</h4><ul><li>指一个对象拥有多种形态</li><li>多态存在的三个必要条件：<ul><li>继承</li><li>重写</li><li>父类引用指向子类对象</li></ul></li></ul><ul><li><p>实现:extends或者implements实现是多态的前提</p></li><li><p>代码当中体现多态性:<strong>父类引用指向子类对象</strong> 格式:</p><p><code>父类名称 对象名 = new 子类名称();</code>(一只猫被当作动物来看待)</p><p>或者<code>接口名称 对象名 = new 实现类名称();</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Fu</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Zi</span>();</span><br><span class="line">obj.Method();<span class="comment">//优先使用Zi中的Method(new什么优先用哪个),子类没有则向上找&lt;----前提：子类和父类都有Method这个方法，如果子类特有的方法则不能这样写，需要向下转型</span></span><br></pre></td></tr></table></figure></li><li><p>多态中成员变量的使用:</p><ul><li>成员变量通过对象名称直接访问:看等号左边是谁,优先用谁,没有则向上找</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Fu</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Zi</span>();</span><br><span class="line">obj.num;<span class="comment">//优先使用Fu中的num,没有则向上找</span></span><br></pre></td></tr></table></figure><ul><li>成员变量通过成员方法间接访问:看该方法属于谁,优先用谁</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Fu</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Zi</span>();</span><br><span class="line">obj.shownum();<span class="comment">//优先使用Zi中的shownum()方法,没有则向上找</span></span><br></pre></td></tr></table></figure></li><li><p>多态中成员方法的使用规则:</p><p>​            看new的是谁,则使用谁,没有则向上找,但是这个方法必须是子类和父类都有,若要使用子类特有的方法则需要向下转型.</p><ul><li><p><u>在这个引用变量f指向的对象中，他的成员变量和静态方法与父类是一致的，他的非静态方法，在编译时是与父类一致的，运行时却与子类一致（发生了复写）</u>(编译看左,运行看右)</p></li><li><blockquote><p><u><strong>就是说，方法和成员变量都用当作父类来用，如果子类有复写的方法则用子类的方法</strong></u></p></blockquote></li><li><p><strong>成员变量：</strong>编译看左边，运行还看左边。</p></li><li><p><strong>成员方法：</strong>编译看左边，运行看右边</p></li></ul></li><li><p>多态的好处</p></li><li><p>多态的弊端：无法使用子类特有的方法和属性</p></li></ul><h4 id="5-8-对象的转型"><a href="#5-8-对象的转型" class="headerlink" title="5.8 对象的转型"></a>5.8 对象的转型</h4><ul><li><p>向上转型:即多态的写法</p><p><code>父类名称 对象名 = new 子类名称();</code></p><p>含义:右侧创建一个子类对象,当作父类来使用(一只猫被当作动物来看待)</p><p>注:</p><ul><li>向上转型一定是安全的(小范围转向了大范围)</li></ul></li><li><p>向下转型:其实是一个还原的动作<br><code>子类名称 对象名 = (子类名称)父类对象</code>(将猫从动物还原为猫)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Animal</span> <span class="variable">animal</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cat</span>();</span><br><span class="line"><span class="type">Cat</span> <span class="variable">cat</span> <span class="operator">=</span> (Cat)animal;</span><br></pre></td></tr></table></figure><p>注:</p><ul><li>必须保证原来本来创建的时候是猫,才能向下转为猫</li><li>如果原来创建的时候不是猫,向下转为狗则为报错 ———-&gt; ClassCastException</li></ul></li><li><p>用instanceof关键字进行类型判断</p><p><code>对象 instanceof 类名称</code>(返回boolean)</p></li></ul><h4 id="5-9-接口多态练习"><a href="#5-9-接口多态练习" class="headerlink" title="5.9 接口多态练习"></a>5.9 接口多态练习</h4><p><u><em>接口多态练习：day0707/Multi_Interface</em></u>：笔记本USB接口案例</p><p><img src="TyporaImg/javaSE笔记.assets/image-20220707151954672.png" alt="image-20220707151954672"></p><h3 id="0708-六"><a href="#0708-六" class="headerlink" title="0708 六"></a>0708 六</h3><h4 id="6-1-final关键字"><a href="#6-1-final关键字" class="headerlink" title="6.1 final关键字"></a>6.1 final关键字</h4><ul><li><p>用法：</p><ol><li><p>修饰类 <code>public final class 类名&#123;&#125;</code></p><ul><li>不能有子类，所有的成员方法无法进行覆盖重写</li></ul></li><li><p>修饰方法 <code>public final 返回值类型 方法名()&#123;&#125;</code></p><ul><li>该方法不能被覆盖重写</li></ul></li><li><p>修饰局部变量 <code>final 变量类型 变量名;</code></p><ul><li>一次赋值，终生不变(如果为引用类型则是名字指向的地址值不变)</li></ul></li><li><p>修饰成员变量 <code>public final 变量名 = 值;</code></p><ul><li>由于成员变量会有默认值，所有一旦使用了final修饰，就必须手动赋值</li><li>对于final成员变量，要么直接赋值，要么通过构造方法赋值（只能使用一种）</li><li>若使用第二种方法，必须保证类中所有重载的构造方法会对final成员变量赋值</li></ul></li></ol></li><li><p>对于类和方法来说，fianl和abstract不能同时使用</p></li></ul><h4 id="6-2-四种权限修饰符"><a href="#6-2-四种权限修饰符" class="headerlink" title="6.2 四种权限修饰符"></a>6.2 四种权限修饰符</h4><div class="table-container"><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">PUBLIC</th><th style="text-align:center">protected</th><th style="text-align:center">(default)</th><th style="text-align:center">private</th></tr></thead><tbody><tr><td style="text-align:center">同一个类</td><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">同一个包</td><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:center">0</td></tr><tr><td style="text-align:center">不同包子类</td><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:center">0</td><td style="text-align:center">0</td></tr><tr><td style="text-align:center">不同包非子类</td><td style="text-align:center">1</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td></tr></tbody></table></div><h4 id="6-3-内部类"><a href="#6-3-内部类" class="headerlink" title="6.3 内部类"></a>6.3 内部类</h4><p>​                一个事物内部包含另一个事物</p><ul><li><p>成员内部类</p><ul><li><p>定义格式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">修饰符 class 外部类名称&#123;</span><br><span class="line">    修饰符 class 内部类&#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>注：内用外随意，外用内需要内部类对象</p></li><li><p>成员内部类的使用</p><ul><li>间接方式：在外部类中的方法中，使用内部类；然后main只是调用外部类方法</li><li>直接方式：<code>外部类名.内部类名 对象名 = new 外部类名().new 内部类名();</code></li></ul></li><li><p>内部类访问同名变量</p><p>​    <code>外部类名称.this.外部类成员变量</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Outer</span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Inner</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">methodInner</span><span class="params">()</span>&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">30</span>;</span><br><span class="line">            System.out.println(num);<span class="comment">//30</span></span><br><span class="line">            System.out.println(<span class="built_in">this</span>.num);<span class="comment">//20</span></span><br><span class="line">            System.out.println(Outer.<span class="built_in">this</span>.num);<span class="comment">//10</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><ul><li><p>局部内部类（包含匿名内部类）（在方法里面）</p><ul><li><p>定义格式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">修饰符 class 外部类名称&#123;</span><br><span class="line">    修饰符 返回值类型 外部类方法名称(参数列表)&#123;</span><br><span class="line">        class 局部内部类名称&#123;</span><br><span class="line">            <span class="comment">//...</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>局部内部类的final问题</p><ul><li><p>如果希望访问所在方法的局部变量，那么这个变量必须是有效final的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyOuter</span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">menthodOuter</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">10</span>;<span class="comment">//final可以不写，但要保证num不变</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">class</span> <span class="title class_">MyInnter</span>&#123;</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">methodinter</span><span class="params">()</span>&#123;</span><br><span class="line">                sout(num);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>注：从java 8开始，只要局部变量事实不变，那么final关键字可以省略</p></li><li><p>原因：</p><ol><li>new出来的对象在堆中</li><li>局部变量跟着方法走，在栈中 </li><li>方法运行结束后立刻出栈，局部变量立刻消失</li><li>但是new出来的对象在堆中持续存在直到垃圾回收</li></ol></li></ul></li></ul></li><li><p>定义一个类的时候，权限修饰符</p><ul><li>外部类：public/(default)</li><li>成员内部类：所有</li><li>局部内部类：什么都不能写（和default不一样）</li></ul></li><li><p>匿名内部类：如果接口的实现类（或者是父类的子类，只需要使用唯一的一次，那么这种情况下就可以省略掉该类的定义，而改为使用匿名内部类</p><ul><li><p>定义格式：</p><ul><li><p>```java<br>接口名称 对象名 = new 接口名称(){</p><pre><code>//覆盖重写所有的抽象方法;</code></pre><p>}</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">```java</span><br><span class="line">public class test &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        MyInterface my = new MyInterface() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void method() &#123;</span><br><span class="line">                System.out.println(&quot;匿名内部类&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;//单独使用匿名内部类</span><br><span class="line">        </span><br><span class="line">        my.method();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">MyInterface</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;匿名内部类&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.method();<span class="comment">//匿名内部类和匿名对象一起使用</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>注意：匿名内部类在创建对象的时候，只使用唯一的一次</p><p>​            匿名对象在调用方法的时候，只能使用一次</p><p>​            匿名内部类是省略了实现类/子类名称，匿名对象是省略了对象名称</p></li></ul></li></ul><h4 id="6-4-类作为成员变量类型"><a href="#6-4-类作为成员变量类型" class="headerlink" title="6.4 类作为成员变量类型"></a>6.4 类作为成员变量类型</h4><h4 id="6-5-接口作为成员变量类型、方法的参数或返回值"><a href="#6-5-接口作为成员变量类型、方法的参数或返回值" class="headerlink" title="6.5 接口作为成员变量类型、方法的参数或返回值"></a>6.5 接口作为成员变量类型、方法的参数或返回值</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DEMO</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//左边接口名称，右边实现类，这就是多态写法</span></span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        List&lt;String&gt; result = addNames(list);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; result.size(); i++) &#123;</span><br><span class="line">            System.out.println(result.get(i));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title function_">addNames</span><span class="params">(List&lt;String&gt; list)</span> &#123;</span><br><span class="line">        list.add(<span class="string">&quot;1111&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="0711-七-常用类"><a href="#0711-七-常用类" class="headerlink" title="0711 七 常用类"></a>0711 七 常用类</h3><h4 id="7-1-Object类"><a href="#7-1-Object类" class="headerlink" title="7.1 Object类"></a>7.1 Object类</h4><ul><li><p>java.lang.Object</p><p>Object是类层次结构的根（父）类</p><p>每个类都使用Object作为父类</p><p>所有对象都实现这个类的方法</p></li><li><p>toString()方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">       <span class="keyword">return</span> getClass().getName() + <span class="string">&quot;@&quot;</span> + Integer.toHexString(hashCode());</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li><li><p>equals()方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object obj)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="built_in">this</span> == obj);<span class="comment">//谁调用了equals方法，谁就是this</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>基本数据类型比较的是值，引用数据类型比较的是地址</p><p>重写eqals方法，问题：</p><ul><li><p>隐含一个多态，无法使用子类特有的内容（方法和属性）<code>Object ob = new Person(&quot;张三&quot;, 19);</code></p></li><li><p>解决方法：使用向下转型，将Object转为Person</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object obj)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(obj == <span class="built_in">this</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;<span class="comment">//提高效率</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(obj == <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//提高效率</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//Person p = (Person)obj;//直接转换有风险</span></span><br><span class="line">    <span class="keyword">if</span>(obj <span class="keyword">instanceof</span> Person)&#123;</span><br><span class="line">        <span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> (Person)obj;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">b</span> <span class="operator">=</span> <span class="built_in">this</span>.name.eauqls(p.name) &amp;&amp; <span class="built_in">this</span>.age.equals(p.age);</span><br><span class="line">    <span class="keyword">return</span> b;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h4 id="7-2-Date类"><a href="#7-2-Date类" class="headerlink" title="7.2 Date类"></a>7.2 Date类</h4><p>java.util.Date：表示日期和时间</p><p>时间原点：1970.1.1 00:00:00</p><p>DateFormat：格式化的日期的抽象类（抽象类），作用：格式化和解析日期</p><ul><li><p>DateFormat为抽象类，无法直接创建，需要使用它的子类</p></li><li><p>SimpleDateFormat的构造方法：<code>`SimpleDateFormat(String pattern)</code> `</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">SimpleDateFormat</span> <span class="variable">sdf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd HH-mm-ss&quot;</span>);</span><br><span class="line"><span class="type">Date</span> <span class="variable">date</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">date</span>();</span><br><span class="line"><span class="type">String</span> <span class="variable">d</span> <span class="operator">=</span> sdf.format(date);</span><br><span class="line">sout(d);</span><br></pre></td></tr></table></figure></li></ul><h4 id="7-3-Calendar类"><a href="#7-3-Calendar类" class="headerlink" title="7.3 Calendar类"></a>7.3 Calendar类</h4><p>java.util.Calendar类不能直接创建使用（抽象类），里面提供了很多操作日历字段的方法</p><p>里面有一个静态方法叫getInstance()，该方法返回了一个Calendar类的子类对象</p><p><code>static Calendar getInstance()</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Calendar</span> <span class="variable">c</span> <span class="operator">=</span> Calendar.getInstance();<span class="comment">//多态</span></span><br><span class="line">sout(c);</span><br></pre></td></tr></table></figure><p>常用方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">get</span><span class="params">(<span class="type">int</span> field)</span>;<span class="comment">//返回给定的日历字段值</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(ine field, <span class="type">int</span> value)</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> field, <span class="type">int</span> amount()</span>);<span class="comment">//增加或者减少指定的时间量</span></span><br><span class="line"><span class="keyword">public</span> Date <span class="title function_">getTime</span><span class="params">()</span>;<span class="comment">//日历转换为日期</span></span><br></pre></td></tr></table></figure><h4 id="7-4-System类"><a href="#7-4-System类" class="headerlink" title="7.4 System类"></a>7.4 System类</h4><p> (java.lang包下无需导包，直接使用)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">long</span> <span class="title function_">currentTimeMillis</span><span class="params">()</span>;<span class="comment">//返回以毫秒为单位的时间，用于测试程序效率</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">arraycopy</span><span class="params">(Object src, <span class="type">int</span> srcPos, Object dest, <span class="type">int</span> destPos, <span class="type">int</span> length)</span>;<span class="comment">//从指定的源数组中复制一个数组，开始在指定的位置，到目标数组的指定位置。 </span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="7-5-StringBuilder的原理"><a href="#7-5-StringBuilder的原理" class="headerlink" title="7.5 StringBuilder的原理"></a>7.5 StringBuilder的原理</h4><ul><li><p>java.lang.StringBuilder</p></li><li><p>在内存中始终是一个数组，占用空间少，效率高，如果超出了StringBuilder的容量，会自动扩容    </p></li><li><p>构造方法：</p><p><code>StringBuilder()</code>：构造一个不带任何字符的字符串生成器，初始容量为16字符</p><p><code>StringBuilder(String str)</code></p></li><li><p>方法</p><p><code>public StringBuilder append()</code>：添加数据，返回的是this，即调用对象的地址，所以以后调用的时候直接.append()使用即可</p><p><u>链式编程：方法返回值是一个对象，可以继续调用</u></p><p><code>public String toString()</code>：将当前的StringBuilder对象转换为String对象</p></li></ul><h4 id="7-6-包装类"><a href="#7-6-包装类" class="headerlink" title="7.6 包装类"></a>7.6 包装类</h4><ul><li><p>基本数据类型使用很方便，但是没有对应的方法去操作这些基本数据类，可以使用一个类把基本数据类型装起来，通过其中的一些方法去操作这些数据</p></li><li><p><img src="TyporaImg/javaSE笔记.assets/image-20220711121509756.png" alt="image-20220711121509756"></p></li><li><p>装箱与拆箱：基本数据类型和包装类的转换</p></li><li><p>自动拆箱与装箱：自动的转换</p><p><code>Integer in = 1; in = in + 2;//相当于in = in.intValue() + 2</code></p></li><li><p>字符串的转换</p><p><img src="TyporaImg/javaSE笔记.assets/image-20220711122357509.png" alt="image-20220711122357509"></p></li></ul><h4 id="7-7-Collection集合"><a href="#7-7-Collection集合" class="headerlink" title="7.7 Collection集合"></a>7.7 Collection集合</h4><p>java.uitl.Collection    </p><p><img src="TyporaImg/javaSE笔记.assets/image-20220711135040955.png" alt="image-20220711135040955"></p><ul><li><p>共性的方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">boolean</span><span class="params">()</span> add(E e);</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">clear</span><span class="params">()</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">remove</span><span class="params">(E e)</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">contains</span><span class="params">(E e)</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span>;</span><br><span class="line"><span class="keyword">public</span> Object[] toArray();<span class="comment">//把集合中的元素储存到数组中</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="7-8-Iterator迭代器"><a href="#7-8-Iterator迭代器" class="headerlink" title="7.8 Iterator迭代器"></a>7.8 Iterator迭代器</h4><ul><li><p>java.uitl.Iterator</p></li><li><p>（接口）对集合进行遍历</p></li><li><p>常用方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span> <span class="comment">//如果仍有元素可以迭代，则返回true</span></span><br><span class="line">E <span class="title function_">next</span><span class="params">()</span> <span class="comment">//返回迭代的下一个元素</span></span><br></pre></td></tr></table></figure></li><li><p>Iterator迭代器是一个接口，不能直接使用，需要使用Iterator接口实现的对象，获取实现类的方式比较特殊</p><p>Collection接口中有一个方法：<code>iterator()</code>返回的就是迭代器</p><ul><li><code>Iterator&lt;E&gt; iterator</code>返回在此collection的元素上进行迭代的迭代器</li></ul></li><li><p>使用步骤</p><ol><li>使用集合中的方法iterator()获取迭代器的实现类对象，使用Iterator接口接收（多态）</li><li>使用Iterator接口中的方法hasNext判断还有没有元素</li><li>使用Iterator接口中的方法next取出集合的下一个元素</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Collection&lt;String&gt; coll = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">coll.add(<span class="string">&quot;张三&quot;</span>);</span><br><span class="line">coll.add(<span class="string">&quot;李四&quot;</span>);</span><br><span class="line">coll.add(<span class="string">&quot;王五&quot;</span>);</span><br><span class="line">coll.add(<span class="string">&quot;赵六&quot;</span>);</span><br><span class="line"></span><br><span class="line">Iterator&lt;String&gt; it = coll.iterator();</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(it.hasNext())&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">e</span> <span class="operator">=</span> it.next();</span><br><span class="line">    sout(e);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(Iterator&lt;String&gt; it2 = coll.iterator; it2.hasNext();)&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">e</span> <span class="operator">=</span> it.next();</span><br><span class="line">    sout(e);</span><br><span class="line">&#125;<span class="comment">//用的少</span></span><br></pre></td></tr></table></figure></li><li><p>迭代器实现原理</p></li></ul><h4 id="7-9-增强for循环"><a href="#7-9-增强for循环" class="headerlink" title="7.9 增强for循环"></a>7.9 增强for循环</h4><ul><li><p>底层也是迭代器，只是使用了for循环的格式简化了迭代器的书写（jdk1.5以后）</p><p><code>Collection&lt;E&gt; extends Iterator&lt;E&gt;</code>：所有单列集合都可以使用增强for</p><p><code>public interface Iterable&lt;T&gt;</code>实现这个接口允许对象成为“foreach”语句的目标</p></li><li><p>格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(集合/数组的数据类型 变量名: 集合/数组名)&#123;</span><br><span class="line"><span class="comment">//操作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">list.add(...)</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">for</span>(String s:list)&#123;</span><br><span class="line">    sout(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="7-10-泛型"><a href="#7-10-泛型" class="headerlink" title="7.10 泛型"></a>7.10 泛型</h4><ul><li><p>一种未知的数据类型，当我们不知道使用什么数据类型的时候，就可以使用泛型，</p><p>泛型也可以看出是一个变量，用来接收数据类型</p><p>​        E e ：Element 元素</p><p>​        T t ：Type 类型</p></li><li><p>好处：</p><ul><li>避免了数据转换的麻烦：不适用泛型，里面存储的数据默认都是是Object类（多态），假如要使用String类特有的方法，则需要向下转型</li><li>把运行期的异常，提升到了编译期（写代码的时候会报错）</li></ul></li><li><p>弊端：泛型是什么类型，只能存储什么类型的数据</p></li></ul><h4 id="7-11-定义含有泛型的类、方法、接口"><a href="#7-11-定义含有泛型的类、方法、接口" class="headerlink" title="7.11 定义含有泛型的类、方法、接口"></a>7.11 定义含有泛型的类、方法、接口</h4><ul><li><p>不写泛型默认是Object类型</p></li><li><p>类：<code>修饰符 class 类名&lt;代表泛型的变量&gt;&#123;&#125;</code></p></li><li><p>方法：<code>修饰符 &lt;泛型&gt; 返回值类型 方法名(参数列表(使用泛型))&#123;方法体&#125;</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;M&gt; <span class="keyword">void</span> <span class="title function_">method</span><span class="params">(M m)</span>&#123;</span><br><span class="line">    <span class="comment">//方法体</span></span><br><span class="line">&#125;<span class="comment">//传递什么数据类型，泛型就是什么类型</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;M&gt; <span class="keyword">void</span> <span class="title function_">method</span><span class="params">(M m)</span>&#123;<span class="comment">//含有泛型的静态方法</span></span><br><span class="line">    <span class="comment">//方法体</span></span><br><span class="line">&#125;<span class="comment">//传递什么数据类型，泛型就是什么类型</span></span><br></pre></td></tr></table></figure></li><li><p>接口：<code>public interface 接口名&lt;泛型&gt;&#123;&#125;</code></p></li><li><p>泛型通配符&lt;?&gt; ：代表任意的数据类型</p><ul><li><p><strong>不能创建对象使用，只能作为方法的参数使用</strong> </p></li><li><p>比如定义一个方法遍历所有类型的ArrayList集合，这个时候不知道ArrayList集合使用什么数据类型，可以使用泛型的通配符？来接收数据</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">printArray</span><span class="params">(ArrayList&lt;?&gt; list)</span>&#123;</span><br><span class="line">        <span class="type">Iterator</span> <span class="variable">iterator</span> <span class="operator">=</span> list.iterator();</span><br><span class="line">        <span class="keyword">while</span>(iterator.hasNext())&#123;</span><br><span class="line">            System.out.println(iterator.next());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>泛型的上限、下限限定（能看懂就好了）</p><ul><li><p>? extends  E：表示使用的泛型只能是E类型的子类/本身</p></li><li><p>? super E：表示使用的泛型只能是E类型的父类/本身</p><p><img src="TyporaImg/javaSE笔记.assets/image-20220711145917957.png" alt="image-20220711145917957"></p></li></ul></li></ul><h4 id="7-12-斗地主案例"><a href="#7-12-斗地主案例" class="headerlink" title="7.12 斗地主案例"></a>7.12 斗地主案例</h4><p><u><em>综合练习：day0711/Fight_The_Landlord</em></u>：斗地主案例</p><h3 id="0712-八-数据结构、常用集合"><a href="#0712-八-数据结构、常用集合" class="headerlink" title="0712 八 数据结构、常用集合"></a>0712 八 数据结构、常用集合</h3><h4 id="8-1-数据结构"><a href="#8-1-数据结构" class="headerlink" title="8.1 数据结构"></a>8.1 数据结构</h4><ol><li><p>栈：先进后出</p></li><li><p>队列：先进先出</p></li><li><p>数组：查询快，增删慢</p><ul><li><p>查询快：数组的地址是连续的，可以通过数组的首地址找到数组，通过索引快速找到某一个原色</p></li><li><p>增删慢：数组的长度是固定的，想要增删一个元素，必须创建一个新的数组，把源数组的数据复制过来</p></li></ul></li><li><p>链表：查询慢，增删快</p><ul><li><p>链表中每个元素称为一个节点，每个节点包含了一个数据源（存储数组）和两个指针（存储自己的地址和下一个节点的地址）</p></li><li><p>查询慢：链表中的地址不是连续的，每次查询都必须从头开始查询</p></li><li><p>增删快：链表中增删一个元素对链表的整体结构没有影响</p></li><li><p>分类：</p><ul><li><p>单向链表：只有一条链，不能保证元素的顺序</p></li><li><p>双向链表：两条链子，有一条用来记录元素的顺序，是一个有序集合</p><p><img src="TyporaImg/javaSE笔记.assets/image-20220712111543206.png" alt="image-20220712111543206"></p></li></ul></li></ul></li><li><p>红黑树：</p><ul><li><p>二叉树：分支不超过两个</p></li><li><p>排序数/查找树：在二叉树的基础上，元素是有大小顺序的，特点：左子树小，右子树大</p></li><li><p>平衡树与不平衡树：左孩子和右孩子相等与不相等</p></li><li><p>红黑树：特点：趋于平衡树，查询的速度非常快，查询叶子节点最大次数和最小次数不能超过2倍</p><p>约束：</p><ul><li>节点可以是红色或者黑色</li><li>根节点是黑色的</li><li>叶子节点（空节点）是黑色的</li><li>每个红色的节点的子节点都是黑色的</li><li>任何一个节点到其每一个叶子节点的所有路径上黑色节点数相同</li></ul></li></ul></li></ol><h4 id="8-2-List集合"><a href="#8-2-List集合" class="headerlink" title="8.2 List集合"></a>8.2 <strong>List集合</strong></h4><ul><li><p>java.util.list接口 extends Collection接口</p></li><li><p>特点：</p><ul><li>有序的集合，存取元素顺序一致（存123，取123）</li><li>有索引，包含了一些带索引的方法</li><li>允许存储重复的元素</li></ul></li><li><p>list接口中带索引的方法（特有）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> index, E element)</span>;</span><br><span class="line"><span class="keyword">public</span> E <span class="title function_">get</span><span class="params">(<span class="type">int</span> index)</span>;</span><br><span class="line"><span class="keyword">public</span> E <span class="title function_">remove</span><span class="params">(<span class="type">int</span> index)</span>;</span><br><span class="line"><span class="keyword">public</span> E <span class="title function_">set</span><span class="params">(<span class="type">int</span> index, E element)</span>;</span><br></pre></td></tr></table></figure></li><li><p>创建一个list集合对象，多态：<code>List&lt;String&gt; list = new ArrayList&lt;&gt;();</code></p></li></ul><h4 id="8-3-ArrayList集合"><a href="#8-3-ArrayList集合" class="headerlink" title="8.3 ArrayList集合"></a>8.3 <strong>ArrayList集合</strong></h4><ul><li>List接口的数组结构实现</li><li>底层数组结构，查询快，增删慢</li></ul><h4 id="8-4-LinkedList集合"><a href="#8-4-LinkedList集合" class="headerlink" title="8.4 LinkedList集合"></a>8.4 LinkedList集合</h4><ul><li><p>List接口的链表列表实现</p></li><li><p>底层链表结构，查询慢，增删快</p></li><li><p>里面包含了大量操作首尾元素的方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addFirst</span><span class="params">(E e)</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addLast</span><span class="params">(E e)</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(E e)</span>;<span class="comment">//将元素推入此列表所表示的堆栈</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> E <span class="title function_">getFirst</span><span class="params">()</span>;</span><br><span class="line"><span class="keyword">public</span> E <span class="title function_">getLast</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> E <span class="title function_">removeFirst</span><span class="params">()</span>;</span><br><span class="line"><span class="keyword">public</span> E <span class="title function_">removeLast</span><span class="params">()</span>;</span><br><span class="line"><span class="keyword">public</span> E <span class="title function_">pop</span><span class="params">()</span>;<span class="comment">//从此列表所表示的堆栈处弹出一个元素</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure></li></ul><h4 id="8-5-Vector集合"><a href="#8-5-Vector集合" class="headerlink" title="8.5 Vector集合"></a>8.5 Vector集合</h4><ul><li>可实现可增长的对象数组，即底层也是数组结构，后面被ArrayList取代了</li></ul><h4 id="8-6-Set集合"><a href="#8-6-Set集合" class="headerlink" title="8.6 Set集合"></a>8.6 Set集合</h4><ul><li><p>继承了Collection接口</p></li><li><p>特点：1.不允许重复元素；2.无索引没有带索引的方法，也不能使用普通的for循环遍历（用迭代器、增强for）</p></li><li><p>Set集合不允许重复的原理:（前提必须重写hashCode方法和equals方法）</p><p>Set集合调用add方法的时候，add会调用元素的hashCode方法和equals方法，判断元素是否重复</p><p>先判断有无相同的哈希值，没有则直接存储，有则调用equals方法和哈希值相同元素进行判断，相同则不存储</p><p><img src="TyporaImg/javaSE笔记.assets/image-20220712123114894.png" alt="image-20220712123114894"></p></li></ul><h4 id="8-7-HashSet集合"><a href="#8-7-HashSet集合" class="headerlink" title="8.7 HashSet集合"></a>8.7 HashSet集合</h4><ul><li><p>Set接口的实现</p></li><li><p>特点：不重复；无索引；无序；底层是一个哈希表结构（查询快）</p></li><li><p>哈希值：一个十进制整数，由系统随机给出（对象的地址值，是一个逻辑值，是模拟出来得到地址，不是数据实际存储的物理地址）</p><p>获取：Object类中有一个<code>public native int hashCode()</code>（native表示该方法调用的是本地操作系统的方法）</p></li></ul><ul><li>HashSet集合存储数据的结构（哈希表）：<ul><li>jdk1.8之前哈希表 = 数组+链表；1.8之后为数组+红黑树（提高查询速度）</li><li>数组结构：把元素分组（哈希值相同的为一组），再用链表/红黑树把相同哈希值的元素连接到一起</li></ul></li><li>注：<ul><li>先用链表，如果链表长度超过8个，则用红黑树</li></ul></li><li>HashSet存储自定义类型元素<ul><li>必须重写HashCode和equals方法 &lt;—8.6有说</li></ul></li></ul><h4 id="8-8-LinkedHashSet集合"><a href="#8-8-LinkedHashSet集合" class="headerlink" title="8.8 LinkedHashSet集合"></a>8.8 LinkedHashSet集合</h4><ul><li>继承了HashSet</li><li>底层是哈希表（数组+链表/红黑树） + 链表：多了一条链表（记录链表存储顺序），保证元素顺序</li><li>特点：有序（因为多了一条链表）</li></ul><h4 id="8-9-可变参数"><a href="#8-9-可变参数" class="headerlink" title="8.9 可变参数"></a>8.9 可变参数</h4><ul><li>JDK1.5之后</li><li>前提：参数列表类型确定，个数不确定</li><li>格式：<code>修饰符 返回值类型 方法名(数据类型...变量名)&#123;&#125;</code></li><li>原理：可变参数底层是一个数组，根据传参不同，创建不同长度的数组，来存储这些数据，传递的参数可以是0,1,2…</li><li>注意：<ul><li>一个方法的可变参数只能有一个 <code>public void method(Sting...a, int...b)是错误的</code></li><li>多个方法参数，那么可变参数必须写在参数列表末尾</li></ul></li></ul><h4 id="8-10-Collections集合工具类"><a href="#8-10-Collections集合工具类" class="headerlink" title="8.10 Collections集合工具类"></a>8.10 Collections集合工具类</h4><ul><li><p>java.utils.Collections集合工具类，用于操作集合，常用方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="type">boolean</span> <span class="title function_">addAll</span><span class="params">(Collections&lt;T&gt; c, T...elements)</span>;<span class="comment">//往集合加元素</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">shuffle</span><span class="params">(list&lt;?&gt; list)</span>;<span class="comment">//打乱顺序</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(List&lt;T&gt; list)</span>;<span class="comment">//默认规则排序（升序）</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(List&lt;T&gt; list, Comparator&lt;? <span class="built_in">super</span> T&gt;)</span>;<span class="comment">//指定规则排序（方便）</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">Collections.allAll(list, <span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>);</span><br><span class="line">Collections.shuffle(list);</span><br></pre></td></tr></table></figure></li><li><p>注：</p><ul><li>使用sort默认排序，被排序的集合里面存储元素，必须实现Comparable，重写接口中的方法compareTo定义排序规则</li><li>Comparator和Comparable区别<ul><li>Comparable：自己(this)和别人(参数)比较，自己需要实现Comparable接口,重写比较的规则compareTo方法</li><li>Comparator：相当于找一个第三方的裁判进行比较</li></ul></li></ul></li></ul><h4 id="8-11-Map集合"><a href="#8-11-Map集合" class="headerlink" title="8.11 Map集合"></a>8.11 Map集合</h4><ul><li><p>接口Map<K, V> — 两个泛型，一个元素包含两个值,键和值，故叫双列集合</p></li><li><p>一个映射不能包含重复的键，一个键最多一个值，通过键找到对应的值（键不能重复，值可以）</p></li><li><p>常用方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">put</span><span class="params">(K key, V value)</span>;<span class="comment">//放入键值对。注：返回值V当key不重复，返回null，当key重复，使用新的value替换原来的value，并返回原来的value</span></span><br><span class="line"><span class="keyword">public</span> V <span class="title function_">remove</span><span class="params">(Object key)</span>;<span class="comment">//删键值对</span></span><br><span class="line"><span class="keyword">public</span> V <span class="title function_">get</span><span class="params">(Object key)</span>;</span><br><span class="line"><span class="type">boolean</span> <span class="title function_">containsKey</span><span class="params">(Object key)</span>;</span><br><span class="line"><span class="keyword">public</span> Set&lt;K&gt; <span class="title function_">keySet</span><span class="params">()</span>;<span class="comment">//获取所有的键存储在Set中</span></span><br><span class="line"><span class="keyword">public</span> Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet();<span class="comment">//获取Map集合中所有的键值对对象的集合（Set集合）</span></span><br></pre></td></tr></table></figure><p>注：Map.Entry<K,V>:在map接口中有一个内部接口Entry</p><p>​        作用：在Map集合创建的时候会在Map集合中创建在一个Entry对象，用来记录键与值</p></li><li><p>遍历Map集合</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用keySet(),entrySet()方法</span></span><br><span class="line"><span class="comment">//通过keySet()，也就是键</span></span><br><span class="line">Set&lt;String&gt; set = map.keySet();</span><br><span class="line">Iterator&lt;String&gt; it = set.iterator();</span><br><span class="line"><span class="keyword">while</span>(it.hasNext())&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> it.next();</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">value</span> <span class="operator">=</span> map.get(key);</span><br><span class="line">&#125;<span class="comment">//用增强for也可以</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//通过entrySet方法</span></span><br><span class="line">Set&lt;Map.Entry&lt;String, Integer&gt;&gt; set = map.entrySet();</span><br><span class="line"><span class="keyword">for</span>(Map.Entry&lt;String, Integer&gt; entry:set)&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> entry.getKey();</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">value</span> <span class="operator">=</span> entry.getValue();</span><br><span class="line">&#125;<span class="comment">//也可用迭代器</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="8-12-HashMap"><a href="#8-12-HashMap" class="headerlink" title="8.12 HashMap"></a>8.12 HashMap</h4><ul><li>无序，key不重复</li><li>底层是哈希表，查询快。JDK1.8之前为数组+单向链表，JDK1.8之后为数组+单向链表/红黑树</li><li>也有一个类似与LinkedHashSet的LinkedHashMap子类（有序）</li><li>HashMap存储自定义数据类型<ul><li>保证key是唯一的，所以要重写key的hashCode和eqauls方法</li></ul></li></ul><h4 id="8-13-Hashtable"><a href="#8-13-Hashtable" class="headerlink" title="8.13 Hashtable"></a>8.13 Hashtable<K, V></h4><ul><li>不允许存储null（之前的集合都可以存储null）</li><li>单线程，速度慢</li><li>和Vector一样，后面被HashMap取代</li><li>其子类Properties依然使用较多（IO流中）</li></ul><h4 id="8-14-JDK9对集合添加的优化"><a href="#8-14-JDK9对集合添加的优化" class="headerlink" title="8.14 JDK9对集合添加的优化"></a>8.14 JDK9对集合添加的优化</h4><ul><li><p>List Set Map接口添加了一个静态方法of，一次性添加多个元素</p><p><code>static &lt;E&gt; list of(E...elements)</code></p></li><li><p>注：</p><ul><li>只适用于List Set Map接口，不适用于接口的实现类</li><li>of方法返回一个不可变的集合，集合不能再使用add，put方法添加元素，会抛出异常</li><li>Set接口和Map接口调用of方法的时候，不能有重复的元素</li></ul></li></ul><h4 id="8-15-练习"><a href="#8-15-练习" class="headerlink" title="8.15 练习"></a>8.15 练习</h4><ol><li><u><em>练习：day0712/CalEachWordNum</em></u>：统计一个字符串中每个字符出现次数</li><li><u><em>练习：day0712/Fight_The_Landlord_pro</em></u>：斗地主案例（对牌进行了排序）</li></ol><h3 id="0714-九-异常、线程"><a href="#0714-九-异常、线程" class="headerlink" title="0714 九 异常、线程"></a>0714 九 异常、线程</h3><h4 id="9-1-异常"><a href="#9-1-异常" class="headerlink" title="9.1 异常"></a>9.1 异常</h4><ul><li><p>程序在执行过程中，出现的非正常现象</p></li><li><p>异常的根类为Java.lang.Throwable，下面有两个子类Error和Exception</p></li><li><p>Exception：编译器异常，（写代码）java程序出现的问题</p><ul><li>RuntimeException：运行期异常</li></ul></li><li><p>Error：错误。必须修改源代码</p></li><li><p>异常产生过程解析</p><p><img src="TyporaImg/javaSE笔记.assets/image-20220714112238211.png" alt="image-20220714112238211"></p></li></ul><h4 id="9-2-异常处理的关键字"><a href="#9-2-异常处理的关键字" class="headerlink" title="9.2 异常处理的关键字"></a>9.2 异常处理的关键字</h4><ul><li><p>throw关键字：在指定的方法中抛出指定的异常</p><p>格式：<code>throw new xxxException(&quot;异常产生的原因&quot;)</code></p><p>注：</p><ul><li>throw必须写在方法内部</li><li>throw后面new的对象必须是Exception或者Exception的子类对象</li><li>throw后抛出的指定异常对象，必须处理这个异常对象<ul><li>throw关键字后面创建的是RuntimeException及其子对象，可以不处理，默认给JVM处理（打印并中断）</li><li>throw关键字后面创建的是编译异常，就必须处理，用throws或者try…catch</li></ul></li></ul></li><li><p>throws关键字：当方法内部抛出异常对象的时候，可以使用throws处理，会把异常对象声明抛出给方法的调用者(自己不处理，交给别人处理)，最终交给JVM处理—&gt;中断处理</p><ul><li><p>格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">修饰符 返回值类型 方法名(参数列表) <span class="keyword">throws</span> AAAException,BBBException...&#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">AAAException</span>(<span class="string">&quot;...&quot;</span>);</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BBBException</span>(<span class="string">&quot;...&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>注：</p><ul><li>throws必须写在方法声明处</li><li>throws关键字后面声明的异常必须是Exception或者其子类</li><li>方法内部如果抛出了多个异常对象，那么throws后边必须也声明多个异常，如果是父子关系，明父类即可</li></ul></li></ul></li><li><p>try…catch与finally</p><ul><li><p>格式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    <span class="comment">//可能产生的代码</span></span><br><span class="line">&#125;<span class="keyword">catch</span>(定义一个异常变量用于接收)&#123;</span><br><span class="line">    <span class="comment">//异常的处理逻辑</span></span><br><span class="line">    <span class="comment">//一般会写到工作日志中</span></span><br><span class="line">&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">    <span class="comment">//无论怎么样都会执行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>注</p><ul><li>try中可能会抛出多个异常对象，可以用多个catch（子类必须写在父类上面）</li><li>finally 不能单独使用，得和try一起</li><li>finally一般用于资源的释放（资源回收）</li></ul></li></ul></li></ul><h4 id="9-3-Throwable类中的三个处理异常方法"><a href="#9-3-Throwable类中的三个处理异常方法" class="headerlink" title="9.3 Throwable类中的三个处理异常方法"></a>9.3 Throwable类中的三个处理异常方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">getMessage</span><span class="params">()</span>;<span class="comment">//返回该Throwable的简短描述</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printStackTrace</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure><h4 id="9-4-子类父类异常"><a href="#9-4-子类父类异常" class="headerlink" title="9.4 子类父类异常"></a>9.4 子类父类异常</h4><ul><li>如果父类抛出了多个异常，子类重写方法的时候，抛出和父类相同的异常或者是父类异常的子类或者不抛</li><li>父类方法没有异常，子类重写父类方法也不可以抛出异常，此时子类产生异常只能捕获处理不能声明抛出</li><li>父亲异常时什么样，子类异常就什么样</li></ul><h4 id="9-5-自定义异常类"><a href="#9-5-自定义异常类" class="headerlink" title="9.5 自定义异常类"></a>9.5 自定义异常类</h4><ul><li><p>java提供的异常类，不够我们自己使用，需要自己定义一些异常类</p></li><li><p>格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">XXXException</span> <span class="keyword">extends</span> <span class="title class_">Exception</span>|RuntimeException&#123;</span><br><span class="line">   <span class="comment">//添加一个空参数方法</span></span><br><span class="line">   <span class="comment">//添加一个带异常信息的构造方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>注：</p><ul><li>一般以Exception结尾</li><li>必须继承Exception或者RuntimeException，前者必须throws或者try catch，后面可以不处理</li></ul></li></ul><h4 id="9-6-并发与并行"><a href="#9-6-并发与并行" class="headerlink" title="9.6 并发与并行"></a>9.6 并发与并行</h4><ul><li><p>并发：两个或多个事件在同一个时间段内发生</p></li><li><p>并行：两个或多个事情在同一时刻发生（同时）</p></li><li><p>并行速度快</p></li></ul><h4 id="9-7-进程与线程"><a href="#9-7-进程与线程" class="headerlink" title="9.7 进程与线程"></a>9.7 进程与线程</h4><ul><li><p>指一个内存中运行的应用程序，每个进程都有一个独立的空间，一个应用程序可以同时运行多个进程；进程是程序的一次执行过程，是系统运行过程中的基本单位；系统运行一个程序是一个进程从创建运行到死亡的过程</p></li><li><p>线程：线程是进程中的一个执行单元，负责当前进程中程序的执行，一个进程中至少又一个线程，一个程序中可以有多个线程，这样的程序被称为多线程程序</p><p><img src="TyporaImg/javaSE笔记.assets/image-20220714130606307.png" alt="image-20220714130606307"></p></li><li><p>线程调度</p><ul><li>分时调度</li><li>抢占调度</li></ul></li></ul><h4 id="9-8-线程类Thread"><a href="#9-8-线程类Thread" class="headerlink" title="9.8 线程类Thread"></a>9.8 线程类Thread</h4><ul><li><p>创建</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//第一种方式：创建Thread类 java.lang.Thread</span></span><br><span class="line"><span class="comment">/*步骤</span></span><br><span class="line"><span class="comment">创建Thread类；</span></span><br><span class="line"><span class="comment">重写Thread类种的run方法，设置线程任务</span></span><br><span class="line"><span class="comment">创建Thread类的子类对象</span></span><br><span class="line"><span class="comment">调用Thread类的方法start方法，开启新的线程，执行run方法</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//内容</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//主方法中</span></span><br><span class="line"><span class="type">MyThread</span> <span class="variable">mt</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>();</span><br><span class="line">mt.start();</span><br><span class="line"></span><br><span class="line"><span class="comment">//第二种方式：实现Runnable接口，然后重写run()方法，然后作为参数在Thread方法执行</span></span><br><span class="line"><span class="comment">//java.lang.Thread类的构造方法</span></span><br><span class="line"><span class="comment">//Thread(Runnable target) 分配新的Thread对象</span></span><br><span class="line"><span class="comment">//  Thread(Runnable target, String name)</span></span><br><span class="line"><span class="comment">/*步骤</span></span><br><span class="line"><span class="comment">创建Runnable接口的实现类</span></span><br><span class="line"><span class="comment">重写run方法，设置线程任务</span></span><br><span class="line"><span class="comment">创建Runnable接口实现类对象</span></span><br><span class="line"><span class="comment">创建Thread类对象，构造方法中传递Runnable接口的实现类对象</span></span><br><span class="line"><span class="comment">调用Thread类中start方法</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RunnableImpl</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//内容</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//主方法中</span></span><br><span class="line"><span class="type">RunnableImpl</span> <span class="variable">run</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RunnableImpl</span>();</span><br><span class="line"><span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(run);</span><br><span class="line">t.start();</span><br></pre></td></tr></table></figure></li><li><p>Thread和Runnable的区别（实现Runnable的好处）</p><ul><li><p>Runnable避免了单继承的局限性，可以继承其他的类，实现其他的接口</p></li><li><p>增强了程序的扩展性，降低程序的耦合性</p><p>​    实现Runnable接口的方式，把设置线程任务和开启线程进行了分离（解耦）</p><p>​    实现类中，重写了run方法：用来设置任务</p><p>​    创建Thread类对象，调用start方法：用来开启多线程</p></li></ul></li><li><p>多线程的随机执行过程</p><p><img src="TyporaImg/javaSE笔记.assets/image-20220714134240389.png" alt="image-20220714134240389"></p></li><li><p>多线程的内存图解</p><p><img src="TyporaImg/javaSE笔记.assets/image-20220714134556723.png" alt="image-20220714134556723"></p></li><li><p>常用方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span>; <span class="comment">//返回线程名称</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Thread <span class="title function_">currentThread</span><span class="params">()</span>; <span class="comment">//返回对当前正在执行的线程对象的引用</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span>; <span class="comment">//设置名称</span></span><br><span class="line">Thread(String name);<span class="comment">//也可以通过构造方法直接设置</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sleep</span><span class="params">(<span class="type">long</span> millis)</span>;<span class="comment">//当前的进程以指定的毫秒暂停，之后再继续执行</span></span><br></pre></td></tr></table></figure></li><li><p>匿名内部类实现线程的创建</p><ul><li><p>格式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//匿名内部类格式</span></span><br><span class="line"><span class="keyword">new</span> 父类/接口()&#123;</span><br><span class="line">    重复父类/接口中的方法</span><br><span class="line">&#125;；</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>()&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//线程任务</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;.start();</span><br><span class="line"></span><br><span class="line"><span class="comment">//方式2</span></span><br><span class="line"><span class="type">Runnable</span> <span class="variable">r</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Runnable</span>()&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//线程任务</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;<span class="comment">//(多态写法，接口=实现类)</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(r).start();</span><br><span class="line"></span><br><span class="line"><span class="comment">//简化方式2</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>()&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//线程任务</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;).start();</span><br></pre></td></tr></table></figure></li></ul></li></ul><h4 id="9-9-线程安全问题"><a href="#9-9-线程安全问题" class="headerlink" title="9.9 线程安全问题"></a>9.9 线程安全问题</h4><p><img src="TyporaImg/javaSE笔记.assets/image-20220714143918835.png" alt="image-20220714143918835"></p><ul><li><p>解决方法一：同步代码块</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(同步锁)&#123;</span><br><span class="line">    <span class="comment">//需要同步操作的代码，即可能出现线程安全问题的代码(访问了共享数据的代码)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过代码块中的锁对象，可以使用任意的对象</p><p>但是必须保证多个线程使用的锁是同一个</p><p>锁对象作用：锁住同步代码块，只让一个线程在同步代码块中执行</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RunnableImpl</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">ticked</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">    <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();<span class="comment">//创建一个锁对象</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (obj)&#123;</span><br><span class="line">                <span class="comment">//判断是否有票</span></span><br><span class="line">                <span class="keyword">if</span>(ticked &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">10</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">                    &#125;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot;正在卖第&quot;</span> + ticked + <span class="string">&quot;张票&quot;</span>);</span><br><span class="line">                    ticked--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//主程序</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">RunnableImpl</span> <span class="variable">run</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RunnableImpl</span>();</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t0</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(run);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(run);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(run);</span><br><span class="line"></span><br><span class="line">        t0.start();</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>同步代码块原理</p><p><img src="TyporaImg/javaSE笔记.assets/image-20220714150021020.png" alt="image-20220714150021020"></p></li><li><p>解决方法二：同步方法</p><p>步骤：</p><ul><li>把访问了共享数据的代码抽取，放到一个方法中</li><li>在方法上添加synchronized修饰符 <code>修饰符 synchronized 返回值类型 方法名(参数列表)&#123;&#125;</code></li></ul></li><li><p>静态同步方法</p><ul><li>锁对象不能是this（this是创建对象后产生的，静态方法优先于对象）</li><li>静态方法的锁对象是本类的class属性 ——&gt; .class文件对象(反射)</li></ul></li><li><p>解决方法三：Lock锁</p><ul><li><p>java.util.concurrent.locks.lock接口</p></li><li><p>lock接口实现了比synchronized方法和语句更广泛的锁定操作</p></li><li><p>方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span>;<span class="comment">//获取锁</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span>;<span class="comment">//释放锁</span></span><br></pre></td></tr></table></figure><p>java.util.concurrent.locks.Reentrantlock implements lock</p></li><li><p>使用步骤</p><ol><li>在成员位置创建一个Reentrantlock对象</li><li>在可能会出现安全问题的代码前调用lock()方法</li><li>在可能会出现安全问题的代码后调用unlock()方法</li></ol></li></ul></li></ul><h3 id="0715-十-线程池、Lambda表达式"><a href="#0715-十-线程池、Lambda表达式" class="headerlink" title="0715 十 线程池、Lambda表达式"></a>0715 十 线程池、Lambda表达式</h3><h4 id="10-1-线程间通信"><a href="#10-1-线程间通信" class="headerlink" title="10.1 线程间通信"></a>10.1 线程间通信</h4><ul><li><p>也叫等待唤醒机制：多个线程处理一个资源，处理的动作不一样，就存在线程之间的通信</p></li><li><p>为什么要处理线程之间的通信：多线程并发执行的时候，在默认的情况下CPU是随机切换线程的，当我需要多个线程处理一个任务的时候，并且希望他们有规律的执行，那么多线程之间则需要通信（即解决线程对同一个变量的使用和操作）</p></li><li><p>等待唤醒机制的三个方法：</p><ol><li>wait：线程不在活动，不去竞争锁，进入wait set集合中，因此不会浪费CPU资源，此时线程的状态是WAITING</li><li>notify：选取所通知对象的wait set中的一个线程释放</li><li>notifyAll：释放所通知对象的wait set上全部的线程</li></ol><p>注：</p><ol><li>wait和notify方法必须要同一个锁对象调用，因为对应的锁对象可以通过notify唤醒使用同一个锁对象调用的wait方法后的线程</li><li>wait方法和notify方法是属于Object类的方法</li><li>wait方法和notify方法必须在同步代码块或者同步函数中使用，因为必须要通过锁对象调用这两个方法</li><li>调用obj.wait()会立即释放锁，以便其他线程可以执行obj.notify()，但是notify()不会立刻释放sycronized（obj）中的obj锁，必须要等notify()所在线程执行完synchronized（obj）块中的所有代码才会释放这把锁.</li></ol></li><li><p><img src="TyporaImg/javaSE笔记.assets/image-20220715120026498.png" alt="image-20220715120026498"></p><p><u><em>等待唤醒机制练习：day0715/wakeUp</em></u>：生成包子吃包子案例</p></li></ul><p>​        </p><h4 id="10-2-线程状态"><a href="#10-2-线程状态" class="headerlink" title="10.2 线程状态"></a>10.2 线程状态</h4><ul><li><p>阻塞状态BLOCKED：具有cpu的执行资格，等待cpu空闲执行</p></li><li><p>休眠状态TIME_WAITING：放弃cpu 的执行资格，cpu空闲也不执行</p></li><li><p>运行状态RUNNING</p></li><li><p>死亡状态TERMINATED</p></li><li><p>等待状态WAITING</p><p><img src="TyporaImg/javaSE笔记.assets/image-20220715125651889.png" alt="image-20220715125651889"></p></li></ul><ul><li>注：进入到TimeWaiting(计时等待)有两种方式<ul><li>sleep(long m)方法在毫秒值结束之后，线程睡醒进入Runnable/Blocked状态</li><li>wait(long m),wait在毫秒值结束后，还没有被notify唤醒，就自动醒来进入Runnable/Blocked状态</li></ul></li></ul><h4 id="10-3-线程池"><a href="#10-3-线程池" class="headerlink" title="10.3 线程池"></a>10.3 线程池</h4><ul><li><p>概念：一个容纳多个线程的容器，其中的线程可以反复利用，省去了频繁创建线程对象的操作而避免了创建线程消耗过多的资源</p></li><li><p>线程池：容器—&gt;(ArrayList,Hashset,LinkedList<Thread>,HashMap)第三个最好 </p></li><li><p>当程序第一次启动的时候，创建多个线程，保存到一个集合中，当想要使用的时候，就可以从集合中取出线程<code>Thread t = list.remove(o);//返回的是被移除的元素</code></p><p><code>Thread t = linked.remove(o);</code></p></li><li><p>当使用完毕，归还线程</p><p><code>list.add(t);</code></p><p><code>linked.addList(t);</code></p></li><li><p>JDK1.5之后，JDK就内置了线程池，我们可以直接使用</p></li></ul><h4 id="10-4-线程池的代码实现"><a href="#10-4-线程池的代码实现" class="headerlink" title="10.4 线程池的代码实现"></a>10.4 线程池的代码实现</h4><ul><li><p>JDK1.5后：java.util.concurrent.Executors</p><p><code>static ExecutorService newFixedThreadPool(int nThreads);//生产指定线程数量的线程池</code></p><p>返回值：java.util.concurrent.ExecutorService 接口，返回的是ExecutorService接口的实现类对象，我们可以使用ExecutorService 接口接收（面向接口的编程）</p><p>其中有两个方法：</p><p><code>Future&lt;?&gt; submit(Runnable task);//提交执行一个Runnable任务并返回一个表示该任务的未来</code> </p><p><code>void shutdown();//关闭/销毁线程池的方法</code></p></li><li><p>线程池使用步骤：</p><ol><li>使用线程池的工厂类Executors里面提供的静态方法newFixedThreadPool生成指定数量的线程池</li><li>创建一个类，实现Runnable，重写run方法，设置线程任务</li><li>调用ExecutorService 中的方法submit，传递线程任务（实现类），开启线程，执行run方法</li><li>调用ExecutorService 中的方法shutdown，销毁线程池（不建议使用）</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">executorService</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">2</span>);</span><br><span class="line">        executorService.submit(<span class="keyword">new</span> <span class="title class_">RunnableImpl</span>());</span><br><span class="line">        executorService.submit(<span class="keyword">new</span> <span class="title class_">RunnableImpl</span>());</span><br><span class="line">        executorService.submit(<span class="keyword">new</span> <span class="title class_">RunnableImpl</span>());</span><br><span class="line">        executorService.submit(<span class="keyword">new</span> <span class="title class_">RunnableImpl</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RunnableImpl</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*输出：</span></span><br><span class="line"><span class="comment">pool-1-thread-1</span></span><br><span class="line"><span class="comment">pool-1-thread-2</span></span><br><span class="line"><span class="comment">pool-1-thread-1</span></span><br><span class="line"><span class="comment">pool-1-thread-2</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="10-5-函数式编程思想"><a href="#10-5-函数式编程思想" class="headerlink" title="10.5 函数式编程思想"></a>10.5 函数式编程思想</h4><ul><li>面向对象的思想：做一个事情，找一个能解决这个事情的对象，调用对象的方法完成事情</li><li>面向编程的思想：只要获取结果，怎么做的不重要，重视结果不重视过程</li><li>冗余的Runnable代码</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 冗余的Runnable代码</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DemoRunnable</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">RunnableImpl</span> <span class="variable">run</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RunnableImpl</span>();</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(run);</span><br><span class="line">        t.start();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//简化：使用匿名内部类,省去了定义RunnableImpl实现类</span></span><br><span class="line">        <span class="type">Runnable</span> <span class="variable">r</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;new Runnable&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(r).start();]</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//继续简化</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;new Runnable&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="10-6-Lambda表达式"><a href="#10-6-Lambda表达式" class="headerlink" title="10.6 Lambda表达式"></a>10.6 Lambda表达式</h4><ul><li><p>JDK1.8</p></li><li><p>```java<br>public class LambdaDemo {</p><pre><code>public static void main(String[] args) &#123;    //使用匿名内部类的方法实现    new Thread(new Runnable() &#123;        @Override        public void run() &#123;            System.out.println(&quot;new Runnable&quot;);        &#125;    &#125;).start();    //使用Lambda表达式实现多线程    new Thread(()-&gt;&#123;        System.out.println(&quot;new Runnable&quot;);    &#125;    ).start();&#125;</code></pre><p>}</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- Runnable接口中只有一个run方法的定义：`public abstract void run();`</span><br><span class="line"></span><br><span class="line">  制定了一种做事情的方案（函数）：</span><br><span class="line"></span><br><span class="line">  - 无参数</span><br><span class="line">  - 无返回值</span><br><span class="line">  - 代码块</span><br><span class="line"></span><br><span class="line">  同样的语义在Lambda语法中更简单：`() -&gt; System.out.println(&quot;new Runnable&quot;);  `</span><br><span class="line"></span><br><span class="line">- Lambda表达式的标准格式由三部分：</span><br><span class="line"></span><br><span class="line">  - 一些参数</span><br><span class="line"></span><br><span class="line">  - 一个箭头</span><br><span class="line"></span><br><span class="line">  - 一段代码</span><br><span class="line"></span><br><span class="line">​`(参数列表) -&gt; &#123;一些重写方法的代码块&#125;`    </span><br><span class="line"></span><br><span class="line">​注：()是接口中抽象方法的参数列表，没有参数就空着；有参数就写出参数，多个参数用逗号分隔</span><br><span class="line"></span><br><span class="line">​-&gt;是传递参数的意思</span><br><span class="line"></span><br><span class="line">- ```java</span><br><span class="line">  public interface Cook()&#123;</span><br><span class="line">      public abstract void makefood();</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  punlic class Main()&#123;</span><br><span class="line">      public static void main(String[] args) &#123;</span><br><span class="line">          //使用invokeCook方法，参数为Cook接口，传递Cook接口的匿名内部类对象</span><br><span class="line">          invokeCook(new Cook()&#123;</span><br><span class="line">              @Override</span><br><span class="line">              public void makefood()&#123;</span><br><span class="line">                  System.out.println(&quot;吃饭&quot;);</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;);</span><br><span class="line">          </span><br><span class="line">          //使用Lambda表达式，调用invoke方法，参数是Cook接口，传递Cook接口的匿名内部类对象</span><br><span class="line">          invokeCook(()-&gt;&#123;</span><br><span class="line">              System.out.println(&quot;吃饭&quot;);</span><br><span class="line">          &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      public static void invokeCook(Cook cook)&#123;</span><br><span class="line">          cook.makefood();</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li><li><p><u><em>Lambda表达式练习：day0715/LambdaTest</em></u>：使用数组存储多个Person对象，对数组中的Person对象使用Arrays的sort方法通过年龄升序排序</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Person[] arr = &#123;</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;jack&quot;</span>, <span class="number">19</span>),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;mack&quot;</span>, <span class="number">17</span>),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;rose&quot;</span>, <span class="number">18</span>),</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//对数组中的Person对象进行升序排序</span></span><br><span class="line">        Arrays.sort(arr, <span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;Person&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Person o1, Person o2)</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> o1.getAge()-o2.getAge();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Person person : arr) &#123;</span><br><span class="line">            System.out.println(person.toString());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//使用Lambda表达式简化匿名内部类</span></span><br><span class="line">        Arrays.sort(arr,(Person o1, Person o2)-&gt;&#123;</span><br><span class="line">            <span class="keyword">return</span> o1.getAge()-o2.getAge();</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">for</span> (Person person : arr) &#123;</span><br><span class="line">            System.out.println(person.toString());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><u><em>Lambda表达式练习2：day0715/LambdaTest/DemoInvokeCalc.java</em></u>：给定一个计算器Calculator接口，内含抽象方法calc可以将两个int</p><p>数字相加得到和</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DemoInvokeCalc</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        invoke(<span class="number">3</span>, <span class="number">4</span>, <span class="keyword">new</span> <span class="title class_">Calculator</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">calc</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> a+b;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"><span class="comment">//使用Lambda表达式</span></span><br><span class="line">        invoke(<span class="number">3</span>, <span class="number">4</span>, (<span class="type">int</span> a, <span class="type">int</span> b) -&gt;&#123;</span><br><span class="line">            <span class="keyword">return</span> a+b;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">invoke</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, Calculator cal)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> cal.calc(a, b);</span><br><span class="line">        System.out.println(result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="10-7-使用Lambda的前提"><a href="#10-7-使用Lambda的前提" class="headerlink" title="10.7 使用Lambda的前提"></a>10.7 使用Lambda的前提</h4><ul><li><p>Lambda表达式是可推导可省略的：凡是根据上下文可以推导出来的内容都可以省略</p></li><li><p>可以省略的内容：</p><ul><li><p>(参数列表)：括号中的参数列表的数据类型可以省略不写</p></li><li><p>(参数列表)：括号中的参数只有一个，那么类型和（）都可以省略不写 </p></li><li><p>(一些代码)：如果{}中的代码只有一行，无论是否有返回值，都可以省略（{}，return，分号）</p><p>注：要省略就一起省略</p><p><code>new Thread(()-&gt;System.out.println(&quot;new Runnable&quot;).start();</code></p></li></ul></li><li><p>使用前提：</p><ul><li>使用Lambda必须具有接口，且要求接口中有且仅有一个抽象方法</li><li>使用Lambda必须具有上下文推断，也就是方法的参数或局部变量类型必须为Lambda对应的接口类型，才能使用Lambda作为该接口的实例。</li></ul></li></ul><h3 id="0718-十一-流"><a href="#0718-十一-流" class="headerlink" title="0718 十一 流"></a>0718 十一 流</h3><h4 id="11-1-File类"><a href="#11-1-File类" class="headerlink" title="11.1 File类"></a>11.1 File类</h4><ul><li><p>java.io.file：文件和目录路径名的抽象表示形式</p><p>Java把电脑中的文件和文件夹封装为一个File类，可以使用File类对他们进行操作</p><p>File类是与系统无关的类，任何操作系统都可以使用</p></li><li><p>三个单词： file、directory、path</p></li><li><p>File的静态成员变量</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> String pathSeparator;<span class="comment">//系统依赖路径分隔符的字符，表示为方便的字符串</span></span><br><span class="line"><span class="keyword">static</span> <span class="type">char</span> pathSeparatorChar;<span class="comment">//系统依赖路径分隔符的字符</span></span><br><span class="line"><span class="comment">// 路径分隔符windows:分号 linux:冒号</span></span><br><span class="line"><span class="keyword">static</span> String separator;<span class="comment">//系统依赖的默认名称分隔符字符，表示为方便的字符串</span></span><br><span class="line"><span class="keyword">static</span> <span class="type">char</span> separatorChar; <span class="comment">//系统依赖的默认名称分隔符字符</span></span><br><span class="line"><span class="comment">//文件分隔符 windows:反斜杠/ linux:正斜杠/</span></span><br></pre></td></tr></table></figure></li><li><p>绝对路径和相对路径</p><ul><li><p>绝对路径是以盘符开始的完整的路径</p></li><li><p>相对路径是相对于当前项目的根目录</p></li><li><p>注：不区分大小写；路径中文件名分隔符windows为反斜杠，反斜杠为转转义字符，两个普通的反斜杠代表一个反斜杠</p><p><code>C://Users//ManYile</code></p></li></ul></li><li><p>File类的构造方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">File(String pathname);<span class="comment">//通过将给定的路径名的字符串转换成一个抽象路径名创建一个新的 File实例</span></span><br><span class="line">File(File parent, String child);<span class="comment">//创建从一个家长的抽象路径名和一个孩子的路径字符串的新 File实例</span></span><br><span class="line">File(String parent, String child);<span class="comment">//创建从父路径名的字符串和一个孩子的一个新的 File实例文件。</span></span><br><span class="line">File(URI uri);<span class="comment">//通过将给定的 file: URI到一个抽象路径名创建一个新的 File实例。 </span></span><br></pre></td></tr></table></figure><p>注：</p><ul><li>pathname可以是以文件或者文件夹结尾</li><li>可以是相对路径/绝对路径</li><li>可以是存在，也可以是不存在</li><li>创建File对象，只是把字符串路径封装为File对象，不考虑路径存在真假情况</li></ul></li><li><p>File类的常用方法</p><ul><li><p>获取的方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">getAbsolutePath</span><span class="params">()</span>;<span class="comment">//获取绝对路径</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">getPath</span><span class="params">()</span>;<span class="comment">//将此File转换为路径名字符串，绝对就是绝对，相对就是相对</span></span><br><span class="line"><span class="comment">//File类的toString方法用的就是getPath()</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span>;<span class="comment">//将此</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">long</span> <span class="title function_">length</span><span class="params">()</span>;<span class="comment">//返回此File表示的文件长度，以字节为单位，不能获取文件夹大小（文件夹没有大小），若不存在则返回0</span></span><br></pre></td></tr></table></figure></li><li><p>判断的方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">exists</span><span class="params">()</span>;<span class="comment">//目录是否存在</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isDirectory</span><span class="params">()</span>;<span class="comment">//是否为目录</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isFile</span><span class="params">()</span>;<span class="comment">//是否为文件夹</span></span><br></pre></td></tr></table></figure></li><li><p>创建删除功能</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">createNewFile</span><span class="params">()</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">delete</span><span class="params">()</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">mkdir</span><span class="params">()</span>;<span class="comment">//创建由此File表示的目录</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">mkdirs</span><span class="params">()</span>;<span class="comment">//创建由此File表示的目录，包括任何必须但不存在的父目录 </span></span><br></pre></td></tr></table></figure></li><li><p>File类的遍历（文件夹）功能</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String[] list();<span class="comment">//返回一个String数组，表示该File目录中所有的子文件或者目录</span></span><br><span class="line"><span class="keyword">public</span> File[] listFiles();<span class="comment">//返回一个File数组，表示所有的子文件或者目录</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><h4 id="11-2-递归"><a href="#11-2-递归" class="headerlink" title="11.2 递归"></a>11.2 递归</h4><ul><li>注：<ul><li>构造方法禁止递归</li><li>递归不宜太多或者无法跳出，否则会导致栈内存溢出</li></ul></li><li><p><u><em>递归练习：day0718/SearchJava.java</em></u>：搜索D盘的.java文件</p><h4 id="11-3-FileFilter过滤器"><a href="#11-3-FileFilter过滤器" class="headerlink" title="11.3 FileFilter过滤器"></a>11.3 FileFilter过滤器</h4></li><li><p>java.io.FileFilter接口：用于抽象路径名（File对象）的过滤器</p></li><li><p>抽象方法：用来过滤文件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="title function_">accept</span><span class="params">(File pathname)</span>;<span class="comment">//测试指定抽象路径名是否应该包含在某个路径名列表中</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="11-4-FileNameFilter"><a href="#11-4-FileNameFilter" class="headerlink" title="11.4 FileNameFilter"></a>11.4 FileNameFilter</h4><ul><li><p>java.io.FileNameFilter接口</p></li><li><p>抽象方法：用于过滤文件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="title function_">accept</span><span class="params">(File dir, String name)</span>;<span class="comment">//测试文件是否包含在某一文件夹中</span></span><br></pre></td></tr></table></figure></li><li><p>注：两个过滤器没有实现类，我们需要自己重写实现类，重写accept方法，自己定义规则</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">File[] file = dir.listFiles(<span class="keyword">new</span> <span class="title class_">FileFilter</span>()&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">accept</span><span class="params">(File pathname)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> pathname.isDirectory() || pathname.getName().toLowerCase().endWith(<span class="string">&quot;.java&quot;</span>);<span class="comment">//返回以java结尾的文件</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//lambda</span></span><br><span class="line">File[] file = dir.listFiles(() -&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> pathname.isDirectory() ||pathname.getName().toLowerCase().endWith(<span class="string">&quot;.java&quot;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li></ul><h4 id="11-5-字节流"><a href="#11-5-字节流" class="headerlink" title="11.5 字节流"></a>11.5 字节流</h4><ul><li><p>IO：input output</p></li><li><p>一切皆为字节</p></li><li><p>字节输出流：OutputStream，一切输出流的父类，是一个抽象类，已知直接子类：</p><p>ByteArrayOutputStream，FileOutputStream，FilterOutputStream，ObjectOutputStream，OutputStream，PipedOutputStream </p></li></ul>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">flush</span><span class="params">()</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">write</span><span class="params">(<span class="type">byte</span>[] b)</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">write</span><span class="params">(<span class="type">byte</span>[] b, <span class="type">int</span> off, <span class="type">int</span> len)</span>;<span class="comment">//写字节数组的一部分,off为开始索引,len为长度</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">write</span><span class="params">(<span class="type">int</span> b)</span>;</span><br></pre></td></tr></table></figure><ul><li><p>FileOutputStream</p><ul><li><p>构造方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">FileOutputStream(String name);</span><br><span class="line">FileOutputStream(File file);</span><br><span class="line">FileOutputStream(String name, <span class="type">boolean</span> append);</span><br><span class="line">FileOutputStream(File name, <span class="type">boolean</span> append);<span class="comment">//第三第四个为追加写</span></span><br><span class="line"><span class="comment">//append为true则不会覆盖，为flase则会覆盖</span></span><br></pre></td></tr></table></figure></li><li><p>构造方法作用</p><ul><li>创建一个FileOutputStream对象</li><li>会根据构造方法中传递的文件/文件路径，创建一个空的文件</li><li>会把FileOutputStream对象指向创建好的文件</li></ul></li></ul></li><li><p>写入数据的原理</p><ul><li>java程序 -&gt; JVM(java虚拟机) -&gt; OS系统 -&gt; os调用写数据的方法 -&gt; 把数据写入到文件</li></ul></li><li><p>字节输出流的使用步骤</p><ol><li><p>创建一个FileOutputStream对象，构造方法中传递输入数据目的地</p></li><li><p>调用FileOutputStream对象方法中的write，写入数据</p></li><li><p>释放资源（流会占用内存）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">FileOutputStream</span> <span class="variable">fos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;D//a.txt&quot;</span>);</span><br><span class="line">fos.wirte(<span class="number">97</span>);</span><br><span class="line">fos.close();</span><br></pre></td></tr></table></figure></li></ol></li><li><p>一次写多个字节的方法 <code>public void write(byte[] b);</code></p><ul><li>如果第一个字节为正数（0-127），则显示的时候会查询ASCII表</li><li>如果为负数，则第一个字节会和第二个字节，两个字节组成一个中文显示，查询系统默认码表（GBK）</li></ul></li><li><p>写入字符的方法：使用String类中的 <code>byte[] getBytes()</code>将字符串转换为字节数组，然后再输入</p></li><li><p>字节输出流的续写和换行</p><ul><li>续写：（第3第4中构造方法）</li><li>换行：写换行符号 windows：/r/n     linux：/n       mac:：/r     <code>fos.write(&quot;/r/n&quot;.getBytes())</code></li></ul></li><li><p>字节输入流：InputStream ，同OutputSteam</p><p>   子类：AudioInputStream，ByteArrayInputStream，FileInputStream，FilterInputStream，InputStream， ObjectInputStream，PipedInputStream，SequenceInputStream，StringBufferInputStream </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">read</span><span class="params">()</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">read</span><span class="params">(<span class="type">byte</span>[] b)</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure></li><li><p>FileInputStream：文件字节输入流</p><ul><li><p>构造方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">FileInputStream(String name);</span><br><span class="line">FileInputStream(File file);</span><br></pre></td></tr></table></figure></li><li><p>作用类似于FileOutputStream构造方法</p></li></ul></li><li><p>读取数据原理与FileOutputStream相似</p></li><li><p>字节输入流的使用步骤</p><ol><li>创建一个FileInputStream对象，绑定要读取的数据源</li><li>调用FileInputStream对象方法中的read，读取数据</li><li>释放资源（流会占用内存）</li></ol></li><li><p>读取文件，while循环</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>((len = fis.read()) != -<span class="number">1</span>)&#123;</span><br><span class="line">    sout(<span class="type">char</span>(len));<span class="comment">//读取文件里面的字节用char表示</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>一次读取多个字节：<code>public int read(byte[] b);</code></p><p>注：方法参数byte[]的作用为起到缓冲作用，存储每次读取到的多个字节，数组长度一般定义为1024的整数倍；</p><p>​        方法返回值int 是每次读取的有效字节数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">byte</span>[] bytes = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line"><span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>((len = fis.read(bytes)) != -<span class="number">1</span>)&#123;</span><br><span class="line">    sout(<span class="keyword">new</span> <span class="title class_">String</span>(bytes));<span class="comment">//这样会有很多空格（因为长度为1024，而文件可能没有这么多字节</span></span><br><span class="line">    sout(<span class="keyword">new</span> <span class="title class_">String</span>(bytes, <span class="number">0</span>, len));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ul><li>String类的构造方法： <code>String(bytes[] bytes):将bytes数组转为String</code>和 <code>String(bytes[] bytes, int off, int length)</code></li></ul><p><u><em>字节流练习：day0718/Stream.java</em></u>：复制文件</p><h4 id="11-6-字符流"><a href="#11-6-字符流" class="headerlink" title="11.6 字符流"></a>11.6 字符流</h4><ul><li><p>字节流的缺点：使用字节流读取文件，1个中文在GBK中占两个字节，在UFT-8占用3个字节</p></li><li><p>字符输入流：java.io.Reader，是字符输入流最顶层的父类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">read</span><span class="params">()</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">read</span><span class="params">(<span class="type">char</span>[] cbuf)</span>;<span class="comment">//一次读取多个字符</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure></li><li><p>FileReader：文件字符输入流</p><ul><li><p><code>FileReader extends InputStreamReader extends Reader</code>    </p></li><li><p>构造方法： <code>FileReader(String name);FileReader(File file);</code></p></li><li><p>使用步骤：同字节输出流</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">FileReader</span> <span class="variable">fr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="string">&quot;文件位置&quot;</span>);</span><br><span class="line"><span class="comment">//一个字符一个字符的读取</span></span><br><span class="line"><span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>((len = fr.read()) != -<span class="number">1</span>)&#123;</span><br><span class="line">    sout(<span class="type">char</span>(len));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//以字符数组读取</span></span><br><span class="line"><span class="type">char</span>[] cs = <span class="keyword">new</span> <span class="title class_">char</span>[<span class="number">1024</span>];</span><br><span class="line"><span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>((len = fr.read(cs)) != -<span class="number">1</span>)&#123;</span><br><span class="line">    sout(<span class="keyword">new</span> <span class="title class_">String</span>(cs, <span class="number">0</span>, len));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fr.close();</span><br></pre></td></tr></table></figure></li></ul></li><li><p>字符输出流：java.io.Writer，是字符输出流最顶层的父类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">write</span><span class="params">(<span class="type">int</span> c)</span>;<span class="comment">//写入单个单词</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">wirte</span><span class="params">(<span class="type">char</span>[] cbuf)</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">write</span><span class="params">(<span class="type">char</span>[] cbuf, <span class="type">int</span> off, <span class="type">int</span> len)</span>; </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">wirte</span><span class="params">(String str)</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">wirte</span><span class="params">(String str, <span class="type">int</span> off, <span class="type">int</span> len)</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">flush</span><span class="params">()</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure></li><li><p>FileWriter：FileWriter extends OutputStreamWriter extends Writer</p><ul><li><p>构造方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">FileWriter(File file);</span><br><span class="line">FileWriter(String name);</span><br></pre></td></tr></table></figure></li><li><p>使用步骤</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">FileWriter</span> <span class="variable">fw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileWriter</span>(name);</span><br><span class="line">fw.write(<span class="number">97</span>);</span><br><span class="line">fw.flush();<span class="comment">//需要刷新一下</span></span><br><span class="line">fw.close();</span><br></pre></td></tr></table></figure></li><li><p>字符输出流写数据的其他方法（调用其他方法）</p></li><li><p>续写和换行</p><ul><li><p>续写：<code>FileWriter(String name, boolean append)</code>或<code>FileWriter(File name, boolean append)</code></p><p>​        append为true则不会创建新的文件覆盖，为false则会覆盖</p></li><li><p>换行：同字节输入流</p></li></ul></li></ul></li></ul><h4 id="11-7-JDK7和JDK9中的异常处理"><a href="#11-7-JDK7和JDK9中的异常处理" class="headerlink" title="11.7 JDK7和JDK9中的异常处理"></a>11.7 JDK7和JDK9中的异常处理</h4><ul><li><p>JDK7新特性，在try后面可以增加一个()，在括号里面进行对象的定义，那么这个流对象的作用域就在try中有效，try中的代码执行完毕，会自动把流对象释放，不用写finally。</p></li><li><p>JDK9新特性：try前面可以定义流对象，try后面（）中可以直接引入流对象的名称（变量名），在try代码执行完毕后，流对象也可以释放，不用写finally，格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">A</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">A</span>();</span><br><span class="line"><span class="type">B</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">B</span>();</span><br><span class="line"><span class="keyword">try</span>(a, b)&#123;</span><br><span class="line">    <span class="comment">//可能出现异常部分;</span></span><br><span class="line">&#125;<span class="keyword">catch</span>(异常类变量 变量名)&#123;</span><br><span class="line">    <span class="comment">//异常处理</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="11-8-属性集"><a href="#11-8-属性集" class="headerlink" title="11.8 属性集"></a>11.8 属性集</h4><ul><li><p>java.util.Properties继承于HashTable：表示一个持久的属性集，可保存流中或从流中加载，属性列表中每个键以及对应值都是一个字符串</p></li><li><p>Properties是唯一一个和IO流相结合的集合</p><ul><li><p>使用集合中的方法store，把集合中的临时数据，持久化写入到硬盘中存储</p><p><code>void store(OutputStream out, String comments);</code></p><p><code>void store(Writer writer, String comments);</code></p><p>参数说明</p><ul><li>OutputStream  out：字节输出流，不能写中文</li><li>Writer writer：字符输出流，可以写中文</li><li>String comments：注释，用来解释说明保存的文件，不能使用中文，一般使用空字符串</li></ul></li><li><p>使用方法load，把硬盘中保存的文件，读取到集合中</p></li><li><p>双列集合，key和value都是默认字符串</p></li><li><p>Properties中一些操作字符串的方法</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Object <span class="title function_">setProperties</span><span class="params">(String key, String value)</span>;</span><br><span class="line">String <span class="title function_">getProperties</span><span class="params">(String key)</span>;</span><br><span class="line">Set&lt;String&gt; <span class="title function_">StringPropertyNames</span><span class="params">()</span>;<span class="comment">//返回属性列表中的键集 </span></span><br></pre></td></tr></table></figure></li><li><p>使用步骤：</p><ol><li>创建Properties集合对象，添加数据</li><li>创建字节/字符输出流对象，构造方法中绑定输出目的地</li><li>使用Properties集合中的store方法，把集合中的临时数据持久化写入到硬盘中</li><li>释放资源</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Properties</span> <span class="variable">prop</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">prop.setProperties(<span class="string">&quot;张三&quot;</span>, <span class="string">&quot;19&quot;</span>);</span><br><span class="line"><span class="type">FileWriter</span> <span class="variable">fw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileWriter</span>(<span class="string">&quot;地址&quot;</span>);</span><br><span class="line">prop.store(fw, <span class="string">&quot;save data&quot;</span>);</span><br><span class="line">fw.close();</span><br></pre></td></tr></table></figure></li></ul><h3 id="0719-十二-缓冲流、转换流、序列化"><a href="#0719-十二-缓冲流、转换流、序列化" class="headerlink" title="0719 十二 缓冲流、转换流、序列化"></a>0719 十二 缓冲流、转换流、序列化</h3><h4 id="12-1-缓冲流"><a href="#12-1-缓冲流" class="headerlink" title="12.1 缓冲流"></a>12.1 缓冲流</h4><ul><li><p>给基本的字节/字符输入/输出流增加一个缓冲区（数组），提高字节/字符输入/输出的效率</p><p>注：比使用一个数组更有效率</p></li><li><p>字节缓冲流：<code>BufferInputStream;BufferOutputStream</code></p></li><li><p>字符缓冲流：<code>BufferedReader;BufferedWriter</code></p></li><li><p><code>BufferedOutputStream extends OutputStream</code>：字节缓冲输出流</p><ul><li>构造方法：<code>BufferedOutputStream(OutputStream out);BufferedOutputStream(OutputStream out,int size)</code>，size为内部缓冲区的大小，不指定则默认</li><li>步骤<ol><li>创建FileOutputStream对象，构造方法中要绑定输出目的地</li><li>创建BufferOutputStream对象，构造方法中传递FileOutputStream，以提高FileOutputStream对象效率</li><li>使用BufferOutputStream的write方法，把数据写入到内部缓冲区中</li><li>使用BufferOutputStream的flush方法，刷新（可省略）</li><li>关闭close</li></ol></li></ul></li><li><p><code>BufferedInputStream extends inputStream</code>：字节缓冲输入流</p><ul><li>构造方法：类似</li><li>步骤：类似</li></ul></li><li><p><code>BufferedWriter extends Writer</code>：字符缓冲输出流</p><ul><li>构造方法：<code>BufferedWriter (Writer writer, int size);</code>size可以不写</li><li>特有的成员方法：<code>void newLine()://创建行分隔符</code></li></ul></li><li><p><code>BufferedReader extends Reader</code>：字符缓冲输入流</p><ul><li>构造方法</li><li>特有成员方法：<code>String readLine();//读取一个文本行，读取一行数据</code></li></ul></li></ul><h4 id="12-2-转换流"><a href="#12-2-转换流" class="headerlink" title="12.2 转换流"></a>12.2 转换流</h4><ul><li><p>字符编码和解码</p></li><li><p>字符集：也叫编码表，常见的有：</p><p>​    ASCII字符集（英文）</p><p>​    GBK字符集（最常用的中文码表），两个字节一个中文</p><pre><code> Unicode字符集（任意语言），三个字节一个中文</code></pre></li><li><p>编码引出的问题：FileReader可以读取IDEA默认编码格式（UTF-8）的文件，它读取系统默认的编码格式（中文GBK）文件会产生乱码</p></li><li><p>转换流原理：</p><ul><li><p>InputStreamReader：可以指定编码表</p><ul><li>构造方法：类似下面</li><li>步骤：类似下面</li></ul></li><li><p>OutputStreamWriter：可以使用指定的charset将要写入的字符编码成字节</p><ul><li><p>构造方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">OutputStreamWriter(OutputStream out, String charsetName);</span><br><span class="line"><span class="comment">//charsetName不分大写</span></span><br><span class="line">OutputStreamWriter(OutputStream out);</span><br></pre></td></tr></table></figure></li><li><p>步骤</p><ul><li>创建OutputStreamWriter对象</li><li>使用OutputStreamWriter的write方法</li><li>flush</li><li>close</li></ul></li></ul></li></ul></li></ul><h4 id="12-3-序列化和反序列化"><a href="#12-3-序列化和反序列化" class="headerlink" title="12.3 序列化和反序列化"></a>12.3 序列化和反序列化</h4><ul><li>序列化：把对象以流的方式，写入到文件中进行保存，也叫写对象<ul><li>对象中包含的不仅仅是字符，所以使用字节流</li><li>ObjectOutputStream：对象的序列化流 <code>void writeObject(Object obj)</code> </li></ul></li><li>反序列化：读取文件中保存的字节，<ul><li>使用字节流</li><li>ObjectInputStream：对象的反序列化流 <code>Object readObject()</code> </li></ul></li><li><code>java.io.ObjectOutputStream extends OutputStream</code><ul><li>构造方法<ul><li><code>ObjectOutputStream(OutputStream out)</code> </li></ul></li><li>特有的成员方法<ul><li><code>void writeObject(Object obj)</code></li></ul></li></ul></li><li><code>java.io.ObjectInputStream extends InputStream</code><ul><li>构造方法<ul><li><code>ObjectInputStream(InputStream in)</code> </li></ul></li><li>特有的成员方法<ul><li><code>Object readObject()</code> </li></ul></li></ul></li></ul><h4 id="12-4-transient关键字"><a href="#12-4-transient关键字" class="headerlink" title="12.4 transient关键字"></a>12.4 transient关键字</h4><ul><li>瞬态关键字</li><li>static关键字：静态关键字，优先于非静态加载到内存中（静态优先于对象进入到内存中），被static修饰的成员变量不能被序列化，序列化的都是对象</li><li>被transient修饰的成员变量不能被序列化、</li></ul><h4 id="12-5-InvalidClassException异常"><a href="#12-5-InvalidClassException异常" class="headerlink" title="12.5 InvalidClassException异常"></a>12.5 InvalidClassException异常</h4><ul><li>原理：当JVM反序列化对象时，能找到.class文件，但是.class文件再序列化对象之后发生了修改，那么反序列化的操作也会失败，抛出 <code>InvalidClassException</code>异常</li><li>原因：<ul><li>该类的序列版本号于从流中读取的类描述的版本号不匹配</li><li>该类包含未知数据类型</li><li>该类没有可访问的无参数构造方法</li></ul></li><li><p>解决方案：</p><ul><li>让相应的类实现Serializable接口，然后 <code>private static final long serialVersionUID = 1L;(随便赋值)</code>（就是为了序列号不改变）</li></ul><h4 id="12-6-打印流"><a href="#12-6-打印流" class="headerlink" title="12.6 打印流"></a>12.6 打印流</h4></li><li><p><code>java.io.PrintStream</code>：打印流</p></li><li><p>特点：</p><ul><li>只负责数据的输出，不负责输入</li><li>不抛出IOException</li><li>特有的方法：print、println，可以输出任意的数据类型</li></ul></li><li><p>构造方法：</p><ul><li><code>PrintStream(File file)</code></li><li><code>PrintStream(String filename)</code></li><li><code>PrintStream(OutputStream out)</code></li></ul></li><li><p>注：如果使用继承父类的write()方法，那么查看数据的时候会查询编码表   97-&gt;a</p><p>​        如果使用字节的方法print/println方法写数据，写的数据原样输出         97-&gt;97</p></li></ul><p><u><em>序列化集合练习：day0719/</em></u>：序列化集合（当我们想在文件中保存多个对象的时候，可以把对象存储到一个集合中，对集合进行序列化和反序列化）</p><h3 id="0720-十三-网络编程、函数式编程"><a href="#0720-十三-网络编程、函数式编程" class="headerlink" title="0720 十三 网络编程、函数式编程"></a>0720 十三 网络编程、函数式编程</h3><h4 id="13-1-网络编程入门"><a href="#13-1-网络编程入门" class="headerlink" title="13.1 网络编程入门"></a>13.1 网络编程入门</h4><ul><li><p>软件结构：C/S结构和B/S结构</p></li><li><p>网络通信协议：</p><ul><li><p>TCP/IP协议（Internet最广泛的协议）</p></li><li><p>四层结构（物理层/数据链路层、网络层（核心）、传输层、应用层）</p></li><li><p>分类：UDP协议（无连接的通信，不能保证数据完整耗资小，一般视频会议用UDP）</p><p>​            TCP协议：三次握手，保证数据的安全</p></li></ul></li><li><p>IP地址：Ipv4和Ipv6 </p></li><li><p>端口号：是一个逻辑端口，无法直接看到，可以使用软件看到，当使用网络软件开打，操作系统会随机分配一个端口号，由两个字节组成，范围为：0-65535之前</p><p> 注：1024之前的不能使用，已经被系统分配给已知的网络软件了</p><ul><li>常用端口号： 80端口：网络端口口；数据库：mysql为3306，oracle为1521；Tomcat服务器为8080</li></ul></li></ul><h4 id="13-2-TCP通信程序"><a href="#13-2-TCP通信程序" class="headerlink" title="13.2 TCP通信程序"></a>13.2 TCP通信程序</h4><ul><li><p>能够实现两台计算机之间的数据交互，要严格分为客户端和服务端，服务端先启动，然后客户端主动连接服务端才能连接成功</p></li><li><p>TCP通信：面向连接的通信，客户端和服务端必须经过3次握手才能通信（安全）</p><ul><li>使用IO对象进行通信，为字节流对象（不是字符流，因为不仅仅只有字符）</li></ul><p><img src="TyporaImg/javaSE笔记.assets/image-20220720144704192.png" alt="image-20220720144704192"></p><ul><li><p>TCP通信的客户端：想服务器发送连接请求，给服务器发送数据，读取服务器回写的数据</p><ul><li><p>表示客户端的类：java.net.Socket：此类实现客户端套字（两台机器间通信的端点，包含了IP地址和端口号）                                                                                                  </p></li><li><p>构造方法： <code>Socket(String host, int port)</code></p></li><li><p>成员方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">OutputStream <span class="title function_">getOutputStream</span><span class="params">()</span>;<span class="comment">//返回此套接字的输出流</span></span><br><span class="line">InputStream <span class="title function_">getInputStream</span><span class="params">()</span>;</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span>;<span class="comment">//关闭套接字</span></span><br></pre></td></tr></table></figure></li><li><p>实现步骤：</p><ol><li>创建一个客户端对象Socket，构造方法绑定服务器和ip地址和端口号</li><li>getOutputStream()获取网络字节输出流对象</li><li>使用getOutputStream()对象中write方法给服务器发送数据</li><li>使用getInputStream()后去网络字节输入流对象，并使用read()方法读取服务器回写的数据</li><li>释放资源（Socket）</li></ol></li><li><p>注：</p><ul><li>客户端和服务器的交互必须使用Socket中提供的网络流，不能使用自己创建的对象</li><li>当创建客户端对象Socket对象的时候，就会去请求服务器和服务器经过3次握手建立连接网络，若服务器没有启动，则抛出异常，若服务器启动则可以交互了</li></ul></li></ul></li><li><p>TCP通信的服务器段：</p><ul><li>表示服务器端的类：java.net.ServerSocket：此类实现服务器的套接字</li><li>构造方法：<code>ServerSocket(int port);//创建绑定到特定端口的雾浮起套接字</code></li><li>服务器端必须明确哪一个客户端请求的服务器，所以用accept方法获取到请求的客户端对象Socket</li><li>成员方法：<code>Socket accept();</code></li><li>实现步骤：<ol><li>创建服务器ServerSocket对象和系统指定的端口号</li><li>使用accept方法获取请求的客户端对象Socket</li><li>使用getInputStream()后去网络字节输入流对象，并使用read()方法读取客户端发送的数据</li><li>getOutputStream()获取网络字节输出流对象，使用getOutputStream()对象中write方法给客户端回写数据</li><li>释放资源（Socket，ServerSocket）</li></ol></li></ul></li></ul></li><li><p><u><em>文件上传练习：day0720/FileUpload</em></u>：TCP通信的文件上传</p><p><img src="TyporaImg/javaSE笔记.assets/image-20220720151225461.png" alt="image-20220720151225461"></p><ul><li><p>注：<code>Socket.shutdownOutput();</code>如果不加此代码就会阻塞。因为服务器会一直等待客户端的输出。既然服务器阻塞了，客户端等待着服务器的输出，也会被阻塞，所以导致客户端和服务端都被阻塞。</p><p>调用<code>Socket.shutdownOutput()</code>方法后，客户端输出的数据都将被发送，并加上 TCP 的正常连接终止序列（-1，也就是服务端终止循环的判断条件)，这样服务端读取数据时就不会被阻塞了。</p></li></ul></li><li><p><u><em>web服务器练习：day0720/web</em></u>：web服务器</p><p><img src="TyporaImg/javaSE笔记.assets/image-20220720164322212.png" alt="image-20220720164322212"></p></li></ul><h4 id="13-3-函数式接口"><a href="#13-3-函数式接口" class="headerlink" title="13.3 函数式接口"></a>13.3 函数式接口</h4><ul><li><p>定义：有且只有一个抽象方法的接口</p></li><li><p>适用于Lambda使用的接口，就是只有一个抽象方法，所以Lambda才能顺利使用</p></li><li><p>格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">修饰符 interface 接口名称&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> 返回值 方法名称(可选参数信息);</span><br><span class="line">    <span class="comment">//其他非抽象方法信息</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>@FunctionalInterface</code>注解：检测接口是否是一个函数式接口</p></li><li><p>调用函数式接口可以使用lambda表达式</p></li></ul><h4 id="13-4-函数式编程"><a href="#13-4-函数式编程" class="headerlink" title="13.4 函数式编程"></a>13.4 函数式编程</h4><ul><li><p>函数式接口作为方法的参数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">startThread</span><span class="params">(Runnable run)</span>&#123;</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(run).start();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">psvm&#123;</span><br><span class="line">    startThread(<span class="keyword">new</span> <span class="title class_">Runnable</span>()&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">            sout(<span class="string">&quot;开启线程&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">//优化</span></span><br><span class="line">    startThread(()-&gt;&#123;</span><br><span class="line">       sout(<span class="string">&quot;开启线程&quot;</span>); </span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>函数式接口作为方法的返回值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Comparator&lt;String&gt; <span class="title function_">getComparator</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;String&gt;()&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(String o1, String o2)</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> o2.length()-o1.length();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">//使用lambda</span></span><br><span class="line">    <span class="keyword">return</span>(String o1, String o2) -&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> o2.length()-o1.length();</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//继续优化</span></span><br><span class="line">    <span class="keyword">return</span>(o1, o2) -&gt; o2.length()-o1.length();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="13-5-常用的函数式接口"><a href="#13-5-常用的函数式接口" class="headerlink" title="13.5 常用的函数式接口"></a>13.5 常用的函数式接口</h4><ul><li><p>Supplier接口</p><ul><li><p><code>java.util.function.Supplier&lt;T&gt;</code>:被称为生产型接口，指定的泛型是什么，接口中的get方法就会产生什么类型的数据</p></li><li><p>仅包含一个无参的方法 <code>T get()</code></p></li><li><p>使用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">getString</span><span class="params">(Supplier&lt;String&gt; sup)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> suo.get();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">psvm&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> getString(()-&gt;&#123;</span><br><span class="line">       <span class="comment">//重写get方法</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;get方法返回&quot;</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//优化</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> getString(()-&gt;<span class="string">&quot;get方法返回&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p><u><em>Supplier接口练习：day0720/SupplierDemo.java</em></u>：使用Supplier接口求数组最大值</p></li><li><p>Consumer接口</p><ul><li><p><code>java.util.Consumer&lt;T&gt;</code>：消费型接口，泛型是什么，就使用accpt方法消费什么类型数据</p></li><li><p><code>void accept()</code></p></li><li><p>使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">(String name, Consumer&lt;String&gt; con)</span>&#123;</span><br><span class="line">    co.accept(name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">psvm&#123;</span><br><span class="line">    method(<span class="string">&quot;jack&quot;</span>, <span class="keyword">new</span> <span class="title class_">Consumer</span>&lt;String&gt;&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(String name)</span>&#123;</span><br><span class="line">            sout(name);</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    method(<span class="string">&quot;jack&quot;</span>,(name)-&gt;&#123;</span><br><span class="line">        sout(name);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Consumer接口的默认方法：<code>andThen</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">default</span> Consumer&lt;T&gt; <span class="title function_">andThen</span><span class="params">(Consumer&lt;? <span class="built_in">super</span> T&gt; after)</span>&#123;</span><br><span class="line">    Objects.requireNonNull(after);</span><br><span class="line">    <span class="keyword">return</span> (T t) -&gt; &#123;accept(t);after.accept(t);&#125;;</span><br><span class="line">&#125;<span class="comment">//组合使用两个Consumer接口的accept方法，谁写前面，谁先消费</span></span><br><span class="line"></span><br><span class="line">Consumer&lt;String&gt; con1;</span><br><span class="line">Consumer&lt;String&gt; con2;</span><br><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">那么</span><br><span class="line">con1.accept(s);</span><br><span class="line">con2.accept(s);</span><br><span class="line">等价于</span><br><span class="line">con1.andThen(con2).accept(s);</span><br></pre></td></tr></table></figure><p><u><em>Consumer接口练习：day0720/ConsumerDemo.java</em></u>：使用Consumer接口拼接字符串</p></li></ul></li><li><p>Predicate接口</p><ul><li><p><code>java.function.Predicate&lt;T&gt;</code>接口：对某种数据类型进行判断，结果返回一个boolean</p></li><li><p><code>boolean test(T t)</code></p></li><li><p>默认方法：</p><ul><li><p><code>and()</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">default</span> Predicate&lt;T&gt; <span class="title function_">and</span><span class="params">(Predicate&lt;? <span class="built_in">super</span> T&gt; other)</span>&#123;</span><br><span class="line">    Objects.requireNonNull(after);</span><br><span class="line">    <span class="keyword">return</span> (t) -&gt; test(t) &amp;&amp; other.test(t);</span><br><span class="line">&#125;<span class="comment">//组合使用两个Consumer接口的accept方法，谁写前面，谁先消费</span></span><br><span class="line"></span><br><span class="line">pre1.and(pre2).test(t);<span class="comment">//t要满足pre1和pre2的两个才为true</span></span><br></pre></td></tr></table></figure></li><li><p><code>or()//或者</code></p></li><li><p><code>negate()//取反</code></p></li></ul></li></ul></li><li><p>Function接口</p><ul><li><code>java.function.Function&lt;T,R&gt;</code>接口：用来将T类型的数据转换为R类型的数据</li><li><code>R apply(T t)</code></li><li>默认方法： <code>andThen</code>：用来组合操作</li></ul></li></ul><h3 id="0721-十四"><a href="#0721-十四" class="headerlink" title="0721 十四"></a>0721 十四</h3><h4 id="14-1-Stream流"><a href="#14-1-Stream流" class="headerlink" title="14.1 Stream流"></a>14.1 Stream流</h4><ul><li><p>传统集合循环遍历的弊端：若有多层条件。则需要多次循环筛选</p></li><li><p>使用Stream流的方式进行集合的遍历：JDK1.8，关注的是做什么而不是怎么做</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">list.Stream().filter(name -&gt; name.starsWith(<span class="string">&quot;张&quot;</span>))</span><br><span class="line">     .fliter(name -&gt; name.length() == <span class="number">3</span>)</span><br><span class="line">       .forEach(name -&gt; sout(name));<span class="comment">//筛选出list中以张开头长度为三的对象</span></span><br><span class="line">    <span class="comment">//filter方法内传入的是Predicate接口</span></span><br><span class="line"><span class="comment">//filter(Predicate&lt;? super T&gt; predicate) </span></span><br><span class="line">    <span class="comment">//forEach(Consumer&lt;? super T&gt; action) </span></span><br></pre></td></tr></table></figure></li><li><p>使用流：获取数据源 -&gt; 数据转换 -&gt; 执行操作获取想要结果（每次转换原有的Stream对象不变，返回一个新的Stream对象）</p></li><li><p>获取流；</p><ul><li>所有的Collection都可以通过<code>default Stream&lt;E&gt; stream()</code>方法获取流（必须是单列集合，Map集合要分别把键值单独生成为相应的单列集合再转换） </li><li>Stream接口的静态方法<code>static&lt;T&gt; Stream&lt;T&gt; of(T t)</code>可以获取数组对应的流</li></ul></li><li><p>常用方法：</p><ul><li><p>延迟方法:可以用来链式编程</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;T&gt; <span class="title function_">filter</span><span class="params">(Predicate&lt;? <span class="built_in">super</span> T&gt; predicate)</span>;</span><br><span class="line">&lt;R&gt; Stream&lt;R&gt; <span class="title function_">map</span><span class="params">(Function&lt;? <span class="built_in">super</span> T,? extends R&gt; mapper)</span>;<span class="comment">//将一个流映射到另一个流中</span></span><br><span class="line">Stream&lt;T&gt; <span class="title function_">limit</span><span class="params">(<span class="type">long</span> maxSize)</span>;<span class="comment">//截取前maxSize个元素</span></span><br><span class="line">Stream&lt;T&gt; <span class="title function_">skip</span><span class="params">(<span class="type">long</span> n)</span>;<span class="comment">//跳过前n个元素</span></span><br><span class="line"><span class="keyword">static</span> &lt;T&gt; Stream&lt;T&gt; <span class="title function_">concat</span><span class="params">(Stream&lt;? extends T&gt; a, Stream&lt;? extends T&gt; b)</span>;<span class="comment">//组合两个流</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;String&gt; stream = Stream.of(<span class="string">&quot;1&quot;</span>, <span class="string">&quot;2&quot;</span>, <span class="string">&quot;3&quot;</span>);</span><br><span class="line"><span class="comment">//使用map方法将其转换为Integer数据类型</span></span><br><span class="line">Stream&lt;Integer&gt; stream2 = stream.map((String s)-&gt;&#123;</span><br><span class="line">    <span class="keyword">return</span> Integer.parseInt(s);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li><p>终结方法：使用之后就不能再使用Stream流的方法了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">forEach</span><span class="params">(Consumer&lt;? <span class="built_in">super</span> T&gt; action)</span>;<span class="comment">//用来遍历</span></span><br><span class="line"><span class="type">long</span> <span class="title function_">count</span><span class="params">()</span>;<span class="comment">//返回流中的元素个数</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>Stream流的特点：只能被使用一次，第一个Stream流调用方法完毕，返回一个Stream流，此时就不能再用了</p></li><li><u><em>集合元素处理练习：day0721/StreamDemo.java</em></u>：使用Stream实现集合的元素处理</li></ul><h4 id="14-2-方法引用"><a href="#14-2-方法引用" class="headerlink" title="14.2 方法引用"></a>14.2 方法引用</h4><ul><li><p>在使用lambda表达式的时候，我们实际上传递进去的代码是一种解决方案：拿什么参数做什么操作，那么考虑一种情况：我们在lambda中所指定的操作已经有地方存在相同方案，则没有必要再写重复逻辑。</p></li><li><p>使用前提：对象和方法都是已经存在的</p></li><li><p><code>::</code> 为引用运算符，它所在的表达式被称为方法引用</p><ul><li><code>lambda: s-&gt; System.out.println(s);</code></li><li><code>方法引用:System.out::println</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">printString</span><span class="params">(Printable data)</span>&#123;</span><br><span class="line">    data.print(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">psvm()&#123;</span><br><span class="line">printString(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>通过对象名引用成员方法（前提：对象存在，成员方法存在）</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">printString</span><span class="params">(Printable p)</span>&#123;</span><br><span class="line">    p.print(<span class="string">&quot;Hello&quot;</span>);<span class="comment">//Printable为一个抽象接口，只有一个print方法</span></span><br><span class="line">&#125;</span><br><span class="line">psvm()&#123;</span><br><span class="line">    printString((s) -&gt; &#123;</span><br><span class="line">        <span class="type">MethodRerObject</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MethodRerObject</span>();</span><br><span class="line">        obj.printUpperCaseString(s);<span class="comment">//方法的作用为将输入的字符串大写打出</span></span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">//采用方法引用优化lambda</span></span><br><span class="line">    <span class="comment">//对象MethodRerObject存在，成员方法printUpperCaseString()也存在</span></span><br><span class="line">    <span class="comment">//所以使用对象名引用成员方法</span></span><br><span class="line">    <span class="type">MethodRerObject</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MethodRerObject</span>();</span><br><span class="line">    printString(obj::printUpperCaseString);</span><br><span class="line">      </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>通过类名引用静态成员方法（前提：类存在，静态成员方法存在）</p><p>格式类似于上面，将对象改为类名</p></li><li><p>通过super引用父类成员方法（前提：super存在，成员方法存在）</p><p>格式类似</p></li><li><p>通过this引用本类成员方法</p></li><li><p>类的构造器（构造方法）的引用 <code>类名称::new</code></p></li><li><p>数组的构造器引用 </p></li></ul><p>​                                   </p><link rel="stylesheet" href="https://cdn1.tianli0.top/gh/zhheo/Post-Abstract-AI@0.15.2/tianli_gpt.css"><script>let tianliGPT_postSelector = '#post #article-container';let tianliGPT_key = 'c9b7741d290063ab872e';</script><script src="https://cdn1.tianli0.top/gh/zhheo/Post-Abstract-AI@0.15.2/tianli_gpt.js"></script>]]></content>
      
      
      <categories>
          
          <category> study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java基础 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
