<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><!-- 百度的html标记--><meta name="baidu-site-verification" content="codeva-bSLYjtWXtR"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>实习 | myl's blog</title><meta name="author" content="myl"><meta name="copyright" content="myl"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="https://javaguide.cn/ https://itwanger.gitee.io/tobebetterjavaer/#/ https://pdai.tech/ 一 基础1 JavaSEhttps://javaguide.cn/java/basis/java-basic-questions-01.html  StringBuilder和StringBuffer:后者是线程安全的，每个公">
<meta property="og:type" content="article">
<meta property="og:title" content="实习">
<meta property="og:url" content="http://yileman.github.io/posts/56035.html">
<meta property="og:site_name" content="myl's blog">
<meta property="og:description" content="https://javaguide.cn/ https://itwanger.gitee.io/tobebetterjavaer/#/ https://pdai.tech/ 一 基础1 JavaSEhttps://javaguide.cn/java/basis/java-basic-questions-01.html  StringBuilder和StringBuffer:后者是线程安全的，每个公">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/defaultArticleCover.jpg">
<meta property="article:published_time" content="2024-03-14T00:00:00.000Z">
<meta property="article:modified_time" content="2024-06-02T07:23:00.528Z">
<meta property="article:author" content="myl">
<meta property="article:tag" content="搬砖">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/defaultArticleCover.jpg"><link rel="shortcut icon" href="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/touxiang.jpg"><link rel="canonical" href="http://yileman.github.io/posts/56035.html"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="preconnect" href="//busuanzi.ibruce.info"><meta name="baidu-site-verification" content="codeva-bSLYjtWXtR"><link rel="stylesheet" href="/css/index.css?v=4.13.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.11.1/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '实习',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-06-02 15:23:00'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><link rel="stylesheet" href="/css/modify.css"><link rel="stylesheet" href="/css/user.css"><link rel="stylesheet" href="/css/rightMenu.css"><link rel="stylesheet" href="/css/iconfont.css"><link rel="stylesheet" href="/css/mouse.css"><link rel="stylesheet" href="https://cdn1.tianli0.top/gh/zhheo/Post-Abstract-AI@0.15.2/tianli_gpt.css"><link rel="stylesheet" href="/css/custom.css" media="defer" onload="this.media='all'"><!-- hexo injector head_end start --><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Zfour/hexo-electric-clock@1.0.6/clock.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Zfour/Butterfly-double-row-display@1.00/cardlistpost.min.css">
<style>#recent-posts > .recent-post-item >.recent-post-info > .article-meta-wrap > .tags:before {content:"\A";
  white-space: pre;}#recent-posts > .recent-post-item >.recent-post-info > .article-meta-wrap > .tags > .article-meta__separator{display:none}</style>
<link rel="stylesheet" href="https://unpkg.com/hexo-butterfly-tag-plugins-plus-chinese@latest/lib/assets/font-awesome-animation.min.css" media="defer" onload="this.media='all'"><link rel="stylesheet" href="https://unpkg.com/hexo-butterfly-tag-plugins-plus-chinese@latest/lib/tag_plugins.css" media="defer" onload="this.media='all'"><script src="https://unpkg.com/hexo-butterfly-tag-plugins-plus-chinese@latest/lib/assets/carousel-touch.js"></script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.1.1"></head><body><div id="loading-box"><div class="pokeball-back"></div><div class="pokeball-loading"><div class="pokeball" id="pokeball-normal"></div><div class="pokeball" id="pokeball-great"></div><div class="pokeball" id="pokeball-ultra"></div><div class="pokeball" id="pokeball-master"></div><div class="pokeball" id="pokeball-safari"></div></div></div><script>(()=>{
  const $loadingBox = document.getElementById('loading-box')
  const $body = document.body
  const preloader = {
    endLoading: () => {
      //- console.log("end")
      $body.style.overflow = 'auto'

      document.getElementById('loading-box').style.transition = 'opacity 3s ease 0s'
      document.getElementById('loading-box').style.opacity = '0'
      setTimeout(function(){
        document.getElementById('loading-box').classList.add("loaded")
      }, 3000);

      //- $loadingBox.classList.add('loaded')
    },
    initLoading: () => {
      $body.style.overflow = ''
      $loadingBox.classList.remove('loaded')
      
    }
  }

  preloader.initLoading()
  //- setTimeout(function(){preloader.endLoading();}, 3000);
  window.addEventListener('load',() => { preloader.endLoading() })
  document.getElementById('loading-box').addEventListener('click',()=> {preloader.endLoading()})

  if (true) {
    document.addEventListener('pjax:send', () => { preloader.initLoading() })
    document.addEventListener('pjax:complete', () => { preloader.endLoading() })
  }
})()</script><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/touxiang.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">23</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">8</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">4</div></a></div><hr class="custom-hr"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page" href="/comments/"><i class="fa-fw fa fa-link"></i><span> 留言板</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://myl-mdimg.oss-cn-beijing.aliyuncs.com/defaultArticleCover.jpg')"><nav id="nav"><span id="blog-info"><a href="/" title="myl's blog"><span class="site-name">myl's blog</span></a></span><div id="menus"></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page" href="/comments/"><i class="fa-fw fa fa-link"></i><span> 留言板</span></a></div></div><center id="name-container"><a id="page-name" href="javascript:scrollToTop()">PAGE_NAME</a></center><div id="nav-right"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div id="randomPost"><a class="site-page social-icon search" href="javascript:;" onclick="randomPost()" title="随机访问一篇文章"><i class="fas fa-circle-notch fa-fw"></i></a></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">实习</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-03-14T00:00:00.000Z" title="发表于 2024-03-14 08:00:00">2024-03-14</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-06-02T07:23:00.528Z" title="更新于 2024-06-02 15:23:00">2024-06-02</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/study/">study</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="实习"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><div class="top-img" style="background-image: url('https://myl-mdimg.oss-cn-beijing.aliyuncs.com/defaultArticleCover.jpg');"></div><article class="post-content" id="article-container"><p><a target="_blank" rel="noopener" href="https://javaguide.cn/">https://javaguide.cn/</a></p>
<p><a target="_blank" rel="noopener" href="https://itwanger.gitee.io/tobebetterjavaer/#/">https://itwanger.gitee.io/tobebetterjavaer/#/</a></p>
<p><a target="_blank" rel="noopener" href="https://pdai.tech/">https://pdai.tech/</a></p>
<h2 id="一-基础"><a href="#一-基础" class="headerlink" title="一 基础"></a>一 基础</h2><h3 id="1-JavaSE"><a href="#1-JavaSE" class="headerlink" title="1 JavaSE"></a>1 JavaSE</h3><p><a target="_blank" rel="noopener" href="https://javaguide.cn/java/basis/java-basic-questions-01.html">https://javaguide.cn/java/basis/java-basic-questions-01.html</a></p>
<ul>
<li><code>StringBuilder</code>和<code>StringBuffer</code>:后者是线程安全的，每个公开方法都被<code>synchronized</code> 修饰了</li>
</ul>
<blockquote>
<p>hashMap新增元素</p>
</blockquote>
<p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/image-20240314172246695.png" alt="image-20240314172246695" style="zoom:67%;"></p>
<hr>
<blockquote>
<p>ThreadLocal内存泄漏</p>
</blockquote>
<p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/image-20240315170346022.png" alt="image-20240315170346022" style="zoom: 33%;"></p>
<ul>
<li>一个<code>Thread</code>里面有多个<code>ThreadLocal</code>对象，每个<code>ThreadLocal</code>对象对应一个值，所有的<code>ThreadLocal</code>放在<code>ThreadLocalMap</code>中，里面有一个<code>Entry</code>数组，根据<code>ThreadLocal</code>对象的哈希值来确定在数组中的位置。</li>
<li>内存泄露的根本原因：</li>
</ul>
<p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/image-20240315170633122.png" alt="image-20240315170633057" style="zoom: 50%;"></p>
<ul>
<li><code>ThreadLocalMap</code> 中使用的 key 为 <code>ThreadLocal</code> 的弱引用，而 value 是强引用。所以，如果 <code>ThreadLocal</code> 没有被外部强引用的情况下，在垃圾回收的时候，key 会被清理掉，而 value 不会被清理掉。</li>
<li>如果ThreadLocal没有外部强引用，那么在发生垃圾回收的时候，ThreadLocal就必定会被回收，而ThreadLocal又作为Map中的key，ThreadLocal被回收就会导致一个key为null的entry，外部就无法通过key来访问这个entry，垃圾回收也无法回收，这就造成了内存泄漏</li>
<li>如何防止：<code>ThreadLocal</code>的<code>remove()</code>方法<ul>
<li>在get和set的方法中可能会调用这个remove方法</li>
<li>ThreadLocal虽然提供了避免内存泄露的方法，但是ThreadLocal不会主动去执行这些方法，需要我们在使用完ThreadLocal对象中保存的数据后，在<strong>finally{}代码块中调用ThreadLocal的remove()方法</strong>，加快GC自动垃圾回收，避免内存泄露。</li>
</ul>
</li>
</ul>
<hr>
<blockquote>
<p>synchronized底层原理</p>
</blockquote>
<ul>
<li>Java 对象底层都会关联一个 monitor，使用 synchronized 时 JVM 会根据使用环境找到对象的 monitor，根据 monitor 的状态进行加解锁的判断。如果成功加锁就成为该 monitor 的唯一持有者，monitor 在被释放前不能再被其他线程获取。</li>
<li>执行 monitorenter 指令时，首先尝试获取对象锁。如果这个对象没有被锁定，或当前线程已经持有锁，就把锁的计数器加 1，执行 monitorexit 指令时会将锁计数器减 1。一旦计数器为 0 锁随即就被释放。cc</li>
</ul>
<hr>
<blockquote>
<p>重写equals方法的时候为什么一定要重写hashcode方法？</p>
</blockquote>
<ul>
<li>通常判断两个对象是否相等会先判断<code>hashcode()</code>返回值，如果不等则一定不等，相等了就继续判断<code>equals()</code>——性能</li>
<li>以HashMap举例，当put元素的时候：<ul>
<li>会先计算对象的<code>hashcode()</code>,而Object方法中的<code>hashcode()</code>对比的是不同对象的地址，所以结果一定是false，导致这个元素被认为是新的key被添加，就会出现重复key的情况</li>
</ul>
</li>
<li>Set也是这样</li>
</ul>
<hr>
<blockquote>
<p>获取.Class方式</p>
</blockquote>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Class</span> <span class="variable">alunbarClass</span> <span class="operator">=</span> TargetObject.class; <span class="comment">// 知道了具体的类</span></span><br><span class="line"><span class="type">Class</span> <span class="variable">alunbarClass1</span> <span class="operator">=</span> Class.forName(<span class="string">"cn.javaguide.TargetObject"</span>); <span class="comment">// Class.forName传入全路径</span></span><br><span class="line"><span class="type">Class</span> <span class="variable">alunbarClass2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TargetObject</span>().getClass(); <span class="comment">// 通过对象实例getClass()方法</span></span><br><span class="line"><span class="type">Class</span> <span class="variable">alunbarClass3</span> <span class="operator">=</span> ClassLoader.getSystemClassLoader().loadClass(<span class="string">"cn.javaguide.TargetObject"</span>); <span class="comment">// classLoader</span></span><br></pre></td></tr></tbody></table></figure>
<hr>
<blockquote>
<p>ArrayList 扩容？</p>
</blockquote>
<ul>
<li><p><code>grow()</code>函数</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">newCapacity</span> <span class="operator">=</span> oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>); <span class="comment">// 每次扩容1.5倍</span></span><br><span class="line"><span class="comment">// 如果小于最小容量，就设置newCapacity为最小容量</span></span><br><span class="line"><span class="comment">// 如果大于最大容量，则更新最大容量</span></span><br></pre></td></tr></tbody></table></figure>
</li>
</ul>
<blockquote>
<p>RandomAccess 接口</p>
</blockquote>
<ul>
<li>一个标记接口，表明实现该接口的类支持随机访问</li>
</ul>
<blockquote>
<p>hashMap 扩容</p>
</blockquote>
<ul>
<li><code>resize()</code>：会伴随一次重新的hash分配，遍历hash表中的所有元素，非常耗时</li>
<li>扩容为原来的两倍</li>
</ul>
<blockquote>
<p>ConcurrentHashMap</p>
</blockquote>
<ul>
<li>1.7之前<ul>
<li>由多个segment数组组成，每个segment是一个类似于HashMap的结构，可以扩容，但是segment数组不能扩</li>
<li>默认是16个segment，也就是默认的并发数量16</li>
</ul>
</li>
<li>1.8及之后<ul>
<li>node数组+链表/红黑树</li>
</ul>
</li>
</ul>
<blockquote>
<p>CopyOnWriteArrayList</p>
</blockquote>
<ul>
<li>写时复制，只有写写操作的时候才会互斥</li>
</ul>
<blockquote>
<p>为什么String不可变</p>
</blockquote>
<ul>
<li>线程安全</li>
<li>缓存Hash值，将String作为Key在hash表中查找时，由于hashCode不变，所以查找速度快</li>
<li>安全性，如果可以变的话会被攻击（密码），因为string不可变，所以对应的hash也不可变</li>
<li>避免重复创建字符串，提高效率</li>
</ul>
<h3 id="2-Spring"><a href="#2-Spring" class="headerlink" title="2 Spring"></a>2 Spring</h3><blockquote>
<p>Spring、Spring boot、Spring MVC</p>
</blockquote>
<ul>
<li>Spring是一个IOC容器，用来管理Bean，使用依赖注入来实现控制反转，可以很方便的整合各种框架，提供AOP机制弥补面向对象的OOP的代码重复问题，更方便的将不同类不同方法中的共同处理抽取成切面、自动注入给方法执行，比如日志、异常等</li>
<li>Spring MVC是spring对web框架的一个解决方案，提供了一个总的前端控制器servlet：DispatcherServlet，用来接收请求，然后定义了一套路由策略（从url到handle 的映射）以及适配执行handle，将handler结果使用视图解析技术生成视图展现给前端</li>
<li>springboot是spring提供的一个快速开发工具包，让程序员更方便、更快速的开发spring+springmvc应用，简化了配置（约定了默认配置），整合了一系列的解决方案（starter机制）、redis、mongodb、es可以开箱即用</li>
</ul>
<hr>
<blockquote>
<p>为什么SpringBoot的jar包可以直接运行</p>
</blockquote>
<ul>
<li>引入了spring-boot-maven-plugin</li>
<li>springBoot程序打包后生成了一个 Fat jar(jar中包含jar)，包含了依赖的jar包和springboot loader相关类</li>
<li><code>java -jar</code>会去找jar中的mainfest文件，在那里找到启动类</li>
</ul>
<blockquote>
<p>SpringBoot如何支持跨域请求</p>
</blockquote>
<ul>
<li><p>CORS：跨源资源共享</p>
<ul>
<li><p>Controller方法上<code>@CrossOrigin("http://localhost:8081")</code>设置某一个接口允许跨域</p>
</li>
<li><p>实现<code>WebMvcConfigurer</code>，重写其中的<code>addCorsMappings(CorsRegistry registry)</code>方法</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyWebMvcConfigurer</span> <span class="keyword">implements</span> <span class="title class_">WebMvcConfigurer</span> {</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addCorsMappings</span><span class="params">(CorsRegistry registry)</span> {</span><br><span class="line">        registry.addMapping(<span class="string">"/user/*"</span>)</span><br><span class="line">            	.allowedOrigins(<span class="string">"http://localhost:8080"</span>)</span><br><span class="line">            	.allowedMethods(<span class="string">"GET"</span>, <span class="string">"POST"</span>, <span class="string">"PUT"</span>, <span class="string">"DELETE"</span>);</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>通过配置一个bean控制所有的请求</p>
</li>
</ul>
</li>
<li><p>Nginx反向代理</p>
<ul>
<li><p>比如前端要发送跨域的请求就统一加上一个 /cors/</p>
</li>
<li><p>在nginx中配置location</p>
<figure class="highlight nginx"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">location</span> /cors/ {</span><br><span class="line">	<span class="attribute">proxy_pass</span> http://localhost:8080/user/;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
</li>
</ul>
</li>
</ul>
<hr>
<blockquote>
<p>spring AOP </p>
</blockquote>
<ul>
<li>AOP 的目的是将横切关注点（如日志记录、事务管理、权限控制、接口限流、接口幂等等）从核心业务逻辑中分离出来，通过动态代理、字节码操作等技术，实现代码的复用和解耦，提高代码的可维护性和可扩展性。</li>
<li>为减少代码冗余，使开发专注于核心业务逻辑，减少代码维护成本而提出的一种思想，是通过动态代理的方式来实现的，将需要注入切面的对象进行代理，在进行调用的时候，将公共的逻辑直接添加进去，而不需要修改原有业务的逻辑代码，只需要在原来的业务逻辑基础之上做一些增强功能即可。<ul>
<li>切面 ==&gt;  公共代码：通知和切点的结合。通知和切点共同定义了切面的全部内容——它是什么，在何时和在何处完成其功能</li>
<li>切点： 定义了需要执行在哪些连接点上执行通知。</li>
<li>连接点：是在应用执行过程中能够插入切面的一个点。</li>
<li>引入：引入允许我们向现有的类添加新方法或属性</li>
<li>织入：把切面应用到目标对象并创建新的代理对象的过程</li>
<li>通知：定义了何时，做什么。<code>@After @Around @Before @AfterReturning @AfterThrowing</code></li>
</ul>
</li>
</ul>
<hr>
<blockquote>
<p>spring IOC</p>
</blockquote>
<ul>
<li>使用的<code>interface ApplicationContext</code>是<code>BeanFactory</code>的子类</li>
<li>继承了多个接口扩展功能</li>
<li><p>有两个具体实现的子类</p>
<ul>
<li><code>ClassPathXmlApplicationContext</code>：从class path 中加载配置文件，更常用一些；</li>
<li><code>FileSystemXmlApplicationContext</code> ：从本地文件中加载配置文件，不是很常用，如果再到 Linux 环境中，还要改路径，不是很方便。</li>
</ul>
</li>
<li><p>通过对象的set方法注入的</p>
</li>
</ul>
<p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/image-20240318205523668.png" alt="image-20240318205523668"></p>
<ul>
<li><p>如何实现一个IOC容器</p>
<p>1、先准备一个基本的容器对象，包含一些map结构的集合，用来方便后续过程中存储具体的对象</p>
<p>2、进行配置文件的读取工作或者注解的解析工作，将需要创建的bean对象都封装成BeanDefinition对象存储在容器中</p>
<p>3、容器将封装好的BeanDefinition对象通过反射的方式进行实例化，完成对象的实例化工作</p>
<p>4、进行对象的初始化操作，也就是给类中的对应属性值就行设置，也就是进行依赖注入，完成整个对象的创建，变成一个完整的bean对象，存储在容器的某个map结构中</p>
<p>5、通过容器对象来获取对象，进行对象的获取和逻辑处理工作</p>
<p>6、提供销毁操作，当对象不用或者容器关闭的时候，将无用的对象进行销毁</p>
</li>
</ul>
<p>注意：依赖注入是实现IOC的一个方法</p>
<hr>
<blockquote>
<p>bean生命周期</p>
</blockquote>
<ul>
<li>Bean容器找到配置文件中的bean，通过反射创建，用set()方法赋值</li>
<li>如果 Bean 实现了 <code>BeanNameAware</code> 接口，调用 <code>setBeanName()</code>方法，传入 Bean 的名字。</li>
<li>如果实现了 <code>*.Aware</code>接口，就调用相应的方法。<ul>
<li>如果 Bean 实现了 <code>BeanClassLoaderAware</code> 接口，调用 <code>setBeanClassLoader()</code>方法，传入 <code>ClassLoader</code>对象的实例。</li>
<li>如果 Bean 实现了 <code>BeanFactoryAware</code> 接口，调用 <code>setBeanFactory()</code>方法，传入 <code>BeanFactory</code>对象的实例。</li>
</ul>
</li>
<li>如果有和加载这个 Bean 的 Spring 容器相关的 <code>BeanPostProcessor</code> 对象，执行<code>postProcessBeforeInitialization()</code> 方法</li>
<li>如果 Bean 实现了<code>InitializingBean</code>接口，执行<code>afterPropertiesSet()</code>方法。</li>
<li>如果 Bean 在配置文件中的定义包含 init-method 属性，执行指定的方法。</li>
<li><p>如果有和加载这个 Bean 的 Spring 容器相关的 <code>BeanPostProcessor</code> 对象，执行<code>postProcessAfterInitialization()</code> 方法</p>
</li>
<li><p>使用</p>
</li>
<li>当要销毁 Bean 的时候，如果 Bean 实现了 <code>DisposableBean</code> 接口，执行 <code>destroy()</code> 方法。</li>
<li>当要销毁 Bean 的时候，如果 Bean 在配置文件中的定义包含 destroy-method 属性，执行指定的方法。</li>
</ul>
<p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/image-20240318205941719.png" alt="image-20240318205941719"></p>
<hr>
<blockquote>
<p>spring中的设计模式</p>
</blockquote>
<ul>
<li>工厂模式<ul>
<li><code>BeanFactory</code></li>
<li><code>ApplicationContext</code></li>
</ul>
</li>
<li>单例模式<ul>
<li>bean的默认作用域就是单例</li>
</ul>
</li>
<li>代理模式<ul>
<li>AOP动态代理</li>
</ul>
</li>
<li>模板方法设计模式<ul>
<li>jdbcTemplate</li>
<li>redistemplate</li>
</ul>
</li>
<li>观察者设计模式</li>
<li>适配器设计模式<ul>
<li>在Spring MVC中，DispatcherServlet根据请求信息调用HandlerMapping，解析请求对应的Handler，解析到对应的Handler（也就是我们常说的Controller控制器）后，开始由HandlerAdapter适配器处理</li>
</ul>
</li>
<li>装饰者设计模式<ul>
<li>Spring 中配置DataSource的时候，DataSource可能是不同的数据库和数据源。我们能否根据客户的需求在少修改原有类的代码下切换不同的数据源？这个时候据需要用到装饰者模式。</li>
</ul>
</li>
</ul>
<hr>
<blockquote>
<p>Spring 依赖注入的方式</p>
</blockquote>
<ul>
<li>能注入的数据类型<ul>
<li>基本类型+String</li>
<li>其他的bean</li>
<li>复杂类型/集合类型</li>
</ul>
</li>
<li>注入方式<ul>
<li>使用构造函数</li>
<li>set方法</li>
<li>注解</li>
</ul>
</li>
</ul>
<hr>
<blockquote>
<p>自动装配 - SpringBoot约定大于配置的理念的产物</p>
</blockquote>
<ul>
<li><p>依赖注入的plus，简化了依赖注入的配置而生成的</p>
</li>
<li><p>主启动类上的注解<strong><code>@SpringbootApplication</code></strong>是一个复合注解，其中比较重要的</p>
<ul>
<li><code>@SpringbootConfiguration</code>：springboot的相关配置</li>
<li><code>@EnableAutoConfiguration</code></li>
<li><code>@ComponentScan</code>：扫描一些包并注入</li>
</ul>
</li>
<li>重点<strong><code>@EnableAutoConfiguration</code></strong>，也是一个复合注解<ul>
<li><code>@import(AutoConfigurationImportSelect.class)</code></li>
</ul>
</li>
<li><p><code>AutoConfigurationImportSelect</code> implements了<strong><code>DeferredImportSelector</code></strong></p>
<ul>
<li><p>因为是Deferred,所以自动配置类会放在最后加载,方便扩展和覆盖</p>
</li>
<li><p>其中重写了<strong><code>selectImports()</code></strong>方法：获取所有符合条件的类的全限定类名，加载到IOC容器中</p>
<ul>
<li><p>判断是否开启了自动装配：<code>spring.boot.enableautoconfiguration=true</code></p>
</li>
<li><p>获取<code>@EnableAutoConfiguration</code>中的<code>exclude</code>和<code>excludeName</code></p>
</li>
<li><p>读取所有spring boot start下面的classpath:/META-INF/spring.factories文件(key-value形式)</p>
</li>
<li><p>通过<code>@ConditionalOn</code>排除无效的自动配置类</p>
</li>
</ul>
</li>
</ul>
</li>
<li>配置文件的信息如何加载到bean中：classpath:/META-INF/spring.factories文件存储了一些键信息（<strong>SpringBoot约定大于配置的理念</strong>），然后加载的时候配置文件的值就被加载到这个文件中了</li>
<li>两种<ul>
<li><code>@Autowired</code>：根据类型自动注入<ul>
<li><code>@Qualifier</code>：格外指定bean的id（当IOC根据属性类型去容器中找找到多个相同类型的组件的时候需要使用）</li>
</ul>
</li>
<li><code>@Resource</code>：根据bean的名称自动注入<ul>
<li>这个是Java规范</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<blockquote>
<p>代理</p>
</blockquote>
<ul>
<li><p>不直接访问目标类,而是通过访问代理类来实现目标类方法,形成方法增强</p>
</li>
<li><p>静态代理</p>
<ul>
<li>预先编写,执行前有了编译好的字节码文件</li>
</ul>
</li>
<li>动态代理<ul>
<li>JDK动态代理：<ul>
<li><code>Proxy</code> 类的<code>newProxyInstance()</code>来生成代理对象</li>
<li>实现<code>invocationHandler</code>,重写<code>invoke()</code>方法实现代理类方法的增强</li>
<li>通过反射执行</li>
<li><code>getInstance()</code>传入代理对象 生成代理类</li>
</ul>
</li>
<li>CGLIB<strong>(Spring AOP默认)</strong><ul>
<li><code>Enhancer</code>类的<code>create()</code>方法创建代理类</li>
<li>实现<code>MethodInterceptor</code>，重写<code>intercept()</code>方法实现增强</li>
<li>why Spring AOP默认:非接口代理</li>
</ul>
</li>
</ul>
</li>
<li>对比jdk和cglib<ul>
<li>都是运行期间生成字节码，jdk直接生成class字节码，cglib使用ASM框架写的class字节码。后者更加复杂，代理类生成效率更低</li>
<li>jdk动态代理是通过反射机制来执行方法，cglib是通过FastClass机制（索引分配直接调用）直接调用方法，后者动态代理类执行效率更高</li>
</ul>
</li>
</ul>
<hr>
<blockquote>
<p>spring boot 常用注解</p>
</blockquote>
<ul>
<li><code>@RestController</code> &lt;==&gt; <code>@Controller</code> + <code>@ResponseBody</code> ：返回的是json，不能返回html页面</li>
<li><code>@ResquestMapping</code> ，<code>@PutMapping</code> ，<code>@PGetMapping</code> ，<code>@PostMapping</code> ，<code>@DeleteMapping</code> </li>
<li><code>@PathVarible</code> </li>
<li><p><code>@Value</code>，<code>@Autowired</code> ，<code>@Resource</code></p>
</li>
<li><p><code>@ControllerAdvice</code> ，<code>@ExceptionHandler</code></p>
</li>
<li><p><code>@Configuration</code>，<code>@Component</code> ， <code>@Service</code>，<code>@Mapper</code></p>
</li>
<li><code>@Transactional</code></li>
<li><code>@FeignClient</code></li>
</ul>
<hr>
<blockquote>
<p>Spring MVC 过程</p>
</blockquote>
<p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/image-20240308102514363.png" alt="image-20240308102514363"></p>
<ul>
<li><code>filter</code>：在1和11过程中发挥作用</li>
<li><code>interceptor</code>：<ul>
<li><code>preHandle()</code>方法在4之前的时候执行</li>
<li><code>postHandle()</code>在9之前完成</li>
<li><code>afterCompletion()</code>在10渲染完成后执行</li>
</ul>
</li>
<li>过滤器和拦截器一般使用<ul>
<li>前者一般用于过滤敏感词汇（sql注入）、设置字符编码、URL权限访问控制、压缩响应信息</li>
<li>后者一般用于登录验证（JWT）、访问资源权限验证、日志记录、处理cookie、本地化/国际化/主题、性能监控：请求处理时长</li>
</ul>
</li>
</ul>
<hr>
<blockquote>
<p>spring 三级缓存</p>
</blockquote>
<ul>
<li><p>解决循环依赖</p>
<ul>
<li>前提：单例bean；依赖注入的方式不能全是构造器注入的方式</li>
</ul>
</li>
<li><p>一级缓存singletonObjects：已经初始化好的bean，即已经完成初始化好的注入对象的代理</p>
</li>
<li><p>二级缓存earlySingletonObjects：还没有完全被初始化好的中间对象代理</p>
</li>
<li><p>三级缓存singletonFactory：存放的是还未初始化完的bean，不是代理对象</p>
</li>
<li><p>过程：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/daimzh/p/13256413.html">https://www.cnblogs.com/daimzh/p/13256413.html</a></p>
<p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/image-20240321165705162.png" alt="image-20240321165705162" style="zoom: 50%;"></p>
</li>
</ul>
<blockquote>
<p>spring的事务</p>
</blockquote>
<ul>
<li>编程式事务：通过 <code>TransactionTemplate</code>或者<code>TransactionManager</code>手动管理事务，少用</li>
<li>声明式事务：基于AOP实现，一般使用<code>@Transactional</code> 的注解</li>
</ul>
<blockquote>
<p>spring 事务失效</p>
</blockquote>
<ul>
<li>bean对象没有被容器管理</li>
<li>方法修饰符不是public</li>
<li>自身调用自身方法</li>
<li>数据源没有配置事务管理器</li>
<li>数据库不支持事务</li>
<li>异常被捕获</li>
<li>异常类型错误或配置错误</li>
</ul>
<h3 id="3-SpringCloud"><a href="#3-SpringCloud" class="headerlink" title="3 SpringCloud"></a>3 SpringCloud</h3><ul>
<li>配置中心与注册中心:Nacos<ul>
<li>eureka注册中心</li>
</ul>
</li>
<li>统一网关:Gateway</li>
<li>Feign的远程调用<ul>
<li>熔断处理</li>
</ul>
</li>
<li><p>CAP:</p>
<ul>
<li><strong>Consistency</strong>（一致性）：任意时刻都一致</li>
<li><strong>Availability</strong>（可用性）：任意时刻都可用</li>
<li><strong>Partition tolerance</strong>（分区容忍性）:由于分布式系统通过网络进行通信，网络是不可靠的。当任意数量的消息丢失或延迟到达时，系统仍会继续提供服务，不会挂掉</li>
<li>CP：秒杀</li>
<li>CA：银行</li>
</ul>
</li>
<li><p>BASE理论</p>
<ul>
<li><strong>Basically Available</strong>：基本可用</li>
<li><strong>Soft-state</strong>：软状态</li>
<li><strong>Eventually Consistent</strong>：最终一致</li>
</ul>
</li>
</ul>
<blockquote>
<p>事务一致性</p>
</blockquote>
<ul>
<li>事务四大特：原子性、一致性、隔离性、持久性</li>
<li>事务一致性是指数据库处理前后结果应与其所抽象的客观世界中真实状况保持一致。<ul>
<li>银行AB转账，总和为100(A50 B50)，转账后不可能为A-50 B150</li>
</ul>
</li>
</ul>
<blockquote>
<p>数据一致性</p>
</blockquote>
<ul>
<li>根本原因在于数据的复制</li>
<li>强一致性：CP<ul>
<li>主库更新后会一直等待所有从库更新再返回更新成功。保证了主从一直一致，保证了数据的完整性</li>
<li>银行</li>
</ul>
</li>
<li>弱一致性：AP： 最终一致性、读写一致性、单调读、因果一致性<ul>
<li>主库更新后就直接返回更新成功</li>
<li>互联网场景一般使用这个来保证高可用</li>
</ul>
</li>
</ul>
<h3 id="4-Git"><a href="#4-Git" class="headerlink" title="4 Git"></a>4 Git</h3><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/面试准备.assets/image-20240307145205270.png" alt="image-20240307145205270" style="zoom: 67%;"></p>
<ul>
<li><p>rebase和merge</p>
<ul>
<li><p>merge就是直接合</p>
</li>
<li><p>rebase会分块</p>
<p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/面试准备.assets/image-20240307145801991.png" alt="image-20240307145801991" style="zoom:50%;"></p>
</li>
</ul>
</li>
</ul>
<h3 id="5-Linux"><a href="#5-Linux" class="headerlink" title="5 Linux"></a>5 Linux</h3><ul>
<li><p>切换用户</p>
<figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">su yao               <span class="comment">#切换为用户"yao",输入后回车需要输入该用户的密码</span></span><br><span class="line">  <span class="built_in">exit</span>               <span class="comment">#退出当前用户</span></span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>目录</p>
<figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> <span class="comment"># 切换</span></span><br><span class="line"><span class="built_in">ls</span> <span class="comment"># 查看</span></span><br><span class="line">ll <span class="comment"># 查看详细信息</span></span><br><span class="line"><span class="built_in">mkdir</span> <span class="comment"># 创建</span></span><br><span class="line"><span class="built_in">rm</span> <span class="comment"># 删除remove</span></span><br><span class="line"><span class="built_in">mv</span> <span class="comment"># 移动move</span></span><br><span class="line"><span class="built_in">cp</span> <span class="comment"># 拷贝 copy</span></span><br><span class="line">find <span class="comment"># 搜索</span></span><br><span class="line"><span class="built_in">pwd</span> <span class="comment"># 显示当前路径</span></span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>文件</p>
<figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">rm</span></span><br><span class="line"><span class="built_in">mv</span></span><br><span class="line">vi  <span class="comment"># 编辑</span></span><br><span class="line">vim <span class="comment"># 编辑 更高级</span></span><br><span class="line"><span class="built_in">chmod</span> <span class="comment"># 授权</span></span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>权限说明</p>
<figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 'r' 代表可读（4），'w' 代表可写（2），'x' 代表执行权限</span></span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>压缩与解压</p>
<figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#  .zip、.rar        //windows系统中压缩文件的扩展名</span></span><br><span class="line"><span class="comment">#  .tar              //Linux中打包文件的扩展名</span></span><br><span class="line"><span class="comment">#  .gz               //Linux中压缩文件的扩展名</span></span><br><span class="line"><span class="comment">#  .tar.gz           //Linux中打包并压缩文件的扩展名</span></span><br><span class="line">tar -zxvf a.tar                      <span class="comment">#解包至当前目录</span></span><br><span class="line">tar -zcvf a.tar file1 file2,...      <span class="comment">#多个文件压缩打包</span></span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>安装</p>
<figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">rpm -ivh httpd-2.2.3-22.0.1.el5.i386.rpm    <span class="comment"># 使用rpm文件安装apache </span></span><br><span class="line">rpm -uvh httpd-2.2.3-22.0.1.el5.i386.rpm    <span class="comment"># 使用rpm更新apache </span></span><br><span class="line">rpm -ev httpd								<span class="comment"># 卸载/删除apache </span></span><br><span class="line">yum install httpd      						<span class="comment"># 使用yum安装apache   </span></span><br><span class="line">yum update httpd       						<span class="comment"># 更新apache </span></span><br><span class="line">yum remove httpd       						<span class="comment"># 卸载/删除apache </span></span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>运行docker</p>
<figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl start docker</span><br></pre></td></tr></tbody></table></figure>
</li>
</ul>
<blockquote>
<p>文件描述符File descriptor（fd）</p>
</blockquote>
<ul>
<li>内核为了高效管理这些已经被打开的文件所创建的<strong>索引</strong></li>
<li>所有执行IO操作的系统调用都通过文件描述符来实现</li>
<li>0是标准输入，1是标准输出，2是标准错误</li>
<li>打开一个文件，它的文件描述符会是3，再打开一个文件文件描述符就是4…</li>
</ul>
<h3 id="6-Docker"><a href="#6-Docker" class="headerlink" title="6 Docker"></a>6 Docker</h3><ul>
<li><p>镜像（image）：Docker将应用程序及其所需的依赖、函数库、环境、配置等文件打包在一起，称为镜像。</p>
</li>
<li><p>容器（Container）：镜像中的应用程序运行后形成的进程就是<strong>容器</strong>，只是Docker会给容器做隔离，对外不可见。</p>
</li>
<li><p>通过命令启动docker：</p>
<figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">systemctl start docker  <span class="comment"># 启动docker服务</span></span><br><span class="line"></span><br><span class="line">systemctl stop docker  <span class="comment"># 停止docker服务</span></span><br><span class="line"></span><br><span class="line">systemctl restart docker  <span class="comment"># 重启docker服务</span></span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>镜像操作</p>
<figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">docker push <span class="comment"># 推送镜像</span></span><br><span class="line">docker pull <span class="comment"># 从服务器拉取镜像</span></span><br><span class="line">docker build <span class="comment"># 构建镜像</span></span><br><span class="line">docker save <span class="comment"># 保存镜像为压缩包</span></span><br><span class="line">docker load <span class="comment"># 加载压缩的镜像</span></span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>容器操作</p>
<figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">docker run <span class="comment"># 镜像加载为容器</span></span><br><span class="line">docker <span class="built_in">exec</span> <span class="comment"># 进入容器执行命令</span></span><br><span class="line">docker logs <span class="comment"># 查看日志</span></span><br><span class="line">docker ps <span class="comment"># 查看所有运行的容器</span></span><br><span class="line">docker pause <span class="comment"># 暂停</span></span><br><span class="line">docker stop <span class="comment"># 容器停止</span></span><br><span class="line">docker start <span class="comment"># 容器启动</span></span><br><span class="line">docker <span class="built_in">rm</span> <span class="comment"># 删除</span></span><br></pre></td></tr></tbody></table></figure>
</li>
</ul>
<h3 id="7-Redis：NoSQL-数据库"><a href="#7-Redis：NoSQL-数据库" class="headerlink" title="7 Redis：NoSQL 数据库"></a>7 Redis：NoSQL 数据库</h3><ul>
<li>见苍穹和学成</li>
<li>主从和哨兵可以解决高可用、高并发读的问题</li>
</ul>
<blockquote>
<p>redis数据类型</p>
</blockquote>
<ul>
<li><p>5种基本数据类型：</p>
<ul>
<li><p>String</p>
</li>
<li><p>List：双向链表数据结构</p>
</li>
<li><p>Hash：类似于HashMap(数组+链表)还做了些优化，一个key下面有多个键值对</p>
<p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/image-20240321105748037.png" alt="image-20240321105748037" style="zoom: 50%;"></p>
</li>
<li><p>Set：类似于HashSet</p>
</li>
<li><p>Zset：有序的set</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SET、 MSET(批量) 、GET 、SETNX 、SETEX 、EXISTS 、DEL 、EXPIRE key seconds 								-- String</span><br><span class="line">RPUSH(尾部/右边添加元素)、LPUSH 、LSET key index value(设置值，指定了索引)、LPOP、RPOP(移除并获取)、LLEN(长度)  -- List</span><br><span class="line">HSET key field value、HMSET key field1 value1 field2 value2...、HGET key field、HEXISTS key field、     -- Hash</span><br><span class="line">SADD key member1 member2 ...、																		  -- Set</span><br><span class="line">SETBIT key offset value、GETBIT key offset、BITOP operation destkey key1 key2...(位运算，and or nor..)   -- Bitmap</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>3种特殊数据类型：</p>
<ul>
<li><p>Bitmap(位图) <code>SETBIT</code>  <code>GETBIT</code>：就是一个01的数组</p>
<p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/image-20240321113223104.png" alt="image-20240321113223104" style="zoom:50%;"></p>
</li>
<li><p>HyperLogLog（基数统计）</p>
</li>
<li><p>Geospatial (地理位置)</p>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>为什么快？</p>
</blockquote>
<ul>
<li>基于内存存储</li>
<li>单线程事件循环和 IO 多路复用</li>
<li>内置了多种优化过后的数据类型/结构实现，性能非常高</li>
</ul>
<blockquote>
<p>redis的IO多路复用</p>
</blockquote>
<ul>
<li>多路指多个网络连接客户端，复用指同一个进程/线程，redis的I/O 多路复用其实是使用一个线程来检查多个Socket的就绪状态，在单个线程中通过记录跟踪每一个socket（I/O流）的状态来管理处理多个I/O流</li>
<li>Reactor设计模式</li>
<li>当一个客户端建立连接的时候，会生成一个套接字描述符（是文件描述符fd的一种）</li>
<li>redis将这个fd注册到监听表中，监听多个fd的读写状态</li>
<li>当有事件产生的时候I/O 多路复用模块就会将那些产生了事件的套接字fd传送给文件事件分派器。</li>
<li>文件事件分派器接收到I/O多路复用程序传来的套接字fd后，并根据套接字产生的事件类型，将套接字派发给相应的事件处理器来进行处理相关命令操作</li>
</ul>
<blockquote>
<p>缓存读写策略</p>
</blockquote>
<ul>
<li>Cache Aside Pattern 旁路缓存模式：适合读比较多的情况<ul>
<li>写：先更新db后删除cache</li>
<li>读：先从cache读，没有数据再从db读，再写入数据到cache</li>
</ul>
</li>
<li>Read/Write Through Pattern 读写穿透 （减小db压力）<ul>
<li>写：先查cache，不存在则更新db；存在则更新cache，然后cache服务自己更新db（同步）</li>
<li>读：从cache读，读到则返回；没读到则从db加载到cache再返回</li>
</ul>
</li>
<li>Write Behind Pattern 异步缓存协议<ul>
<li>写：与上不同之处在于cache服务自己更新db是批量更新（异步）</li>
<li>读：同上</li>
</ul>
</li>
</ul>
<blockquote>
<p>redis的应用场景</p>
</blockquote>
<ul>
<li>缓存</li>
<li>分布式锁：互斥、高可用、可重入、高性能、非阻塞<ul>
<li><code>SETNX lockKey uniqueValue</code>  来获取锁； <code>DEL lockKey</code> 来释放锁</li>
<li>为了防止误删到其他锁，可以使用lua脚本通过key value来判断一下是不是这个锁</li>
<li>为了防止程序突然挂掉，需要给锁设置一个失效时间：<code>SET lockKey uniqueValue EX 3 NX</code>——3s过期，也可以用PX(单位是ms)</li>
</ul>
</li>
<li>限流<ul>
<li>redis+lua(为了保证操作的原子性)+AOP</li>
</ul>
</li>
<li>消息队列（没人用）<ul>
<li>List 数据类型</li>
</ul>
</li>
<li>延时队列<ul>
<li>Redisson 内置了延时队列，基于Sorted Set</li>
</ul>
</li>
<li>分布式session</li>
</ul>
<blockquote>
<p>常见实现</p>
</blockquote>
<ul>
<li><p>购物车用Hash：用户id位key，商品id为field，商品数量为value</p>
</li>
<li><p>排行榜用ZSet</p>
</li>
<li><p>抽奖用Set：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SADD key member1 member2 ...：向指定集合添加一个或多个元素。</span><br><span class="line">SPOP key count：随机移除并获取指定集合中一个或多个元素，适合不允许重复中奖的场景。</span><br><span class="line">SRANDMEMBER key count : 随机获取指定集合中指定数量的元素，适合允许重复中奖的场景。</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>统计活跃用户：bitmap，日期作为key，用户id为offset(类似于数组下标)，活跃就设置为1，没活跃就设置为0</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">SETBIT 20210308 1 1</span><br><span class="line">SETBIT 20210308 2 1</span><br><span class="line">SETBIT 20210309 1 1</span><br><span class="line">// 用户1 两天都登录了， 用户2只在3.8登录</span><br><span class="line"></span><br><span class="line">BITOP and desk1 20210308 20210309</span><br><span class="line">BITCOUNT desk1 //总活跃人数：1(两天都登录)</span><br><span class="line"></span><br><span class="line">BITOP or desk2 20210308 20210309</span><br><span class="line">BITCOUNT desk2 // 在线活跃人数：2(只要登录就行)</span><br></pre></td></tr></tbody></table></figure>
</li>
</ul>
<blockquote>
<p>redis有序集合为什么用跳表不用平衡树、红黑树、B+树</p>
</blockquote>
<ul>
<li>平衡树的插入、删除和查询的时间复杂度和跳表一样都是 O(log n)，但是插入和删除都要额外的维护平衡而旋转(耗时)</li>
<li>红黑树需要通过旋转和染色（红黑变换）来保证黑平衡。并且，按照区间来查找数据这个操作，红黑树的效率没有跳表高。</li>
<li>B+树更适合作为数据库和文件系统中常用的索引结构之一，它核心是为了减少IO来快速定位到索引，但是redis并不需要这个</li>
</ul>
<p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/image-20240321111144680.png" alt="image-20240321111144680" style="zoom:67%;"></p>
<blockquote>
<p>redis持久化</p>
</blockquote>
<ul>
<li>AOF(append only file) ：<code>appendonly yes</code>开启 先写到AOF缓冲区 再写到系统内核缓冲区 最后写到AOF文件<ul>
<li><strong>命令追加（append）</strong>：所有的写命令会追加到 AOF 缓冲区。<ul>
<li>先执行命令后记录日志（mysql相反）<ul>
<li>避免额外的检查开销；不会阻塞当前的命令执行。</li>
<li>风险是可能会发送数据丢失</li>
</ul>
</li>
</ul>
</li>
<li><strong>文件写入（write）</strong>：将 AOF 缓冲区的数据写入到 AOF 文件中。这一步需要调用<code>write</code>函数（系统调用），<code>write</code>将数据写入到了系统内核缓冲区之后直接返回了（延迟写）。注意！！！此时并没有同步到磁盘。</li>
<li><strong>文件同步（fsync）</strong>：AOF 缓冲区根据对应的持久化方式（ <code>fsync</code> 策略）向硬盘做同步操作。这一步需要调用 <code>fsync</code> 函数（系统调用）， <code>fsync</code> 针对单个文件操作，对其进行强制硬盘同步，<code>fsync</code> 将阻塞直到写入磁盘完成后返回，保证了数据持久化。<ul>
<li>fsync：file synchronization</li>
<li>根据刷盘时机可以区分几种AOF方式：write后马上fsync，write后由后台线程fsync，write后由操作系统fsync(linux为30秒)</li>
</ul>
</li>
<li><strong>文件重写（rewrite）</strong>：随着 AOF 文件越来越大，需要定期对 AOF 文件进行重写，达到压缩的目的。</li>
<li><strong>重启加载（load）</strong>：当 Redis 重启时，可以加载 AOF 文件进行数据恢复。</li>
</ul>
</li>
<li>RDB(redis database)：快照（快速恢复）<ul>
<li>save： 同步保存操作，会阻塞 Redis 主线程；</li>
<li>bgsave：fork 出一个子进程，子进程执行，不会阻塞 Redis 主线程，默认选项。</li>
</ul>
</li>
</ul>
<blockquote>
<p>redis线程问题：</p>
</blockquote>
<ul>
<li>单线程：文件事件处理器使用 I/O 多路复用（multiplexing）程序来同时监听多个套接字，I/O 多路复用技术的使用让 Redis 不需要额外创建多余的线程来监听客户端的大量连接，降低了资源的消耗</li>
<li>4.0之后加入了多线程的支持，但是针对大键值对的删除操作</li>
<li>6.0之后就基本多线程了</li>
<li>为什么不使用多线程<ul>
<li>单线程编程容易并且更容易维护；</li>
<li>Redis 的性能瓶颈不在 CPU ，主要在内存和网络；</li>
<li>多线程就会存在死锁、线程上下文切换等问题，甚至会影响性能。</li>
</ul>
</li>
<li>redis后台线程<ul>
<li><code>bio_close_file</code>：释放 AOF / RDB 等过程中产生的临时文件资源。</li>
<li><code>bio_aof_fsync</code>：调用 <code>fsync</code> 函数将系统内核缓冲区还未同步到到磁盘的数据强制刷到磁盘（ AOF 文件）。</li>
<li><code>bio_lazy_free</code>：后台线程释放大对象（已删除）占用的内存空间</li>
</ul>
</li>
</ul>
<blockquote>
<p>redis的过期删除策略</p>
</blockquote>
<ul>
<li>惰性删除：取出key的时候删</li>
<li>定期删除：定期删</li>
</ul>
<blockquote>
<p>redis内存淘汰策略</p>
</blockquote>
<ul>
<li>LRU（最近最少使用）</li>
<li>LFU（最不经常使用）</li>
<li>Random</li>
<li>TTL（生存时间）</li>
<li>Maxmemory Policy（最大内存策略）</li>
</ul>
<blockquote>
<p>redis性能优化</p>
</blockquote>
<ul>
<li><p>使用批量操作减少网络传输 MSET MGET HMGET HMSET SADD</p>
</li>
<li><p>大量key的集中过期问题</p>
<ul>
<li>key随机过期时间</li>
<li>惰性删除</li>
</ul>
</li>
<li><p>避免使用bigkey（大key：value内存过大的key） <code>--bigkeys</code>查找</p>
</li>
<li><p>对于hotkey（热点key） <code>--hotkeys</code>查找</p>
<ul>
<li>读写分离：主节点写，从节点读</li>
<li>使用redis集群，将热点数据分散</li>
<li>采用二级缓存，将 hotkey 存放一份到 JVM 本地内存中</li>
</ul>
</li>
<li><p>内存碎片</p>
<ul>
<li><p>原因</p>
<ul>
<li>Redis 存储存储数据的时候向操作系统申请的内存空间可能会大于数据实际需要的存储空间</li>
<li>频繁的修改reids的数据</li>
</ul>
</li>
<li><p>怎么清理</p>
<figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">config <span class="built_in">set</span> activedefrag <span class="built_in">yes</span></span><br><span class="line"><span class="comment"># 内存碎片占用空间达到 500mb 的时候开始清理</span></span><br><span class="line">config <span class="built_in">set</span> active-defrag-ignore-bytes 500mb</span><br><span class="line"><span class="comment"># 内存碎片率大于 1.5 的时候开始清理</span></span><br><span class="line">config <span class="built_in">set</span> active-defrag-threshold-lower 50</span><br></pre></td></tr></tbody></table></figure>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>redis 生产问题</p>
</blockquote>
<ul>
<li>缓存穿透：大量请求打在不存在的key<ul>
<li>缓存无效的key，设置过期时间</li>
<li>布隆过滤器</li>
<li>接口限流</li>
</ul>
</li>
<li>缓存击穿：热点key失效导致大量请求打在db<ul>
<li>热点数据不过期或者过期时间长</li>
<li>针对热点数据提前预热，提前放到缓存</li>
<li>锁：请求数据库写数据到缓存之前，先获取互斥锁，保证只有一个请求落到数据库上，减少数据库压力</li>
</ul>
</li>
<li>缓存雪崩：大量key同时失效导致大量请求打在db<ul>
<li>针对redis服务器：集群；限流；多级缓存（本地+redis）</li>
<li>针对缓存失效：随机失效时间；缓存预热；</li>
</ul>
</li>
</ul>
<blockquote>
<p>缓存预热的方式</p>
</blockquote>
<ul>
<li>分布式任务调度系统：xxl-job</li>
<li>消息队列</li>
</ul>
<hr>
<blockquote>
<p>如何保证redis和数据库的同步</p>
</blockquote>
<ul>
<li><p><a target="_blank" rel="noopener" href="https://itwanger.gitee.io/tobebetterjavaer/#/docs/mysql/redis-shuju-yizhixing">https://itwanger.gitee.io/tobebetterjavaer/#/docs/mysql/redis-shuju-yizhixing</a><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/image-20240311214614711.png" alt="image-20240311214614711" style="zoom:67%;"></p>
</li>
<li><p>先写mysql再写redis为什么比先写mysql再删redis差？</p>
<ul>
<li><p>如果有多线程修改数据的时候，就可能出现写redis出错，所以直接删除比较好</p>
<p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/面试准备.assets/image-20240311215337895.png" alt="image-20240311215337895" style="zoom:50%;"></p>
</li>
</ul>
</li>
</ul>
<hr>
<h3 id="8-ES"><a href="#8-ES" class="headerlink" title="8 ES"></a>8 ES</h3><ul>
<li><p>Elasticsearch 是一个分布式、RESTful 风格的搜索和数据分析引擎，能够解决不断涌现出的各种用例</p>
</li>
<li><p>倒排索引过程</p>
<p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/学成在线.assets/image-20240304153213090.png" alt="image-20240304153213090" style="zoom:67%;"></p>
</li>
<li><p>概念</p>
<ul>
<li>文档：一条完整的数据，包括索引、名称等，以json方式存储</li>
<li>字段：文档中的具体字段，类似于表格的列</li>
<li>索引：就是相同类型的文档的集合，类似于表。eg：用户的索引、商品的索引、订单的索引…</li>
<li>映射(mapping)：索引中字段的约束信息，类似于表的结构约束。</li>
</ul>
</li>
<li><p>安装ik分词器</p>
</li>
<li><p>索引库的操作</p>
<p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/学成在线.assets/image-20240304154138185.png" alt="image-20240304154138185" style="zoom:67%;"></p>
</li>
<li><p>文档的操作</p>
<p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/学成在线.assets/image-20240304154206085.png" alt="image-20240304154206085" style="zoom:67%;"></p>
</li>
<li><p>搜索结果处理</p>
<ul>
<li>排序</li>
<li>分页</li>
<li>高亮<ul>
<li>给文档中的所有关键字都添加一个标签，例如<code>&lt;em&gt;</code>标签</li>
<li>页面给<code>&lt;em&gt;</code>标签编写CSS样式</li>
</ul>
</li>
</ul>
</li>
<li><p>demo</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testMatchAll</span><span class="params">()</span> <span class="keyword">throws</span> IOException {</span><br><span class="line">    <span class="comment">// 1. 准备Request对象，对应 GET /hotel/_search</span></span><br><span class="line">    <span class="type">SearchRequest</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SearchRequest</span>(<span class="string">"hotel"</span>);</span><br><span class="line">    <span class="comment">// 2. 组织DSL参数 对应 "query": {"match_all": {}}</span></span><br><span class="line">    request.source().query(QueryBuilders.matchAllQuery());</span><br><span class="line">    <span class="comment">// 3. 发送请求，得到相应结果</span></span><br><span class="line">    <span class="type">SearchResponse</span> <span class="variable">response</span> <span class="operator">=</span> client.search(request, RequestOptions.DEFAULT);</span><br><span class="line">    System.out.println(response);</span><br><span class="line">}</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    创建SearchRequest对象，指定索引库名</span></span><br><span class="line"><span class="comment">    利用request.source()构建DSL，DSL中可以包含查询、分页、排序、高亮等</span></span><br><span class="line"><span class="comment">    利用client.search()发送请求，得到响应</span></span><br><span class="line"><span class="comment">关键API：    </span></span><br><span class="line"><span class="comment">    一个是request.source()，其中包含了query、order、from、size、highlight等所有功能</span></span><br><span class="line"><span class="comment">    另一个是QueryBuilders，其中包含了match、term、function_score、bool等各种查询</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>数据聚合：用来实现对数据的统计分析计算等</p>
</li>
</ul>
<h3 id="9-RabbitMQ"><a href="#9-RabbitMQ" class="headerlink" title="9 RabbitMQ"></a>9 RabbitMQ</h3><ul>
<li>概念<ul>
<li>channel：操作MQ的工具</li>
<li>exchange：路由消息到队列中</li>
<li>queue：缓存消息</li>
<li>virtual host：虚拟主机，是对queue、exchange等资源的逻辑分组</li>
</ul>
</li>
<li>常见模型<ul>
<li>基本消息队列</li>
<li>工作消息队列</li>
<li>发布订阅:广播/路由/主题</li>
</ul>
</li>
<li>异步通讯</li>
</ul>
<p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/面试准备.assets/image-20240306162652779.png" alt="image-20240306162652779" style="zoom:67%;"></p>
<blockquote>
<p>死信队列？如何导致？</p>
</blockquote>
<ul>
<li>DLX，全称为 <code>Dead-Letter-Exchange</code>，死信交换器，死信邮箱。当消息在一个队列中变成死信 (<code>dead message</code>) 之后，它能被重新被发送到另一个交换器中，这个交换器就是 DLX，绑定 DLX 的队列就称之为死信队列。</li>
<li>死信的原因<ul>
<li>消息被拒</li>
<li>消息过期</li>
<li>队列满了无法添加</li>
</ul>
</li>
</ul>
<blockquote>
<p> 什么是延时队列</p>
</blockquote>
<ul>
<li>延迟队列指的是存储对应的延迟消息，消息被发送以后，并不想让消费者立刻拿到消息，而是等待特定时间后，消费者才能拿到这个消息进行消费。</li>
<li>实现<ul>
<li>使用死信交换机Exchange和设置消息的存活时间TTL</li>
<li>插件</li>
</ul>
</li>
<li>场景<ul>
<li>订单到期未支付</li>
</ul>
</li>
</ul>
<blockquote>
<p>如何确保消息100%不丢失？</p>
</blockquote>
<ul>
<li>消息丢失可能发生于：消息生产阶段(生产者 -&gt; MQ Broker)、消息存储阶段(MQ内部完成)、消息消费阶段(MQ Broker -&gt; 消费者)</li>
<li>解决：版本递增号校验(多生产端多消费端的时候失效)、全局唯一 ID </li>
<li>具体实现：<ul>
<li>生产者 -&gt; Broker：开启RabbitMQ事务，但是缺点是性能消耗大；<strong>使用confirm机制</strong>，这个是异步的<ul>
<li>代价比较大，需要在生产端额外写相关的确认代码，相对于消息丢失的概率来说代价昂贵</li>
<li><strong>消息入库</strong>：发送成功后生产端修改消息表的state为0，broker接收到后修改为1，生产端需要开一个定时器来检索消息表，确保发送成功</li>
</ul>
</li>
<li>Broker内部：开启rabbitMQ的持久化机制，将消息持久化到磁盘上；设置MQ集群的镜像模式</li>
<li>Broker -&gt; 消费者端：ACK确认机制</li>
</ul>
</li>
</ul>
<blockquote>
<p>如何保证消息的顺序性</p>
</blockquote>
<ul>
<li>拆分多个 queue(消息队列)，每个 queue(消息队列) 一个 consumer(消费者)，就是多一些 queue (消息队列)而已，确实是麻烦点；</li>
<li>或者就一个 queue (消息队列)但是对应一个 consumer(消费者)，然后这个 consumer(消费者)内部用内存队列做排队，然后分发给底层不同的 worker 来处理</li>
<li>用缓存来记录消息的消费情况</li>
</ul>
<blockquote>
<p> 如何确保消息只会被消费一次（任务幂等性的问题）？</p>
</blockquote>
<ul>
<li>建消息表（消息id，是否被消费）</li>
<li>或者利用redis存储</li>
<li><p>上述两个问题的关键在于<strong>消息全局id的唯一性</strong>：数据库自增主键、UUID、Redis，Twitter-Snowflake 算法等</p>
</li>
<li><p>如何处理消息积压问题？</p>
<ul>
<li><p>与生产端没关系，一般中间件的性能也很高，所以一般问题出现在<strong>消费端</strong></p>
</li>
<li><p>扩容、降级一些非核心的业务</p>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>消息队列的作用</p>
</blockquote>
<ul>
<li>通过异步处理提高系统性能（减少响应所需时间）</li>
<li>削峰/限流：先将短时间高并发产生的事务消息存储在消息队列中，然后后端服务再慢慢根据自己的能力去消费这些消息，这样就避免直接把后端服务打垮掉。</li>
<li>降低系统耦合性。</li>
</ul>
<blockquote>
<p>消息队列带来的问题</p>
</blockquote>
<ul>
<li>系统可用性降低<ul>
<li>需要考虑消息丢失或者说 MQ 挂掉等等的情况</li>
</ul>
</li>
<li>系统复杂性提高<ul>
<li>需要保证消息没有被重复消费、处理消息丢失的情况、保证消息传递的顺序性等等问题</li>
</ul>
</li>
<li>一致性问题</li>
</ul>
<h3 id="10-Mybaits"><a href="#10-Mybaits" class="headerlink" title="10 Mybaits"></a>10 Mybaits</h3><blockquote>
<p>Mybatis设计模式</p>
</blockquote>
<ul>
<li>缓存模块:装饰器模式</li>
<li>日志模块:适配器模式</li>
<li>SqlSessionFactory:工厂模式</li>
<li>Mapper接口:代理模式</li>
<li>SqlssionFactoryBuiler:建造者模式</li>
</ul>
<blockquote>
<p>xml中的常见标签</p>
</blockquote>
<ul>
<li><code>select insert update delete</code></li>
<li><code>&lt;resultMap&gt;、 &lt;parameterMap&gt;、 &lt;sql&gt;、 &lt;include&gt;、 &lt;selectKey&gt;</code></li>
<li>动态sql <code>trim|where|set|foreach|if|choose|when|otherwise|bind</code></li>
</ul>
<blockquote>
<p>Executor执行器类别</p>
</blockquote>
<ul>
<li>SimpleExecutor：执行一次销毁</li>
<li>ReuseExecutor：重复执行</li>
<li>BatchExecutor：批处理</li>
</ul>
<blockquote>
<p>工作原理/过程</p>
</blockquote>
<ul>
<li>启动加载：SqlSessionFactory完成解析，保存相关配置</li>
<li>通过SqlSession对象处理请求，先走二级缓存，再一级缓存最后走数据库</li>
<li>交给StatementHandler来处理，通过ParameterHandler处理SQL中的占位符，通过ResultSetHandler处理结果集的映射</li>
</ul>
<blockquote>
<p>自定义sql的过程</p>
</blockquote>
<ul>
<li>首先在mapper中自定义一个方法以及参数，可以用<code>@Param</code>标注</li>
<li>在相应的xml中实现sql<ul>
<li>if标签，when标签等</li>
<li><code>#{}</code> 取参数</li>
</ul>
</li>
<li>四个一致：<ul>
<li>Mapper接口名和xml文件名一致</li>
<li>Mapper中的方法名和xml中对应的id一致</li>
<li>Mapper中的方法返回值类型和xml中的resultType一致</li>
<li>Mapper全路径名和xml中的namespace一致</li>
</ul>
</li>
</ul>
<hr>
<blockquote>
<p>分页查询</p>
</blockquote>
<ul>
<li><p><code>PageHelper</code>：原理是存储分页信息在<code>ThreadLocal</code>中，在执行sql前拦截器会读取到分页信息动态插入到sql中再执行</p>
<p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/image-20240224180047211.png" alt="image-20240224180047211"></p>
</li>
</ul>
<hr>
<blockquote>
<p>批量插入</p>
</blockquote>
<ul>
<li>法一：<strong>循环插入</strong>：频繁建立和关闭连接，资源消耗大</li>
<li>法二：<strong>forEach标签</strong>，通过拼接SQL语句的方式完成批量操作的。但是当拼接的SQL过多，导致SQL大小超过了MySQL服务器中<strong>max_allowed_packet</strong>变量的值时，会导致操作失败</li>
<li>法三：<strong>批处理</strong>，效率最高，但是比较麻烦</li>
</ul>
<p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/image-20240224182755036.png" alt="image-20240224182755036"></p>
<p>mapper：</p>
<p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/image-20240224182807077.png" alt="image-20240224182807077"></p>
<hr>
<blockquote>
<p>参数传递</p>
</blockquote>
<ul>
<li><p><code>xxxMapper.java</code>中方法的形参名可以不与<code>.xml</code>一致，MyBatis 会按照参数的位置进行匹配而不是参数的名字，若有多个参数，则应该按顺序使用</p>
</li>
<li><p>也可以使用<code>@Param</code>：<code>List&lt;TeachplanDto&gt; selectTreeNodes(@Param("courseId") Long courseId, @Param("name") String name);</code>指定mapper中的名字</p>
</li>
</ul>
<hr>
<blockquote>
<p>多表联查</p>
</blockquote>
<ul>
<li><p>定义好实体类，接口等</p>
</li>
<li><p>在xml中定义resultMap的映射</p>
<ul>
<li><code>property</code>表示属性对应的是实体类的字段名称</li>
<li><code>column</code>表示的是自己定义的属性值，与sql语句定义的字段名称相同</li>
<li><code>association</code>和<code>javaType</code>在一对一关联查询的时候使用</li>
<li><code>association</code>里映射的是被关联查询的表和属性值</li>
</ul>
</li>
<li><p>编写主要的联查语句，<code>resultMap</code>中指定刚刚定义的id</p>
<ul>
<li>如果是一对多的话就用外连接 <code>left join</code></li>
<li>如果是多对多，需要一个中间表然后两个 <code>left join</code></li>
</ul>
<figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">"husbandAndWife"</span> <span class="attr">type</span>=<span class="string">"husband"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">"id"</span> <span class="attr">column</span>=<span class="string">"id"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"name"</span> <span class="attr">column</span>=<span class="string">"name"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">association</span> <span class="attr">property</span>=<span class="string">"wife"</span> <span class="attr">javaType</span>=<span class="string">"wife"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">"id"</span> <span class="attr">column</span>=<span class="string">"wid"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"name"</span> <span class="attr">column</span>=<span class="string">"wname"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">association</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"findByName"</span> <span class="attr">parameterType</span>=<span class="string">"string"</span> <span class="attr">resultMap</span>=<span class="string">"husbandAndWife"</span>&gt;</span></span><br><span class="line">    select h.id,h.name,w.id wid, w.name wname</span><br><span class="line">    from t_husband h,t_wife w </span><br><span class="line">    where h.id = w.id and h.name = #{name}</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>
</li>
</ul>
<h3 id="11-MySQL"><a href="#11-MySQL" class="headerlink" title="11 MySQL"></a>11 MySQL</h3><blockquote>
<p>SQL: 是一种结构化查询语言(Structured Query Language)，专门用来与数据库打交道，目的是提供一种从数据库中读写数据的简单有效的方法。</p>
<p>sql常用关键字：SELECT， INSERT，UPDATE，DELETE，BETWEEN，EXISTS，WHERE，FROM，AND，NOT，OR，LIKE，JOIN，ALTER </p>
<p>函数处理：AVG，COUNT，MAX，MIN，SUM</p>
<p>三种删除：Drop，Delete，Truncate(清空数据)</p>
<p>group by：分组</p>
</blockquote>
<figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> customer_id, <span class="built_in">SUM</span>(order_amount) <span class="keyword">AS</span> total_amount</span><br><span class="line"><span class="keyword">FROM</span> orders</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> customer_id;</span><br></pre></td></tr></tbody></table></figure>
<blockquote>
<p>子查询：用于嵌套查询，放在()里面</p>
<p>mysql索引：索引是一种用于快速查询和检索数据的数据结构，其本质可以看成是一种排序好的数据结构。</p>
</blockquote>
<ul>
<li><p>优点：可以快速检索，唯一性保证（唯一索引）缺点：创建和维护耗时，存储需要消耗物理空间</p>
<ul>
<li>为什么可以加快？<ul>
<li>索引会按照列的值建立一个有序的数据结构（B/B+树），这样查找的时候就不用线性扫描表了</li>
<li>由于只读取索引所在的数据页，大大减少了磁盘IO</li>
</ul>
</li>
</ul>
</li>
<li><p>分类</p>
<ul>
<li><p>按照数据结构划分：BTree索引、hash索引、RTree 索引、全文索引</p>
</li>
<li><p>按照底层存储方式划分：</p>
<ul>
<li><p>聚簇索引（聚集索引）：索引结构和数据一起存放的索引，InnoDB的主键索引就是</p>
<ul>
<li>默认是主键</li>
<li>如果表没有定义主键，但有唯一非空索引，那么第一个唯一非空索引会被用作聚集索引。</li>
<li>如果表既没有主键也没有唯一非空索引，InnoDB存储引擎会自动生成一个隐藏的聚集索引</li>
</ul>
</li>
<li><p>非聚簇索引（非聚集索引）：不存在一起的索引</p>
</li>
</ul>
<p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/image-20240320172122032.png" alt="image-20240320172122032" style="zoom:50%;"></p>
<ul>
<li>区别<ul>
<li>聚簇索引只能有一个，后者可以有多个</li>
<li>聚集索引存储记录是物理上连续存在</li>
<li>聚集索引在叶子节点上存储的是数据</li>
</ul>
</li>
</ul>
</li>
<li><p>按照引用维度划分</p>
<ul>
<li>主键索引：加速查询 + 列值唯一（不可以有 NULL）+ 表中只有一个<ul>
<li>除了这个其他的索引都是二级索引，二级索引数据位置存储的是主键</li>
</ul>
</li>
<li>普通索引：加速查询</li>
<li>唯一索引：加速查询 + 列值唯一（可以有 NULL）</li>
<li>覆盖索引：一个索引包含（或者说覆盖）所有需要查询的字段的值</li>
<li>联合索引：多列值组成一个索引，专门用于组合搜索，其效率大于索引合并</li>
<li>全文索引：对文本的内容进行分词，一般不会使用，效率较低，通常使用搜索引擎如 ElasticSearch 代替</li>
</ul>
</li>
</ul>
</li>
</ul>
  <figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> INDEX idx_name(索引名) <span class="keyword">ON</span> 表名 (字段名); # B<span class="operator">-</span>Tree 索引，默认索引</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">UNIQUE</span> INDEX idx_name <span class="keyword">ON</span> 表名 (字段名); # 唯一索引</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 表名 <span class="keyword">ADD</span> <span class="keyword">PRIMARY</span> KEY (字段名); # 主键索引</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 表名 <span class="keyword">ADD</span> FULLTEXT INDEX idx_name (字段名);<span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 表名 <span class="keyword">ADD</span> FULLTEXT INDEX idx_name (字段名); # 全文索引</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><p>索引的底层数据结构选型</p>
<ul>
<li>hash表：快，但是不支持范围查询</li>
<li>二叉查找树：性能很依赖其平衡性</li>
<li>AVL树(高度差不超过1)：需要频繁地进行旋转操作来保持平衡，且一个节点只存一个数据，磁盘IO性能开销大</li>
<li>红黑树：自平衡二叉查找树，平衡性稍弱（不追求完全的平衡）所以有些查询效率较低(多次IO)，但是增删效率高</li>
<li>B树：所有节点既存放key又存放date</li>
<li><strong>B+树</strong>：多路平衡查找树，更稳定快速。原因：数据存放在叶子节点，保证了其他节点能够存放更多的索引，大大压缩了树的高度，减少磁盘IO次数；且叶子节点之间用双向链表连接</li>
</ul>
</li>
</ul>
<blockquote>
<p>索引的设计原则</p>
</blockquote>
<ul>
<li>适合索引的列是出现在where字句中的列，或者连接子句中指定的列</li>
<li>定义有外键的数据列一定要创建索引</li>
<li>更新频繁的字段不要有索引</li>
<li>大文本、大对象不要创建索引</li>
</ul>
<blockquote>
<p>MYSQL字段类型：数值类型、字符串类型(char/varchar)、日期时间类型</p>
<p>mysql架构</p>
</blockquote>
<p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/image-20240320164909208.png" alt="image-20240320164909208" style="zoom:50%;"></p>
<ul>
<li><strong>    连接器：</strong> 身份认证和权限相关(登录 MySQL 的时候)。</li>
<li><strong>查询缓存：</strong> 执行查询语句的时候，会先查询缓存（MySQL 8.0 版本后移除，因为这个功能不太实用）。</li>
<li><strong>分析器：</strong> 没有命中缓存的话，SQL 语句就会经过分析器，分析器说白了就是要先看你的 SQL 语句要干嘛，再检查你的 SQL 语句语法是否正确。</li>
<li><strong>优化器：</strong> 按照 MySQL 认为最优的方案去执行。</li>
<li><strong>执行器：</strong> 执行语句，然后从存储引擎返回数据。 执行语句之前会先判断是否有权限，如果没有权限的话，就会报错。</li>
<li><strong>插件式存储引擎</strong>：主要负责数据的存储和读取，采用的是<strong>插件式架构</strong>，支持 <strong>InnoDB</strong>、MyISAM、Memory 等多种存储引擎。</li>
</ul>
<blockquote>
<p>InnoDB和MyISAM</p>
</blockquote>
<ul>
<li>MyISAM是表级锁、不支持MVCC、不支持事务、不支持外键且<strong>数据库崩溃后数据不可恢复</strong></li>
<li>MyISAM 引擎和 InnoDB 引擎都是使用 B+Tree 作为索引结构，但是两者的实现方式不太一样。</li>
</ul>
<blockquote>
<p>数据库事务</p>
</blockquote>
<ul>
<li>数据库事务是一个或一系列操作的最小逻辑单元</li>
<li>特性：原子性、一致性、隔离性、持久性</li>
</ul>
<blockquote>
<p>并发事务的带来的问题</p>
</blockquote>
<ul>
<li>读读：没有问题，不需要并发控制</li>
<li>读写：脏读、不可重复读、幻读</li>
<li>写写：丢失修改</li>
</ul>
<blockquote>
<p> 如何控制？</p>
</blockquote>
<ul>
<li>锁：<ul>
<li>共享锁(S锁)/读锁：读读并行</li>
<li>排他锁(X锁)/写锁：如果有写就禁止其他线程读写了</li>
</ul>
</li>
<li><p>MVCC：多版本并发控制方法，主要依赖的手段：三个隐藏字段、read view、undolog。</p>
<ul>
<li><p>三个隐藏字段：</p>
<ul>
<li>DB_TRX_ID：表示最后一次插入或更新该行的事务 id</li>
<li>DB_ROLL_PTR：回滚指针，指向该行的 <code>undolog</code></li>
<li>DB_ROW_ID：隐藏主键</li>
</ul>
</li>
<li><p>undolog 用于记录某行数据的多个版本的数据。</p>
</li>
<li>read view 和 三个隐藏字段 : 用来判断当前版本数据的可见性。</li>
</ul>
</li>
</ul>
<blockquote>
<p>InnoDB存储引擎实现MVCC</p>
</blockquote>
<ul>
<li>仅针对写操作</li>
<li>为要修改的数据行创建版本，将修改后的数据写入新版本，旧版本的数据仍然存在</li>
<li>事务的提交后所作的修改对所有事务可见；回滚后修改被撤销，其他事务不可见</li>
<li>版本的回收：MVCC 会定期进行版本的回收。回收机制会删除已经不再需要的旧版本数据，从而释放空间。</li>
</ul>
<blockquote>
<p>SQL定义的事务隔离级别：基于锁和MVCC实现</p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/baidu_40120883/article/details/118755990?utm_source=miniapp_weixin">https://blog.csdn.net/baidu_40120883/article/details/118755990?utm_source=miniapp_weixin</a></p>
<ul>
<li>读取未提交、读取已提交、<strong>可重复读</strong>(InnoDB默认)、可串行化<ul>
<li>读取未提交：不设任何限制 ==&gt; 问题<strong>脏读</strong>：直接读取到错误的数据</li>
<li>读取已提交：只能读取到别人提交/回滚的事务 ==&gt; 问题<strong>不可重复读</strong>：两次读取之间有别的事务提交导致读取到了不一样的数据</li>
<li>可重复读：在事务写数据的时候将数据加锁，其他事务无法读写该数据 ==&gt; 问题<strong>幻读</strong>：两次查询之间有别的事务提交导致读取到了行数不同的数据</li>
<li>可串行化：直接禁止事务的并发    </li>
</ul>
</li>
</ul>
<p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/image-20240320173313410.png" alt="image-20240320173313410" style="zoom:67%;"></p>
<blockquote>
<p>InnoDB如何解决幻读</p>
</blockquote>
<ul>
<li>间隙锁</li>
</ul>
<blockquote>
<p>mysql日志</p>
</blockquote>
<ul>
<li><p>二进制日志(归档日志)<code>binlog</code>：数据库的备份，同步</p>
<ul>
<li>写入时机：事务提交时从binlog cache中写入到binlog</li>
</ul>
</li>
<li><p>事务日志(重做日志)<code>redolog</code>：InnoDB独有，mysql崩溃恢复的能力</p>
<ul>
<li><p>记录的是物理级别的操作，比如页号xxx、偏移量yyy写入了’zzz’数据</p>
</li>
<li><p>刷盘时机(将用户在缓冲区的修改刷到磁盘上持久化)：事务提交、log buffer 空间不足、事务日志缓冲区满、定期检查刷盘、正常关闭服务器</p>
</li>
<li><p>两阶段提交：保证两个log的一致性，但是增加了磁盘IO和锁竞争</p>
<ul>
<li>若发生异常：判断 redolog 是否完整，如果判断是完整的，就立即提交。如果 redolog 只是预提交但不是 commit 状态，这个时候就会去判断 binlog 是否完整，如果完整就提交 redolog, 不完整就回滚事务。</li>
</ul>
<p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/image-20240321095820154.png" alt="image-20240321095820154" style="zoom: 50%;"></p>
</li>
</ul>
</li>
<li><p>回滚日志(回滚日志)<code>undolog</code>：保证事务</p>
<ul>
<li>记录的是逻辑操作：比如INSERT操作后，undolog就记录了DELETE</li>
<li>事务中会写到undolog buffer中，事务提交后写到undolog </li>
</ul>
</li>
</ul>
<blockquote>
<p>一个完整的mysql语句执行（写）</p>
</blockquote>
<ul>
<li>连接器：权限校验</li>
<li>查询缓存：命中则返回</li>
<li>分析器：sql语句的词法语法分析</li>
<li>优化器：优化执行顺序</li>
<li>执行器：调用存储引擎（InnoDB）执行sql<ul>
<li>开启事务，修改数据</li>
<li>写入redolog，状态为prepare</li>
<li>写入binlog</li>
<li>事务提交，redolog状态修改为commit</li>
</ul>
</li>
</ul>
<blockquote>
<p>mysql的锁有哪些</p>
</blockquote>
<ul>
<li><p>基于属性分：共享锁/S锁，排他锁/X锁</p>
</li>
<li><p>基于粒度：行级锁(innodb ) 、表级锁（ innodb、myisam)、页级锁（ innodb引擎)、记录锁、间隙锁、临键锁。</p>
</li>
<li>基于状态：意向共享锁、意向排它锁。</li>
</ul>
<blockquote>
<p>如何给字符串建立一个索引</p>
</blockquote>
<ul>
<li>使用前缀索引</li>
<li>需要定义好前缀的长度</li>
<li>必要的时候可以选择倒排存储，比如 422100200003018877 存储为 778810300002001224 这样前六位就很有辨识度了</li>
</ul>
<blockquote>
<p>分库分表</p>
</blockquote>
<ul>
<li>分库分表就是为了解决由于数据量过大而导致数据库性能降低的问题，将原来独立的数据库拆分成若干数据库组成 ，将数据大表拆分成若干数据表组成，使得单一数据库、单一数据表的数据量变小，从而达到提升数据库性能的目的。</li>
<li>垂直分表：将一个表按照字段分成多个表，每个表存储一部分字段<ul>
<li>不常用的字段放一张表</li>
<li>text，blob等大字段拆分出来放在附表</li>
<li>经常组合查询的列放在一张表</li>
</ul>
</li>
<li>垂直分库：按照业务分类，分布到不同数据库上，每个库可以放在不同的服务器<ul>
<li>解耦</li>
<li>高并发的场景可以提升IO</li>
</ul>
</li>
<li>水平分库：按照一定规则把同一个表中的数据拆到不同的数据库中<ul>
<li>比如单数在一个表，双数在另一个表</li>
<li>解决了单库大数据问题</li>
</ul>
</li>
<li>水平分表：是在同一个数据库内，把同一个表的数据按一定规则拆到多个表中</li>
</ul>
<blockquote>
<p>慢查询如何排查优化</p>
</blockquote>
<ul>
<li>sql语句：是否加载了不必要的字段</li>
<li>分析sql执行，是否命中的索引</li>
<li>看sql涉及到的表结构</li>
<li>可以考虑分表分库</li>
<li>利用缓存，减少查询</li>
</ul>
<blockquote>
<p>mysql索引失效</p>
</blockquote>
<ul>
<li>不合适的索引类型</li>
<li>索引列上使用了函数</li>
<li>使用了<code>or</code>操作符：当子条件中的列没有索引的时候，整个条件都无法使用索引</li>
<li>索引列存在<code>NULL</code></li>
<li>数据量小的时候索引查询可能比全表查询还慢</li>
</ul>
<h3 id="12-并发"><a href="#12-并发" class="headerlink" title="12 并发"></a>12 并发</h3><blockquote>
<p>线程和进程 并发和并行</p>
<p>开启线程</p>
</blockquote>
<ul>
<li>继承Thread类</li>
<li>实现Runnable接口（还是要通过Thread调用）</li>
<li>实现Callable接口（同上）</li>
<li>使用线程池</li>
</ul>
<blockquote>
<p>线程生命周期和状态</p>
</blockquote>
<ul>
<li>New</li>
<li>Runnable</li>
<li>Blocked</li>
<li>Waiting</li>
<li>TIME_WAITING：超时等待</li>
<li>TERMINATED</li>
</ul>
<blockquote>
<p>sleep和wait</p>
</blockquote>
<ul>
<li><code>sleep()</code> 方法没有释放锁，而 <code>wait()</code> 方法释放了锁 </li>
<li>后者常用于线程间的通信，需要别的线程在同一个对象上使用<code>notify()</code>或者<code>notifyAll()</code>唤醒，也可以用<code>wait(long timeout)</code>超时唤醒</li>
</ul>
<blockquote>
<p>volatile 关键字</p>
</blockquote>
<ul>
<li>指示 JVM，这个变量是共享且不稳定的，每次使用它都到主存中进行读取。</li>
<li>在编译的时候禁止指令重排</li>
</ul>
<blockquote>
<p>乐观锁和悲观锁</p>
</blockquote>
<ul>
<li><p>悲观锁总是假设最坏的情况，认为共享资源每次被访问的时候就会出现问题(比如共享数据被修改)，所以每次在获取资源操作的时候都会上锁</p>
<ul>
<li><code>synchronized</code>和<code>ReentrantLock</code></li>
</ul>
</li>
<li><p>乐观锁总是假设最好的情况，认为共享资源每次被访问的时候不会出现问题，线程可以不停地执行，无需加锁也无需等待，只是在提交修改的时候去验证对应的资源（也就是数据）是否被其它线程修改了</p>
<ul>
<li>版本号或者CAS算法</li>
<li><p>CAS算法三个参数：当仅当V==E的时候才会修改N</p>
<ul>
<li>V：要更新的变量值(Var)</li>
<li>E：预期值(Expected)</li>
<li>N：拟写入的新值(New)</li>
</ul>
</li>
<li><p>存在的问题：</p>
<ul>
<li>ABA问题：在变量前面加版本号</li>
<li>循环时间长开销大：</li>
<li>只能保证一个共享变量的原子操作</li>
</ul>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>死锁的形成条件与解决</p>
</blockquote>
<ul>
<li><p>条件</p>
<ul>
<li><p>互斥条件：一个资源每次只能被一个进程使用。</p>
</li>
<li><p>请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。</p>
</li>
<li><p>不剥夺/非抢占条件:进程已获得的资源，在末使用完之前，不能强行剥夺。</p>
</li>
<li><p>循环等待条件:若干进程之间形成一种头尾相接的循环等待资源关系。</p>
</li>
</ul>
</li>
<li><p>解决：破坏四个条件之一</p>
<ul>
<li>破坏互斥：让资源可以同时访问（往往行不通）</li>
<li>破坏非抢占：剥夺式调度算法，但是会导致资源利用率低（不怎么用）</li>
<li>破坏请求与保持：静态分配策略：在进程执行之前先获取到他需要的所有资源，如果不满足就不开启（会导致资源利用率低，因为部分资源可能在进程后期才会用）</li>
<li>破坏循环等待：层次分配策略：将资源分层，先释放低层次的资源再获取高层次的资源</li>
</ul>
</li>
</ul>
<blockquote>
<p>synchronized </p>
</blockquote>
<ul>
<li>修饰实例方法：给对象加锁</li>
<li>修饰静态方法：给类加锁</li>
<li>修饰静态代码块：对括号里面的类/对象加锁</li>
<li>尽量不要使用 <code>synchronized(String a)</code> 因为 JVM 中，字符串常量池具有缓存功能</li>
<li>底层原理：使用的<code>monitorenter</code>锁住，使用<code>monitorexit</code>退出</li>
</ul>
<blockquote>
<p>线程池</p>
</blockquote>
<ul>
<li><p>创建</p>
<ul>
<li><code>ThreadPoolExecutor</code>创建（推荐）</li>
<li>通过<code>Executor</code>框架的工具类 <code>Executors</code> 来创建。</li>
</ul>
</li>
<li><p>线程池参数：</p>
<ul>
<li>corePoolSize : 任务队列未达到队列容量时，最大可以同时运行的线程数量。</li>
<li>maximumPoolSize : 任务队列中存放的任务达到队列容量的时候，当前可以同时运行的线程数量变为最大线程数。</li>
<li>workQueue: 新任务来的时候会先判断当前运行的线程数量是否达到核心线程数，如果达到的话，新任务就会被存放在队列中。</li>
<li>keepAliveTime：当线程数大于corePoolSize 且没有新的任务提交，多余的空闲线程的等待时间</li>
<li>unit : keepAliveTime 参数的时间单位。</li>
<li>threadFactory :executor 创建新线程的时候会用到。</li>
<li>handler :饱和策略<ul>
<li><code>ThreadPoolExecutor.AbortPolicy</code>： 抛出 <code>RejectedExecutionException</code>来拒绝新任务的处理。</li>
<li><code>ThreadPoolExecutor.DiscardPolicy</code>：不处理新任务，直接丢弃掉。</li>
<li><code>ThreadPoolExecutor.DiscardOldestPolicy</code>： 此策略将丢弃最早的未处理的任务请求。</li>
<li><code>ThreadPoolExecutor.CallerRunsPolicy</code>：由调用线程处理该任务。如果执行程序已关闭，则会丢弃该任务</li>
</ul>
</li>
</ul>
</li>
<li><p>参数设置原则</p>
<ul>
<li><p>最佳corePoolSize ，N为CPU的核数</p>
<ul>
<li><p>如果是IO密集型（CPU计算时间短，而等待IO操作（如读写文件、网络通信等）的时间长）的任务就设置为2N</p>
<ul>
<li>文件处理，数据库读写，网络操作等</li>
</ul>
</li>
<li><p>如果是CPU密集型（几乎没有IO等待）就设置为N+1</p>
<ul>
<li>数值计算、图像视频处理、加密解密、模型训练等</li>
</ul>
</li>
<li><p>还可以这样计算：<code>((线程等待时间+线程CPU时间) / 线程CPU时间)* CPU数目</code></p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>执行过程</p>
<p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/image-20240321213330649.png" alt="image-20240321213330649" style="zoom: 80%;"></p>
</li>
</ul>
<blockquote>
<p>Java中的锁机制</p>
</blockquote>
<ul>
<li><strong>互斥锁</strong>：<code>synchronized</code>关键字：JVM底层实现，最基本的线程同步机制</li>
<li><strong>可重入锁</strong>：实现类<code>ReentrantLock</code>，允许更细粒度的锁控制</li>
<li><strong>读写锁</strong>：<code>ReadWriteLock</code></li>
<li><strong>乐观锁</strong>和<strong>悲观锁</strong></li>
<li>对<code>synchronized</code>性能的优化<ul>
<li>java对象头mark word存储了一些信息</li>
<li><strong>偏向锁</strong>：把线程ID放入对象的Mark Word字段中</li>
<li><strong>轻量级锁</strong>：采用CAS自旋锁的方式来完成加锁</li>
<li><strong>重量级锁</strong>：让抢占锁的线程从用户态转变为内核态，开销很大</li>
</ul>
</li>
<li><strong>自旋锁</strong>：让线程获取锁的时候不断的重试获取锁的操作，而不是立即进入阻塞状态</li>
<li><strong>分段锁</strong>：如<code>ConcurrentHashMap</code></li>
</ul>
<blockquote>
<p><code>synchronized</code>和<code>ReentrantLock</code></p>
</blockquote>
<ul>
<li>前者是JVM实现，后者是JDK实现</li>
<li>两者性能大致相同（因为新版本JVM对<code>synchronized</code>进行了优化，也支持了自旋锁等</li>
<li>前者不可中断，后者可以</li>
<li>优先使用前者，因为是JVM原生支持，且不用担心死锁问题，因为JVM会保证锁的释放</li>
</ul>
<blockquote>
<p>Java主流锁</p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://pdai.tech/md/java/thread/java-thread-x-lock-all.html">https://pdai.tech/md/java/thread/java-thread-x-lock-all.html</a></p>
<ul>
<li>线程是否锁同步资源<ul>
<li>乐观锁：采用无锁编程实现，CAS算法常用</li>
<li>悲观锁：<code>synchronized</code>关键字和<code>Lock</code>的实现类实现<ul>
<li><code>ReentrantLock</code>、<code>ReadLock</code>、<code>WriteLock</code>（后两者是<code>ReentrantReadWriteLock</code>内部类）</li>
</ul>
</li>
</ul>
</li>
<li>锁住同步资源失败时，线程要不要阻塞<ul>
<li><strong>为什么要非阻塞</strong>：阻塞线程要切换CPU的状态，耗时，自旋就是不让线程阻塞（及不放弃CPU的时间片）</li>
<li>阻塞</li>
<li>非阻塞<ul>
<li>自旋锁</li>
<li>适应性自旋锁</li>
</ul>
</li>
</ul>
</li>
<li>多个线程竞争同步资源的流程细节<ul>
<li>这是针对<code>synchronized</code>的优化，表示锁的四个状态</li>
<li>无锁</li>
<li>偏向锁：同一个线程执行同步资源时自动获取资源</li>
<li>轻量级锁：多个线程竞争时，没获取资源的线程自旋等待所释放</li>
<li>重量级锁：多个线程竞争时，没获取资源的线程阻塞等待被唤醒</li>
</ul>
</li>
<li>多个线程竞争锁时要不要排队<ul>
<li>公平锁</li>
<li>非公平锁：先尝试插队，失败了再排队</li>
</ul>
</li>
<li>一个线程的多个流程能不能获取同一把锁（前提是锁的是同一个对象或者class）<ul>
<li>可重入锁：<code>ReentrantLock</code>和<code>synchronized</code></li>
<li>不可重入锁</li>
</ul>
</li>
<li>多个线程能否共享锁<ul>
<li>共享锁：<code>ReentrantReadWriteLock</code>，本质是里面的两把锁，读锁和写锁</li>
<li>排他锁：<code>synchronized</code>和JUC中<code>Lock</code>的实现类就是互斥锁。</li>
</ul>
</li>
</ul>
<h3 id="13-计网"><a href="#13-计网" class="headerlink" title="13 计网"></a>13 计网</h3><blockquote>
<p>七层模型</p>
</blockquote>
<ul>
<li>应用层：FTP、<strong>DNS</strong>、Telnet、SMTP、<strong>HTTP</strong>、WWW、NFS<ul>
<li>为计算机用户提供服务</li>
</ul>
</li>
<li>表示层：JPEG、MPEG、ASII<ul>
<li>数据处理（编解码、加密解密、压缩解压缩)</li>
</ul>
</li>
<li>会话层：NFS、SQL、NETBIOS、RPC<ul>
<li>管理(建立、维护、重连)应用程序之间的会话</li>
</ul>
</li>
<li>传输层：<strong>TCP</strong>、<strong>UDP</strong>、SPX<ul>
<li>为两台主机进程之间的通信提供通用的数据传输服务</li>
</ul>
</li>
<li>网络层：路由和寻址（决定数据在网络的游走路径)<ul>
<li><strong>IP</strong>：分为ipv4 和 ipv6，定义数据包格式，对数据包进行路由和寻址</li>
<li><strong>ARP</strong>：地址解析协议，用于解决网络层和数据链路层的地址的转换问题(IP地址转MAC地址)<ul>
<li>维护一个表：<code>&lt;IP, MAC, TTL&gt;</code>TTL为生存时间</li>
</ul>
</li>
<li><strong>ICMP</strong>：互联网控制报文协议，ping命令</li>
<li><strong>NAT</strong>：网络地址转换协议，内部网到外部网的转换</li>
<li>OSPF（Open Shortest Path First）：内部网关协议</li>
</ul>
</li>
<li>数据链路层：PPP、FR、HDLC、VLAN、MAC（网桥、交换机）<ul>
<li>帧编码和误差纠正控制</li>
</ul>
</li>
<li>物理层：RJ45、CLOCK、IEEE802.3（中继器、集线器）<ul>
<li>透明地传送比特流传输</li>
</ul>
</li>
</ul>
<blockquote>
<p>四层模型</p>
</blockquote>
<ul>
<li>应用层           1-3</li>
<li>传输层           4</li>
<li>网络层           5</li>
<li>网络接口层    6-7</li>
</ul>
<blockquote>
<p>三握四挥</p>
</blockquote>
<ul>
<li><p>名词解释</p>
<ul>
<li>seq：sequence ，序号，用于确认数据是否准确</li>
<li>ack：acknowledgement ，确认号，用于确认数据是否准确</li>
<li>flags：标志位，一共有6个，用于确认/更改连接状态<ul>
<li><strong>URG</strong>(ent)：紧急指针（urgent pointer）有效。</li>
<li><strong>ACK</strong>(nowledgment)：确认序号有效。（为了与确认号ack区分开，我们用大写表示）</li>
<li><strong>P</strong>(u)<strong>SH</strong>：接收方应该尽快将这个报文交给应用层。</li>
<li><strong>R</strong>(e)<strong>S</strong>(e)<strong>T</strong>：重置连接。</li>
<li><strong>SYN</strong>(chronization)：同步，发起一个新连接。</li>
<li><strong>FIN</strong>(ish)：释放一个连接</li>
</ul>
</li>
</ul>
</li>
<li><p>握手</p>
<p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/image-20240322223936856.png" alt="image-20240322223936856"></p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sequenceDiagram</span><br><span class="line">    客户端 -&gt;&gt; + 服务器 : SYN(seq=x)</span><br><span class="line">    服务器 -&gt;&gt; 客户端 : ACK(ack=1)，SYN(seq=y)</span><br><span class="line">    客户端 -&gt;&gt; + 服务器 : ACK(ack=y+1) </span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>挥手</p>
<p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/image-20240322223944455.png" alt="image-20240322223944455"></p>
</li>
</ul>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sequenceDiagram</span><br><span class="line">    客户端 -&gt;&gt; + 服务器 : FIN(seq=m)</span><br><span class="line">    服务器 -&gt;&gt; 客户端 : ACK(ack=m+1)</span><br><span class="line">    服务器 -&gt;&gt; 客户端 : FIN(seq=y)</span><br><span class="line">    客户端 -&gt;&gt; + 服务器 : ACK(ack=y+1) </span><br></pre></td></tr></tbody></table></figure>
<blockquote>
<p>TCP传输稳定性</p>
</blockquote>
<ul>
<li>数据传输之前会有三次握手来进行连接</li>
<li>在数据传输时：<ul>
<li>基于数据块（报文）</li>
<li>对数据包排序防丢失和重复</li>
<li>校验和：将保持它首部和数据的检验和</li>
<li>重传机制（直到收到ACK应答）</li>
<li>流量控制：控制发送的速率，保证能及时接收，利用滑动窗口<ul>
<li>发送窗口：四个部分 ==&gt; 已发送确认 + 已发送未确认 + 可以发送 + 不可发送</li>
<li>接收窗口：三个部分 ==&gt; 已发送确认 + 已接收未确认 + 不可接收</li>
</ul>
</li>
<li>拥塞控制：发送方维持一个拥塞窗口 ，四个算法 ==&gt; 慢开始，拥塞避免，快重传，快恢复</li>
<li>ARQ协议：自动重传请求（Automatic Repeat-reQuest），在数据链路层和传输层都有<ul>
<li>停止等待ARQ协议：每发送一个请求就等待对方确认ACK</li>
<li>连续ARQ协议：连续发送n个消息，接收方返回连续成功接收的第n个消息的序号，表示前n个消息都收到了<ul>
<li>优点：信道利用率高，容易实现，即使确认丢失，也不必重传。</li>
<li>缺点：如果发送了5条消息，第3条消息丢失了，那么接受方返回的是前两条的确认信息，发送方会重新发送345条消息</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>数据传输之后会进行四次挥手断开连接来节约系统资源。</li>
</ul>
<blockquote>
<p>TCP和UDP</p>
</blockquote>
<ul>
<li><code>Transmission Control Protocol</code>传输控制协议</li>
<li><code>User Dategram Protocol</code>用户数据协议</li>
<li>TCP面向连接（传输之前需要建立连接）</li>
<li>TCP传输可靠</li>
<li>TCP传输有状态</li>
<li>TCP是面向字节传输，UDP面向报文<ul>
<li>面向字节出现粘包</li>
</ul>
</li>
<li>TCP 首部开销（20 ～ 60 字节）比 UDP 首部开销（8 字节）要大。</li>
<li>TCP点对点，UDP都支持</li>
</ul>
<blockquote>
<p>Http和Https</p>
</blockquote>
<ul>
<li><p>https协议要申请证书到ca，需要一定经济成本；</p>
</li>
<li><p>http是明文传输，https是加密的安全传输；  </p>
</li>
<li><p>连接的端口不一样，http是80，https是443；</p>
</li>
<li><p>http3.0之前是基于tcp连接的，https在此基础上还增加了SSL/TLS协议用作加密和安全认证</p>
<ul>
<li><p>SSL/TLS：TLS是SSL发展来的，一般就混在一起了，核心是用非对称加密传递对称加密的密钥，之后用对称加密来传输数据</p>
</li>
<li><p>https带证书的公钥传输机制：<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1mj421d7VE/?spm_id_from=333.337.search-card.all.click&amp;vd_source=1a39594354c31d775ddc587407a55282">https://www.bilibili.com/video/BV1mj421d7VE/?spm_id_from=333.337.search-card.all.click&amp;vd_source=1a39594354c31d775ddc587407a55282</a></p>
<ul>
<li><p>设有服务器 Bob，客户端 Alice，和第三方信赖机构 CA。目的：让Alice知道Bob的公钥，且这个过程不会被别人篡改</p>
</li>
<li><p>Bob 信任 CA，CA 是知道 Bob 公钥的，CA 向 Bob  颁发证书。</p>
<ul>
<li>数字证书内容：Bob的公钥+Bob的身份+CA<strong>私钥</strong>对前两者hash运算结果的签名</li>
<li>签名是为了保证Bob公钥和身份没有被篡改，如果第三方修改了，那么两个部分就对不上了</li>
</ul>
</li>
<li><p>Bob 获得 CA 颁发的证书，将该证书传递给 Alice。</p>
</li>
<li><p>Alice 获得 Bob 的证书，并且还有CA的公钥（浏览器安装的时候会附带安装CA相关信息），</p>
<ul>
<li>使用 CA 公钥对证书上的签名解密，得到Bob的身份和Bob的公钥hash运算后的结果，也就是摘要</li>
<li>将证书的另一部分（Bob的公钥和身份）进行hash运算，对比两个摘要相同的话就说明证书是真实的</li>
</ul>
</li>
<li><p>如果 Alice 验证 Bob  证书是真实的，则信任 Bob  的公钥（在 S 证书中）。</p>
</li>
<li><p>注意：中间对文件hash运算一次的原因是为了压缩传输信息，加快传输速度(不可逆)</p>
<p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/image-20240322205844944.png" alt="image-20240322205844944" style="zoom:67%;"></p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>http连接很简单，没有状态；</p>
</li>
<li><p>https是ssl加密的传输，身份认证的网络协议，相对http传输比较安全。</p>
</li>
</ul>
<blockquote>
<p>http常见的header</p>
</blockquote>
<figure class="highlight http"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Accept   			能够接受的回应内容类型</span><br><span class="line">Accept-Charset		能够接受的字符集</span><br><span class="line">Accept-Encoding		能够接受的编码方式列表</span><br><span class="line">Accept-Language		能够接受的回应内容的自然语言列表。</span><br><span class="line">Authorization		用于超文本传输协议的认证的认证信息</span><br><span class="line">Content-Type		请求体的 多媒体类型 （用于 POST 和 PUT 请求中）</span><br><span class="line">Host				服务器的域名以及服务器所监听的传输控制协议端口号</span><br><span class="line">Origin				发起一个针对跨来源资源共享的请求。</span><br><span class="line">User-Agent			浏览器的浏览器身份标识字符串</span><br></pre></td></tr></tbody></table></figure>
<blockquote>
<p>http1.0和http1.1</p>
</blockquote>
<ul>
<li><p>优化了缓存</p>
</li>
<li><p>tcp连接：1.0是短连接：每进行一次http操作就建立一次连接，1.1是长连接</p>
</li>
<li><p>host头处理：1.1在请求头中加入了Host字段，也就是主机名</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//请求http://example1.org/home.html</span><br><span class="line">GET /home.html HTTP/1.0</span><br><span class="line"></span><br><span class="line">GET /home.html HTTP/1.1</span><br><span class="line">Host: example1.org</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>带宽优化及网络连接的使用：1.1请求头引入了 range 头域，它允许只请求资源的某个部分</p>
</li>
<li><p>状态响应码新增</p>
</li>
</ul>
<blockquote>
<p>http2.0和http1.1</p>
</blockquote>
<ul>
<li>多路复用：</li>
<li>2.0用二进制帧，1.1用文本传输</li>
<li>1.1支持body压缩，2.0额外支持了header压缩</li>
<li>服务器推送</li>
</ul>
<blockquote>
<p>浏览器输入url发生了什么</p>
</blockquote>
<ul>
<li><p>从事件来看</p>
<ul>
<li>DNS解析查询到对应的ip地址</li>
</ul>
</li>
</ul>
<ul>
<li>根据id地址和端口号，浏览器向服务器发送一个TCP连接请求（发送数据前客户端和服务队建立通道）</li>
</ul>
<ul>
<li>在TCP连接上，发送HTTP请求获取网页内容</li>
</ul>
<ul>
<li>服务器处理请求并返回HTTP报文</li>
</ul>
<ul>
<li>浏览器解析响应中的HTML，渲染结构和样式，同时根据HTML中的其他URL发送请求，获取资源直到网页完全加载</li>
</ul>
<ul>
<li><p>从4层来看</p>
<ul>
<li>应用层：<ul>
<li>浏览器先访问缓存的host，如果没有则使用DNS解析URL，最后得到IP地址</li>
<li>发送http报文，使用http或者https协议</li>
</ul>
</li>
<li>传输层：<ul>
<li>http基于tc协议</li>
</ul>
</li>
<li>网络层：核心：路由与转发<ul>
<li>转发：将分组从路由器的输入端口转移到合适的输出端口。</li>
<li>路由：确定分组从源到目的经过的路径。</li>
</ul>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>一个URL的组成</p>
</blockquote>
<p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/image-20240322202728626.png" alt=""></p>
<ul>
<li>协议：Http或者Https，也可能是ftp</li>
<li>域名</li>
<li>端口</li>
<li>资源路径</li>
<li>参数 ：?开始，&amp;隔开 ，采用k-v的形式</li>
<li>锚点：#开始，相当于一个小书签。并且不会作为请求的一部分发送给服务端。</li>
</ul>
<blockquote>
<p>DNS：Domain Name System 域名管理系统</p>
</blockquote>
<ul>
<li>基于UDP协议，端口53</li>
<li>跟DNS服务器</li>
<li>顶级域DNS服务器（TLD 服务器）：指域名的后缀，com org net edu</li>
<li>权威DNS服务器</li>
<li>本地DNS服务器</li>
<li>查询过程：<code>cis.poly.edu</code> 查询 <code>gaia.cs.umass.edu</code></li>
</ul>
<p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/image-20240322204013957.png" alt="image-20240322204013957" style="zoom:50%;"></p>
<blockquote>
<p>状态码</p>
</blockquote>
<ul>
<li>2xx：成功</li>
<li>3xx：重定向</li>
<li>4xx：客户端出错</li>
<li>5xx：服务器出错</li>
</ul>
<blockquote>
<p>websocket和http</p>
</blockquote>
<ul>
<li>WebSocket 和 HTTP 两者都是基于 TCP 的应用层协议，都可以在网络中传输数据。</li>
<li>区别<ul>
<li>WebSocket 是一种双向实时通信协议，而 HTTP 是一种单向通信协议。并且，HTTP 协议下的通信只能由客户端发起，服务器无法主动通知客户端。</li>
<li>WebSocket 使用 ws:// 或 wss://（使用 SSL/TLS 加密后的协议，类似于 HTTP 和 HTTPS 的关系） 作为协议前缀，HTTP 使用 http:// 或 https:// 作为协议前缀。</li>
<li>WebSocket 通信数据格式比较轻量，用于协议控制的数据包头部相对较小，网络开销小，而 HTTP 通信每次都要携带完整的头部，网络开销较大（HTTP/2.0 使用二进制帧进行数据传输，还支持头部压缩，减少了网络开销）</li>
</ul>
</li>
</ul>
<blockquote>
<p>ping</p>
</blockquote>
<ul>
<li>PING 基于网络层的 ICMP（Internet Control Message Protocol，互联网控制报文协议），其主要原理就是通过在网络上发送和接收 ICMP 报文实现的。</li>
</ul>
<h3 id="14-操作系统"><a href="#14-操作系统" class="headerlink" title="14 操作系统"></a>14 操作系统</h3><blockquote>
<p>操作系统的功能</p>
</blockquote>
<ul>
<li>进程和线程的管理：进程的创建、撤销、阻塞、唤醒，进程间的通信等。</li>
<li>存储管理：内存的分配和管理、外存（磁盘等）的分配和管理等。</li>
<li>文件管理：文件的读、写、创建及删除等。</li>
<li>设备管理：完成设备（输入输出设备和外部存储设备等）的请求或释放，以及设备启动等功能。</li>
<li>网络管理</li>
<li>安全管理：用户的身份认证、访问控制、文件加密等，以防止非法用户对系统资源的访问和操作。</li>
</ul>
<blockquote>
<p>内存管理</p>
</blockquote>
<ul>
<li>内存的分配和回收</li>
<li>地址转换：程序中的地址转为内存中的物理地址</li>
<li>内存扩充：虚拟内存技术</li>
<li>内存映射：将文件映射到内存，加快文件读取速度</li>
<li>内存优化</li>
<li>内存安全</li>
</ul>
<blockquote>
<p>内存碎片</p>
</blockquote>
<ul>
<li><p>内部内存碎片/内碎片：分配了但没使用的空间</p>
</li>
<li><p>外部内存碎片/外碎片：由于段式分配导致一些没有用的小间隙</p>
<p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/image-20240323143949565.png" alt="image-20240323143949565" style="zoom:67%;"></p>
</li>
</ul>
<blockquote>
<p>内存管理方法</p>
</blockquote>
<ul>
<li>连续内存管理：容易造成较多内存碎片，内存利用率不高</li>
<li>非连续内存管理<ul>
<li>段式管理：以段的形式存储，程序的内存被分为大小不等的段，每段有实际的逻辑含义：主程序段、子程序段、数据段、栈段<ul>
<li>优点：无内存碎片</li>
<li>缺点：段换入换出的时候会产生外碎片</li>
</ul>
</li>
<li>页式管理：把物理内存分为连续等长的物理页，应用程序的虚拟地址空间也被划分为连续等长的虚拟页，是现代操作系统广泛使用的一种内存管理方式。<ul>
<li>优点：无外碎片</li>
<li>缺点：可能有内碎片，因为页框可能填不满</li>
</ul>
</li>
<li>段页式管理：结合了段式管理和页式管理的一种内存管理机制，把物理内存先分成若干段，每个段又继续分成若干大小相等的页。</li>
</ul>
</li>
</ul>
<blockquote>
<p>用户态和内核态</p>
</blockquote>
<ul>
<li><p>两种形态是进程的运行级别（一个用了用户栈一个用了内核栈）</p>
</li>
<li><p>用户态： 用户态运行的进程可以直接读取用户程序的数据，拥有较低的权限。当需要进行磁盘读写的时候就会申请进入内核态</p>
</li>
<li><p>内核态：几乎可以访问系统的任何资源（不止一个）</p>
</li>
<li><p>用户态到内核态的三种方式</p>
<ul>
<li><p>系统调用</p>
<ul>
<li><p>用户态的进程发起系统调用，由于权限不足，因此会中断执行（trap）</p>
</li>
<li><p>发生中断后，当前CPU执行的程序中断，内核程序开始运行处理系统调用</p>
</li>
<li><p>内核处理完成后，主动触发trap，再次中断切换回用户态</p>
<p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/image-20240323134044281.png" alt="image-20240323134044281"></p>
</li>
</ul>
</li>
<li><p>中断：外围设备完成请求后向CPU发送中断信号，这个时候如果进程是用户态就会被切换到运行态。比如比如硬盘读写操作完成，系统会切换到硬盘读写的中断处理程序中执行后续操作等</p>
</li>
<li><p>异常</p>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>线程和进程</p>
</blockquote>
<ul>
<li>进程：计算机中运行的实例</li>
<li>线程：多个线程在一个进程中运行，共享进程中的资源（内存空间、文件句柄、网络连接等）</li>
<li>进程切换开销大，线程开销小</li>
<li>同一进程下的线程共享文件，因此他们之间的通信无需调用内核</li>
<li>多个线程可以并发处理不同任务，而进程只能在一个时间段干一件事，遇到阻塞如IO阻塞就会挂起</li>
</ul>
<blockquote>
<p>进程状态</p>
</blockquote>
<ul>
<li>与线程类似：创建、就绪、运行、阻塞、结束</li>
</ul>
<blockquote>
<p>进程间通信</p>
</blockquote>
<ul>
<li>管道/匿名管道(Pipes)：用于具有亲缘关系的父子进程间或者兄弟进程之间的通信。</li>
<li>有名管道(Named Pipes) </li>
<li>信号</li>
<li>消息队列</li>
<li>信号量</li>
<li>共享内存</li>
<li>套接字</li>
</ul>
<blockquote>
<p>进程调度算法</p>
</blockquote>
<ul>
<li>先到先服务</li>
<li>短作业优先</li>
<li>时间片轮转调度</li>
<li><strong>多级反馈队列调度</strong>：既能使高优先级的作业得到响应又能使短作业（进程）迅速完成best</li>
<li>优先级调度</li>
</ul>
<blockquote>
<p>僵尸进程和孤儿进程</p>
</blockquote>
<ul>
<li>僵尸进程：子进程已经终止，但是其父进程仍在运行</li>
<li>孤儿进程：一个进程的父进程已经终止或者不存在，但是该进程仍在运行</li>
</ul>
<blockquote>
<p>线程间的同步方式</p>
</blockquote>
<ul>
<li>互斥锁：比如java中的<code>synchronized</code>关键字和各种<code>lock</code></li>
<li>读写锁：只有一个线程可以写，可以多个线程同时读</li>
<li>信号量：允许同一时刻多个线程访问资源，但是需要控制线程数量</li>
<li>屏障：java中的<code>CyclicBarrier</code>：多个线程到了同一状态再一起行动</li>
<li>事件：<code>Wait/Notify</code>：通过通知操作的方式来保持多线程同步，还可以方便的实现多线程优先级的比较操作。</li>
</ul>
<blockquote>
<p>线程的上下文切换</p>
</blockquote>
<ul>
<li>CPU通过分配时间片来执行任务，一个任务从保存到加载的过程就是一次上下文切换</li>
<li>自发性的切换<ul>
<li><code>Thread.sleep()</code></li>
<li><code>Object.wait()</code></li>
<li><code>Thread.yeild()</code>：运行 ==&gt; 就绪</li>
<li><code>Thread.join()</code></li>
</ul>
</li>
<li>非自发性的切换<ul>
<li>时间片用完</li>
<li>更高优先级的线程需要运行</li>
<li>虚拟机的垃圾回收动作</li>
</ul>
</li>
</ul>
<h3 id="15-IO及IO模型"><a href="#15-IO及IO模型" class="headerlink" title="15 IO及IO模型"></a>15 IO及IO模型</h3><ul>
<li>应用程序发起IO调用，由内核来执行具体的IO操作：内核等待IO设备准备好数据 ==&gt; 内核将数据从内核空间拷贝到用户空间</li>
</ul>
<blockquote>
<p>Java常见IO类</p>
</blockquote>
<ul>
<li>磁盘操作：<code>File</code></li>
<li>字节操作：<code>InputStream</code>、<code>OutputStream</code></li>
<li>字符操作：<code>Reader</code>、<code>Writer</code></li>
<li>对象操作：<code>Serializable</code>、<code>transient</code><ul>
<li>只是一个标准，实现前者接口表示需要序列化，后者关键字标识表示不会被序列化</li>
</ul>
</li>
<li>网络操作：<code>Socket</code></li>
</ul>
<blockquote>
<p>UNIX系统下的IO模型</p>
</blockquote>
<ul>
<li><p>同步阻塞IO</p>
<ul>
<li><p>应用程序发起read调用，然后阻塞</p>
</li>
<li><p>内核空间准备数据，拷贝数据</p>
</li>
<li><p>直到拷贝数据结束的这段实际，线程处于阻塞</p>
</li>
<li><p>缺点：客户端连接数量多无法处理</p>
<p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/image-20240323150836151.png" alt="image-20240323150836151" style="zoom: 80%;"></p>
</li>
</ul>
</li>
<li><p>同步非阻塞IO</p>
<ul>
<li><p>应用程序发起read调用</p>
</li>
<li><p>内核空间准备数据，拷贝数据，在此期间应用程序不断的read轮询（polling），如果每准备好就会马上返回错误（所以这段时间可以视为没阻塞）</p>
</li>
<li><p>准备完毕，read调用然后内核拷贝数据到用户空间，此间线程阻塞，直到拷贝完毕</p>
</li>
<li><p>缺点：应用程序不断进行 I/O 系统调用轮询数据是否已经准备好的过程是十分消耗 CPU 资源的。</p>
<p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/image-20240323150859310.png" alt="image-20240323150859310" style="zoom:80%;"></p>
</li>
</ul>
</li>
<li><p>IO多路复用：</p>
<ul>
<li><p>多路：多个请求/网络连接</p>
</li>
<li><p>复用：同一个进程/线程</p>
</li>
<li><p>应用程序发起select/poll/epoll调用，询问内核数据是否准备就绪(读写就绪)，然后线程处于阻塞</p>
</li>
<li><p>内核空间准备数据，查询相关文件描述符的状态，准备完毕发送ready(可能是部分的文件描述符)</p>
</li>
<li><p>用户线程再发起 read 调用</p>
</li>
<li><p>read 调用的过程（数据从内核空间 -&gt; 用户空间），所有数据获取完毕则解除阻塞</p>
</li>
<li><p>优点：</p>
<ul>
<li>通过减少无效的系统调用，减少了对CPU的消耗</li>
<li><strong>一个线程可以检测多个文件描述符</strong>(linux中的文件索引)</li>
</ul>
</li>
<li><p>select几乎所用操作系统都支持，epoll是linux对select的升级，优化了IO执行效率</p>
</li>
<li><p>举例</p>
<ul>
<li>应用程序A使用select/poll/epoll等系统调用监控多个文件描述符(例如是ab两个文件)，随后处于阻塞</li>
<li>内核去查询文件描述符的状态，如果不可操作就进行数据准备</li>
<li>当文件描述符就绪(如b可读取)，内核就会通知应用程序A</li>
<li>A拿到通知后，会检查有哪些文件描述符就绪，并对就绪的文件描述符进行IO操作</li>
<li><strong>如果有多个应用程序都在等b，内核就会通知所有相关的程序，这也是IO多路复用的精髓</strong></li>
</ul>
<p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/image-20240323150252477.png" alt="image-20240323150252477" style="zoom: 50%;"></p>
</li>
<li><p><code>select/poll/epoll</code>区别</p>
<ul>
<li><code>select</code>：程序指定一组文件描述符，用<code>bitmap</code>存储，然后阻塞等待其中任何一个文件描述符就绪。<ul>
<li>不足：文件描述符数量有限(0-1023)，每次调用都需要将全部文件描述符集合从用户态拷贝到内核态，效率低</li>
</ul>
</li>
<li><code>poll</code>：使用了更灵活的链表来管理文件描述符集合，所以文件描述符数量没有限制，但本质上仍然是一种轮询机制。<ul>
<li>不足：在大量文件描述符的情况下需要线性循环扫描，效率依然不高。</li>
</ul>
</li>
<li><code>epoll</code>：linux内核提供，更高效，红黑树+链表</li>
</ul>
</li>
<li><p><code>select/poll</code>过程</p>
<ul>
<li>从<strong>用户空间拷贝fd集合到内核空间</strong>（这部分的开销很大，因为内核空间要修改里面的值，所以要拷贝）</li>
<li>注册回调函数<code>_pollwait</code></li>
<li><strong>遍历所有的fd</strong>，调用其<code>poll</code>方法</li>
<li><code>poll</code>方法返回时会返回一个描述读写操作是否就绪的<code>mask</code>掩码</li>
<li>遍历完所有的fd，还没有返回mask掩码，则使当前的进程进入睡眠状态，当资源可读写后再唤醒，如果长时间没有唤醒则调用<code>select/poll</code>的进程会重新唤醒获取CPU，进而重新遍历fd，判断有没有就绪</li>
<li>如果文件就绪，则将fd集合的引用返回给用户空间</li>
<li>用户再<strong>遍历fd集合</strong>，判断相应的文件描述符状态</li>
</ul>
</li>
<li><p><code>epoll</code>过程：event poll，复杂度降低到了<code>O(1)</code></p>
<ul>
<li>内核空间创建<code>epoll</code>结构体，即一个红黑树和一个就绪链表</li>
<li>用户线程调用<code>epoll_ctl</code>向内核空间注册文件描述符，内核空间会将文件描述符加入到epoll的红黑树中，并建立回调关系</li>
<li>当文件描述符状态发生变化的时候（可读、可写、异常），内核空间会将就绪事件加入到epoll链表中</li>
<li>用户空间调用<code>epoll_wait</code>等待就绪的事件，内核空间将就绪事件从就绪链表中返回给用户空间</li>
<li>用户空间线性扫描就绪链表，获取就绪文件描述符号，调用<code>read()</code>等方法进行IO操作</li>
</ul>
</li>
</ul>
</li>
<li><p>信号驱动IO</p>
</li>
<li><p>异步IO：基于事件和回调机制实现，应用系统不需要自己检查IO操作</p>
<p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/image-20240323153018146.png" alt="image-20240323153018146" style="zoom:50%;"></p>
</li>
</ul>
<blockquote>
<p>同步非阻塞和IO多路复用？</p>
</blockquote>
<ul>
<li>前者发送read后收到错误就解除阻塞了，如果是数据准备完成就直到获取完数据就解除阻塞，后者在发送系统调用后就一直阻塞，直到内核返回文件描述符就绪信息</li>
<li>并发请求比较少的情况下前者的效率更高，后者的优势在于一个线程监测多个文件描述符，可以实现文件描述符的复用，减少不必要的资源消耗</li>
</ul>
<blockquote>
<p>java中的三种IO模型</p>
</blockquote>
<ul>
<li><p>不同的是内核空间变成了服务端，用户空间变成了客户端</p>
</li>
<li><p>BIO(Blocking I/O)：同步阻塞IO</p>
</li>
<li>NIO(Non-blocking/New I/O)，可以看作是IO多路复用模型<ul>
<li>三个核心组件：<ul>
<li>Channel：通道，用于传递信息</li>
<li>Buffer：缓冲区，连接Channel和客户端/服务端的缓冲区</li>
<li>Selector：选择器，用于监控Channel中的IO事件的组件</li>
</ul>
</li>
</ul>
</li>
<li>AIO(Asynchronous I/O)：异步 IO 模型</li>
</ul>
<h3 id="16-JVM"><a href="#16-JVM" class="headerlink" title="16 JVM"></a>16 JVM</h3><blockquote>
<p>JVM 内存模型</p>
</blockquote>
<p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/image-20240315171612257.png" alt="image-20240315171612257" style="zoom:33%;"></p>
<p><img src="C:\Users\H\AppData\Roaming\Typora\typora-user-images\image-20240324104828501.png" alt="image-20240324104828031" style="zoom:67%;"></p>
<ul>
<li>运行时内存<ul>
<li>线程私有：<ul>
<li><strong>程序计数器</strong>：不会产生<code>StackOverflowError</code>和<code>OutOfMemoryError</code>。</li>
<li><strong>Java虚拟机栈</strong>：可能出现<code>StackOverflowError</code>和<code>OutOfMemoryError</code>。<ul>
<li>栈帧：栈的小单元<ul>
<li>局部变量表</li>
<li>操作数栈</li>
<li>动态链接：一个方法调用另一个方法的情景</li>
<li>方法返回地址</li>
</ul>
</li>
</ul>
</li>
<li><strong>本地方法栈</strong></li>
</ul>
</li>
<li>线程共享：<ul>
<li><strong>方法区</strong>：存储编译器编译后的代码缓存数据：类信息、字段信息、方法信息、常量、静态变量<ul>
<li>JDK8之前用的<strong>永久代(JAVA堆的内存)</strong>，JDK8之后用的<strong>元空间(操作系统的内存)</strong></li>
<li>包含的的是整个程序唯一的元素：static，class变量</li>
<li>运行时常量池</li>
</ul>
</li>
<li><strong>java堆</strong>：内存最大的一块，存放实例对象<ul>
<li>结构：可以分为新生代和老年代，JDK8之前还有一个永久代区域用于方法区<ul>
<li>新生代：由Eden、S0(From Sruvivor)、S1(To Sruvivor)组成：8：1：1</li>
<li>老年代：</li>
</ul>
</li>
<li>字符串常量池</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>本地内存<ul>
<li>元空间：也就是JDK8之后的方法区</li>
<li>直接内存</li>
</ul>
</li>
</ul>
<blockquote>
<p>为什么要分两个S区？</p>
</blockquote>
<ul>
<li>为了保证任何时候总有一个survivor是空的（幸存区），主要为了解决内存的碎片化问题，防止频繁触发GC,影响程序的性能和响应速度。</li>
<li>从Eden进入survivor时，如果S区不是空的，就会产生内存碎片，本来S区的内存就不大</li>
</ul>
<blockquote>
<p>垃圾回收</p>
</blockquote>
<ul>
<li><p>主要是对堆内存的垃圾回收</p>
</li>
<li><p>分类</p>
<ul>
<li><p>Partial GC</p>
<ul>
<li><p>young GC：只收集新生代</p>
</li>
<li><p>Old GC：只收集老年代</p>
</li>
<li><p>Mixed GC ：新生代+部分老年代</p>
</li>
</ul>
</li>
<li><p>Full GC：整个Java堆和方法区（不会影响元空间）</p>
</li>
</ul>
</li>
<li><p>内存分配</p>
<ul>
<li>优先在新生代的Eden区分配，空间不足就发起一次GC</li>
<li>大对象（需要大量连续内存空间的对象：字符串、数组等）直接进老年代</li>
<li>长期存活对象进老年代<ul>
<li>在Eden区第一次出生，经过一次 Minor GC 后存活则进入Survivor区（S0或者S1）</li>
<li>每熬过一次GC就加一岁，默认到15岁进入老年区</li>
</ul>
</li>
</ul>
</li>
<li><p>死亡对象判断（并不会马上宣判死亡）</p>
<ul>
<li><p>引用计数法：当被引用就+1，计数器为0就判断死亡</p>
</li>
<li><p>可达性分析算法：用一系列成为”GC Root“的对象作为起点，如果对象不在以这个Root为起点的链上，就死亡</p>
<ul>
<li><p>常见GC Root：</p>
<ul>
<li><p>虚拟机栈(栈帧中的局部变量表)中引用的对象</p>
</li>
<li><p>本地方法栈(Native 方法)中引用的对象</p>
</li>
<li><p>方法区中类静态属性引用的对象</p>
</li>
<li><p>方法区中常量引用的对象</p>
</li>
<li><p>所有被同步锁持有的对象</p>
</li>
<li><p>JNI（Java Native Interface）引用的对象</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>四大引用</p>
</blockquote>
<ul>
<li>强引用：用的多，不会被回收</li>
<li>软引用：内存空间够就不会回收</li>
<li>弱引用：发现了就会被回收</li>
<li>虚引用：</li>
</ul>
<blockquote>
<p>如何判断废弃常量和无用的类</p>
</blockquote>
<ul>
<li>常量：没用引用</li>
<li>类：满足条件就“可以”被回收<ul>
<li>堆中没有实例</li>
<li>加载该类的<code>ClassLoader</code>被回收</li>
<li>该类对应的<code>java.lang.Class</code>没有被引用，也没有反射调用</li>
</ul>
</li>
</ul>
<blockquote>
<p>垃圾清除算法</p>
</blockquote>
<ul>
<li><p>标记-清除算法</p>
<ul>
<li>内存碎片问题；效率问题</li>
</ul>
<p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/image-20240324113013046.png" alt="image-20240324113013046" style="zoom:67%;"></p>
</li>
<li><p>标记-复制算法：内存切半，一次用一半</p>
<ul>
<li>可用内存变小；不适合老年代（对象数量大，复制性能差）</li>
</ul>
<p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/image-20240324113118170.png" alt="image-20240324113118170" style="zoom: 67%;"></p>
</li>
<li><p>标记-整理算法：</p>
<ul>
<li>多了整理这一步，效率不高。</li>
<li>适合老年代这种垃圾回收频率不是很高的场景。</li>
</ul>
<p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/image-20240324113228667.png" alt="image-20240324113228667" style="zoom:67%;"></p>
</li>
<li><p><strong>分代收集算法</strong></p>
<ul>
<li>分为新生代和老年代</li>
<li>新生代中每次收集都有很多对象死去，可用标记-复制算法</li>
<li>老年代中对象存活几率是比较高，必须选择“标记-清除”或“标记-整理”算法</li>
<li>这也是堆分代的原因</li>
</ul>
</li>
</ul>
<blockquote>
<p>垃圾收集器</p>
</blockquote>
<ul>
<li>Serial（串行）收集器：单线程</li>
</ul>
<p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/image-20240324114051981.png" alt="image-20240324114051981"></p>
<ul>
<li>ParNew 收集器：多线程版本</li>
</ul>
<p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/image-20240324114117775.png" alt="image-20240324114117775"></p>
<ul>
<li>Parallel Scavenge 收集器</li>
</ul>
<p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/image-20240324114202214.png" alt="image-20240324114202214"></p>
<ul>
<li>Serial Old 收集器</li>
</ul>
<p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/image-20240324114310340.png" alt="image-20240324114310340"></p>
<ul>
<li>Parallel Old 收集器：Parallel Scavenge 收集器的老年代版本</li>
</ul>
<p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/image-20240324114336382.png" alt="image-20240324114336382"></p>
<ul>
<li>CMS收集器：注重用户的体验的应用上使用，实现用户线程和GC线程并发<ul>
<li>过程<ul>
<li>初始标记：暂停用户线程，标记与Root直连的对象</li>
<li>并发标记：开启用户线程，用一个闭包记录可达对象（是针对于上一个时刻的状态）</li>
<li>重新标记：暂停用户线程，再次标记并发标记过程中用户线程变动的标记情况（相当于一个同步）</li>
<li>并发清除：开启用户线程，GC线程清除未标记区域</li>
</ul>
</li>
<li>缺点：从 JDK9 开始，CMS 收集器已被弃用<ul>
<li>对 CPU 资源敏感；</li>
<li>无法处理浮动垃圾；</li>
<li>它使用的回收算法-“标记-清除”算法会导致收集结束时会有大量空间碎片产生。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/image-20240324114611636.png" alt="image-20240324114611636"></p>
<ul>
<li><p><strong>G1收集器</strong>：JDK就之后的默认收集器</p>
<ul>
<li>低延迟，高吞吐量</li>
<li>大内存，多核场景</li>
<li>标记整理</li>
</ul>
<p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/image-20240324115056539.png" alt="image-20240324115056539"></p>
</li>
</ul>
<blockquote>
<p>类的生命周期</p>
</blockquote>
<ul>
<li>加载（Loading）<ul>
<li>类的加载是通过类加载器完成<code>ClassLoader</code></li>
<li>用哪个加载器是通过 <strong>双亲委派模型</strong> 决定</li>
</ul>
</li>
<li>验证（Verification）<ul>
<li>确保 Class 文件的字节流中包含的信息符合安全</li>
</ul>
</li>
<li>准备（Preparation）<ul>
<li>为类在方法区分配空间</li>
</ul>
</li>
<li>解析（Resolution）<ul>
<li>虚拟机将常量池内的符号引用替换为直接引用的过程</li>
</ul>
</li>
<li>初始化（Initialization）<ul>
<li>执行初始化方法 <code>&lt;clinit&gt;</code> ()方法</li>
</ul>
</li>
<li>使用（Using）</li>
<li>卸载（Unloading）<ul>
<li>三个条件<ul>
<li>该类的所有的实例对象都已被 GC，也就是说堆不存在该类的实例对象。</li>
<li>该类没有在其他任何地方被引用</li>
<li>该类的类加载器的实例已被 GC</li>
</ul>
</li>
<li>JDK 自带的 <code>BootstrapClassLoader</code>, <code>ExtClassLoader</code>, <code>AppClassLoader</code> 负责加载 JDK 提供的类，所以它们(类加载器的实例)肯定不会被回收。</li>
<li>自定义的类加载器的实例是可以被回收的</li>
</ul>
</li>
</ul>
<blockquote>
<p>类加载器</p>
</blockquote>
<ul>
<li><p>负责加载类的对象，<code>ClassLoader</code> 是一个抽象类</p>
</li>
<li><p>将<code>.class</code>文件加载到JVM中</p>
</li>
<li><p>每个 Java 类都有一个引用指向加载它的 <code>ClassLoader</code>。不过，数组类不是通过 <code>ClassLoader</code> 创建的，而是 JVM 在需要的时候自动创建的，数组类通过<code>getClassLoader()</code>方法获取 <code>ClassLoader</code> 的时候和该数组的元素类型的 <code>ClassLoader</code> 是一致的。</p>
</li>
<li><p>动态加载：要用的时候再加载</p>
</li>
<li>JVM内置类加载器<ul>
<li><code>BootstrapClassLoader</code>（启动类加载器）<ul>
<li>最顶层，C++实现，通常表示为 null<ul>
<li><code>getClassLoader()</code>得到的是null,因为C++实现，没有对应的Java类</li>
</ul>
</li>
<li>加载核心类库：<code>%JAVA_HOME%/lib</code>下的<code>rt.jar</code>、<code>resources.jar</code>、<code>charsets.jar</code>等 jar 包和类<ul>
<li><code>rt.jar</code>就是基础类库</li>
</ul>
</li>
<li>还有被<code>-Xbootclasspath</code>参数指定的路径下的所有类</li>
</ul>
</li>
<li><code>ExtensionClassLoader</code>（扩展类加载器）<ul>
<li><code>%JRE_HOME%/lib/ext</code>下的jar</li>
<li><code>java.ext.dirs</code> 系统变量所指定的路径下的所有类。</li>
</ul>
</li>
<li><code>AppClassLoader</code>（应用程序类加载器）<ul>
<li>加载当前classpath 下的类和jar包</li>
</ul>
</li>
</ul>
</li>
<li><p>自定义类加载器</p>
<ul>
<li><code>protected Class loadClass(String name, boolean resolve)</code>：加载指定二进制名称的类，实现了双亲委派机制 。</li>
<li><code>protected Class findClass(String name)</code>：根据类的二进制名称来查找类，默认实现是空方法。</li>
<li>区别：<ul>
<li>不想打破双亲委派，就重写<code>findClass</code>方法，无法被父类加载器加载的都过这个加载器加载</li>
<li>想打破双亲委派，就重写<code>loadClass</code></li>
</ul>
</li>
<li>Tomcat：自定义了<code>WebAppClassLoader</code>加载相关目录下的类</li>
<li>Spring：自定义了<code>ThreadContextClassLoader</code>线程上下文类加载器，</li>
</ul>
</li>
<li><p>双亲委派模型（就一个父类）</p>
<ul>
<li><p><code>ClassLoader</code> 类使用委托模型来搜索类和资源。</p>
</li>
<li><p>双亲委派模型要求除了顶层的启动类加载器外，其余的类加载器都应有自己的父类加载器。</p>
</li>
<li><p><code>ClassLoader</code> 实例会在试图亲自查找类或资源之前，将搜索类或资源的任务委托给其父类加载器。</p>
<p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/image-20240324134630162.png" alt="image-20240324134630162" style="zoom: 33%;"></p>
</li>
<li><p>注意：</p>
<ul>
<li>只是JDK的一种推荐，并不是强制的约束</li>
<li>类加载器之间的父子关系一般不是以继承的关系来实现的，而是通常使用组合关系来复用父加载器的代码。</li>
</ul>
</li>
<li><p>执行流程</p>
<ul>
<li>判断类有没有被加载过</li>
<li>没有被加载则先委托给父类加载(父类的<code>loadClass</code>)（也就是所有的请求都会从<code>BootstrapClassLoader</code>开始）</li>
<li>父类无法加载则子加载器再加载(<code>findClass</code>)</li>
<li>若还是无法加载，则抛出<code>ClassNotFoundException</code>异常</li>
</ul>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>JVM 参数</p>
</blockquote>
<ul>
<li><p>堆内存相关</p>
<figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 堆内存</span></span><br><span class="line">-Xms&lt;heap size&gt;[unit] <span class="comment"># 最小 unit：g,m,k</span></span><br><span class="line">-Xmx&lt;heap size&gt;[unit] <span class="comment"># 最大</span></span><br><span class="line">-----------------------------------</span><br><span class="line">-Xms2G -Xmx5G</span><br><span class="line">====================================</span><br><span class="line"><span class="comment"># 新生代</span></span><br><span class="line">-XX:NewSize=&lt;young size&gt;[unit]</span><br><span class="line">-XX:MaxNewSize=&lt;young size&gt;[unit]</span><br><span class="line">-----------------------------------</span><br><span class="line">-XX:NewSize=256m</span><br><span class="line">-XX:MaxNewSize=1024m</span><br><span class="line">====================================</span><br><span class="line"><span class="comment"># 新生代2</span></span><br><span class="line">-Xmn&lt;young size&gt;[unit]</span><br><span class="line">-----------------------------------</span><br><span class="line">-Xmn256m</span><br><span class="line">====================================</span><br><span class="line"><span class="comment"># 永久代</span></span><br><span class="line">-XX:PermSize=N <span class="comment"># 方法区 (永久代) 初始大小</span></span><br><span class="line">-XX:MaxPermSize=N <span class="comment"># 方法区 (永久代) 最大大小</span></span><br><span class="line">====================================</span><br><span class="line"><span class="comment">#元空间</span></span><br><span class="line">-XX:MetaspaceSize=N <span class="comment"># 设置 Metaspace 的初始大小</span></span><br><span class="line">-XX:MaxMetaspaceSize=N <span class="comment"># 设置 Metaspace 的最大大小</span></span><br><span class="line">====================================</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>垃圾收集相关</p>
<figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 选择垃圾回收器</span></span><br><span class="line">-XX:+UseSerialGC	<span class="comment"># 串行垃圾收集器</span></span><br><span class="line">-XX:+UseParallelGC	<span class="comment"># 并行垃圾收集器</span></span><br><span class="line">-XX:+UseParNewGC	<span class="comment"># CMS 垃圾收集器</span></span><br><span class="line">-XX:+UseG1GC		<span class="comment"># G1 垃圾收集器</span></span><br><span class="line">=====================================</span><br><span class="line"><span class="comment"># 日志</span></span><br><span class="line"><span class="comment"># 打印基本 GC 信息</span></span><br><span class="line">-XX:+PrintGCDetails</span><br><span class="line">-XX:+PrintGCDateStamps</span><br><span class="line"><span class="comment"># GC日志输出的文件路径</span></span><br><span class="line">-Xloggc:/path/to/gc-%t.log</span><br><span class="line"><span class="comment"># 每个文件上限大小，超过就触发分割</span></span><br><span class="line">-XX:GCLogFileSize=50M</span><br></pre></td></tr></tbody></table></figure>
</li>
</ul>
<h3 id="17-SQL"><a href="#17-SQL" class="headerlink" title="17 SQL"></a>17 SQL</h3><p><a target="_blank" rel="noopener" href="https://sqlmother.solargod.cn/#/learn">https://sqlmother.solargod.cn/#/learn</a></p>
<blockquote>
<p>CRUD</p>
</blockquote>
<ul>
<li><p>增：<code>INSERT</code></p>
</li>
<li><p>删：<code>DELETE</code>（删除记录），<code>TRUNCATE</code>（清空表），<code>DROP</code>（删除表）</p>
</li>
<li><p>改：<code>UPDATE</code></p>
</li>
<li><p>查：</p>
<ul>
<li><p><code>SELECT</code>，<code>LIMIT</code>，<code>ORDER BY</code>，<code>ASC</code>，<code>DESC</code></p>
</li>
<li><p><code>IS NULL</code> 、<code>IS NOT NULL</code></p>
</li>
<li><p><code>GROUP BY</code></p>
<ul>
<li>分组之前过滤用<code>WHERE</code></li>
<li>分组之后用<code>HAVING</code></li>
</ul>
</li>
<li><p>子查询常用在 <code>WHERE</code> 子句和 <code>FROM</code> 子句后边，放在<code>()</code>里面，<code>EXISTS</code>、<code>NOT EXISTS</code></p>
</li>
<li><p><code>IN(XX,XX,XX...)</code></p>
</li>
<li><p><code>BETWEEN x AND y</code></p>
</li>
<li><p><code>AND</code> <code>OR</code> <code>NOT</code></p>
</li>
<li><p><code>DISTINCT</code>：去重，如果有多个字段就是组合去重</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select distinct class_id, exam_num from student;</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>列操作</p>
<figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> name, score, score <span class="operator">*</span> <span class="number">2</span> <span class="keyword">as</span> double_score <span class="keyword">from</span> student；</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p><code>LIKE</code> </p>
<ul>
<li><code>%</code>：任意字符出现任意次数</li>
<li><code>_</code>：任意字符出现一次</li>
<li>eg：<code>WHERE prod_name LIKE '%bean bag%';</code></li>
</ul>
</li>
<li><p><code>JOIN</code> 用 <code>ON</code>表示连接条件</p>
<figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> c.cust_name, o.order_num</span><br><span class="line"><span class="keyword">from</span> Customers c</span><br><span class="line"><span class="keyword">inner</span> <span class="keyword">join</span> Orders o</span><br><span class="line"><span class="keyword">on</span> c.cust_id <span class="operator">=</span> o.cust_id</span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> c.cust_name;</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p><code>UNION</code> <code>UNION ALL</code>连接两个表，后者不去重 </p>
</li>
<li><p>条件分支</p>
<figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">-- 一个表有name和age列，返回name，age_level(age &gt; 60为老同学，&gt;=20为年轻，为空或者&lt;20为小同学)，最后结果用name升序排</span></span><br><span class="line"><span class="keyword">select</span></span><br><span class="line">  name,</span><br><span class="line">  <span class="keyword">case</span></span><br><span class="line">    <span class="keyword">when</span> (age <span class="operator">&gt;</span> <span class="number">60</span>) <span class="keyword">then</span> "老同学"</span><br><span class="line">    <span class="keyword">when</span> (age <span class="operator">&gt;=</span> <span class="number">20</span>) <span class="keyword">then</span> "年轻"</span><br><span class="line">    <span class="keyword">else</span> "小同学"</span><br><span class="line">  <span class="keyword">end</span> <span class="keyword">as</span> age_level</span><br><span class="line"><span class="keyword">from</span></span><br><span class="line">  student</span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span></span><br><span class="line">  name <span class="keyword">ASC</span>;</span><br></pre></td></tr></tbody></table></figure>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>函数</p>
</blockquote>
<ul>
<li><p>开窗函数 <code>PARTITION BY xx</code>分组依据 <code>ORDER BY xx</code> 排序依据</p>
<ul>
<li><p><code>SUM(xx) OVER</code>：计算累计值，比如某个用户的累计消费</p>
<figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">SUM</span>(计算字段名) <span class="keyword">OVER</span> (<span class="keyword">PARTITION</span> <span class="keyword">BY</span> 分组字段名)</span><br><span class="line"><span class="comment">-- 每个学生的详细信息，并且按照分数升序的方式累加计算每个班级的学生总分</span></span><br><span class="line"><span class="keyword">select</span> </span><br><span class="line">    id, name, age, score, class_id,</span><br><span class="line">    <span class="built_in">SUM</span>(score) <span class="keyword">OVER</span> (<span class="keyword">PARTITION</span> <span class="keyword">BY</span> class_id <span class="keyword">order</span> <span class="keyword">by</span> score <span class="keyword">asc</span>) <span class="keyword">as</span> class_sum_score</span><br><span class="line"><span class="keyword">from</span> student</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p><code>AVG(xx) OVER</code>：计算平均值，比如某个班的平均分，加在学生信息后面</p>
<figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span></span><br><span class="line">    id, name, age, score, class_id,</span><br><span class="line">    <span class="built_in">AVG</span>(score) <span class="keyword">OVER</span> (<span class="keyword">PARTITION</span> <span class="keyword">BY</span> class_id) <span class="keyword">as</span> class_avg_score</span><br><span class="line"><span class="keyword">from</span> student</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p><code>RANK() OVER</code></p>
<figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">  id,name,age,score,class_id,</span><br><span class="line">  <span class="built_in">RANK</span>() <span class="keyword">OVER</span> (<span class="keyword">PARTITION</span> <span class="keyword">BY</span> class_id <span class="keyword">ORDER</span> <span class="keyword">BY</span> score <span class="keyword">DESC</span>) <span class="keyword">as</span> ranking</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">  student;</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p><code>ROW_NUMBER() OVER</code>：和<code>RANK() OVER</code>不一样的地方在于这个得到的排序是唯一的</p>
</li>
<li><p><code>Lag() OVER</code> <code>Lead() OVER</code> </p>
<figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- Lag 函数用于获取 当前行之前 的某一列的值 </span></span><br><span class="line"><span class="built_in">LAG</span>(column_name, <span class="keyword">offset</span>, default_value) <span class="keyword">OVER</span> (<span class="keyword">PARTITION</span> <span class="keyword">BY</span> partition_column <span class="keyword">ORDER</span> <span class="keyword">BY</span> sort_column);</span><br><span class="line"><span class="comment">-- Lead 函数用于获取 当前行之后 的某一列的值 </span></span><br><span class="line"><span class="built_in">LEAD</span>(column_name, <span class="keyword">offset</span>, default_value) <span class="keyword">OVER</span> (<span class="keyword">PARTITION</span> <span class="keyword">BY</span> partition_column <span class="keyword">ORDER</span> <span class="keyword">BY</span> sort_column)</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 以班级为单位按照分数降序的方式获取每个班级内的学生的前一名学生姓名（prev_name）、后一名学生姓名（next_name）。</span></span><br><span class="line"><span class="keyword">select</span> </span><br><span class="line">    id, name, age, score, class_id,</span><br><span class="line">    <span class="built_in">LAG</span>(name, <span class="number">1</span>, <span class="keyword">NULL</span>) <span class="keyword">OVER</span> (<span class="keyword">PARTITION</span> <span class="keyword">BY</span> class_id  <span class="keyword">ORDER</span> <span class="keyword">BY</span> score <span class="keyword">desc</span>) <span class="keyword">as</span> prev_name,</span><br><span class="line">    <span class="built_in">LEAD</span>(name, <span class="number">1</span>, <span class="keyword">NULL</span>) <span class="keyword">OVER</span> (<span class="keyword">PARTITION</span> <span class="keyword">BY</span> class_id  <span class="keyword">ORDER</span> <span class="keyword">BY</span> score <span class="keyword">desc</span>) <span class="keyword">as</span> next_name</span><br><span class="line"><span class="keyword">from</span> student</span><br></pre></td></tr></tbody></table></figure>
</li>
</ul>
</li>
</ul>
<h3 id="18-设计模式"><a href="#18-设计模式" class="headerlink" title="18 设计模式"></a>18 设计模式</h3><h4 id="装饰者模式"><a href="#装饰者模式" class="headerlink" title="装饰者模式"></a>装饰者模式</h4><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/image-20240508114653108.png" alt="image-20240508114653108" style="zoom: 80%;"></p>
<ul>
<li><p>抽象组件：<code>Component</code></p>
</li>
<li><p>被装饰类：<code>ConcreteComponent</code></p>
</li>
<li><p>装饰者组件：<code>Decorator</code></p>
</li>
<li><p>具体装饰：<code>ConcreteDecoratorA</code>、<code>ConcreteDecoratorB</code></p>
</li>
<li><p>核心是<code>Decorator</code>内维护一个<code>Component</code>类型的变量</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Decorator</span> <span class="keyword">implements</span> <span class="title class_">Component</span> {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> Component component;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">BitmapDecorator</span><span class="params">(Component component)</span> {</span><br><span class="line">        component = component;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doOperation</span><span class="params">()</span> {</span><br><span class="line">        component.component();<span class="comment">//可以做基础操作</span></span><br><span class="line">        <span class="comment">// 子类ConcreteDecoratorA、ConcreteDecoratorB再对这个方法进行装饰增强</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>使用</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ConcreteComponent</span> <span class="variable">concreteComponent</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConcreteComponent</span>();<span class="comment">//创建被装饰者</span></span><br><span class="line"></span><br><span class="line">concreteComponent.doOperation();<span class="comment">//无任何装饰</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">ConcreteDecoratorA</span>(concreteComponent).doOperation();<span class="comment">//装饰器A增强</span></span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>具体使用，IO类</p>
<p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/image-20240508115513966.png" alt="image-20240508115513966"></p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">FileInputStream</span> <span class="variable">fileInputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(filePath);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 两种不同的装饰</span></span><br><span class="line"><span class="type">BufferedInputStream</span> <span class="variable">bufferedInputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedInputStream</span>(fileInputStream);</span><br><span class="line"><span class="type">DataInputStream</span> <span class="variable">dataInputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DataInputStream</span>(fileInputStream);</span><br></pre></td></tr></tbody></table></figure>
</li>
</ul>
<h2 id="二-项目"><a href="#二-项目" class="headerlink" title="二 项目"></a>二 项目</h2><h3 id="1-FS开发"><a href="#1-FS开发" class="headerlink" title="1 FS开发"></a>1 FS开发</h3><ul>
<li>难点：高频次的呼叫+自定义的移库策略导致任务呼叫时与任务实际执行时库位的状态不一致，且无法通过设置库位预定占用量来确定，无法获取准确的库位信息进而无法确定空闲库位；</li>
<li>解决：自定义呼叫池，延后实际的呼叫事件触发时间，在池中维护一个队列，每次呼叫成功后再从池中获取任务，再根据当前的状态进行任务的调度。</li>
</ul>
<blockquote>
<p>涉及到的设计模式</p>
</blockquote>
<ul>
<li><h3 id="2-苍穹"><a href="#2-苍穹" class="headerlink" title="2 苍穹"></a>2 苍穹</h3></li>
</ul>
<h4 id="2-0-亮点"><a href="#2-0-亮点" class="headerlink" title="2.0 亮点"></a>2.0 亮点</h4><blockquote>
<p>使用AOP+自定义注解的方式实现业务的公共字段的自动插入/更新</p>
</blockquote>
<ul>
<li><p>定义<code>@AutoFill</code>注解，并定义<code>OperationType value();</code>属性是一个枚举类：更新和插入</p>
<p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/image-20240319103405484.png" alt="image-20240319103405484" style="zoom: 67%;"></p>
</li>
<li><p>标识切面类<code>AutoFillAspect</code>（<code>@Aspect</code>修饰）</p>
<p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/image-20240319103353768.png" alt="image-20240319103353768" style="zoom:67%;"></p>
</li>
<li><p>定义切入点<code>@PointCut</code>：限制扫描的包以及需要被<code>@AutoFill</code>修饰</p>
<p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/image-20240319103343189.png" alt="image-20240319103343189"></p>
</li>
<li><p>定义前置通知<code>@Before("autoFillPointCut()")</code></p>
<ul>
<li>通过<code>JoinPoint</code>对象获取实体对象</li>
<li>通过反射来设置对象的值</li>
</ul>
</li>
</ul>
<blockquote>
<p>ThreadLocal对象</p>
</blockquote>
<ul>
<li>实现了线程之间的数据隔离</li>
<li>一个线程里面有一个ThreadLocalMap对象，里面维护了一个Entry数据，key就是Thread对象，value是保存的值</li>
<li>在本项目中实现：<ul>
<li>在拦截器中对JWT解析，解析通过后保存当前用户id</li>
<li>MyBatis中的分页插件Pagehelper底层使用的也是ThreadLocal来保存</li>
</ul>
</li>
<li>ThreadLocal内存泄漏：见java基础</li>
</ul>
<h4 id="2-1介绍"><a href="#2-1介绍" class="headerlink" title="2.1介绍"></a>2.1介绍</h4><ul>
<li>本项⽬包括管理端和小程序端两部分。其中管理端主要给内部员⼯使⽤，可以对菜品的分类、套餐、订单、员⼯信息进⾏管理维 护，对订单进⾏统计分析；小程序端主要给⽤⼾使⽤，可以在线浏览菜品、添加购物⻋、下单、⽀付等</li>
<li><code>SpringBoot+Mybatis+Redis+MySQL</code></li>
</ul>
<h4 id="2-2-数据表"><a href="#2-2-数据表" class="headerlink" title="2.2 数据表"></a>2.2 数据表</h4><ul>
<li><p>地址表 <code>address_book</code></p>
<p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/image-20240311162824258.png" alt="image-20240311162824258"></p>
</li>
<li><p>套餐分类表 <code>category</code></p>
<p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/image-20240311162842385.png" alt="image-20240311162842385"></p>
</li>
<li><p>菜品表 <code>dish</code></p>
<p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/image-20240311162908810.png" alt="image-20240311162908810"></p>
</li>
<li><p>菜品口味表 <code>dish_flavor</code></p>
<p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/image-20240311162923552.png" alt="image-20240311162923552"></p>
</li>
<li><p>员工表 <code>employee</code></p>
</li>
<li><p>用户表 <code>user</code></p>
</li>
<li><p>订单明细表 <code>order_detail</code></p>
<p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/image-20240311163113434.png" alt="image-20240311163113434"></p>
</li>
<li><p>订单表 <code>orders</code></p>
<p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/image-20240311163219518.png" alt="image-20240311163219518"></p>
</li>
<li><p>套餐表 setmeal</p>
<p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/image-20240311163331594.png" alt="image-20240311163331594"></p>
</li>
<li><p>套餐明细表 setmeal_dish</p>
<p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/面试准备.assets/image-20240311163313463.png" alt="image-20240311163313463" style="zoom:67%;"></p>
</li>
<li><p>购物车表 shopping_cart</p>
<p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/image-20240311163341344.png" alt="image-20240311163341344"></p>
</li>
</ul>
<h4 id="2-3-技术点"><a href="#2-3-技术点" class="headerlink" title="2.3 技术点"></a>2.3 技术点</h4><blockquote>
<p>JWT</p>
</blockquote>
<ul>
<li><p>三个部分，头部声明了加密算法HS256合加密类型JWT，载荷声明用户信息，尾部是前两部分的签名</p>
<figure class="highlight json"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//头部</span></span><br><span class="line"><span class="punctuation">{</span></span><br><span class="line">  <span class="attr">"alg"</span><span class="punctuation">:</span> <span class="string">"HS256"</span><span class="punctuation">,</span>   <span class="comment">//第三段字符串的不可逆加密类型HS256，为什么不可逆？</span></span><br><span class="line">  <span class="attr">"typ"</span><span class="punctuation">:</span> <span class="string">"JWT"</span>   <span class="comment">//token类型JWT</span></span><br><span class="line"><span class="punctuation">}</span></span><br><span class="line"><span class="comment">//载荷</span></span><br><span class="line"><span class="punctuation">{</span></span><br><span class="line">  <span class="attr">"sub"</span><span class="punctuation">:</span> <span class="string">"1234567890"</span><span class="punctuation">,</span>   <span class="comment">//用户id</span></span><br><span class="line">  <span class="attr">"name"</span><span class="punctuation">:</span> <span class="string">"John Doe"</span><span class="punctuation">,</span>		<span class="comment">//用户名</span></span><br><span class="line">  <span class="attr">"exp"</span><span class="punctuation">:</span> <span class="number">1516239022</span>		<span class="comment">//token过期时间</span></span><br><span class="line"><span class="punctuation">}</span></span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>生成过程</p>
<ul>
<li>首先将1、2部分进行<code>base64</code>加密(这个过程是可逆的，只要别人知道了使用base64加密就可以直接解析出来)<ul>
<li><code>base64</code>: ‘a’到 ‘z’ ‘A’ 到’Z’ ‘0’ 到 ‘9’ 再加上 ‘+’  ‘/‘一共64个字符</li>
<li>任何符号都可以转换成这个字符集中的字符，这个转换过程就叫做<strong>base64编码</strong></li>
</ul>
</li>
<li>然后使用第一部分声明的HS256和保存在服务器的自定义盐来进行加密得到第三部分</li>
</ul>
</li>
<li><p>解析过程</p>
<ul>
<li>服务端解析1、2部分得到加密类型和信息</li>
<li>根据签名及加密类型解密判断第三部分得到的信息是否与1、2部分一致来判断是否被篡改</li>
<li>进一步判断第2部分进行业务操作</li>
</ul>
</li>
</ul>
<hr>
<blockquote>
<p>HandlerInterceptor拦截器实现JWT校验</p>
</blockquote>
<ul>
<li>实现这个接口，里面有三个方法：<ul>
<li><code>preHandle</code>：Controller方法处理之前<ul>
<li>本项目中用于JWT令牌的校验</li>
</ul>
</li>
<li><code>postHandle</code>：Controller方法处理完之后，DispatcherServlet进行视图的渲染之前，也就是说在这个方法中你可以对ModelAndView进行操作</li>
<li><code>afterCompletion</code>：DispatcherServlet进行视图的渲染之后</li>
</ul>
</li>
</ul>
<hr>
<blockquote>
<p>微信登录</p>
</blockquote>
<ul>
<li>前端传入授权码发送至服务端</li>
<li><p>服务端携带授权码code + appid + secret 采用<code>HttpClient</code>发送请求到<a target="_blank" rel="noopener" href="https://api.weixin.qq.com/sns/jscode2session">https://api.weixin.qq.com/sns/jscode2session</a></p>
</li>
<li><p>得到微信服务端返回的openid + session_key，其中openid也就是微信用户的唯一标识</p>
</li>
<li><p>根据openid查询数据库中是否存在此用户（openid不是主键），若不存在则自动创建，存在则返回该用户信息</p>
</li>
<li><p>为该用户生成jwt令牌（密钥+过期时间+信息）</p>
<ul>
<li>密钥用于加密解密jwt信息</li>
<li>信息claims是一个map，在本项目中只存储了userId这一个信息</li>
</ul>
</li>
<li><p>返回VO对象（token +用户id+微信openid）</p>
</li>
</ul>
<hr>
<blockquote>
<p>redis序列化的方式</p>
</blockquote>
<ul>
<li>JdkSerializationRedisSerializer：默认，将Java对象序列化为字节数组</li>
<li>StringRedisSerializer：默认，使用String类型作为Redis的key和value的序列化方式</li>
<li>GenericToStringSerializer：可以将任何对象泛化为字符串并序列化</li>
<li>Jackson2JsonRedisSerializer ：一种更加轻量级的序列化方式，它仅仅支持JSON格式的序列化和反序列化</li>
<li><strong>GenericJackson2JsonRedisSerializer</strong>：使用Jackson库将Java对象序列化为JSON格式的字符串，以便在Redis中存储和检索 — 常用</li>
</ul>
<blockquote>
<p> Reids与SpringCache</p>
</blockquote>
<ul>
<li><p><strong>key的命名:用户Id+业务名</strong>使用心得</p>
<ul>
<li>取key的时候通过定义工具类来取（输入用户id然后输出key）</li>
</ul>
</li>
<li><p>redis缓存菜品分类</p>
<ul>
<li><p>根据分类id查询菜品存储在List中，随后redis的key为dish_id号，value是list的内容     </p>
</li>
<li><p>当新增、修改、删除菜品的时候删除所有的dish_*的缓存（这里可以做的更细一点）</p>
<p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/苍穹外卖.assets/image-20240224195415885.png" alt="image-20240224195415885" style="zoom:67%;"></p>
</li>
</ul>
</li>
<li><p>SpringCache缓存套餐</p>
<ul>
<li><p>本质：SpringCache在JVM中，集群中不可用，当然也可以实现其整合redis等缓存中间件</p>
</li>
<li><p><code>application</code>类上添加<code>@EnableCaching</code></p>
</li>
<li><p>在根据分类id查询套餐前判断setmealCache这个缓存管理器中有没有指定的分类id的value，有则直接返回，没有则再执行方法，再将查询结果存储在缓存中</p>
<p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/苍穹外卖.assets/image-20240224201425719.png" alt="image-20240224201425719" style="zoom:67%;"></p>
</li>
<li><p>在批量删除套餐的时候清理所有缓存</p>
<p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/苍穹外卖.assets/image-20240224201343039.png" alt="image-20240224201343039" style="zoom:67%;"></p>
</li>
</ul>
</li>
</ul>
<hr>
<blockquote>
<p>定时任务</p>
</blockquote>
<ul>
<li>Spring Task和xxl-job区别：后者是分布式的，更稳定</li>
</ul>
<blockquote>
<p>微信支付</p>
</blockquote>
<ul>
<li>用户点击支付，向接口发送请求</li>
<li>服务端生成订单：获取到当前用户的id，采用JSAPI下单，传入appid、mchid（商户号）、description、out_trade_no、notify_url（回调地址）等信息，发送post请求给微信端（httpclient）<a target="_blank" rel="noopener" href="https://api.mch.weixin.qq.com/v3/pay/transactions/jsapi">https://api.mch.weixin.qq.com/v3/pay/transactions/jsapi</a></li>
<li>微信端返回预支付订单信息返回给服务端</li>
<li>解析返回结果：<strong>prepay_id</strong>（关键，这个要给前端）： 预支付交易会话标识，根据prepay_id及appid、时间等信息生成二次签名（预支付交易单），生成vo对象给前端，前端生成支付二维码</li>
<li>支付成功请求回调地址：完成读取数据、解密数据、业务处理：修改订单状态、给微信响应</li>
</ul>
<hr>
<blockquote>
<p>百度地图和阿里云OSS</p>
</blockquote>
<ul>
<li>申请ak</li>
<li>请求的时候注意参数的顺序：address、output、ak</li>
<li>获取经纬度信息：<a target="_blank" rel="noopener" href="https://api.map.baidu.com/geocoding/v3">https://api.map.baidu.com/geocoding/v3</a></li>
<li>获取路径规划信息：<a target="_blank" rel="noopener" href="https://api.map.baidu.com/directionlite/v1/driving">https://api.map.baidu.com/directionlite/v1/driving</a></li>
</ul>
<hr>
<blockquote>
<p>来单提醒/用户催单</p>
</blockquote>
<ul>
<li><p>客户端通过<code>/ws/{sid}</code>与服务端建立websocket长连接，会话对象<code>Session</code>存储在map中，当需要发送消息的时候调用<code>session.getBasicRemote().sendText(message);</code>方法即可</p>
</li>
<li><p>在客户支付成功之后调用</p>
</li>
<li><p>websocket基于TCP连接</p>
<ul>
<li>TCP三次握手</li>
<li>四次挥手</li>
</ul>
</li>
</ul>
<blockquote>
<p>多用户抢单</p>
</blockquote>
<ul>
<li>乐观锁</li>
</ul>
<blockquote>
<p>订单超时未支付怎么处理</p>
</blockquote>
<ul>
<li>扫表轮询<ul>
<li>用一个定时任务获取数据库中的待支付状态数据，批量关闭超时订单</li>
<li>缺点：表的数据多的时候就会耗时</li>
</ul>
</li>
<li>懒删除<ul>
<li>用户查询订单的时候在业务逻辑中额外做一个判断</li>
<li>缺点：如果没有查询的话就会一直挂起，库存数据就一直被占用</li>
</ul>
</li>
<li>消息队列实现（多）<ul>
<li>下单的时候发送消息到延时队列，到期的时候检测支付状态，未支付就关闭</li>
</ul>
</li>
<li>redis实现<ul>
<li>发送一个redis消息，设置过期时间，然后设置过期回调，处理检测支付状态</li>
<li>缺点：redis 自动过期的实现方式是：定时任务离线扫描并删除<strong>部分</strong>过期键；在访问键时惰性检查是否过期并删除过期键。不能保证一到过期时间就删除</li>
</ul>
</li>
</ul>
<h3 id="3-学成"><a href="#3-学成" class="headerlink" title="3 学成"></a>3 学成</h3><ul>
<li>总结的不错:<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_64948664/article/details/134403243">https://blog.csdn.net/qq_64948664/article/details/134403243</a></li>
</ul>
<h4 id="3-0-项目亮点"><a href="#3-0-项目亮点" class="headerlink" title="3.0 项目亮点"></a>3.0 项目亮点</h4><ul>
<li><p>Spring Security整合了OAuth2.0,JWT完成分布式的认证</p>
<ul>
<li>自定义继承<code>DaoAuthenticationProvider</code>,取消里面的密码校验,<code>checks()</code>方法直接返回null</li>
<li>在<code>WebSecurityConfig</code>配置类中注入刚刚的对象</li>
<li>自定义类继承<code>UserDetailService</code>接口,重写<code>loadUserByUsername()</code> 方法,根据登录方式在方法里面通过<code>ApplicationContext</code>容器找到对应的service bean,调用对应的方法(策略模式),最终返回<code>UserDetails</code>对象(username修改为用户信息,password随便写,但不能为空,authorities表示权限的数组)</li>
</ul>
</li>
<li><p>分布式事务控制的幂等性</p>
<ul>
<li>使用一个任务表记录任务的执行情况,保证了任务只会被执行一次</li>
</ul>
</li>
<li><p>使用redis对缓存进行优化，将课程的发布信息存入到redis中，减少对数据库的访问压力</p>
</li>
</ul>
<h4 id="3-1介绍"><a href="#3-1介绍" class="headerlink" title="3.1介绍"></a>3.1介绍</h4><ul>
<li><p>本项目是一个在线学习网站项目，采用SpringBoot、SpringCloud技术栈开发，划分的微服务包括网关服务、认证授权服务、注册中心服务、配置中心服务、内容管理服务、媒资管理服务、搜索服务、订单支付服务、学习中心服务、系统管理服务等，可以实现用户的网课在线学习等功能.</p>
</li>
<li><p><code>SpringBoot+SprintCloud Alibaba+Spring Security+ Mybatis-Plus+Redis+RabbitMQ+Elasticsearch+MinIO</code></p>
<ul>
<li><p>本项目包括两个端：用户端(学生端)、机构端</p>
<p>核心模块包括：内容管理、媒资管理、课程搜索、订单支付、选课管理、认证授权等，每个模块对应了一个微服务，</p>
<p>采用前后端分离架构，后端采用SpringBoot、SpringCloud技术栈开发，数据库使用了MySQL，还使用的Redis、消息队列、分布式文件系统、Elasticsearch等中间件系统。</p>
<p>我在这个项目中负责了课程内容管理、媒资管理、订单支付管理、搜索管理、认证授权管理模块的开发。</p>
</li>
<li><p>内容管理模块.是对平台上的课程进行管理，课程的相关信息比较多这里在数据库设计了课程基本信息表、课程营销表、课程计划、课程师资表进行存储 ，培训机构要发布一门课程需要填写课程基本信息、课程营销信息、课程计划信息、课程师资信息，填写完毕后需要提交审核，由运营人员进行课程信息的审核。课程审核通过即可选择发布课程，课程的相关信息会聚合到课程发布表中，这里不仅要将课程信息写到课程发布表还要将课程信息写到redis、课程索引写进ES索引库、课程内容静态页面上传分布式文件系统，所以这里存在分布式事务的问题，项目使用本地消息表加任务调度的方式去解决这里的分布式事务，保存数据的最终一致性。</p>
</li>
<li><p>媒资管理模块。对平台上的媒资信息进行管理,主要包括相关图片视频的分布式存储,采用的MINIO分布式文件系统，特别的，实现了对大文件的分块上传及校验；以及使用分布式任务调度平台xxl-job来实现视频转码的功能。</p>
</li>
<li><p>搜索模块。目前是完成了对课程的搜索，通过定义索引的操作接口（增删改查）及搜索接口，实现用户快速进行关键字索引课程的需求</p>
<ul>
<li><p><code>RestHighLevelClient</code>对象的<code>index</code>、<code>update</code>、<code>delete</code>方法进行索引的管理</p>
</li>
<li><p><code>RestHighLevelClient</code>对象的<code>search</code>进行搜索</p>
</li>
</ul>
</li>
<li><p>认证授权管理模块。在这个模块中主要是通过SpringSecurity实现了统一登录接口，具体的支持账号密码及微信扫码登录两种方式；此外也实现了基于角色的访问控制(RBAC)，通过定义不同类型的用户来实现角色的权限控制。</p>
</li>
<li><p>支付模块。目前是使用一个支付宝的沙箱环境完成了一个模拟在线支付的行为，了解到了支付宝的支付流程，在选课支付成功后通过向MQ中发送消息更新相关的用户课程信息来实现业务的解耦。</p>
</li>
</ul>
</li>
</ul>
<h4 id="3-2-数据表"><a href="#3-2-数据表" class="headerlink" title="3.2 数据表"></a>3.2 数据表</h4><ul>
<li>数据表</li>
</ul>
<h4 id="3-3-模块点"><a href="#3-3-模块点" class="headerlink" title="3.3 模块点"></a>3.3 模块点</h4><blockquote>
<p>内容管理服务</p>
</blockquote>
<ul>
<li>表：课程基本信息表、课程营销表、课程计划表、课程师资表、课程媒资表</li>
<li><p>为什么用多张表？方便不同的服务使用，比如课程媒资表</p>
</li>
<li><p>课程提交审核、课程发布、课程查看(Freemarker)</p>
<ul>
<li>为什么使用Freemarker？（FreeMarker、Velocity、Thymeleaf）<ul>
<li>页面静态化是指使用模板引擎技术将一个动态网页生成html静态页面，满足以下条件可以考虑使用静态化<ol>
<li>该页面被访问频率高，例如：商品信息展示、讲师介绍页面</li>
<li>页面上数据变化频率低，例如：商品发布后对商品信息的修改频率低、讲师介绍信息修改频率低</li>
</ol>
</li>
<li>静态化的技术很多，Freemarker是一个成熟的开源的模板引擎工具，简单易用，功能强大，本项目使用Freemarker将课程信息静态化<ol>
<li>使用Freemarker的标签编写课程信息的模板</li>
<li>调用接口获取模板上需要的模型数据</li>
<li>调用Freemarker的API生成静态页面</li>
<li>生成的静态页面最终会上传到文件系统方便访问</li>
</ol>
</li>
</ul>
</li>
</ul>
</li>
<li>师资的增删改查</li>
</ul>
<hr>
<blockquote>
<p>媒资管理服务</p>
</blockquote>
<ul>
<li><p>表：媒资信息表、视频任务处理表</p>
</li>
<li><p>云计算厂家：阿里云OSS、百度对象存储BOS，这里用的MINIO</p>
</li>
<li>上传图片/视频</li>
<li>断点续传(视频分块)</li>
<li>视频处理(分布式任务调度xxl-job，FFmpeg工具)</li>
<li>视频下载：FileOutputStream，InputStream</li>
<li>分块合并：<ul>
<li><code>MinioClient</code>的<code>composeObject()</code>方法</li>
<li>合并完成后下载，校验md5</li>
<li>信息入库并删除分块</li>
</ul>
</li>
</ul>
<hr>
<blockquote>
<p>认证授权服务</p>
</blockquote>
<ul>
<li>Spring Security：<a target="_blank" rel="noopener" href="https://blog.csdn.net/justry_deng/article/details/103549894">https://blog.csdn.net/justry_deng/article/details/103549894</a></li>
</ul>
<p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/image-20240318161649210.png" alt="image-20240318161649210"></p>
<ul>
<li><p>OAuth2.0的流程</p>
<p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/image-20240318195542692.png" alt="image-20240318195542692"></p>
</li>
<li><p>JWT小工具：<a target="_blank" rel="noopener" href="https://jwt.io/">https://jwt.io/</a> </p>
</li>
<li><p>微信登录</p>
</li>
</ul>
<hr>
<blockquote>
<p>订单服务</p>
</blockquote>
<ul>
<li>支付宝支付（订单表+消息通知表）<ul>
<li>请求学习中心服务创建选课记录</li>
<li>请求订单服务创建商品订单、生成支付二维码（<strong>存储到订单表数据库，payNo主键</strong>）</li>
<li>用户扫码请求订单支付服务，订单支付服务请求第三方支付平台生成支付订单（<strong>根据payNo，支付金额，订单名称，回调地址等信息，使用AlipayClient调用sdk请求下单</strong>）</li>
<li>前端唤起支付客户端（<strong>支付宝会返回一个表单数据，用户前端会生成支付宝支付的界面</strong>），用户输入密码完成支付</li>
<li>第三方支付平台支付完成后，发起支付通知</li>
<li>订单支付服务接收支付通知结果（<strong>支付宝在支付完成后会自动的请求这个回调通知接口</strong>）<ul>
<li>获取支付宝传来的DTO，然后根据payNo在数据库中找到订单，然后更新订单数据</li>
<li>向MQ中添加消息（<strong>解耦</strong>）</li>
</ul>
</li>
<li>用户在前端查询支付结果，请求订单支付服务查询支付结果，如果订单服务还没有收到支付结果，则请求学习中心查询支付结果</li>
<li>订单支付服务向学习中心通知支付结果</li>
<li>学习中心服务收到支付结果，如果支付成功则更新选课记录，并添加到我的课程表</li>
</ul>
</li>
</ul>
<hr>
<blockquote>
<p>搜索服务</p>
</blockquote>
<ul>
<li>本项目使用ElasticSearch开发搜索服务，步骤如下<ol>
<li>创建索引（相当于数据库表），将课程信息添加到索引库，对课程信息进行分词，存储到索引库</li>
<li>开发一个搜索服务，编写课程搜索接口，调用ElasticSearch的rest接口根据关键字、课程分类等信息进行搜索</li>
</ol>
</li>
<li>如何保证索引同步？<ul>
<li>本项目时使用本地任务表 + xxl-job任务调度进行索引同步，具体流程如下<ol>
<li>添加或修改或删除课程的同时，向任务表插入一条记录，这条记录就记录了是添加还是修改还是删除了哪个课程</li>
<li>任务调度定时扫描任务表，根据任务表的内容对课程信息进行同步<ul>
<li>如果添加了课程，将课程添加到索引库</li>
<li>如果修改了课程，就修改索引库的课程</li>
<li>如果是删除了课程，将课程信息从索引库删除</li>
</ul>
</li>
</ol>
</li>
</ul>
</li>
</ul>
<hr>
<h4 id="3-4-技术点"><a href="#3-4-技术点" class="headerlink" title="3.4 技术点"></a>3.4 技术点</h4><blockquote>
<p>异常处理</p>
</blockquote>
<ul>
<li><p><code>@ControllerAdvice</code>与<code>@ExceptionHandler</code>用来捕获异常</p>
<ul>
<li><code>@ControllerAdvice</code> 是一个特殊的 <code>@Component</code>（可以通过源码看得到），用于标识一个类，这个类中被以下三种注解标识的方法：<code>@ExceptionHandler</code>，<code>@InitBinder</code>，<code>@ModelAttribute</code>，将作用于所有<code>@Controller</code> 类的接口上。</li>
</ul>
</li>
<li><p><code>@ResponseStatus</code>用来确定响应数据</p>
<p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/image-20240303152434784.png" alt="image-20240303152434784"></p>
</li>
</ul>
<hr>
<blockquote>
<p>传入数据是否为空的方法</p>
</blockquote>
<ul>
<li><p>在controller方法内部手动判断：<code>StringUtils.isNotEmpty</code></p>
</li>
<li><p>实体类的数据上标注<code>@NotNull</code>，然后在controller中的形参前面加上<code>@Valid</code>注解，再在全局异常中添加<code>BindException</code>异常类的捕获</p>
<p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/面试准备.assets/image-20240303153429684.png" alt="image-20240303153429684" style="zoom:50%;"></p>
</li>
</ul>
<hr>
<blockquote>
<p>controller与前端的数据传递</p>
</blockquote>
<ul>
<li>形参不带注解：此时参数名称一定要和请求参数的名称一致<ul>
<li>get方式提交，直接写参数</li>
<li>通过<code>HttpServletRequest</code>接收：<code>request.getParameter("username")</code></li>
<li>通过java类对象接收</li>
</ul>
</li>
<li>形参带注解<ul>
<li><code>@RequestParam</code>：有value、require、defaultValue字段可填充</li>
<li><code>@PathVariable</code>：支持类似于：<code>user/get/mac/{macAddress}</code>的请求</li>
<li><code>@ModelAttribute("user")</code>:会将客户端传递过来的参数按名称注入到指定对象中，并且会将这个对象自动加入ModelMap中，便于View层使用</li>
</ul>
</li>
</ul>
<hr>
<blockquote>
<p>树形查询</p>
</blockquote>
<ul>
<li><p><code>left join</code>连接表（可以是相同的表）</p>
</li>
<li><p>指定<code>resultMap</code>为一个值，然后再在指定的<code>resultMap</code>中设置映射关系并将结果返回。</p>
<p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/image-20240303160733160.png" alt="image-20240303160733160"></p>
<p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/image-20240303160740937.png" alt="image-20240303160740937"></p>
</li>
</ul>
<hr>
<blockquote>
<p>视频分块上传</p>
</blockquote>
<ul>
<li><code>RandomAccessFile</code>实现文件的分块和合并</li>
<li>判断是否一致 ==&gt; <code>DigestUtils.md5Hex()</code></li>
</ul>
<hr>
<blockquote>
<p>@Transactional</p>
</blockquote>
<ul>
<li><p>自调用的时候需要声明一个代理对象来方便进行事务的管理</p>
<p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/学成在线.assets/image-20240304110055984.png" alt="image-20240304110055984" style="zoom:67%;"></p>
</li>
<li><p><code>@Transactional</code>即声明式事务管理， 建立在AOP之上的。其本质是对方法前后进行拦截，然后在目标方法开始之前创建或者加入一个事务，在执行完目标方法之后根据执行情况提交或者回滚事务。</p>
</li>
</ul>
<hr>
<blockquote>
<p>freemarker</p>
</blockquote>
<ul>
<li>controller中返回<code>ModelAndView</code>对象，在<code>setViewName</code>中设置重定向的页面文件，在<code>addObject</code>中传值</li>
</ul>
<p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/面试准备.assets/image-20240304142757986.png" alt="image-20240304142757986" style="zoom:80%;"></p>
<hr>
<blockquote>
<p>xxj-job</p>
</blockquote>
<ul>
<li>工作原理：xxl-job分布式任务调度服务由调度中心和执行器组成，调度中心负责按任务调度策略向执行器下发任务，执行器负责接收任务，执行任务</li>
<li>获取执行器序号、 执行器总数，然后用表的<code>id % 总数 == 序号</code>来保证一个任务只会被一个执行器执行，用字段标识来保证一个任务只会被执行一次(乐观锁)</li>
<li>用于视频转码作业</li>
<li>课程发布操作后，先更新数据库中的课程发布状态，更新后向Redis、ElasticSearch、MinIO写课程信息，只要在一定时间内最终成功写入数据即可<ul>
<li>这里使用了feign远程调用，在向MinIO写信息的时候调用了Media服务的相关接口<ul>
<li>熔断降级：返回null对象，然后再去判断是否为null来判断是否发生了故障</li>
<li>注意启动类开启注解<code>@EnableFeignClients</code></li>
</ul>
</li>
</ul>
</li>
<li>如何保证任务幂等性？<ul>
<li>数据库约束，例如：唯一索引、主键</li>
<li>乐观锁，长用户数据库，更新数据时根据乐观锁状态去更新</li>
<li>唯一序列号，操作传递一个唯一序列号，操作时判断与该序列号相等，则执行</li>
<li>在这里我们在数据库视频处理表中添加状态处理字段，视频处理完成更新状态为完成，执行视频前判断状态是否完成，如果完成则不再处理</li>
</ul>
</li>
</ul>
<hr>
<blockquote>
<p>ES</p>
</blockquote>
<ul>
<li>如何解决索引同步的问题？<ul>
<li>xxl-job 详见模块点中搜索模块</li>
</ul>
</li>
</ul>
<hr>
<blockquote>
<p>Spring Security</p>
</blockquote>
<ul>
<li><p>继承<code>UserDetailsService</code>接口，重写<code>loadUserByUsername()</code>方法</p>
<ul>
<li><p>返回<code>UserDetails</code>对象</p>
<p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/image-20240305102255518.png" alt="image-20240305102255518"></p>
</li>
</ul>
</li>
<li><p><code>DaoAuthenticationProviderCustom extends DaoAuthenticationProvider</code></p>
<ul>
<li>刚刚我们重写的<code>loadUserByUsername()</code>方法是由<code>DaoAuthenticationProvider</code>调用的</li>
<li>重写<code>additionalAuthenticationChecks()</code>里面会比对密码，但不是所有的登录方式都有密码</li>
<li>然后在<code>WebSecurityConfig extends WebSecurityConfigurerAdapter</code>中配置刚刚定义的 <code>DaoAuthenticationProvider</code></li>
</ul>
</li>
</ul>
<p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/image-20240318202120889.png" alt=""></p>
<ul>
<li><p>OAuth2.0</p>
<ul>
<li>客户端请求资源拥有者授权</li>
<li>资源拥有者授权客户端，即用户授权目标网站访问自己的用户信息</li>
<li>目标网站携带授权码请求认证</li>
<li>认证通过，颁发令牌</li>
<li>目标网站携带令牌请求资源服务器，获取资源</li>
<li>资源服务器校验令牌通过后，提供受保护的资源</li>
</ul>
</li>
<li><p>JWT：</p>
<ul>
<li>好处：在认证服务颁发令牌给客户端后，客户端携带令牌请求其他服务的资源时，其他服务可以直接校验令牌合法性，无需再经过认证服务。</li>
<li>缺点：JWT令牌占用空间较大</li>
<li>无状态认证：用户身份信息存储在令牌中，服务端从JWT解析出用户信息</li>
<li>有状态认证：用户信息通过session存储在服务端</li>
<li>组成<ul>
<li>头部Header：令牌类型及使用的哈希算法</li>
<li>负载Payload：用户信息</li>
<li>签名Sugbature：根据密钥进行加密前两部分，防止篡改</li>
</ul>
</li>
</ul>
</li>
<li><p><code>SecurityContextHolder</code>获取当前访问的用户信息：<code>Authentication</code>对象</p>
<ul>
<li>原理：<code>ThreadLocal</code></li>
</ul>
</li>
<li><p>用户授权</p>
<ul>
<li>授权认证服务器<code>@EnableAuthorizationServer</code> ==&gt; 配置资源列表：<code>xuecheng-plus</code></li>
<li>资源服务器<code>@EnableResourceServer</code> ==&gt; 定义资源id：<code>xuecheng-plus</code></li>
<li>接口添加<code>@PreAuthorize("hasAuthority('权限标识符')")</code>即可</li>
<li>授权定义在<code>loadUserByUsername</code>方法中返回的<code>UserDetails</code>中，是一个<code>String</code>类型的数组</li>
<li>没有权限抛出<code>AccessDeniedException</code>在全局异常处理器中捕获即可</li>
</ul>
</li>
</ul>
<hr>
<blockquote>
<p>验证码</p>
</blockquote>
<ul>
<li><code>Kaptcha</code></li>
</ul>
<hr>
<blockquote>
<p>RabbitMQ</p>
</blockquote>
<ul>
<li><h3 id="4-仿真项目"><a href="#4-仿真项目" class="headerlink" title="4 仿真项目"></a>4 仿真项目</h3></li>
</ul>
<h2 id="三-笔试"><a href="#三-笔试" class="headerlink" title="三 笔试"></a>三 笔试</h2><h3 id="3-13-携程"><a href="#3-13-携程" class="headerlink" title="3.13 携程"></a>3.13 携程</h3><ul>
<li>long </li>
</ul>
<h3 id="3-16-蚂蚁"><a href="#3-16-蚂蚁" class="headerlink" title="3.16 蚂蚁"></a>3.16 蚂蚁</h3><blockquote>
<p>数组每次可以变化ij下标的值（+2 和 -2），如果可以在有限次数让所有值的最大公因数为素数，则输出所有的可能</p>
</blockquote>
<ul>
<li>sum不变，分奇偶</li>
<li>讨论 [3, sum/n]区间内的所有素数</li>
<li>如果全是偶数(even个)，则只能是2</li>
<li>如果有奇数(odd个)<ul>
<li>记最大素数为i</li>
<li>先分配偶数，则一共分配 <code>2 * i * even</code></li>
<li>判断剩下 <code>sum - 2 * i * even</code> 能否恰好分配给odd个奇数  ==&gt; <code>(sum-2*i*even) % i == 0 &amp;&amp; (sum-2*i*even) / i &gt;= odd</code></li>
</ul>
</li>
</ul>
<h3 id="3-16-美团"><a href="#3-16-美团" class="headerlink" title="3.16 美团"></a>3.16 美团</h3><blockquote>
<p>小美拿到了一个数组，她每次操作会将除了第x个元素的其余元素翻倍，一共操作了q次。请你帮小美计算操作结束后所有元素之和。 由于答案过大，请对10^9+7取模。16%</p>
</blockquote>
<ul>
<li><p>快速幂法</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="type">long</span> <span class="title function_">qpow</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> mod)</span> {</span><br><span class="line">    <span class="comment">// 求a翻倍b次，结果取模mod</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">1</span>, t = a;</span><br><span class="line">    <span class="keyword">while</span> (b &gt; <span class="number">0</span>) {</span><br><span class="line">        <span class="keyword">if</span> ((b &amp; <span class="number">1</span>) == <span class="number">1</span>) { <span class="comment">// 只计算末尾是1的指数，因为任何数的0次方=1，就没必要乘了</span></span><br><span class="line">        	res = (res * t) % mod;</span><br><span class="line">        }</span><br><span class="line">        b &gt;&gt;= <span class="number">1</span>;			<span class="comment">// 指数位右移动：1011(2) -&gt; 101(2)</span></span><br><span class="line">        t = (t * t) % mod;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>调用</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) {</span><br><span class="line">	res = (res + qpow(<span class="number">2</span>, s[i + <span class="number">1</span>], mod) * a[i] % mod) % mod;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>eg:比如求3^45</p>
<ul>
<li>指数位置 45(10) = 101101(2)</li>
<li>也就只要求 2^5 2^3 2^2 2^0这几个幂指数</li>
</ul>
</li>
</ul>
<hr>
<blockquote>
<p>小美拿到了一个数组只包含1和2，她希里你求出所有区间众数之和 70%</p>
</blockquote>
<ul>
<li><p><strong>树状数组/二叉索引树(Binary Indexed Tree)</strong>解决的问题：对于每个index，左边有多少数字小于等于它，有多少数字大于等于它</p>
<ul>
<li><p>O(logn)得到任意前缀和</p>
</li>
<li><p>由数组arr构建二叉索引数bit规则：</p>
<ul>
<li><p>bit[x] = arr[x]，当x为奇数</p>
</li>
<li><p>bit[x] = a[0] + a[1] + … + a[x]，当x为偶数且x为2的幂</p>
</li>
<li><p>bit[x] = a[x-2^k+1]+ … + a[x]，当x为偶数且不为2的幂，其中k = lowbit(x)</p>
<p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/image-20240318135832990.png" alt="image-20240318135832990" style="zoom:50%;"></p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">from https://codefun2000.com/p/P1704 实战最重要 加了点注释</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> {</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> n;</span><br><span class="line">    <span class="comment">// 有效部分[n+1, :] tr[i]表示前缀和为i的出现次数</span></span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span>[] tr;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 返回一个整数在二进制表示中最低位的1及其后面的0构成的数 10(10) &lt;==&gt; 1010(2) -&gt; 10(2) &lt;==&gt; 2</span></span><br><span class="line">    <span class="comment">// 可以用这个方法获取一个数对应的所有二进制位为1对应的十进制数(递归) </span></span><br><span class="line">    <span class="comment">// 比如：lowbit(11)=1 然后 11-1=10；再lowbit(10)=2,然后10-2 = 8； 再lowbit(8)=8, 8-8 -= 0；结束</span></span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">lowbit</span><span class="params">(<span class="type">int</span> x)</span>{</span><br><span class="line">        <span class="keyword">return</span> x &amp; -x;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 在树状数组bit中的指定索引idx处增加1。这个操作相当于更新前缀和。</span></span><br><span class="line">    <span class="comment">// 比如：add(12)</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> idx)</span>{</span><br><span class="line">        idx += n + <span class="number">1</span>; <span class="comment">// 这里的索引idx可能为负数(如果是2的情况是--1的)，然后是从bit[1]开始算的 所以 += n+1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span>idx;i&lt;tr.length;i += lowbit(i)){</span><br><span class="line">            tr[i] += <span class="number">1</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">        </span><br><span class="line">    <span class="comment">// 计算前缀和</span></span><br><span class="line">    <span class="comment">// 比如：pre(12) = Bit(12) + Bit(8) = a[12]+..+a[9] + a[8]+...a[1]</span></span><br><span class="line">    <span class="comment">// pre(13) = Bit[13] + Bit[12] + Bit[8]</span></span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">pre</span><span class="params">(<span class="type">int</span> idx)</span>{</span><br><span class="line">        idx += n + <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> idx;i &gt; <span class="number">0</span>;i-=lowbit(i)){</span><br><span class="line">            sum += tr[i];</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        n = sc.nextInt();</span><br><span class="line">        <span class="type">int</span>[] A = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">2</span> * n + <span class="number">100</span>];</span><br><span class="line">        tr = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">2</span> * n + <span class="number">10</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n;i++) {</span><br><span class="line">            A[i] = sc.nextInt();</span><br><span class="line">        }</span><br><span class="line">        <span class="type">int</span> <span class="variable">presum</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// A[0, index] 当前位置之前（包括当前位置）的前缀和。其中1对应-1 2对应1</span></span><br><span class="line">        add(presum);</span><br><span class="line">        <span class="type">long</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n;i++){</span><br><span class="line">            <span class="keyword">if</span>(A[i] == <span class="number">1</span>) {</span><br><span class="line">                presum += <span class="number">1</span>;</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                presum -= <span class="number">1</span>;</span><br><span class="line">            }</span><br><span class="line">           </span><br><span class="line">            <span class="comment">// pre(presum)：在当前位置之前，有多少个区间的众数是1</span></span><br><span class="line">            <span class="comment">// i - pre(presum)：在当前位置之前，有多少个区间的众数是2</span></span><br><span class="line">            ans += (<span class="type">long</span>) pre(presum) + <span class="number">2L</span> *(i - pre(presum));</span><br><span class="line">            add(presum);</span><br><span class="line">        }</span><br><span class="line">        System.out.println(ans);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<h3 id="3-29-小红书"><a href="#3-29-小红书" class="headerlink" title="3.29 小红书"></a>3.29 小红书</h3><ul>
<li><p>一个数组，一个目标值，每个元素至多用一次，并且可以变成自己的一半（向下取整），当取出的元素之和为目标值时，计算最小的元素个数</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入： arr：1 2 3 4 11 target：8</span><br><span class="line">输出： 2</span><br><span class="line">解释：取3和11，其中11向下除以2取整变成5 则3+5=8</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>写了一个动态规划复杂度过高</li>
</ul>
</li>
</ul>
<h3 id="4-3-淘天"><a href="#4-3-淘天" class="headerlink" title="4.3 淘天"></a>4.3 淘天</h3><ul>
<li><p>给定一个长度为<code>n</code>的数组<code>arr</code>, 定义一个函数<code>f(l,r,x)</code>表示区间<code>[l,r]</code>内<code>x</code>出现的次数，现在给出数组<code>arr</code>,求所有的数对<code>(i,j)</code>满足<code>f(0,i,arr[i]) &gt; f(j, n-1, arr[j])</code></p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">findPairs</span><span class="params">(<span class="type">int</span>[] arr)</span> {</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> arr.length;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 前缀map数组和后缀map数组</span></span><br><span class="line">    <span class="comment">// prefixCounts[i]存储了[0, i]所有元素出现的次数</span></span><br><span class="line">    <span class="comment">// suffixCounts[j]存储了[j, n]所有元素出现的次数</span></span><br><span class="line">    Map&lt;Integer, Integer&gt;[] prefixCounts = <span class="keyword">new</span> <span class="title class_">HashMap</span>[n];</span><br><span class="line">    Map&lt;Integer, Integer&gt;[] suffixCounts = <span class="keyword">new</span> <span class="title class_">HashMap</span>[n];</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 初始化map数组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) {</span><br><span class="line">        prefixCounts[i] = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        suffixCounts[i] = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    }</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 填充前缀map数组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) {</span><br><span class="line">        <span class="keyword">if</span> (i != <span class="number">0</span>) {</span><br><span class="line">            <span class="comment">// 复制前一个map到当前map</span></span><br><span class="line">            prefixCounts[i].putAll(prefixCounts[i - <span class="number">1</span>]);</span><br><span class="line">        }</span><br><span class="line">        prefixCounts[i].put(arr[i], prefixCounts[i].getOrDefault(arr[i], <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 填充后缀map数组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) {</span><br><span class="line">        <span class="keyword">if</span> (i != n - <span class="number">1</span>) {</span><br><span class="line">            <span class="comment">// 复制后一个map到当前map</span></span><br><span class="line">            suffixCounts[i].putAll(suffixCounts[i + <span class="number">1</span>]);</span><br><span class="line">        }</span><br><span class="line">        suffixCounts[i].put(arr[i], suffixCounts[i].getOrDefault(arr[i], <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line">  </span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 遍历数组，寻找符合条件的数对(i, j)</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) {</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + <span class="number">1</span>; j &lt; n; j++) {</span><br><span class="line">            <span class="type">int</span> <span class="variable">prefixCount</span> <span class="operator">=</span> prefixCounts[i].getOrDefault(arr[i], <span class="number">0</span>);</span><br><span class="line">            <span class="type">int</span> <span class="variable">suffixCount</span> <span class="operator">=</span> suffixCounts[j].getOrDefault(arr[j], <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span> (prefixCount &gt; suffixCount) {</span><br><span class="line">                <span class="comment">// 输出符合条件的数对(i, j)</span></span><br><span class="line">                System.out.println(<span class="string">"("</span> + i + <span class="string">", "</span> + j + <span class="string">")"</span>);</span><br><span class="line">                count++;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">  </span><br><span class="line">    System.out.println(<span class="string">"Total pairs: "</span> + count);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
</li>
</ul>
<h3 id="4-16-钉钉"><a href="#4-16-钉钉" class="headerlink" title="4.16 钉钉"></a>4.16 钉钉</h3><ul>
<li><p>输入一个十进制数x，数字n以及进制k，求反转后的数。反转的定义：x转为k进制后变为x’,将x’上的所有位上的数p变为k-p</p>
<ul>
<li>例：n=4,x=6,k=2 ，则k’=0110(需要保留高位的0) ,反转后k’’ = 2002 ,对应十进制为：18</li>
<li>思路：将所有位变为k比如n=4，k=2，就变为2222，对应的就是一个等比数列2 4 8 16的和，求这个和记为a，则结果就是a-x（过程中注意取模）</li>
</ul>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CorrectKBaseToDecimal</span> {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">MOD</span> <span class="operator">=</span> <span class="number">1_000_000_007L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 快速幂计算 (a^b) % mod，计算 a 的 b 次方对 mod 取模的结果。</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">long</span> <span class="title function_">powMod</span><span class="params">(<span class="type">long</span> a, <span class="type">long</span> b)</span> {</span><br><span class="line">        <span class="type">long</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        a %= MOD;  <span class="comment">// 确保 a 在 MOD 下</span></span><br><span class="line">        <span class="keyword">while</span> (b &gt; <span class="number">0</span>) {</span><br><span class="line">            <span class="keyword">if</span> ((b &amp; <span class="number">1</span>) == <span class="number">1</span>) {</span><br><span class="line">                result = (result * a) % MOD;</span><br><span class="line">            }</span><br><span class="line">            a = (a * a) % MOD;</span><br><span class="line">            b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算所有位都是k的k进制数并减去x，然后取MOD</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">long</span> <span class="title function_">compute</span><span class="params">(<span class="type">long</span> n, <span class="type">long</span> k, <span class="type">long</span> x)</span> {</span><br><span class="line">        <span class="comment">// 使用等比数列求和公式计算所有位都是k的k进制数的十进制表示</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">sum</span> <span class="operator">=</span> k * ((powMod(k, n) - <span class="number">1</span> + MOD) % MOD) % MOD;</span><br><span class="line">        <span class="comment">// 计算 (k-1) 的逆元</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">inverse</span> <span class="operator">=</span> powMod(k - <span class="number">1</span>, MOD - <span class="number">2</span>);</span><br><span class="line">        <span class="comment">// 计算公式结果</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">result</span> <span class="operator">=</span> (sum * inverse % MOD - x + MOD) % MOD;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="comment">// 示例输入</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">3</span>, k = <span class="number">2</span>;</span><br><span class="line">        <span class="type">long</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">14</span>;</span><br><span class="line">        <span class="comment">// 计算并输出结果</span></span><br><span class="line">        System.out.println(compute(n, k, x));</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
</li>
</ul>
<h3 id="4-18-阿里云"><a href="#4-18-阿里云" class="headerlink" title="4.18 阿里云"></a>4.18 阿里云</h3><ul>
<li><p>给定一个字符串str，求他所有连续子串的权值之和，其中一个字符串权值的定义为：该字符串包含“a”, “li”，“yun”的数量，比如”ali”权值为2，”syuns”权值为1</p>
<ul>
<li>“aliyun”权值为18</li>
</ul>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getTotalWeight</span><span class="params">(String str)</span> {</span><br><span class="line">    <span class="type">int</span> <span class="variable">re</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> str.length();</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span>[] chs = str.toCharArray();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) {</span><br><span class="line">        <span class="keyword">if</span>(chs[i] == <span class="string">'a'</span>) {</span><br><span class="line">        </span><br><span class="line">            <span class="comment">// 计算包含当前字符的所有子串数量</span></span><br><span class="line">            re += n;</span><br><span class="line"></span><br><span class="line">        }<span class="keyword">else</span> <span class="keyword">if</span>(i &gt;= <span class="number">1</span> &amp;&amp; chs[i-<span class="number">1</span>] == <span class="string">'l'</span> &amp;&amp; chs[i] == <span class="string">'i'</span>) {</span><br><span class="line"></span><br><span class="line">            <span class="comment">//这个 li 字符串前面有 i-1 个字符 后面有 n-i-1 个字符</span></span><br><span class="line">            <span class="comment">// xxxlixxxx 那么含有li的子串数量为 3*4 + 3 + 4 + 1（这个1的意思是只包含li）</span></span><br><span class="line">            re += (i-<span class="number">1</span>) * (n-i-<span class="number">1</span>) + i-<span class="number">1</span> + n-i-<span class="number">1</span> + <span class="number">1</span>; </span><br><span class="line"></span><br><span class="line">        }<span class="keyword">else</span> <span class="keyword">if</span>(i &gt;= <span class="number">2</span> &amp;&amp; chs[i-<span class="number">2</span>] == <span class="string">'y'</span> &amp;&amp; chs[i-<span class="number">1</span>] == <span class="string">'u'</span> &amp;&amp; chs[i] == <span class="string">'n'</span>) {</span><br><span class="line">        </span><br><span class="line">            <span class="comment">// yun 前面有 i-2 后面有 n-i-1</span></span><br><span class="line">            re += (i-<span class="number">2</span>) * (n-i-<span class="number">1</span>) + i-<span class="number">2</span> + n-i-<span class="number">1</span> + <span class="number">1</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> re;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
</li>
</ul>
<h3 id="4-26-小红书2"><a href="#4-26-小红书2" class="headerlink" title="4.26 小红书2"></a>4.26 小红书2</h3><ul>
<li><p>从<code>n</code>个粉丝中选<code>k</code>个最狂热的粉丝，给<code>n</code>行输入，每行有2列，第一列是粉丝<code>i</code>点赞数，第二列是粉丝<code>i</code>的收藏数。定义狂热度：点赞数是1分，收藏数是2分。如果两个粉丝狂热度一样就比较收藏数，如果收藏数也一样序号小的狂热度高</p>
<ul>
<li><p>优先级队列：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">solve</span><span class="params">()</span> <span class="keyword">throws</span> IOException {</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> in.nextInt();</span><br><span class="line">    <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> in.nextInt();</span><br><span class="line">    <span class="type">int</span>[][] a = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>][<span class="number">3</span>];</span><br><span class="line">    </span><br><span class="line">    PriorityQueue&lt;<span class="type">int</span>[]&gt; pq = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;<span class="type">int</span>[]&gt;(<span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;<span class="type">int</span>[]&gt;() {</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(<span class="type">int</span>[] o1, <span class="type">int</span>[] o2)</span> {</span><br><span class="line">            <span class="type">int</span> <span class="variable">score1</span> <span class="operator">=</span> o1[<span class="number">1</span>] + o1[<span class="number">2</span>] * <span class="number">2</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">score2</span> <span class="operator">=</span> o2[<span class="number">1</span>] + o2[<span class="number">2</span>] * <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (score1 != score2) {</span><br><span class="line">                <span class="keyword">return</span> score2 - score1;</span><br><span class="line">                </span><br><span class="line">            } <span class="keyword">else</span> <span class="keyword">if</span> (o1[<span class="number">2</span>] != o2[<span class="number">2</span>]) {</span><br><span class="line">                <span class="keyword">return</span> o2[<span class="number">2</span>] - o1[<span class="number">2</span>];</span><br><span class="line">                </span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                <span class="keyword">return</span> o1[<span class="number">0</span>] - o2[<span class="number">0</span>];</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    });</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++) {</span><br><span class="line">        a[i][<span class="number">0</span>] = i;</span><br><span class="line">        a[i][<span class="number">1</span>] = in.nextInt();</span><br><span class="line">        a[i][<span class="number">2</span>] = in.nextInt();</span><br><span class="line">        pq.offer(a[i]);</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span>[] ans = <span class="keyword">new</span> <span class="title class_">int</span>[k];</span><br><span class="line">    <span class="keyword">while</span> (k-- &gt; <span class="number">0</span>) {</span><br><span class="line">        <span class="type">int</span>[] p = pq.poll();</span><br><span class="line">        ans[k] = p[<span class="number">0</span>];</span><br><span class="line">    }</span><br><span class="line">    Arrays.sort(ans);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> id : ans) {</span><br><span class="line">        out.print(Integer.toString(id) + <span class="string">' '</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
</li>
</ul>
</li>
<li><p>给一个数组<code>arr</code>以及一个目标数<code>x</code>，每个粉丝群可转移 <code>a[i]/2</code> 个粉丝，也可以选一个粉丝群转移 <code>a[i]</code> 个粉丝，求获得目标粉丝数所需的最少粉丝群数量。</p>
<ul>
<li><p>背包问题：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">solve</span><span class="params">()</span> <span class="keyword">throws</span> IOException {</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> in.nextInt();</span><br><span class="line">    <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> in.nextInt();</span><br><span class="line">    <span class="type">int</span>[] a = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) {</span><br><span class="line">        a[i] = in.nextInt();</span><br><span class="line">    }</span><br><span class="line">    <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> func(a, -<span class="number">1</span>, x);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) {</span><br><span class="line">        ans = Math.min(ans, func(a, i, x) + <span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line">    out.println(ans == <span class="number">0x3f3f3f3f</span> ? -<span class="number">1</span> : ans);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="type">int</span> <span class="title function_">func</span><span class="params">(<span class="type">int</span>[] a, <span class="type">int</span> idx, <span class="type">int</span> target)</span> {</span><br><span class="line">    <span class="keyword">if</span> (idx != -<span class="number">1</span>) target -= a[idx];</span><br><span class="line">    <span class="keyword">if</span> (target &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0x3f3f3f3f</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> a.length;</span><br><span class="line">    <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[target + <span class="number">1</span>];</span><br><span class="line">    Arrays.fill(dp, <span class="number">0x3f3f3f3f</span>);</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++) {</span><br><span class="line">        <span class="keyword">if</span> (i == idx + <span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">val</span> <span class="operator">=</span> a[i - <span class="number">1</span>] / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> target; j &gt;= val; j--) {</span><br><span class="line">            dp[j] = Math.min(dp[j], dp[j - val] + <span class="number">1</span>);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> dp[target];</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
</li>
</ul>
</li>
</ul>
<h2 id="四-面试"><a href="#四-面试" class="headerlink" title="四 面试"></a>四 面试</h2><h3 id="4-1-携程一面-3-20"><a href="#4-1-携程一面-3-20" class="headerlink" title="4.1 携程一面 3.20"></a>4.1 携程一面 3.20</h3><ul>
<li><p>自我介绍10min 有点多嗯</p>
</li>
<li><p>苍穹中担任什么职务，比较棘手的点？做学习用的，设计数据表，对相关业务的开发；用户高并发的情况</p>
</li>
<li><p>那多用户抢单的高并发过程怎么考虑？时间戳记录版本信息</p>
<ul>
<li>高并发：同一时刻有大量请求访问系统；大量请求并行访问系统。</li>
<li>提升机器的性能。</li>
<li>使用redis缓存数据，记录binlog日志信息，存入消息队列中，实现缓存的最终一致性。</li>
</ul>
</li>
<li><p>怎么理解任务幂等性？怎么实现？ 一个任务只会被执行一次；任务消息表</p>
<ul>
<li>一次和多次请求某一个资源对于资源本身应该具有同样的结果，任意多次执行对资源本身所产生的影响均与一次执行的影响相同</li>
<li>使用唯一索引防止新增脏数据</li>
<li>乐观锁：通过版本号来记录</li>
<li>分布式锁：redis，先获取锁再操作表再释放锁</li>
</ul>
</li>
<li><p>怎么理解AOP？定义+jdk/cglib 原理及区别</p>
</li>
<li><p>AOP的几个概念？切面+连接点+切入点+通知</p>
</li>
<li><p>AOP用什么捕获异常？@AfterThrowing</p>
</li>
<li><p>redis线程？之前是单线程，之后是多线程。提到了线程不是瓶颈及IO多路复用</p>
</li>
<li><p><strong>redis跳表？</strong>g</p>
</li>
<li><p><strong>setEx setNx，如何设置key过期时间？</strong>g</p>
<ul>
<li><code>set key value</code> ：将字符串值 value 关联到 key </li>
<li><p><code>setNX key value</code>： 将 key 的值设为 value ，当且仅当 key 不存在。</p>
<ul>
<li>setnx = SET if Not eXists</li>
</ul>
</li>
<li><p><code>setEX key seconds value</code>：将值 value 关联到 key ，并将 key 的生存时间设为 seconds (以秒为单位)。</p>
<ul>
<li>setex = set expire</li>
</ul>
</li>
</ul>
</li>
<li><p>基本数据类型和包装类型区别？在JVM存储区域</p>
</li>
<li><p>为什么静态方法不能调用非静态变量？</p>
<ul>
<li>在一个类的静态成员中去访问非静态成员之所以会出错是因为在类的非静态成员不存在的时候静态成员就已经存在了，访问一个内存中不存在的东西当然会出错。</li>
</ul>
</li>
<li><p>java三大特性？继承封装多态</p>
</li>
<li><p>HashMap底层原理？数组+链表/红黑树，然后讲了元素的插入过程，数组长度64 链表长度8</p>
</li>
<li><p><strong>乐观锁和悲观锁？</strong>g</p>
<ul>
<li>悲观锁假设冲突会发生，在访问共享资源之前先锁定资源，确保数据的一致性。悲观锁的特点是在访问共享资源之前会先锁定资源，确保其他线程无法修改该资源，直到当前线程完成操作。常见互斥锁和读写锁</li>
<li>乐观锁假设冲突较少，允许多个线程同时读取和操作共享资源，只在更新时进行冲突检查和处理。当要更新共享资源时，乐观锁会检查在操作期间是否有其他线程修改了该资源。如果没有冲突发生，操作继续进行；如果发现冲突，乐观锁会回滚操作并重新尝试。用版本号和时间戳来记录。</li>
</ul>
</li>
<li><p><strong>线程池常用参数</strong>？提高了最大连接数和线程数量</p>
<ul>
<li>核心线程数：corePoolSize</li>
<li>最大连接数：maximumPoolSize</li>
<li>空闲线程存货时间：keepAliveTime</li>
<li>时间单位：unit</li>
<li>工作队列：workQueue：存放待执行任务的队列</li>
<li>线程工厂：threadFactory</li>
<li>拒绝策略：handler</li>
</ul>
</li>
<li><p><strong>线程池策略？</strong>g</p>
<ul>
<li><code>AbortPolicy</code>：丢弃任务并抛出RejectedExecutionException异常。</li>
<li><code>DiscardPolicy</code>：丢弃任务，但是不抛出异常。可能导致无法发现系统的异常状态。</li>
<li><code>DiscardOldestPolicy</code>：丢弃队列最前面的任务，然后重新提交被拒绝的任务。</li>
<li><code>CallerRunsPolicy</code>：由调用线程处理该任务。</li>
</ul>
</li>
<li><p>JVM内存区域？java堆，方法区+java栈，本地方法栈，线程计数器</p>
</li>
<li><p><strong>mysql索引类型？</strong>g</p>
<ul>
<li>主键索引</li>
<li>普通索引</li>
<li>唯一索引</li>
<li>全文索引</li>
<li>前缀索引</li>
<li>组合索引</li>
<li>空间索引</li>
</ul>
</li>
<li><p><strong>序数索引和非序数索引？</strong>g</p>
<ul>
<li><p>聚簇索引和非聚簇索引？</p>
<ul>
<li>聚簇索引（聚集索引）：索引结构和数据一起存放的索引，InnoDB的主键索引就是</li>
<li>非聚簇索引（非聚集索引）：不存在一起的索引</li>
</ul>
<p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/image-20240320172122032.png" alt="image-20240320172122032" style="zoom:50%;"></p>
</li>
</ul>
</li>
</ul>
<h3 id="4-2-美团一面-3-22-外卖平台"><a href="#4-2-美团一面-3-22-外卖平台" class="headerlink" title="4.2 美团一面 3.22 外卖平台"></a>4.2 美团一面 3.22 外卖平台</h3><ul>
<li>自我介绍3min 然后</li>
<li>问了项目什么时候做的，有无团队一起做</li>
<li>问了一下FS立库的算法还有引擎的优化 15min 讲的不太清除</li>
<li>苍穹的表结构 菜品表和套餐表</li>
<li>两个表的关系 多对多 </li>
<li>怎么管理套餐的 增删改查</li>
<li>怎么做套餐的修改的，提供了哪些修改</li>
<li>库存怎么存储的 redis+mysql</li>
<li>redis还存了什么 购物车和菜品</li>
<li>redis和mysql一致性？ 先修改mysql再删除redis</li>
<li>为什么这样做？高并发带来的数据不一致</li>
<li>为什么不先更新redis后更新mysql？举了一个例子</li>
<li>redis是什么时候更新？查询的时候更新</li>
<li>数据修改频繁呢？异步缓存，以redis缓存为主，先修改redis，由后台修改mysql</li>
<li><p>为什么用redis？内存 + IO多路复用</p>
</li>
<li><p>IO多路复用？ 单线程处理多个并发，提到了同步IO 异步IO（应该是阻塞IO和非阻塞IO）</p>
</li>
<li>mysql B+树的优点？对比了hash表、二叉搜索树、平衡树、红黑表、B树</li>
<li>AOP底层原理？JDK cglib，原理，生成字节码，执行效率的对比</li>
<li><p><strong>java多态解决了什么问题？</strong></p>
<ul>
<li>简化对应用软件的代码编写和修改过程</li>
</ul>
</li>
<li><p>进程和线程的区别？进程是操作系统的最小单位由多个线程组成，线程可以上下文切换</p>
</li>
<li><p>线程调度过程，上下文切换</p>
<ul>
<li>线程上下文切换是指操作系统为了能够让多个线程并发执行，在运行一个线程前，需要保存当前线程的 CPU 寄存器、程序计数器、栈指针和其他硬件上下文信息，以便于在恢复该线程时还原到之前的状态。而将这些信息保存起来、加载其他线程运行所需的上下文信息，然后再切换到该线程继续执行的过程就被称为线程上下文切换</li>
</ul>
</li>
<li><p>MQ解决了什么问题？业务解耦，服务的通讯</p>
<ul>
<li>业务解耦</li>
<li><strong>流量削峰</strong></li>
</ul>
</li>
<li><strong>TCP为什么是可靠的</strong>？三挥四握，传输过程中，全双工<ul>
<li>数据传输之前会有三次握手来进行连接</li>
<li>在数据传输时候，有确认、滑动窗口、超时重传、拥塞控制之类机制</li>
<li>数据传输之后会进行四次挥手断开连接来节约系统资源。</li>
</ul>
</li>
<li>算法：二叉树最长路径和 20min</li>
</ul>
<h3 id="4-3-饿了么一面-3-25"><a href="#4-3-饿了么一面-3-25" class="headerlink" title="4.3 饿了么一面 3.25"></a>4.3 饿了么一面 3.25</h3><ul>
<li><p>一直问fs，然后问了毕业情况，能不能出来</p>
</li>
<li><p>fs中的设计模式？</p>
<ul>
<li>单例设计模式。图标</li>
<li>代理模式。堆垛机</li>
</ul>
</li>
</ul>
<h3 id="4-4-美团二面-3-26"><a href="#4-4-美团二面-3-26" class="headerlink" title="4.4 美团二面 3.26"></a>4.4 美团二面 3.26</h3><ul>
<li>介绍自己 5min</li>
<li>主要在第一个项目<ul>
<li>是怎么做优化的，有什么对比，用什么方式评估达到了要求</li>
<li>开发团队是怎么配合的</li>
<li>你们的软件的主要用途</li>
<li>这个过程中挑战比较大的地方  代码上手+立库</li>
<li>这个过程中收获了什么 了解了java，开发的规范性</li>
<li>是怎么沟通的</li>
</ul>
</li>
<li>你是怎么看java后端开发的</li>
<li>为什么选择做外卖项目 学习，和生活贴近</li>
<li>后端都是自己搭的吗？中间有什么问题？ 版本的改动，自己的解决办法</li>
<li>redis怎么用的？购物车，菜品数据</li>
<li>并发量不这么大为什么要用redis？学习</li>
<li>redis为什么这么快？内存IO+IO多路复用</li>
<li>讲一下IO多路复用。 讲了同步阻塞模型、同步非阻塞模型、IO多路复用（文件描述符）</li>
<li>有什么想问的<ul>
<li>做的商家事业部：商家线上注册、外卖、帮助线上商家能卖更多的东西</li>
<li>关于结果：一周内</li>
</ul>
</li>
<li>闲聊时间 10min<ul>
<li>对面试的过程有什么感想</li>
<li>有什么职业规划</li>
<li>怎么看java后端的</li>
<li>什么时候可以实习，实习时间段，准备在北京发展吗</li>
<li>怎么看互联网这个行业</li>
<li>怎么看很多人去选择进入体制内</li>
<li>为什么还在机械学院读研不去计算机学院</li>
</ul>
</li>
</ul>
<h3 id="4-5-腾讯一面-3-27"><a href="#4-5-腾讯一面-3-27" class="headerlink" title="4.5 腾讯一面 3.27"></a>4.5 腾讯一面 3.27</h3><ul>
<li><p>如何解决多个恶意请求（黑名单多到缓存放不下）</p>
<ul>
<li><p>用布隆过滤器，缺点是有可能会造成白名单误被认为是黑名单的情况</p>
</li>
<li><p>如何优化：可以加大哈希函数的数量</p>
</li>
</ul>
</li>
<li><p>输入一个url到完成请求的过程</p>
</li>
<li><p>在使用DNS解析的过程，使用了什么连接</p>
<ul>
<li>本地查询、递归查询、最后向下返回ip地址</li>
<li>UDP（一开始说的TCP，但是又说TCP比较慢，应该用的UDP）</li>
</ul>
</li>
<li><p>TCP和UDP区别</p>
<ul>
<li>面向连接</li>
<li>可靠</li>
<li>数据量</li>
<li>头部开销</li>
</ul>
</li>
</ul>
<ul>
<li>TCP如何确保传输的稳定的<ul>
<li>对数据包有一个排序校验</li>
<li>重传机制</li>
<li>滑动窗口的流量控制：保证发送方不会发过多数据导致接收方处理不过来或者缓冲区溢出</li>
<li>拥塞控制：保证网络中的传输速率不超过网络容量</li>
</ul>
</li>
<li><p>TCP三次握手时，在收到客户端的SYN包后一定会返回ACK吗？如果服务端建立了过多的连接可能不返回（不确定）</p>
<ul>
<li>防火墙导致入站连接被过滤了</li>
<li>网络出现拥塞或者故障</li>
<li>为了防止TCP SYN 攻击，某些服务器可能会配置特殊的防护机制，例如 SYN 队列限制或 SYN cookie，这可能会导致服务端不返回 SYN+ACK 包。</li>
<li>如果服务端的资源（如内存、CPU）不足，可能会导致服务端无法处理新的连接请求，从而不返回 SYN+ACK 包。</li>
</ul>
</li>
<li><p>mysql慢查询是怎么发现的，用什么命令</p>
<ul>
<li><p>启用慢查询日志，在配置文件中</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">slow_query_log = 1 -- 启动</span><br><span class="line">slow_query_log_file = /path/to/slow-query.log -- 指定慢查询日志文件的路径和名称。</span><br><span class="line">long_query_time = 1 -- 定义执行时间超过多少秒的查询被认为是慢查询</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>重启</p>
</li>
<li><p>查看日志</p>
<figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> /path/to/slow-query.log</span><br></pre></td></tr></tbody></table></figure>
</li>
</ul>
</li>
</ul>
<ul>
<li><p>那是如何优化一个sql的</p>
<ul>
<li>优化sql语句<ul>
<li>尽量避免<code>SELECT *</code></li>
<li>尽量减少<code>JOIN</code>，考虑使用子查询或者临时表</li>
<li>避免在<code>WHERE</code>子句中使用函数，因为这可能会导致索引失效。<ul>
<li><code>where</code>中使用了函数</li>
<li><code>where</code>中发生了类型的转换</li>
<li><code>where</code>中使用了模糊查询</li>
<li><code>where</code>中使用了非索引列</li>
</ul>
</li>
</ul>
</li>
<li>索引</li>
<li>优化表的设计：分表分库</li>
</ul>
</li>
<li><p>在采用水平分表的时候，如果是用数据id取模确定数据库的情况下，假如出现了某个数据库的突然宕机该怎么办</p>
<ul>
<li>方案一：修改id取模值，但是这种方式代价相对大，因为他需要将所有的数据进行重新的备份</li>
<li>方案二：对于新插入的数据，当其取模后得到的值对应的是宕机的数据库后，将其id增加一位，保证数据插入到正常数据库中。优点是对于原有的数据可以不用修改</li>
</ul>
</li>
<li><p>linux中如何查看某个端口的使用情况</p>
<figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">netstat -tuln | grep &lt;端口号&gt;  <span class="comment"># t表示tcp u表示udp l表示仅显示监听状态 n表示直接显示IP地址和端口号而不进行反向解析(根据IP查域名)</span></span><br><span class="line">ss -tuln | grep &lt;端口号&gt;</span><br><span class="line">lsof -i :&lt;端口号&gt;</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>了解kafka吗 没用过</p>
</li>
<li><p>手撕：一个字符串数组，然后一个字符串，问匹配的最长字符串是什么</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">	数组：ABC abs ASs ABCD</span><br><span class="line">	字符串：ABCssadoasosahfeiowhoawjsdohABCDasfdhw</span><br><span class="line">输出：ABCD</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>想了一个暴力，面试官说优化一下，没想出来，然后提示说字典树会不会，不会</li>
</ul>
<p>字典树，本质就是维护一个路径</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">class TrieNode {</span><br><span class="line">    TrieNode[] children;</span><br><span class="line">    boolean isEnd;</span><br><span class="line"></span><br><span class="line">    public TrieNode() {</span><br><span class="line">        children = new TrieNode[52]; // 考虑大小写字母，总共52个字符</span><br><span class="line">        isEnd = false;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">public class LongestSubstringMatching {</span><br><span class="line">    public static void main(String[] args) {</span><br><span class="line">        String[] arr = {"AB", "ABC", "ABCD", "asbasd", "asfa"};</span><br><span class="line">        String str = "asfhsadfhiABasdoiahABCDasdhooABC";</span><br><span class="line"></span><br><span class="line">        String longestMatchingSubstring = findLongestMatchingSubstring(arr, str);</span><br><span class="line">        System.out.println("Longest matching substring: " + longestMatchingSubstring);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    public static String findLongestMatchingSubstring(String[] arr, String str) {</span><br><span class="line">        TrieNode root = new TrieNode();</span><br><span class="line">        String longestMatchingSubstring = "";</span><br><span class="line"></span><br><span class="line">        // 构建字典树</span><br><span class="line">        for (String s : arr) {</span><br><span class="line">            insert(root, s);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        int n = str.length();</span><br><span class="line">        for (int i = 0; i &lt; n; i++) {</span><br><span class="line">            TrieNode node = root;</span><br><span class="line">            for (int j = i; j &lt; n; j++) {</span><br><span class="line">                char c = str.charAt(j);</span><br><span class="line">                int index = getIndex(c);</span><br><span class="line">                if (node.children[index] == null) {</span><br><span class="line">                    break;</span><br><span class="line">                }</span><br><span class="line">                node = node.children[index];</span><br><span class="line">                if (node.isEnd &amp;&amp; j - i + 1 &gt; longestMatchingSubstring.length()) {</span><br><span class="line">                    longestMatchingSubstring = str.substring(i, j + 1);</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        return longestMatchingSubstring;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    private static void insert(TrieNode root, String word) {</span><br><span class="line">        TrieNode node = root;</span><br><span class="line">        for (char c : word.toCharArray()) {</span><br><span class="line">            int index = getIndex(c);</span><br><span class="line">            if (node.children[index] == null) {</span><br><span class="line">                node.children[index] = new TrieNode();</span><br><span class="line">            }</span><br><span class="line">            node = node.children[index];</span><br><span class="line">        }</span><br><span class="line">        node.isEnd = true;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    private static int getIndex(char c) {</span><br><span class="line">        if (c &gt;= 'a' &amp;&amp; c &lt;= 'z') {</span><br><span class="line">            return c - 'a';</span><br><span class="line">        } else {</span><br><span class="line">            return c - 'A' + 26;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>又给了一次机会，手写一个LRU数据结构，轻松拿下</p>
</li>
</ul>
<h3 id="4-6-腾讯二面-3-29"><a href="#4-6-腾讯二面-3-29" class="headerlink" title="4.6 腾讯二面 3.29"></a>4.6 腾讯二面 3.29</h3><ul>
<li>自我介绍3min</li>
<li>你不是计算机专业的</li>
<li>网络五层结构</li>
<li>网络如何定位一个进程：端口+IP</li>
<li>TCP为什么要三次握手？而不是两次</li>
<li><strong>linux五种IO</strong>？BIO NIO IO多路复用 AIO<ul>
<li>同步阻塞IO</li>
<li>同步非阻塞IO</li>
<li>IO多路复用</li>
<li>信号驱动IO</li>
<li>异步IO</li>
</ul>
</li>
<li>说一下IO多路复用</li>
<li>双向链表中放的是什么？文件描述符及状态</li>
<li>数组和链表查删综合复杂度</li>
<li>手撕算法：一个乱序数组，输出超过1/2的众数（一定存在），5min<ul>
<li>用的map，时间复杂度O(n)</li>
<li>面试官问快排然后返回中间的那个 O(logn)</li>
</ul>
</li>
<li><p>手撕算法：LRU结构</p>
</li>
<li><p>说一说mysql为什么用B+树</p>
</li>
<li><strong>联合索引</strong></li>
<li>问项目，亮点是什么 redis</li>
<li>缓存穿透？怎么解决<ul>
<li>布隆过滤器</li>
<li>缓存那个不存在的key</li>
<li><strong>接口限流</strong></li>
</ul>
</li>
<li>怎么学习的</li>
<li>看过什么java的书 — java核心技术卷<ul>
<li>还有阿里巴巴开发手册，面试官说那个没用</li>
</ul>
</li>
<li>组织活动的时候怎么解决人与人之间的冲突</li>
<li>怎么解决别人对你的冲突</li>
<li>你是不是一个有责任心的人 举例</li>
<li>反问<ul>
<li>是不是用java</li>
<li>对我的面试评价（不能说）</li>
<li>多久出结果（1周内）</li>
</ul>
</li>
<li>总结：感觉十分看重是不是科班</li>
</ul>
<h3 id="4-7-蚂蚁一面-4-2-做中间件架构"><a href="#4-7-蚂蚁一面-4-2-做中间件架构" class="headerlink" title="4.7 蚂蚁一面 4.2 做中间件架构"></a>4.7 蚂蚁一面 4.2 做中间件架构</h3><ul>
<li><p>自我简单介绍，没说项目</p>
</li>
<li><p>手撕算法：给一个图，从源节点广播，多久能够广播所有的节点，如果不能则返回-1</p>
<ul>
<li>用的dfs，结构出来了，貌似没通过</li>
</ul>
</li>
<li><p>在校成绩、在校比赛、论文情况</p>
</li>
<li><p>在校的课程 c++ java</p>
</li>
<li><p>fs团队分工</p>
</li>
<li><p>TCP四次挥手过程</p>
</li>
<li><p>如何在linux上查询TCP的过程 netstat -nat</p>
</li>
<li><p>如果是time wait状态是哪个？</p>
<ul>
<li>主动断开方（蒙对了）</li>
</ul>
</li>
<li><p>乐观锁和悲观锁</p>
</li>
<li><p>mysql怎么用行级锁</p>
<ul>
<li><p>共享锁</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM table_name WHERE condition LOCK IN SHARE MODE</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>排他锁</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM table_name WHERE condition FOR UPDATE;</span><br></pre></td></tr></tbody></table></figure>
</li>
</ul>
</li>
<li><p>java进程内存占用高 jvm堆空间</p>
<figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pgrep -lf java   <span class="comment"># 查看当前java进程的pid</span></span><br><span class="line">jmap -heap PID   <span class="comment"># 查看java堆的详细信息</span></span><br><span class="line">jmap -histo PID  <span class="comment"># 查看java堆中对象的相关信息，包含数量以及占用的空间大小</span></span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>线程池核心参数，corePoolSize 和 maximumPoolSize 区别</p>
</li>
<li><p>主要做的是中间件架构的设计</p>
</li>
</ul>
<h3 id="4-8-蚂蚁二面-4-9"><a href="#4-8-蚂蚁二面-4-9" class="headerlink" title="4.8 蚂蚁二面 4.9"></a>4.8 蚂蚁二面 4.9</h3><ul>
<li>问了好多微服务相关</li>
<li>自我介绍 4min</li>
<li>实习的软件和专业的关系</li>
<li>hashcode和equals区别 </li>
<li>三次握手四次挥手</li>
<li><p>怎么理解注册中心</p>
<ul>
<li>注册中心是服务实例信息的存储仓库，也是服务提供者和服务消费者进行交互的桥梁。它主要提供了服务注册和服务发现这两大核心功能。</li>
</ul>
</li>
<li><p>nacos上注册中心的信息，存储的信息</p>
<ul>
<li>服务名</li>
<li>分组名</li>
<li>集群数</li>
<li>实例数</li>
<li>健康实例数</li>
<li>触发保护阈值</li>
</ul>
</li>
<li><p>怎么理解CAP，怎么实现</p>
<ul>
<li>CA</li>
<li>CP</li>
</ul>
</li>
<li><p>Seata 有没有了解 无</p>
</li>
<li>分布式事务</li>
<li>有什么技术难点？学成在线的同意登录接口</li>
<li><p>微服务性能瓶颈怎么处理</p>
<ul>
<li>请求：恶意请求过滤</li>
<li>硬件：实例扩容</li>
<li>业务：服务熔断降级</li>
</ul>
</li>
<li><p>怎么理解AOP</p>
</li>
<li><p>redis怎么用的</p>
<ul>
<li>购物车</li>
<li>课程/菜品信息</li>
</ul>
</li>
<li><p>redis和数据库的同步</p>
<ul>
<li>数据更新不频繁：先更新数据库后删除redis</li>
<li>数据更新频繁：先更新redis，后台线程同步到数据库</li>
</ul>
</li>
<li><p>怎么理解微服务？ 网关、注册中心、配置中心、feign远程调用</p>
</li>
<li>地点：北京、上海、杭州、成都</li>
<li>语言转换？java 会 golang最好</li>
</ul>
<link rel="stylesheet" href="https://cdn1.tianli0.top/gh/zhheo/Post-Abstract-AI@0.15.2/tianli_gpt.css">

<script>
let tianliGPT_postSelector = '#post #article-container';
let tianliGPT_key = 'c9b7741d290063ab872e';
</script>
<script src="https://cdn1.tianli0.top/gh/zhheo/Post-Abstract-AI@0.15.2/tianli_gpt.js"></script>







</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="http://yileman.github.io">myl</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://yileman.github.io/posts/56035.html">http://yileman.github.io/posts/56035.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://yileman.github.io" target="_blank">myl's blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E6%90%AC%E7%A0%96/">搬砖</a></div><div class="post_share"><div class="social-share" data-image="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/defaultArticleCover.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer=""></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/posts/37774.html" title="杂七杂八点子"><img class="cover" src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/cover/article_cover21.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">杂七杂八点子</div></div></a></div><div class="next-post pull-right"><a href="/posts/17374.html" title="JVM"><img class="cover" src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/cover/article_cover1.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">JVM</div></div></a></div></nav><hr class="custom-hr"><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="twikoo-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/touxiang.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"></div><div class="author-info__name">myl</div><div class="author-info__description">后端学习</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">23</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">8</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">4</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/yileman"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">写写记记</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80-%E5%9F%BA%E7%A1%80"><span class="toc-number">1.</span> <span class="toc-text">一 基础</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-JavaSE"><span class="toc-number">1.1.</span> <span class="toc-text">1 JavaSE</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-Spring"><span class="toc-number">1.2.</span> <span class="toc-text">2 Spring</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-SpringCloud"><span class="toc-number">1.3.</span> <span class="toc-text">3 SpringCloud</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-Git"><span class="toc-number">1.4.</span> <span class="toc-text">4 Git</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-Linux"><span class="toc-number">1.5.</span> <span class="toc-text">5 Linux</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-Docker"><span class="toc-number">1.6.</span> <span class="toc-text">6 Docker</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-Redis%EF%BC%9ANoSQL-%E6%95%B0%E6%8D%AE%E5%BA%93"><span class="toc-number">1.7.</span> <span class="toc-text">7 Redis：NoSQL 数据库</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-ES"><span class="toc-number">1.8.</span> <span class="toc-text">8 ES</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-RabbitMQ"><span class="toc-number">1.9.</span> <span class="toc-text">9 RabbitMQ</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-Mybaits"><span class="toc-number">1.10.</span> <span class="toc-text">10 Mybaits</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-MySQL"><span class="toc-number">1.11.</span> <span class="toc-text">11 MySQL</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-%E5%B9%B6%E5%8F%91"><span class="toc-number">1.12.</span> <span class="toc-text">12 并发</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-%E8%AE%A1%E7%BD%91"><span class="toc-number">1.13.</span> <span class="toc-text">13 计网</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F"><span class="toc-number">1.14.</span> <span class="toc-text">14 操作系统</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#15-IO%E5%8F%8AIO%E6%A8%A1%E5%9E%8B"><span class="toc-number">1.15.</span> <span class="toc-text">15 IO及IO模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#16-JVM"><span class="toc-number">1.16.</span> <span class="toc-text">16 JVM</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#17-SQL"><span class="toc-number">1.17.</span> <span class="toc-text">17 SQL</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#18-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.18.</span> <span class="toc-text">18 设计模式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A3%85%E9%A5%B0%E8%80%85%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.18.1.</span> <span class="toc-text">装饰者模式</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C-%E9%A1%B9%E7%9B%AE"><span class="toc-number">2.</span> <span class="toc-text">二 项目</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-FS%E5%BC%80%E5%8F%91"><span class="toc-number">2.1.</span> <span class="toc-text">1 FS开发</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E8%8B%8D%E7%A9%B9"><span class="toc-number">2.2.</span> <span class="toc-text">2 苍穹</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-0-%E4%BA%AE%E7%82%B9"><span class="toc-number">2.2.1.</span> <span class="toc-text">2.0 亮点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1%E4%BB%8B%E7%BB%8D"><span class="toc-number">2.2.2.</span> <span class="toc-text">2.1介绍</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-%E6%95%B0%E6%8D%AE%E8%A1%A8"><span class="toc-number">2.2.3.</span> <span class="toc-text">2.2 数据表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-%E6%8A%80%E6%9C%AF%E7%82%B9"><span class="toc-number">2.2.4.</span> <span class="toc-text">2.3 技术点</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%AD%A6%E6%88%90"><span class="toc-number">2.3.</span> <span class="toc-text">3 学成</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-0-%E9%A1%B9%E7%9B%AE%E4%BA%AE%E7%82%B9"><span class="toc-number">2.3.1.</span> <span class="toc-text">3.0 项目亮点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1%E4%BB%8B%E7%BB%8D"><span class="toc-number">2.3.2.</span> <span class="toc-text">3.1介绍</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-%E6%95%B0%E6%8D%AE%E8%A1%A8"><span class="toc-number">2.3.3.</span> <span class="toc-text">3.2 数据表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-%E6%A8%A1%E5%9D%97%E7%82%B9"><span class="toc-number">2.3.4.</span> <span class="toc-text">3.3 模块点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-4-%E6%8A%80%E6%9C%AF%E7%82%B9"><span class="toc-number">2.3.5.</span> <span class="toc-text">3.4 技术点</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E4%BB%BF%E7%9C%9F%E9%A1%B9%E7%9B%AE"><span class="toc-number">2.4.</span> <span class="toc-text">4 仿真项目</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89-%E7%AC%94%E8%AF%95"><span class="toc-number">3.</span> <span class="toc-text">三 笔试</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-13-%E6%90%BA%E7%A8%8B"><span class="toc-number">3.1.</span> <span class="toc-text">3.13 携程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-16-%E8%9A%82%E8%9A%81"><span class="toc-number">3.2.</span> <span class="toc-text">3.16 蚂蚁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-16-%E7%BE%8E%E5%9B%A2"><span class="toc-number">3.3.</span> <span class="toc-text">3.16 美团</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-29-%E5%B0%8F%E7%BA%A2%E4%B9%A6"><span class="toc-number">3.4.</span> <span class="toc-text">3.29 小红书</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-%E6%B7%98%E5%A4%A9"><span class="toc-number">3.5.</span> <span class="toc-text">4.3 淘天</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-16-%E9%92%89%E9%92%89"><span class="toc-number">3.6.</span> <span class="toc-text">4.16 钉钉</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-18-%E9%98%BF%E9%87%8C%E4%BA%91"><span class="toc-number">3.7.</span> <span class="toc-text">4.18 阿里云</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-26-%E5%B0%8F%E7%BA%A2%E4%B9%A62"><span class="toc-number">3.8.</span> <span class="toc-text">4.26 小红书2</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B-%E9%9D%A2%E8%AF%95"><span class="toc-number">4.</span> <span class="toc-text">四 面试</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-%E6%90%BA%E7%A8%8B%E4%B8%80%E9%9D%A2-3-20"><span class="toc-number">4.1.</span> <span class="toc-text">4.1 携程一面 3.20</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-%E7%BE%8E%E5%9B%A2%E4%B8%80%E9%9D%A2-3-22-%E5%A4%96%E5%8D%96%E5%B9%B3%E5%8F%B0"><span class="toc-number">4.2.</span> <span class="toc-text">4.2 美团一面 3.22 外卖平台</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-%E9%A5%BF%E4%BA%86%E4%B9%88%E4%B8%80%E9%9D%A2-3-25"><span class="toc-number">4.3.</span> <span class="toc-text">4.3 饿了么一面 3.25</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-4-%E7%BE%8E%E5%9B%A2%E4%BA%8C%E9%9D%A2-3-26"><span class="toc-number">4.4.</span> <span class="toc-text">4.4 美团二面 3.26</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-5-%E8%85%BE%E8%AE%AF%E4%B8%80%E9%9D%A2-3-27"><span class="toc-number">4.5.</span> <span class="toc-text">4.5 腾讯一面 3.27</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-6-%E8%85%BE%E8%AE%AF%E4%BA%8C%E9%9D%A2-3-29"><span class="toc-number">4.6.</span> <span class="toc-text">4.6 腾讯二面 3.29</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-7-%E8%9A%82%E8%9A%81%E4%B8%80%E9%9D%A2-4-2-%E5%81%9A%E4%B8%AD%E9%97%B4%E4%BB%B6%E6%9E%B6%E6%9E%84"><span class="toc-number">4.7.</span> <span class="toc-text">4.7 蚂蚁一面 4.2 做中间件架构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-8-%E8%9A%82%E8%9A%81%E4%BA%8C%E9%9D%A2-4-9"><span class="toc-number">4.8.</span> <span class="toc-text">4.8 蚂蚁二面 4.9</span></a></li></ol></li></ol></div></div></div></div></main><footer id="footer" style="background: transparent"><div id="footer-wrap"><div class="copyright">©2024 By myl</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=4.13.0"></script><script src="/js/main.js?v=4.13.0"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"><script>(() => {
  const getCount = () => {
    const countELement = document.getElementById('twikoo-count')
    if(!countELement) return
    twikoo.getCommentsCount({
      envId: 'https://comments.manyile.top/',
      region: 'ap-shanghai',
      urls: [window.location.pathname],
      includeReply: false
    }).then(res => {
      countELement.textContent = res[0].count
    }).catch(err => {
      console.error(err)
    })
  }

  const init = () => {
    twikoo.init(Object.assign({
      el: '#twikoo-wrap',
      envId: 'https://comments.manyile.top/',
      region: 'ap-shanghai',
      onCommentLoaded: () => {
        btf.loadLightbox(document.querySelectorAll('#twikoo .tk-content img:not(.tk-owo-emotion)'))
      }
    }, null))

    GLOBAL_CONFIG_SITE.isPost && getCount()
  }

  const loadTwikoo = () => {
    if (typeof twikoo === 'object') setTimeout(init,0)
    else getScript('https://cdn.jsdelivr.net/npm/twikoo@1.6.31/dist/twikoo.all.min.js').then(init)
  }

  if ('Twikoo' === 'Twikoo' || !true) {
    if (true) btf.loadComment(document.getElementById('twikoo-wrap'), loadTwikoo)
    else loadTwikoo()
  } else {
    window.loadOtherComment = loadTwikoo
  }
})()</script></div><script type="text/javascript" src="https://unpkg.zhimg.com/jquery@latest/dist/jquery.min.js"></script><script data-pjax="" type="text/javascript" src="/js/nav.js"></script><div class="aplayer no-destroy" data-id="2664875269" data-server="netease" data-type="playlist" data-fixed="true" data-mini="true" data-listfolded="false" data-order="random" data-preload="none" data-autoplay="false" muted=""></div><script data-pjax="" type="text/javascript" src="/js/randomPaper.js"></script><script type="text/javascript" src="/js/rightMenu.js"></script><script>let tianliGPT_postSelector = '\#post \#article-container';let tianliGPT_key = 'c9b7741d290063ab872e';</script><script src="https://cdn1.tianli0.top/gh/zhheo/Post-Abstract-AI@0.15.2/tianli_gpt.js"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer@1.10.1/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/aplayer@1.10.1/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/metingjs/dist/Meting.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax@0.2.8/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {

  // removeEventListener
  btf.removeGlobalFnEvent('pjax')
  btf.removeGlobalFnEvent('themeChange')

  document.getElementById('rightside').classList.remove('rightside-show')
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

  typeof disqusjs === 'object' && disqusjs.destroy()
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', e => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async="" data-pjax="" src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"></div></div><hr><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js?v=4.13.0"></script></div></div><div class="js-pjax" id="rightMenu"><div class="rightMenu-group rightMenu-small"><a class="rightMenu-item" href="javascript:window.history.back();"><i class="fa fa-arrow-left"></i></a><a class="rightMenu-item" href="javascript:window.history.forward();"><i class="fa fa-arrow-right"></i></a><a class="rightMenu-item" href="javascript:window.location.reload();"><i class="fa fa-refresh"></i></a><a class="rightMenu-item" href="javascript:rmf.scrollToTop();"><i class="fa fa-arrow-up"></i></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-text"><a class="rightMenu-item" href="javascript:rmf.copySelect();"><i class="fa fa-copy"></i><span>复制</span></a><a class="rightMenu-item" href="javascript:window.open(&quot;https://www.baidu.com/s?wd=&quot;+window.getSelection().toString());window.location.reload();"><i class="iconfont icon-baidu"></i><span>百度搜索</span></a><a class="rightMenu-item" href="javascript:rmf.searchinThisPage();"><i class="fas fa-search"></i><span>站内搜索</span></a><a class="rightMenu-item" href="#post-comment" onclick="rmf.yinyong()"><i class="fa-solid fa-message"></i><span>引用文本评论</span></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-too"><a class="rightMenu-item" href="javascript:window.open(window.getSelection().toString());window.location.reload();"><i class="fa fa-link"></i><span>转到链接</span></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-paste"><a class="rightMenu-item" href="javascript:rmf.paste()"><i class="fa fa-copy"></i><span>粘贴</span></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-post"><a class="rightMenu-item" href="#post-comment"><i class="fas fa-comment"></i><span>空降评论</span></a><a class="rightMenu-item" href="javascript:switchCommentBarrage()"><i class="iconfont icon-danmu"></i><span>开/关评论弹幕</span></a><a class="rightMenu-item" href="javascript:rmf.copyWordsLink()"><i class="fa fa-link"></i><span>复制本文地址</span></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-to"><a class="rightMenu-item" href="javascript:rmf.openWithNewTab()"><i class="fa fa-window-restore"></i><span>新窗口打开</span></a><a class="rightMenu-item" id="menu-too" href="javascript:rmf.open()"><i class="fa fa-link"></i><span>转到链接</span></a><a class="rightMenu-item" href="javascript:rmf.copyLink()"><i class="fa fa-copy"></i><span>复制链接</span></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-img"><a class="rightMenu-item" href="javascript:rmf.saveAs()"><i class="fa fa-download"></i><span>保存图片</span></a><a class="rightMenu-item" href="javascript:rmf.openWithNewTab()"><i class="fa fa-window-restore"></i><span>在新窗口打开</span></a><a class="rightMenu-item" href="javascript:rmf.click()"><i class="fa fa-arrows-alt"></i><span>全屏显示</span></a><a class="rightMenu-item" href="javascript:rmf.copyLink()"><i class="fa fa-copy"></i><span>复制图片链接</span></a></div><div class="rightMenu-group rightMenu-line"><a class="rightMenu-item" href="javascript:randomPost()"><i class="fa fa-paper-plane"></i><span>随便逛逛</span></a><a class="rightMenu-item" href="javascript:rmf.switchDarkMode();"><i class="fa fa-moon"></i><span>昼夜切换</span></a><a class="rightMenu-item" href="javascript:fullScreen();"><i class="fas fa-expand"></i><span>进入全屏</span></a></div></div><!-- hexo injector body_end start --><script data-pjax="">function electric_clock_injector_config(){
                var parent_div_git = document.getElementsByClassName('sticky_layout')[0];
                var item_html = '<div class="card-widget card-clock"><div class="card-glass"><div class="card-background"><div class="card-content"><div id="hexo_electric_clock"><img id="card-clock-loading" src="https://cdn.jsdelivr.net/gh/Zfour/Butterfly-clock/clock/images/weather/loading.gif" style="height: 120px; width: 100%;" data-ll-status="loading" class="entered loading"></div></div></div></div></div>';
                console.log('已挂载electric_clock')
                // parent_div_git.innerHTML=item_html+parent_div_git.innerHTML // 无报错，但不影响使用(支持pjax跳转)
                parent_div_git.insertAdjacentHTML("afterbegin",item_html) // 有报错，但不影响使用(支持pjax跳转)
            }if( document.getElementsByClassName('sticky_layout')[0] && (location.pathname ==='all'|| 'all' ==='all')){

            electric_clock_injector_config()
        } </script><script src="https://pv.sohu.com/cityjson?ie=utf-8"></script><script data-pjax="" src="https://cdn.jsdelivr.net/gh/Zfour/hexo-electric-clock@1.0.6/clock.js"></script><script async="" src="//at.alicdn.com/t/font_2032782_8d5kxvn09md.js"></script><!-- hexo injector body_end end --></body></html>