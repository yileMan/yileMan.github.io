<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>javase | myl's blog</title><meta name="author" content="myl"><meta name="copyright" content="myl"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="JAVASE_STUDY0703 一 基础1.1 JDK JRE JVM关系 (jdk安装环境不带中文和空格) 1.2 JAVA编译过程源程序(.java) -&gt; 编译器 -&gt; java字节码文件(.class) -&gt; JVM运行 public class HelloWorld &#123;     public static void main(String[] args)&amp;#">
<meta property="og:type" content="article">
<meta property="og:title" content="javase">
<meta property="og:url" content="http://yileman.github.io/posts/20250.html">
<meta property="og:site_name" content="myl&#39;s blog">
<meta property="og:description" content="JAVASE_STUDY0703 一 基础1.1 JDK JRE JVM关系 (jdk安装环境不带中文和空格) 1.2 JAVA编译过程源程序(.java) -&gt; 编译器 -&gt; java字节码文件(.class) -&gt; JVM运行 public class HelloWorld &#123;     public static void main(String[] args)&amp;#">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/touxiang.jpg">
<meta property="article:published_time" content="2022-09-17T16:00:00.000Z">
<meta property="article:modified_time" content="2024-03-15T13:31:04.517Z">
<meta property="article:author" content="myl">
<meta property="article:tag" content="java基础">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/touxiang.jpg"><link rel="shortcut icon" href="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/touxiang.jpg"><link rel="canonical" href="http://yileman.github.io/posts/20250.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=4.13.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.11.1/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'javase',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-03-15 21:31:04'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 7.1.1"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/touxiang.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">19</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">6</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">4</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page" href="/comments/"><i class="fa-fw fa fa-link"></i><span> 留言板</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a href="/" title="myl's blog"><span class="site-name">myl's blog</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page" href="/comments/"><i class="fa-fw fa fa-link"></i><span> 留言板</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">javase</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-09-17T16:00:00.000Z" title="发表于 2022-09-18 00:00:00">2022-09-18</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-03-15T13:31:04.517Z" title="更新于 2024-03-15 21:31:04">2024-03-15</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/study/">study</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="javase"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h2 id="JAVASE-STUDY"><a href="#JAVASE-STUDY" class="headerlink" title="JAVASE_STUDY"></a>JAVASE_STUDY</h2><h3 id="0703-一-基础"><a href="#0703-一-基础" class="headerlink" title="0703 一 基础"></a>0703 一 基础</h3><h4 id="1-1-JDK-JRE-JVM关系"><a href="#1-1-JDK-JRE-JVM关系" class="headerlink" title="1.1 JDK JRE JVM关系"></a>1.1 JDK JRE JVM关系</h4><p><img src="/TyporaImg/javaSE%E7%AC%94%E8%AE%B0.assets/image-20220703112143738.png" alt="image-20220703112143738"></p>
<p>(jdk安装环境不带中文和空格)</p>
<h4 id="1-2-JAVA编译过程"><a href="#1-2-JAVA编译过程" class="headerlink" title="1.2 JAVA编译过程"></a>1.2 JAVA编译过程</h4><p>源程序(.java) -&gt; 编译器 -&gt; java字节码文件(.class) -&gt; JVM运行</p>
<p><code>public class HelloWorld &#123;     public static void main(String[] args)&#123;         System.out.println(&quot;Hello,World!&quot;);     &#125; &#125;</code></p>
<p>cmd</p>
<p><code>D:/&gt;javac HelloWorld.java</code>  &lt;- 编译生成.class文件</p>
<p><code>D:/&gt;java HelloWorld</code> &lt;- 运行</p>
<h4 id="1-3-关键字、标识符"><a href="#1-3-关键字、标识符" class="headerlink" title="1.3 关键字、标识符"></a>1.3 关键字、标识符</h4><p>标识符：26个字母、10个数字、美元符号$和下划线_   (不以数字开头，不能是关键字)</p>
<p>命名规则：</p>
<ul>
<li>类名：首字母大写，后面每个单词首字母大写（HelloWorld）</li>
<li>变量名：首字母小写，后面每个字母首字母大写（helloWorld）</li>
<li>方法名：同变量名</li>
</ul>
<h4 id="1-4-常量与变量"><a href="#1-4-常量与变量" class="headerlink" title="1.4 常量与变量"></a>1.4 常量与变量</h4><p>常量：</p>
<ul>
<li><p>字符串常量：用双引号引起来的（”abc”）</p>
</li>
<li><p>整数常量：（2）</p>
</li>
<li><p>浮点数常量：（2.5）</p>
</li>
<li><p>字符常量：单引号（’a’、’中’）</p>
</li>
<li><p>布尔常量：（true、false）</p>
</li>
<li><p>空常量：（null）</p>
</li>
</ul>
<p>变量：</p>
<ul>
<li>创建：数据类型 变量名称 &#x3D; 数据值;</li>
<li>注意事项：名称不重复；对于float或者long，字母后缀F和L不能丢</li>
</ul>
<h4 id="1-5-基本数据类型和引用数据类型"><a href="#1-5-基本数据类型和引用数据类型" class="headerlink" title="1.5 基本数据类型和引用数据类型"></a>1.5 基本数据类型和引用数据类型</h4><p>  基本数据类型（4类8种）</p>
<ul>
<li><p>整数型：byte（1字节）、short（2字节）、int（4字节）、long（8字节）</p>
</li>
<li><p>浮点型：float（4字节）、double（近似值，非精确值）</p>
</li>
<li><p>字符型：char</p>
</li>
<li><p>布尔型：boolean</p>
</li>
<li><p>注：并不是字节越大表示的数字范围越大，float就比long类型表示的数字范围大</p>
</li>
</ul>
<p>引用数据类型</p>
<ul>
<li>字符串</li>
<li>数组</li>
<li>类</li>
<li>接口 </li>
<li>Lambda</li>
</ul>
<p>注：对于引用类型，&#x3D;&#x3D;是地址值的比较，对于基本类型，&#x3D;&#x3D;是数值的比较</p>
<h4 id="1-6-数据类型转换"><a href="#1-6-数据类型转换" class="headerlink" title="1.6 数据类型转换"></a>1.6 数据类型转换</h4><ul>
<li><p>自动类型转换（隐式）</p>
</li>
<li><p>强制类型转换（显式）：范围小的类型 变量名 &#x3D; （范围小的类型）范围大的数据 -&gt; int num &#x3D; (int) 100L;</p>
<p>​		精度损失、数据溢出</p>
</li>
<li><p>byte、short、char它们之间进行加减乘除的时候会自动转换为int类型</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">byte</span> <span class="variable">b1</span> <span class="operator">=</span> <span class="number">40</span>;</span><br><span class="line"><span class="type">byte</span> <span class="variable">b2</span> <span class="operator">=</span> <span class="number">40</span>;</span><br><span class="line"><span class="type">short</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="number">50</span>;</span><br><span class="line"><span class="type">char</span> <span class="variable">c1</span> <span class="operator">=</span> <span class="string">&#x27;A&#x27;</span></span><br><span class="line"><span class="type">int</span> <span class="variable">i1</span> <span class="operator">=</span> b1 + b2;</span><br><span class="line"><span class="type">int</span> <span class="variable">i2</span> <span class="operator">=</span> b1 + s1;</span><br><span class="line"><span class="type">int</span> <span class="variable">i3</span> <span class="operator">=</span> b1 + c1; <span class="comment">// =105</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="1-7-ASCII编码"><a href="#1-7-ASCII编码" class="headerlink" title="1.7 ASCII编码"></a>1.7 ASCII编码</h4><p>​		(American Standard Code for Information Interchange,美国信息交换标准代码)		</p>
<p>​		码表：<a target="_blank" rel="noopener" href="http://c.biancheng.net/c/ascii/">http://c.biancheng.net/c/ascii/</a></p>
<p>​		Unicode码表：万国码。数字和符号的对照关系，开头0-127和ASCII一样，从128开始有更多的字符</p>
<h4 id="1-8-运算符"><a href="#1-8-运算符" class="headerlink" title="1.8 运算符"></a>1.8 运算符</h4><ul>
<li>算数运算符：+、-、*、&#x2F;、%(取模)、++、–</li>
</ul>
<p>​			        注：前++是先+1再被使用，后++是先使用再+1</p>
<ul>
<li><p>赋值运算符号：基本赋值运算符（&#x3D;）、复合赋值运算符（+&#x3D;、-&#x3D;、*&#x3D;、&#x2F;&#x3D;、%&#x3D;）<br>      注：复合赋值运算符含有强制转换</p>
</li>
<li><p>比较运算符：&#x3D;&#x3D;、&gt;、&lt;、&gt;&#x3D;、&lt;&#x3D;、!&#x3D;</p>
</li>
<li><p>逻辑运算符：&amp;&amp;、||、!</p>
<pre><code>注：&amp;&amp;和||具有短路效应，若左边可以得到判断结果，则不执行右边，具有节省性能的作用
</code></pre>
</li>
<li><p>三元运算符： 变量类型 &#x3D; 条件判断 ？ 表达式A  : 表达式B;（true执行A，false执行B）</p>
</li>
</ul>
<h4 id="1-9-方法"><a href="#1-9-方法" class="headerlink" title="1.9 方法"></a>1.9 方法</h4><p>方法的定义：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> 方法名称()&#123;</span><br><span class="line">    方法体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法的调用：</p>
<p>​	<code>方法名称（参数）</code></p>
<h4 id="1-10-Jshell"><a href="#1-10-Jshell" class="headerlink" title="1.10 Jshell"></a>1.10 Jshell</h4><p>java 9更新</p>
<p>cmd -&gt; 输入jshell即可</p>
<h3 id="0704-二-结构及方法"><a href="#0704-二-结构及方法" class="headerlink" title="0704 二 结构及方法"></a>0704 二 结构及方法</h3><h4 id="2-1-顺序结构"><a href="#2-1-顺序结构" class="headerlink" title="2.1 顺序结构"></a>2.1 顺序结构</h4><h4 id="2-2-选择结构"><a href="#2-2-选择结构" class="headerlink" title="2.2 选择结构"></a>2.2 选择结构</h4><ul>
<li>if 语句</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(关系表达式<span class="number">1</span>)&#123;</span><br><span class="line">    语句体<span class="number">1</span>;</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(关系表达式<span class="number">2</span>)&#123;</span><br><span class="line">    语句体<span class="number">2</span>;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    语句体<span class="number">3</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>switch语句</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span>(表达式)&#123;</span><br><span class="line">     <span class="keyword">case</span> 常量<span class="number">1</span>:</span><br><span class="line">        语句体<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">     <span class="keyword">case</span> 常量<span class="number">2</span>:</span><br><span class="line">        语句体<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">     ...</span><br><span class="line">     <span class="keyword">default</span>:</span><br><span class="line">        语句体n+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>switch后面小括号当中只能是下列数据类型：</p>
<p>​		基本数据类型：byte&#x2F;short&#x2F;char&#x2F;int</p>
<p>​		引用数据类型：String字符串、enum枚举</p>
<h4 id="2-3-循环结构"><a href="#2-3-循环结构" class="headerlink" title="2.3 循环结构"></a>2.3 循环结构</h4><ul>
<li>for循环</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(初始化语句;条件判断;步进语句)&#123;</span><br><span class="line">    循环体;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>while循环</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">初始化语句;</span><br><span class="line"><span class="keyword">while</span>(条件判断)&#123;</span><br><span class="line">    循环体;</span><br><span class="line">    步进语句;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>do-while循环</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">初始化语句;</span><br><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line">    循环体;</span><br><span class="line">    步进表达式;</span><br><span class="line">&#125;<span class="keyword">while</span>(条件判断);<span class="comment">//&lt;-------有一个分号 </span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>三者的区别：</p>
<p>do-while 至少会执行一次，前两者可能执行0次就跳出;</p>
<p>for 循环的变量在括号内定义，出了循环不能使用，后两者出了循环还可以使用;</p>
<p>确定次数一般用for，否则一般用while，很少用do-while;</p>
</li>
</ul>
<h4 id="2-4-循环控制"><a href="#2-4-循环控制" class="headerlink" title="2.4 循环控制"></a>2.4 循环控制</h4><ul>
<li>break		 直接结束整个循环</li>
<li>continue   立刻跳过当前循环，进行下一次循环</li>
</ul>
<h4 id="2-5-IDEA"><a href="#2-5-IDEA" class="headerlink" title="2.5 IDEA"></a>2.5 IDEA</h4><ul>
<li>项目结构：Project（项目）—&gt;Module（模块）—&gt;Package（包）</li>
<li>一些快捷键：<ul>
<li>alt+&#x2F; ：自动补全代码</li>
<li>alt+enter：自动修复代码</li>
<li>ctrl+Y：删一行</li>
<li>ctrl+D：加一行</li>
<li>ctrl+alt+L：格式化</li>
<li>ctrl+&#x2F;：注释一行</li>
</ul>
</li>
<li>Debug<ul>
<li>f8：逐行执行</li>
<li>f7：进入方法中</li>
<li>shift+f8：跳出方法</li>
<li>f9跳到下一个断点</li>
<li>ctrl + f2：退出debug</li>
</ul>
</li>
</ul>
<h4 id="2-6-方法定义及调用及方法的重载"><a href="#2-6-方法定义及调用及方法的重载" class="headerlink" title="2.6 方法定义及调用及方法的重载"></a>2.6 方法定义及调用及方法的重载</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">修饰符 返回值类型 方法名称（参数类型 参数名称, ...)&#123;</span><br><span class="line">    方法体</span><br><span class="line">    <span class="keyword">return</span> 返回值;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>return的作用：停止当前方法；将返回值还给调用处</p>
<p>方法的三种调用方法：</p>
<ul>
<li>单独调用：方法名（参数）</li>
<li>打印调用：</li>
<li>赋值调用：数据类型 变量名称 &#x3D; 方法名称（参数）;</li>
</ul>
<p>方法重载的情况</p>
<ul>
<li>方法的参数个数不同</li>
<li>方法的参数类型不同</li>
<li>参数的多类型顺序不同</li>
<li>注：方法重载与参数名称无关；与返回值类型无关</li>
</ul>
<h3 id="0705-三-数组、变量"><a href="#0705-三-数组、变量" class="headerlink" title="0705 三 数组、变量"></a>0705 三 数组、变量</h3><h4 id="3-1-数组简介"><a href="#3-1-数组简介" class="headerlink" title="3.1 数组简介"></a>3.1 数组简介</h4><ul>
<li><p>数组是一种容器，可以同时存放多个数据值</p>
</li>
<li><p>特点：是一种引用数据类型；数组之中的多个数据类型必须一致；数组的长度在程序运行期间不可改变。</p>
</li>
<li><p>数组的初始化</p>
<ul>
<li>动态初始化（指定长度）</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">数据类型[] 数组名称 = <span class="keyword">new</span> 数据类型[数组长度];</span><br></pre></td></tr></table></figure>

<ul>
<li>静态初始化（指定内容）</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">数据类型[] 数组名称 = <span class="keyword">new</span> 数据类型[]&#123;元素<span class="number">1</span>, 元素<span class="number">2</span>, ...&#125;;</span><br><span class="line">数据类型[] 数组名称 = &#123;元素<span class="number">1</span>, 元素<span class="number">2</span>, ...&#125;;<span class="comment">//也可以省略一些</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>数组的访问：数组名称[索引];      &lt;–从0开始访问</p>
</li>
</ul>
<h4 id="3-2-JAVA内存划分"><a href="#3-2-JAVA内存划分" class="headerlink" title="3.2 JAVA内存划分"></a>3.2 JAVA内存划分</h4><ul>
<li><p>划分为5个部分：</p>
<ul>
<li><p>栈（stack）：存放方法的局部变量，一旦出了作用域立刻从栈中消失</p>
</li>
<li><p>堆（Heap）：凡是new出来的都在堆内存中，堆内存中都有一个地址值（16进制）</p>
<p>​			若为整数默认为0；浮点数默认为0.0；字符默认为’&#x2F;u0000’；布尔默认为false；引用类型默认为null</p>
</li>
<li><p>方法区（Method Area）：储存.class相关信息，包含方法的信息</p>
</li>
<li><p>本地方法栈（Native Method Stack）：与操作系统相关</p>
</li>
<li><p>寄存器（pc Register）：与CPU相关</p>
</li>
</ul>
</li>
<li><p>一个数组的内存图</p>
</li>
</ul>
<p><img src="/TyporaImg/javaSE%E7%AC%94%E8%AE%B0.assets/image-20220705111140801.png" alt="image-20220705111140801"></p>
<ul>
<li>两个引用指向同一个数组</li>
</ul>
<p><img src="/TyporaImg/javaSE%E7%AC%94%E8%AE%B0.assets/image-20220705112141784.png" alt="image-20220705112141784"></p>
<h4 id="3-3-数组常见问题"><a href="#3-3-数组常见问题" class="headerlink" title="3.3 数组常见问题"></a>3.3 数组常见问题</h4><ul>
<li>索引越界 –&gt; ArrayIndexOutOfBoundsException </li>
<li>空指针异常 –&gt; NullPointException –&gt; 创建数组的时候补上new</li>
</ul>
<h4 id="3-4-数组常用"><a href="#3-4-数组常用" class="headerlink" title="3.4 数组常用"></a>3.4 数组常用</h4><ul>
<li><p>获取数组长度 ：<code>数组名称.length</code>  数组一但创建，长度不可改变</p>
</li>
<li><p>遍历数组：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; array.length;i++)&#123;</span><br><span class="line">    数组操作</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>idea里面可以直接array.fori</p>
</li>
</ul>
<h4 id="3-5-面向对象的思想"><a href="#3-5-面向对象的思想" class="headerlink" title="3.5 面向对象的思想"></a>3.5 面向对象的思想</h4><ul>
<li><p>类与对象：对象是类的实体，类是对象的模板 </p>
</li>
<li><p>类的定义：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClassName</span>&#123;</span><br><span class="line">    <span class="comment">//成员变量</span></span><br><span class="line">    <span class="comment">//类方法，成员方法没有static</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注：成员变量直接定义在类当中，在方法外面；</p>
<p>​		成员方法不要写static关键字（加了static后作用域只能用于代码本身了）。</p>
</li>
<li><p>一个对象的内存图</p>
<p><img src="/TyporaImg/javaSE%E7%AC%94%E8%AE%B0.assets/image-20220705125914306.png" alt="image-20220705125914306"></p>
</li>
<li><p>两个引用指向一个对象的内存图</p>
<p><img src="/TyporaImg/javaSE%E7%AC%94%E8%AE%B0.assets/image-20220705130722445.png" alt="image-20220705130722445"></p>
</li>
<li><p>使用对象类型作为方法的参数</p>
<p><img src="/TyporaImg/javaSE%E7%AC%94%E8%AE%B0.assets/image-20220705131811594.png" alt="image-20220705131811594"></p>
<p>注意：当对象作为参数输入的时候，传递的是一个地址值，所以在方法内修改</p>
</li>
<li><p>使用对象类型作为方法的返回值</p>
<p><img src="/TyporaImg/javaSE%E7%AC%94%E8%AE%B0.assets/image-20220705132352427.png" alt="image-20220705132352427"></p>
<p>注意：当一个对象作为方法的返回值的时候，返回值其实是对象的地址值</p>
</li>
</ul>
<h4 id="3-6-局部变量和成员变量"><a href="#3-6-局部变量和成员变量" class="headerlink" title="3.6 局部变量和成员变量"></a>3.6 局部变量和成员变量</h4><ul>
<li>定义位置不一样。局部变量在方法内部定义，成员变量在外部定义；                       </li>
<li>作用范围不一样。局部变量出了方法就不能用了，成员变量在整个类通用； </li>
<li>默认值不一样。局部变量无默认值，成员变量有，规则和数组一样；<ul>
<li>内存位置不一样。局部变量在栈中，成员变量在堆中；</li>
</ul>
</li>
<li>生命周期不一样。局部变量随着方法进栈诞生，随着方法出栈消失，成员变量随着对象创建诞生，随着对象被垃圾回收而消失。</li>
</ul>
<h4 id="3-7-面向对象的三大特性"><a href="#3-7-面向对象的三大特性" class="headerlink" title="3.7 面向对象的三大特性"></a>3.7 面向对象的三大特性</h4><ul>
<li>封装：方法就是一种封装；private也是一种封装</li>
<li>继承：继承是多态的前提，没有继承就没有多态</li>
<li>多态</li>
</ul>
<h4 id="3-8-private和this关键字"><a href="#3-8-private和this关键字" class="headerlink" title="3.8 private和this关键字"></a>3.8 private和this关键字</h4><ul>
<li><p>使用了private修饰，本类之外就不能直接访问了（定义getset方法可以间接访问）</p>
</li>
<li><p>当方法的局部变量和类的成员变量重名的时候，根据就就近原则，优先使用局部变量</p>
<p>所以当要访问本类中的成员变量，需要使用this关键字：<code>this.成员变量名</code></p>
<p>注：谁调用方法，谁就是this</p>
</li>
</ul>
<h4 id="3-9-构造方法"><a href="#3-9-构造方法" class="headerlink" title="3.9 构造方法"></a>3.9 构造方法</h4><ul>
<li><p>用于创建对象，当使用new创建对象的时候，就是在调用构造方法</p>
<p><code>public 类名称(参数类型 参数名称)&#123;方法体&#125;</code></p>
</li>
<li><p>注：</p>
<ul>
<li>构造方法名称必须和所在的类名称完全一样包括大小写</li>
<li>无返回值，也不写void</li>
<li>构造方法不能return</li>
<li>如果没有构造方法，则编译器会自动生成一个构造方法，没有参数什么也不做</li>
<li>一旦编写了至少一个构造方法，则编译器不自动生成构造方法</li>
<li>构造方法可以进行重载</li>
</ul>
</li>
</ul>
<h4 id="3-10-定义一个标准的类"><a href="#3-10-定义一个标准的类" class="headerlink" title="3.10 定义一个标准的类"></a>3.10 定义一个标准的类</h4><ul>
<li>所用成员变量都用private修饰</li>
<li>为每一个成员变量编写一对getter&#x2F;setter方法</li>
<li>编写一个无参数构造方法</li>
<li>编写一个全参数构造方法</li>
</ul>
<p>这样一个标准的类也叫Java Bean</p>
<h3 id="0706-四-对象、字符串"><a href="#0706-四-对象、字符串" class="headerlink" title="0706 四 对象、字符串"></a>0706 四 对象、字符串</h3><h4 id="4-1-API"><a href="#4-1-API" class="headerlink" title="4.1 API"></a>4.1 API</h4><ul>
<li>Application Programming Interface</li>
<li>引用类的步骤：导包-&gt;创建-&gt;使用     同一个包下不需要导包，java.lang目录下也不需要导包</li>
<li><u><em>Scanner练习：day0705&#x2F;Scanner_test.java</em></u>：键盘输入两数字求和</li>
</ul>
<h4 id="4-2-匿名对象"><a href="#4-2-匿名对象" class="headerlink" title="4.2 匿名对象"></a>4.2 匿名对象</h4><ul>
<li>匿名对象就是只有右边的对象，没有左边的名字和赋值运算符</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Person</span>().name = <span class="string">&quot;jack&quot;</span>  <span class="comment">//标准的是 Person p = new Person()，然后再调用.name()方法</span></span><br></pre></td></tr></table></figure>

<ul>
<li>匿名对象只能使用唯一的一次，下次再用不得不再创建一个新的对象</li>
<li>使用建议：如果确定有一个对象只需要使用唯一的一次，就可以创建匿名对象</li>
<li>匿名对象作为方法参数和返回值</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">method(<span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in));<span class="comment">//System.in为InputStream类</span></span><br></pre></td></tr></table></figure>

<h4 id="4-3-Random类"><a href="#4-3-Random类" class="headerlink" title="4.3 Random类"></a>4.3 Random类</h4><h4 id="4-4-对象数组与ArrayList"><a href="#4-4-对象数组与ArrayList" class="headerlink" title="4.4 对象数组与ArrayList"></a>4.4 对象数组与ArrayList</h4><ul>
<li>ArrayList的长度可以改变而数组长度不能改变</li>
<li>ArrayList有一个<E>表示泛型，泛型只能是引用类型，不能是基本类型（因为基本数据类型没有地址值），如果要用到基本数据类型，可以用它对应的包装类</li>
<li>对于ArrayList打印的是内容而不是地址值</li>
<li>常用方法：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span>;</span><br><span class="line"><span class="keyword">public</span> E <span class="title function_">get</span><span class="params">(<span class="type">int</span> index)</span>;</span><br><span class="line"><span class="keyword">public</span> E <span class="title function_">remove</span><span class="params">(<span class="type">int</span> index)</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span></span><br></pre></td></tr></table></figure>

<ul>
<li><u><em>ArrayList练习：day0705&#x2F;ArrayList_test.java</em></u></li>
</ul>
<h4 id="4-5-字符串"><a href="#4-5-字符串" class="headerlink" title="4.5 字符串"></a>4.5 字符串</h4><ul>
<li><p>字符串特点：</p>
<ul>
<li>字符串内容永不可改变（一些看起来修改了字符串的方法其实是相当于创建了一个新的字符串）</li>
<li>正因为不可改变，所以字符串是可以共享的</li>
<li>字符串效果上相当于是char[]字符数组，但是底层原理是byte[]字节数组</li>
</ul>
</li>
<li><p>字符串的创建（常见3+1种）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>();<span class="comment">//创建空白字符串，不含内容</span></span><br><span class="line"><span class="type">char</span>[] array1 = &#123;<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;C&#x27;</span>&#125;;</span><br><span class="line"><span class="type">byte</span>[] array2 = &#123;<span class="number">97</span>, <span class="number">98</span>, <span class="number">99</span>&#125;;</span><br><span class="line"><span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="type">char</span>[] array1);<span class="comment">//根据字符数组创建对应的字符串</span></span><br><span class="line"><span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="type">byte</span>[] array2);<span class="comment">//根据字节数组的内容创建对应字符串--&gt;是abc</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>;<span class="comment">//直接创建，虽然没有new，但是它也是字符串对象</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>字符串的常量池：程序中直接写上的双引号字符串，就在字符串常量池中。（在堆中）</p>
<ul>
<li>对于引用类型，&#x3D;&#x3D;是地址值的比较，对于基本类型，&#x3D;&#x3D;是数值的比较</li>
</ul>
</li>
</ul>
<p><img src="/TyporaImg/javaSE%E7%AC%94%E8%AE%B0.assets/image-20220706135822547.png" alt="image-20220706135822547"></p>
<ul>
<li><p>字符串的比较相关方法</p>
<ul>
<li><p>&#x3D;&#x3D;是对地址值的比较，如果要进行内容的比较，用</p>
<p><code>public boolean equals(Object obj)</code></p>
<p>推荐<code>&quot;abc&quot;.equals(str)</code>而不是<code>str.equals(&quot;abc&quot;)</code>（常量放前面变量放后面防止空指针异常）</p>
</li>
<li><p><code>public int length()</code></p>
</li>
<li><p><code>public String concat(String str)</code>拼接</p>
</li>
<li><p><code>public char charAt(int index) </code>获取指定索引位置的单个字符串</p>
</li>
<li><p><code>public int indexOf(String str)</code>查找字符串首次出现的索引位置，若没有则返回-1</p>
</li>
<li><p><code>public String subString(int index)</code>;<code>public String subStirng(int begin, int end)</code>截取index之后的字符串以及[begin,end)的字符串</p>
</li>
</ul>
</li>
<li><p>字符串的相关转换方法</p>
<ul>
<li><code>public char[] toCharArray() </code>将当前字符串拆分为字符数组作为返回值</li>
<li><code>public byte[] getBytes()</code>获得当前字符串底层的字节数组（IO流中用较多）</li>
<li><code>public String replace(CharSequence oldString, CharSequence newString)</code>将所有出现的老字符串替换为新字符串，返回替换之后的结果新字符串</li>
</ul>
</li>
<li><p>字符串的分割</p>
<ul>
<li><code>public String[] split(String regex)</code>按照参数的规则，将字符串切分为若干部分</li>
<li>注：split方法的参数其实是一个正则表达式，若要按照英文的”.”分，应该写”&#x2F;&#x2F;.”</li>
</ul>
</li>
</ul>
<h4 id="4-5-static关键字"><a href="#4-5-static关键字" class="headerlink" title="4.5 static关键字"></a>4.5 static关键字</h4><ul>
<li><p>一旦使用了static关键字，那么这样的内容不再属于对象自己，而属于类，凡是本类的对象，都共享同一份</p>
</li>
<li><p>static修饰成员变量</p>
<ul>
<li>多个对象共享，如果有一个对象改变了这个变量，则全部对象的这个变量都会改变</li>
</ul>
</li>
<li><p>static修饰方法，一旦修饰了就为静态方法</p>
<ul>
<li><p>如果没有static关键字，必须创建对象然后通过对象使用</p>
</li>
<li><p>对于静态方法来说，可以通过对象名调用（不推荐），也可以直接通过类名来调用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Myclass</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Myclass</span>();</span><br><span class="line">obj.method.Static();<span class="comment">//通过对象名调用方法（编译之后也会被javac翻译为类名.静态方法）</span></span><br><span class="line">Myclass.methodStatic();<span class="comment">//直接通过类名来调用方法</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>无论是成员变量还是成员方法，若有了static，都推荐使用类名称调用</p>
</li>
<li><p>对于本类的静态方法，可以省略类名称</p>
</li>
<li><p>注意：</p>
<ol>
<li>静态不能直接访问非静态。（原因：在内存中先有静态，后有的非静态）</li>
<li>静态方法不能使用this关键字。（因为静态是直接通过类名调用的）</li>
</ol>
</li>
</ul>
</li>
<li><p>静态static的内存图</p>
<p><img src="/TyporaImg/javaSE%E7%AC%94%E8%AE%B0.assets/image-20220706144028767.png" alt="image-20220706144028767"></p>
</li>
<li><p>静态代码块</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> class 类名称()&#123;</span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        <span class="comment">//静态代码块内容</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>当第一次用到本类的时候，静态代码块执行唯一的一次 </li>
<li>由于静态总是优先于非静态执行，所以静态代码块比构造方法先执行</li>
<li>典型用途：一次性对静态成员变量进行赋值</li>
</ul>
</li>
</ul>
<h4 id="4-6-数组工具类-Arrays"><a href="#4-6-数组工具类-Arrays" class="headerlink" title="4.6 数组工具类 Arrays"></a>4.6 数组工具类 Arrays</h4><ul>
<li>java.util.Arrays是一个与数组相关的工具类，里面提供了大量的静态方法，用于实现数组的常见操作</li>
<li><code>public static String toString(数组)</code>：将参数变为字符串（按默认格式：[元素1，元素2，元素3，…]）</li>
<li><code>public static void sort(数组)</code>：升序排列 <ul>
<li>如果是数字，升序</li>
<li>如果是字符串，默认字母升序</li>
<li>如果是自定义类型，则这个自定义类型需要有Comparable或者Comparator接口的支持</li>
</ul>
</li>
<li><u><em>Arrays练习：day0706&#x2F;Arrays_test.java</em></u>：对随机字符串进行升序排序并倒序打印</li>
</ul>
<h4 id="4-7-Math类"><a href="#4-7-Math类" class="headerlink" title="4.7 Math类"></a>4.7 Math类</h4><p>常见方法</p>
<ul>
<li><code>public static double abs(double num)</code>绝对值</li>
<li><code>public static double ceil(double num)</code>向上取整（floor为向下取整）</li>
<li><code>public static long round(double num)</code>四舍五入</li>
<li><code>Math.PI</code></li>
<li><u><em>Math练习：day0706&#x2F;Math_test.java</em></u>：计算两个数之间的整数个数</li>
</ul>
<h3 id="0707-五-继承、抽象、接口、多态"><a href="#0707-五-继承、抽象、接口、多态" class="headerlink" title="0707 五 继承、抽象、接口、多态"></a>0707 五 继承、抽象、接口、多态</h3><h4 id="5-1-继承"><a href="#5-1-继承" class="headerlink" title="5.1 继承"></a>5.1 继承</h4><ul>
<li><p>共性抽取，父类也叫基类、超类，子类也可以叫派生类</p>
</li>
<li><p>定义父类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> class 父类名称()&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>定义子类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> class 子类名称 extends 父类名称()&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>继承中成员变量的特点：在父子类继承关系中，如果成员变量重名，则创建子类对象的时候，有两种访问方法：</p>
<ul>
<li>直接通过子类对象访问（等号左边是谁则优先是谁，没有则向上找——优先子类的变量）</li>
<li>间接通过成员方法访问（方法属于谁，就优先用谁，没有则向上找——优先本类的变量）</li>
</ul>
</li>
<li><p>区分子类方法中重名的三种变量</p>
<ol>
<li>局部变量：直接写</li>
<li>本类的成员变量：this.成员变量名</li>
<li>父类的成员变量：super.成员变量名</li>
</ol>
</li>
<li><p>继承中成员方法的访问特点：</p>
<p>在父子类继承关系中，创建子类对象，访问成员方法的规则：创建的对象是谁，就优先用谁，没有则向上找</p>
</li>
<li><p>继承中方法的重写(覆盖&#x2F;覆写)：继承中方法的名称一样，参数列表也一样</p>
<ul>
<li><p>重写(override):方法名称、参数列表都一样；重载(Overload):方法名称一样、参数列表不一样</p>
</li>
<li><p>创建的子类对象，则优先用子类的方法</p>
</li>
<li><p>注意事项：</p>
<ul>
<li><p>必须保证父子类方法的名称相同，参数列表相同。</p>
<p><code>@Override</code>写在方法前面，用来检验是不是有效的正确覆盖重写（也可以不写）</p>
</li>
<li><p>子类方法的返回值必须小于等于父类方法的返回值范围（比如父类为object，子类可以为String）</p>
</li>
<li><p>子类方法的权限必须大于等于父类方法的权限修饰符</p>
<p>public &gt; protected &gt; (default) &gt; private   （default代表什么都不写）</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>设计原则：对于已经使用的类，尽量不去修改，而是写一个新类，即继承</p>
</li>
<li><p>继承中构造方法的访问特点：</p>
<ul>
<li><p>子类构造方法中有一个默认的super()调用，所以一定是先调用父类的构造，再调用子类的构造</p>
</li>
<li><p>子类构造方法必须调用父类的构造方法，不写则默认super()</p>
</li>
<li><p>子类构造可以通过super()关键字来调用父类重载构造</p>
</li>
<li><p>super的父类构造调用，必须是子类构造方法的第一个语句</p>
</li>
</ul>
</li>
<li><p>继承的三大特点：</p>
<ul>
<li>单继承：只有一个父类</li>
<li>多级继承</li>
<li>一个父类可以有多个子类</li>
</ul>
</li>
</ul>
<h4 id="5-2-super、this关键字"><a href="#5-2-super、this关键字" class="headerlink" title="5.2 super、this关键字"></a>5.2 super、this关键字</h4><ul>
<li><p>super关键字</p>
<ul>
<li>在子类的成员方法中，访问父类的成员变量</li>
<li>在子类的成员方法中，访问父类的成员方法</li>
<li>在子类的构造方法中，方法父类的构造方法</li>
</ul>
</li>
<li><p>this关键字</p>
<ul>
<li>在本类的成员方法中，访问本类的成员变量</li>
<li>在本类的成员方法中，访问本类另一个成员方法（不能是构造方法！）</li>
<li>在本类的构造方法中，访问本类的另一个构造方法（此时this的调用也必须是构造方法的第一个语句，所以super和this不能同时使用）</li>
</ul>
</li>
<li><p>super、this图解</p>
<p><img src="/TyporaImg/javaSE%E7%AC%94%E8%AE%B0.assets/image-20220707112203251.png" alt="image-20220707112203251"></p>
</li>
</ul>
<h4 id="5-3-抽象"><a href="#5-3-抽象" class="headerlink" title="5.3 抽象"></a>5.3 抽象</h4><ul>
<li><p>抽象方法：加上abstract关键字，然后去掉大括号，直接分号结束</p>
<p>抽象方法所在的类必须是抽象类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Animal</span>&#123;<span class="comment">//抽象类定义</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>;<span class="comment">//抽象方法定义</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">normalMethod</span><span class="params">()</span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>如何使用抽象方法：</p>
<ol>
<li>不能直接创建抽象类对象</li>
<li>必须用一个子类来继承抽象父类</li>
<li>覆盖重写(实现)：去掉abstract关键字，然后补上大括号</li>
<li>创建子类进行使用</li>
</ol>
</li>
<li><p>注意事项：</p>
<ul>
<li>抽象类不能直接创建对象</li>
<li>抽象类中可以有构造方法，初是提供子类创建对象时，始化父类成员使用的</li>
<li>抽象类中，不一定有抽象方法，但是有抽象方法的类必定是抽象类</li>
<li>抽象类的子类，必须重写抽象父类中所有的抽象方法，否则编译无法通过，否则该子类也是抽象类，也要用abstract修饰</li>
</ul>
</li>
<li><p><u><em>抽象练习：day0707&#x2F;MainRedPacket.java</em></u>：发红包案例</p>
</li>
</ul>
<h4 id="5-4-接口"><a href="#5-4-接口" class="headerlink" title="5.4 接口"></a>5.4 接口</h4><ul>
<li><p>接口：一种公共的规范标准，引用数据类型，最重要的内容就是其中的抽象方法</p>
</li>
<li><p>接口的定义:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> interface 接口名称&#123;</span><br><span class="line">    <span class="comment">//接口内容</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注：换成了关键字interface之后，编译生成的字节码文件仍然是：.java —&gt; .class</p>
<p>接口可以包含：</p>
<ol>
<li>常量(java 7)</li>
<li>抽象方法(java 7)</li>
<li>默认方法(java 8)</li>
<li>静态方法(java 8)</li>
<li>私有方法(java 9)</li>
</ol>
</li>
<li><p>接口的抽象方法定义</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> 返回值类型 方法名称(参数列表);</span><br></pre></td></tr></table></figure>

<p>注：修饰符必须是 public和abstract，这两者可以省略但不能改变</p>
</li>
<li><p>接口的使用：接口不能直接使用，必须有一个“实现类”来“实现”：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> class 实现类名称 implements 接口名称&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注：接口中的抽象方法必须全部覆盖重写，创建实现类对象再使用</p>
<p>​		若没有覆盖全部的抽象方法，则该类也必须为抽象方法</p>
</li>
<li><p>接口默认方法的定义与使用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">default</span> 返回值类型 方法名称(参数列表)&#123;</span><br><span class="line">    方法体;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注：接口中的默认方法可以解决接口升级的问题（当接口中新加了抽象方法后，之前定义的实现类还需要 一一更改，默认方法可以防止这样的情况产生）</p>
<ul>
<li>接口的默认方法可以通过接口的实现类直接调用</li>
<li>接口的默认方法也可以被接口的实现类覆盖重写</li>
</ul>
</li>
<li><p>接口静态方法的定义与使用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> 返回值类 方法名称(参数列表)&#123;</span><br><span class="line">    方法体;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注：</p>
<ul>
<li>不能通过接口实现类的对象来调用接口当中的静态方法</li>
<li>正确用法：通过接口的名称直接调用静态方法，格式：<code>接口名称.静态方法名(参数)</code></li>
</ul>
</li>
<li><p>接口私有方法的定义和使用</p>
<ul>
<li>普通私有方法：解决多个默认方法之间的重复代码问题</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> 返回值类型 方法名称(参数列表)&#123;</span><br><span class="line">    方法体;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>静态私有方法：解决多个静态方法之间的重复代码问题</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> 返回值类型 方法名称(参数列表)&#123;</span><br><span class="line">    方法体;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>接口常量的定义和使用</p>
<ul>
<li><p>定义:<code>public static final 数据类型 常量名称 = 数据值;</code></p>
</li>
<li><p>注:</p>
<ul>
<li>可以省略<code>public static final</code>但是不写效果也一样</li>
<li>必须进行赋值,且不可改</li>
<li>常量名称全用大写</li>
</ul>
</li>
</ul>
</li>
<li><p>接口使用注意事项:</p>
<ul>
<li>接口没有静态代码块或者构造方法</li>
<li>一个类的直接父类是唯一的,但是一个类可以同时实现多个接口</li>
</ul>
</li>
</ul>
<h4 id="5-5-继承父类并实现多个接口"><a href="#5-5-继承父类并实现多个接口" class="headerlink" title="5.5 继承父类并实现多个接口"></a>5.5 继承父类并实现多个接口</h4><ul>
<li>格式:</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> class 类名称 extends 父名称 implements 接口<span class="number">1</span>,接口<span class="number">2</span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>注:<ul>
<li>如果多个接口中出现了同名的抽象方法,则只需要重写一个就好了</li>
<li>如果实现类没有覆盖重写所有接口的所有抽象方法,则该类必须是抽象类</li>
<li>如果实现类所实现的多个接口中,存在重复的默认方法,则该实现类一定要对冲突的默认方法进行重写</li>
<li>一个类如果直接父类当中的方法和接口中的默认方法产生冲突,则优先用父类当中的方法</li>
</ul>
</li>
</ul>
<h4 id="5-6-接口之间的多继承"><a href="#5-6-接口之间的多继承" class="headerlink" title="5.6 接口之间的多继承"></a>5.6 接口之间的多继承</h4><ul>
<li><p>类与类单继承的,直接父类就一个;</p>
<p>类与接口之间是多实现的,一个类可以实现多个接口;</p>
<p>接口与接口之间是多继承的</p>
</li>
<li><p>多个父接口的方法重复,没关系</p>
<p>多个父接口的默认方法重复,那么子接口必须进行默认方法的覆盖重写,而且要带着default关键字</p>
</li>
</ul>
<h4 id="5-7-多态"><a href="#5-7-多态" class="headerlink" title="5.7 多态"></a>5.7 多态</h4><ul>
<li><p>指一个对象拥有多种形态</p>
</li>
<li><p>多态存在的三个必要条件：</p>
<ul>
<li>继承</li>
<li>重写</li>
<li>父类引用指向子类对象</li>
</ul>
</li>
<li><p>实现:extends或者implements实现是多态的前提</p>
</li>
<li><p>代码当中体现多态性:<strong>父类引用指向子类对象</strong> 格式:</p>
<p><code>父类名称 对象名 = new 子类名称();</code>(一只猫被当作动物来看待)</p>
<p>或者<code> 接口名称 对象名 = new 实现类名称();</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Fu</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Zi</span>();</span><br><span class="line">obj.Method();<span class="comment">//优先使用Zi中的Method(new什么优先用哪个),子类没有则向上找&lt;----前提：子类和父类都有Method这个方法，如果子类特有的方法则不能这样写，需要向下转型</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>多态中成员变量的使用:</p>
<ul>
<li>成员变量通过对象名称直接访问:看等号左边是谁,优先用谁,没有则向上找</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Fu</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Zi</span>();</span><br><span class="line">obj.num;<span class="comment">//优先使用Fu中的num,没有则向上找</span></span><br></pre></td></tr></table></figure>

<ul>
<li>成员变量通过成员方法间接访问:看该方法属于谁,优先用谁</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Fu</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Zi</span>();</span><br><span class="line">obj.shownum();<span class="comment">//优先使用Zi中的shownum()方法,没有则向上找</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>多态中成员方法的使用规则:</p>
<p>​			看new的是谁,则使用谁,没有则向上找,但是这个方法必须是子类和父类都有,若要使用子类特有的方法则需要向下转型.</p>
<ul>
<li><p><u>在这个引用变量f指向的对象中，他的成员变量和静态方法与父类是一致的，他的非静态方法，在编译时是与父类一致的，运行时却与子类一致（发生了复写）</u>(编译看左,运行看右)</p>
</li>
<li><blockquote>
<p><u><strong>就是说，方法和成员变量都用当作父类来用，如果子类有复写的方法则用子类的方法</strong></u></p>
</blockquote>
</li>
<li><p><strong>成员变量：</strong>编译看左边，运行还看左边。</p>
</li>
<li><p><strong>成员方法：</strong>编译看左边，运行看右边</p>
</li>
</ul>
</li>
<li><p>多态的好处</p>
</li>
<li><p>多态的弊端：无法使用子类特有的方法和属性</p>
</li>
</ul>
<h4 id="5-8-对象的转型"><a href="#5-8-对象的转型" class="headerlink" title="5.8 对象的转型"></a>5.8 对象的转型</h4><ul>
<li><p>向上转型:即多态的写法</p>
<p><code>父类名称 对象名 = new 子类名称();</code></p>
<p>含义:右侧创建一个子类对象,当作父类来使用(一只猫被当作动物来看待)</p>
<p>注:</p>
<ul>
<li>向上转型一定是安全的(小范围转向了大范围)</li>
</ul>
</li>
<li><p>向下转型:其实是一个还原的动作<br><code>子类名称 对象名 = (子类名称)父类对象</code>(将猫从动物还原为猫)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Animal</span> <span class="variable">animal</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cat</span>();</span><br><span class="line"><span class="type">Cat</span> <span class="variable">cat</span> <span class="operator">=</span> (Cat)animal;</span><br></pre></td></tr></table></figure>

<p>注:</p>
<ul>
<li>必须保证原来本来创建的时候是猫,才能向下转为猫</li>
<li>如果原来创建的时候不是猫,向下转为狗则为报错 ——-&gt; ClassCastException</li>
</ul>
</li>
<li><p>用instanceof关键字进行类型判断</p>
<p><code>对象 instanceof 类名称</code>(返回boolean)</p>
</li>
</ul>
<h4 id="5-9-接口多态练习"><a href="#5-9-接口多态练习" class="headerlink" title="5.9 接口多态练习"></a>5.9 接口多态练习</h4><p><u><em>接口多态练习：day0707&#x2F;Multi_Interface</em></u>：笔记本USB接口案例</p>
<p><img src="/TyporaImg/javaSE%E7%AC%94%E8%AE%B0.assets/image-20220707151954672.png" alt="image-20220707151954672"></p>
<h3 id="0708-六"><a href="#0708-六" class="headerlink" title="0708 六"></a>0708 六</h3><h4 id="6-1-final关键字"><a href="#6-1-final关键字" class="headerlink" title="6.1 final关键字"></a>6.1 final关键字</h4><ul>
<li><p>用法：</p>
<ol>
<li><p>修饰类 <code>public final class 类名&#123;&#125;</code></p>
<ul>
<li>不能有子类，所有的成员方法无法进行覆盖重写</li>
</ul>
</li>
<li><p>修饰方法 <code> public final 返回值类型 方法名()&#123;&#125;</code></p>
<ul>
<li>该方法不能被覆盖重写</li>
</ul>
</li>
<li><p>修饰局部变量 <code>final 变量类型 变量名;</code></p>
<ul>
<li>一次赋值，终生不变(如果为引用类型则是名字指向的地址值不变)</li>
</ul>
</li>
<li><p>修饰成员变量 <code>public final 变量名 = 值;</code></p>
<ul>
<li>由于成员变量会有默认值，所有一旦使用了final修饰，就必须手动赋值</li>
<li>对于final成员变量，要么直接赋值，要么通过构造方法赋值（只能使用一种）</li>
<li>若使用第二种方法，必须保证类中所有重载的构造方法会对final成员变量赋值</li>
</ul>
</li>
</ol>
</li>
<li><p>对于类和方法来说，fianl和abstract不能同时使用</p>
</li>
</ul>
<h4 id="6-2-四种权限修饰符"><a href="#6-2-四种权限修饰符" class="headerlink" title="6.2 四种权限修饰符"></a>6.2 四种权限修饰符</h4><table>
<thead>
<tr>
<th align="center"></th>
<th align="center">PUBLIC</th>
<th align="center">protected</th>
<th align="center">(default)</th>
<th align="center">private</th>
</tr>
</thead>
<tbody><tr>
<td align="center">同一个类</td>
<td align="center">1</td>
<td align="center">1</td>
<td align="center">1</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">同一个包</td>
<td align="center">1</td>
<td align="center">1</td>
<td align="center">1</td>
<td align="center">0</td>
</tr>
<tr>
<td align="center">不同包子类</td>
<td align="center">1</td>
<td align="center">1</td>
<td align="center">0</td>
<td align="center">0</td>
</tr>
<tr>
<td align="center">不同包非子类</td>
<td align="center">1</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
</tr>
</tbody></table>
<h4 id="6-3-内部类"><a href="#6-3-内部类" class="headerlink" title="6.3 内部类"></a>6.3 内部类</h4><p>​				一个事物内部包含另一个事物</p>
<ul>
<li><p>成员内部类</p>
<ul>
<li><p>定义格式</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">修饰符 class 外部类名称&#123;</span><br><span class="line">    修饰符 class 内部类&#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>注：内用外随意，外用内需要内部类对象</p>
</li>
<li><p>成员内部类的使用</p>
<ul>
<li>间接方式：在外部类中的方法中，使用内部类；然后main只是调用外部类方法</li>
<li>直接方式：<code>外部类名.内部类名 对象名 = new 外部类名().new 内部类名();</code></li>
</ul>
</li>
<li><p>内部类访问同名变量</p>
<p>​	<code>外部类名称.this.外部类成员变量</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Outer</span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Inner</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">methodInner</span><span class="params">()</span>&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">30</span>;</span><br><span class="line">            System.out.println(num);<span class="comment">//30</span></span><br><span class="line">            System.out.println(<span class="built_in">this</span>.num);<span class="comment">//20</span></span><br><span class="line">            System.out.println(Outer.<span class="built_in">this</span>.num);<span class="comment">//10</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>局部内部类（包含匿名内部类）（在方法里面）</p>
<ul>
<li><p>定义格式</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">修饰符 class 外部类名称&#123;</span><br><span class="line">    修饰符 返回值类型 外部类方法名称(参数列表)&#123;</span><br><span class="line">        class 局部内部类名称&#123;</span><br><span class="line">            <span class="comment">//...</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>局部内部类的final问题</p>
<ul>
<li><p>如果希望访问所在方法的局部变量，那么这个变量必须是有效final的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyOuter</span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">menthodOuter</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">10</span>;<span class="comment">//final可以不写，但要保证num不变</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">class</span> <span class="title class_">MyInnter</span>&#123;</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">methodinter</span><span class="params">()</span>&#123;</span><br><span class="line">                sout(num);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>注：从java 8开始，只要局部变量事实不变，那么final关键字可以省略</p>
</li>
<li><p>原因：</p>
<ol>
<li>new出来的对象在堆中</li>
<li>局部变量跟着方法走，在栈中 </li>
<li>方法运行结束后立刻出栈，局部变量立刻消失</li>
<li>但是new出来的对象在堆中持续存在直到垃圾回收</li>
</ol>
</li>
</ul>
</li>
</ul>
</li>
<li><p>定义一个类的时候，权限修饰符</p>
<ul>
<li>外部类：public&#x2F;(default)</li>
<li>成员内部类：所有</li>
<li>局部内部类：什么都不能写（和default不一样）</li>
</ul>
</li>
<li><p>匿名内部类：如果接口的实现类（或者是父类的子类，只需要使用唯一的一次，那么这种情况下就可以省略掉该类的定义，而改为使用匿名内部类</p>
<ul>
<li><p>定义格式：</p>
<ul>
<li><pre><code class="java">接口名称 对象名 = new 接口名称()&#123;
    //覆盖重写所有的抽象方法;
&#125;
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">```java</span><br><span class="line">public class test &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        MyInterface my = new MyInterface() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void method() &#123;</span><br><span class="line">                System.out.println(&quot;匿名内部类&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;//单独使用匿名内部类</span><br><span class="line">        </span><br><span class="line">        my.method();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">MyInterface</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;匿名内部类&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.method();<span class="comment">//匿名内部类和匿名对象一起使用</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
</li>
<li><p>注意：匿名内部类在创建对象的时候，只使用唯一的一次</p>
<p>​			匿名对象在调用方法的时候，只能使用一次</p>
<p>​			匿名内部类是省略了实现类&#x2F;子类名称，匿名对象是省略了对象名称</p>
</li>
</ul>
</li>
</ul>
<h4 id="6-4-类作为成员变量类型"><a href="#6-4-类作为成员变量类型" class="headerlink" title="6.4 类作为成员变量类型"></a>6.4 类作为成员变量类型</h4><h4 id="6-5-接口作为成员变量类型、方法的参数或返回值"><a href="#6-5-接口作为成员变量类型、方法的参数或返回值" class="headerlink" title="6.5 接口作为成员变量类型、方法的参数或返回值"></a>6.5 接口作为成员变量类型、方法的参数或返回值</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DEMO</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//左边接口名称，右边实现类，这就是多态写法</span></span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        List&lt;String&gt; result = addNames(list);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; result.size(); i++) &#123;</span><br><span class="line">            System.out.println(result.get(i));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title function_">addNames</span><span class="params">(List&lt;String&gt; list)</span> &#123;</span><br><span class="line">        list.add(<span class="string">&quot;1111&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="0711-七-常用类"><a href="#0711-七-常用类" class="headerlink" title="0711 七 常用类"></a>0711 七 常用类</h3><h4 id="7-1-Object类"><a href="#7-1-Object类" class="headerlink" title="7.1 Object类"></a>7.1 Object类</h4><ul>
<li><p>java.lang.Object</p>
<p>Object是类层次结构的根（父）类</p>
<p>每个类都使用Object作为父类</p>
<p>所有对象都实现这个类的方法</p>
</li>
<li><p>toString()方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">       <span class="keyword">return</span> getClass().getName() + <span class="string">&quot;@&quot;</span> + Integer.toHexString(hashCode());</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>equals()方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object obj)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="built_in">this</span> == obj);<span class="comment">//谁调用了equals方法，谁就是this</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>基本数据类型比较的是值，引用数据类型比较的是地址</p>
<p>重写eqals方法，问题：</p>
<ul>
<li><p>隐含一个多态，无法使用子类特有的内容（方法和属性）<code>Object ob = new Person(&quot;张三&quot;, 19);</code></p>
</li>
<li><p>解决方法：使用向下转型，将Object转为Person</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object obj)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(obj == <span class="built_in">this</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;<span class="comment">//提高效率</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(obj == <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//提高效率</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//Person p = (Person)obj;//直接转换有风险</span></span><br><span class="line">    <span class="keyword">if</span>(obj <span class="keyword">instanceof</span> Person)&#123;</span><br><span class="line">        <span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> (Person)obj;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">b</span> <span class="operator">=</span> <span class="built_in">this</span>.name.eauqls(p.name) &amp;&amp; <span class="built_in">this</span>.age.equals(p.age);</span><br><span class="line">    	<span class="keyword">return</span> b;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h4 id="7-2-Date类"><a href="#7-2-Date类" class="headerlink" title="7.2 Date类"></a>7.2 Date类</h4><p>java.util.Date：表示日期和时间</p>
<p>时间原点：1970.1.1 00:00:00</p>
<p>DateFormat：格式化的日期的抽象类（抽象类），作用：格式化和解析日期</p>
<ul>
<li><p>DateFormat为抽象类，无法直接创建，需要使用它的子类</p>
</li>
<li><p>SimpleDateFormat的构造方法：&#96;&#96;SimpleDateFormat(String pattern)<code> </code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">SimpleDateFormat</span> <span class="variable">sdf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd HH-mm-ss&quot;</span>);</span><br><span class="line"><span class="type">Date</span> <span class="variable">date</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">date</span>();</span><br><span class="line"><span class="type">String</span> <span class="variable">d</span> <span class="operator">=</span> sdf.format(date);</span><br><span class="line">sout(d);</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="7-3-Calendar类"><a href="#7-3-Calendar类" class="headerlink" title="7.3 Calendar类"></a>7.3 Calendar类</h4><p>java.util.Calendar类不能直接创建使用（抽象类），里面提供了很多操作日历字段的方法</p>
<p>里面有一个静态方法叫getInstance()，该方法返回了一个Calendar类的子类对象</p>
<p><code>static Calendar getInstance()</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Calendar</span> <span class="variable">c</span> <span class="operator">=</span> Calendar.getInstance();<span class="comment">//多态</span></span><br><span class="line">sout(c);</span><br></pre></td></tr></table></figure>

<p>常用方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">get</span><span class="params">(<span class="type">int</span> field)</span>;<span class="comment">//返回给定的日历字段值</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(ine field, <span class="type">int</span> value)</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> field, <span class="type">int</span> amount()</span>);<span class="comment">//增加或者减少指定的时间量</span></span><br><span class="line"><span class="keyword">public</span> Date <span class="title function_">getTime</span><span class="params">()</span>;<span class="comment">//日历转换为日期</span></span><br></pre></td></tr></table></figure>

<h4 id="7-4-System类"><a href="#7-4-System类" class="headerlink" title="7.4 System类"></a>7.4 System类</h4><p> (java.lang包下无需导包，直接使用)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">long</span> <span class="title function_">currentTimeMillis</span><span class="params">()</span>;<span class="comment">//返回以毫秒为单位的时间，用于测试程序效率</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">arraycopy</span><span class="params">(Object src, <span class="type">int</span> srcPos, Object dest, <span class="type">int</span> destPos, <span class="type">int</span> length)</span>;<span class="comment">//从指定的源数组中复制一个数组，开始在指定的位置，到目标数组的指定位置。 </span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="7-5-StringBuilder的原理"><a href="#7-5-StringBuilder的原理" class="headerlink" title="7.5 StringBuilder的原理"></a>7.5 StringBuilder的原理</h4><ul>
<li><p>java.lang.StringBuilder</p>
</li>
<li><p>在内存中始终是一个数组，占用空间少，效率高，如果超出了StringBuilder的容量，会自动扩容	</p>
</li>
<li><p>构造方法：</p>
<p><code>StringBuilder()</code>：构造一个不带任何字符的字符串生成器，初始容量为16字符</p>
<p><code>StringBuilder(String str)</code></p>
</li>
<li><p>方法</p>
<p><code>public StringBuilder append()</code>：添加数据，返回的是this，即调用对象的地址，所以以后调用的时候直接.append()使用即可</p>
<p><u>链式编程：方法返回值是一个对象，可以继续调用</u></p>
<p><code>public String toString()</code>：将当前的StringBuilder对象转换为String对象</p>
</li>
</ul>
<h4 id="7-6-包装类"><a href="#7-6-包装类" class="headerlink" title="7.6 包装类"></a>7.6 包装类</h4><ul>
<li><p>基本数据类型使用很方便，但是没有对应的方法去操作这些基本数据类，可以使用一个类把基本数据类型装起来，通过其中的一些方法去操作这些数据</p>
</li>
<li><p><img src="/TyporaImg/javaSE%E7%AC%94%E8%AE%B0.assets/image-20220711121509756.png" alt="image-20220711121509756"></p>
</li>
<li><p>装箱与拆箱：基本数据类型和包装类的转换</p>
</li>
<li><p>自动拆箱与装箱：自动的转换</p>
<p><code>Integer in = 1; in = in + 2;//相当于in = in.intValue() + 2</code></p>
</li>
<li><p>字符串的转换</p>
<p><img src="/TyporaImg/javaSE%E7%AC%94%E8%AE%B0.assets/image-20220711122357509.png" alt="image-20220711122357509"></p>
</li>
</ul>
<h4 id="7-7-Collection集合"><a href="#7-7-Collection集合" class="headerlink" title="7.7 Collection集合"></a>7.7 Collection集合</h4><p>java.uitl.Collection	</p>
<p><img src="/TyporaImg/javaSE%E7%AC%94%E8%AE%B0.assets/image-20220711135040955.png" alt="image-20220711135040955"></p>
<ul>
<li><p>共性的方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">boolean</span><span class="params">()</span> add(E e);</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">clear</span><span class="params">()</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">remove</span><span class="params">(E e)</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">contains</span><span class="params">(E e)</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span>;</span><br><span class="line"><span class="keyword">public</span> Object[] toArray();<span class="comment">//把集合中的元素储存到数组中</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="7-8-Iterator迭代器"><a href="#7-8-Iterator迭代器" class="headerlink" title="7.8 Iterator迭代器"></a>7.8 Iterator迭代器</h4><ul>
<li><p>java.uitl.Iterator</p>
</li>
<li><p>（接口）对集合进行遍历</p>
</li>
<li><p>常用方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span> <span class="comment">//如果仍有元素可以迭代，则返回true</span></span><br><span class="line">E <span class="title function_">next</span><span class="params">()</span> <span class="comment">//返回迭代的下一个元素</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>Iterator迭代器是一个接口，不能直接使用，需要使用Iterator接口实现的对象，获取实现类的方式比较特殊</p>
<p>Collection接口中有一个方法：<code>iterator()</code>返回的就是迭代器</p>
<ul>
<li><code>Iterator&lt;E&gt; iterator </code>返回在此collection的元素上进行迭代的迭代器</li>
</ul>
</li>
<li><p>使用步骤</p>
<ol>
<li>使用集合中的方法iterator()获取迭代器的实现类对象，使用Iterator接口接收（多态）</li>
<li>使用Iterator接口中的方法hasNext判断还有没有元素</li>
<li>使用Iterator接口中的方法next取出集合的下一个元素</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Collection&lt;String&gt; coll = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">coll.add(<span class="string">&quot;张三&quot;</span>);</span><br><span class="line">coll.add(<span class="string">&quot;李四&quot;</span>);</span><br><span class="line">coll.add(<span class="string">&quot;王五&quot;</span>);</span><br><span class="line">coll.add(<span class="string">&quot;赵六&quot;</span>);</span><br><span class="line"></span><br><span class="line">Iterator&lt;String&gt; it = coll.iterator();</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(it.hasNext())&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">e</span> <span class="operator">=</span> it.next();</span><br><span class="line">    sout(e);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(Iterator&lt;String&gt; it2 = coll.iterator; it2.hasNext();)&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">e</span> <span class="operator">=</span> it.next();</span><br><span class="line">    sout(e);</span><br><span class="line">&#125;<span class="comment">//用的少</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>迭代器实现原理</p>
</li>
</ul>
<h4 id="7-9-增强for循环"><a href="#7-9-增强for循环" class="headerlink" title="7.9 增强for循环"></a>7.9 增强for循环</h4><ul>
<li><p>底层也是迭代器，只是使用了for循环的格式简化了迭代器的书写（jdk1.5以后）</p>
<p><code>Collection&lt;E&gt; extends Iterator&lt;E&gt;</code>：所有单列集合都可以使用增强for</p>
<p><code>public interface Iterable&lt;T&gt;</code>实现这个接口允许对象成为“foreach”语句的目标</p>
</li>
<li><p>格式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(集合/数组的数据类型 变量名: 集合/数组名)&#123;</span><br><span class="line">	<span class="comment">//操作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">list.add(...)</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">for</span>(String s:list)&#123;</span><br><span class="line">    sout(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="7-10-泛型"><a href="#7-10-泛型" class="headerlink" title="7.10 泛型"></a>7.10 泛型</h4><ul>
<li><p>一种未知的数据类型，当我们不知道使用什么数据类型的时候，就可以使用泛型，</p>
<p>泛型也可以看出是一个变量，用来接收数据类型</p>
<p>​		E e ：Element 元素</p>
<p>​		T t ：Type 类型</p>
</li>
<li><p>好处：</p>
<ul>
<li>避免了数据转换的麻烦：不适用泛型，里面存储的数据默认都是是Object类（多态），假如要使用String类特有的方法，则需要向下转型</li>
<li>把运行期的异常，提升到了编译期（写代码的时候会报错）</li>
</ul>
</li>
<li><p>弊端：泛型是什么类型，只能存储什么类型的数据</p>
</li>
</ul>
<h4 id="7-11-定义含有泛型的类、方法、接口"><a href="#7-11-定义含有泛型的类、方法、接口" class="headerlink" title="7.11 定义含有泛型的类、方法、接口"></a>7.11 定义含有泛型的类、方法、接口</h4><ul>
<li><p>不写泛型默认是Object类型</p>
</li>
<li><p>类：<code>修饰符 class 类名&lt;代表泛型的变量&gt;&#123;&#125;</code></p>
</li>
<li><p>方法：<code>修饰符 &lt;泛型&gt; 返回值类型 方法名(参数列表(使用泛型))&#123;方法体&#125;</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;M&gt; <span class="keyword">void</span> <span class="title function_">method</span><span class="params">(M m)</span>&#123;</span><br><span class="line">    <span class="comment">//方法体</span></span><br><span class="line">&#125;<span class="comment">//传递什么数据类型，泛型就是什么类型</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;M&gt; <span class="keyword">void</span> <span class="title function_">method</span><span class="params">(M m)</span>&#123;<span class="comment">//含有泛型的静态方法</span></span><br><span class="line">    <span class="comment">//方法体</span></span><br><span class="line">&#125;<span class="comment">//传递什么数据类型，泛型就是什么类型</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>接口：<code>public interface 接口名&lt;泛型&gt;&#123;&#125;</code></p>
</li>
<li><p>泛型通配符&lt;?&gt; ：代表任意的数据类型</p>
<ul>
<li><p><strong>不能创建对象使用，只能作为方法的参数使用</strong> </p>
</li>
<li><p>比如定义一个方法遍历所有类型的ArrayList集合，这个时候不知道ArrayList集合使用什么数据类型，可以使用泛型的通配符？来接收数据</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">printArray</span><span class="params">(ArrayList&lt;?&gt; list)</span>&#123;</span><br><span class="line">        <span class="type">Iterator</span> <span class="variable">iterator</span> <span class="operator">=</span> list.iterator();</span><br><span class="line">        <span class="keyword">while</span>(iterator.hasNext())&#123;</span><br><span class="line">            System.out.println(iterator.next());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>泛型的上限、下限限定（能看懂就好了）</p>
<ul>
<li><p>? extends  E：表示使用的泛型只能是E类型的子类&#x2F;本身</p>
</li>
<li><p>? super E：表示使用的泛型只能是E类型的父类&#x2F;本身</p>
<p><img src="/TyporaImg/javaSE%E7%AC%94%E8%AE%B0.assets/image-20220711145917957.png" alt="image-20220711145917957"></p>
</li>
</ul>
</li>
</ul>
<h4 id="7-12-斗地主案例"><a href="#7-12-斗地主案例" class="headerlink" title="7.12 斗地主案例"></a>7.12 斗地主案例</h4><p><u><em>综合练习：day0711&#x2F;Fight_The_Landlord</em></u>：斗地主案例</p>
<h3 id="0712-八-数据结构、常用集合"><a href="#0712-八-数据结构、常用集合" class="headerlink" title="0712 八 数据结构、常用集合"></a>0712 八 数据结构、常用集合</h3><h4 id="8-1-数据结构"><a href="#8-1-数据结构" class="headerlink" title="8.1 数据结构"></a>8.1 数据结构</h4><ol>
<li><p>栈：先进后出</p>
</li>
<li><p>队列：先进先出</p>
</li>
<li><p>数组：查询快，增删慢</p>
<ul>
<li><p>查询快：数组的地址是连续的，可以通过数组的首地址找到数组，通过索引快速找到某一个原色</p>
</li>
<li><p>增删慢：数组的长度是固定的，想要增删一个元素，必须创建一个新的数组，把源数组的数据复制过来</p>
</li>
</ul>
</li>
<li><p>链表：查询慢，增删快</p>
<ul>
<li><p>链表中每个元素称为一个节点，每个节点包含了一个数据源（存储数组）和两个指针（存储自己的地址和下一个节点的地址）</p>
</li>
<li><p>查询慢：链表中的地址不是连续的，每次查询都必须从头开始查询</p>
</li>
<li><p>增删快：链表中增删一个元素对链表的整体结构没有影响</p>
</li>
<li><p>分类：</p>
<ul>
<li><p>单向链表：只有一条链，不能保证元素的顺序</p>
</li>
<li><p>双向链表：两条链子，有一条用来记录元素的顺序，是一个有序集合</p>
<p><img src="/TyporaImg/javaSE%E7%AC%94%E8%AE%B0.assets/image-20220712111543206.png" alt="image-20220712111543206"></p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>红黑树：</p>
<ul>
<li><p>二叉树：分支不超过两个</p>
</li>
<li><p>排序数&#x2F;查找树：在二叉树的基础上，元素是有大小顺序的，特点：左子树小，右子树大</p>
</li>
<li><p>平衡树与不平衡树：左孩子和右孩子相等与不相等</p>
</li>
<li><p>红黑树：特点：趋于平衡树，查询的速度非常快，查询叶子节点最大次数和最小次数不能超过2倍</p>
<p>约束：</p>
<ul>
<li>节点可以是红色或者黑色</li>
<li>根节点是黑色的</li>
<li>叶子节点（空节点）是黑色的</li>
<li>每个红色的节点的子节点都是黑色的</li>
<li>任何一个节点到其每一个叶子节点的所有路径上黑色节点数相同</li>
</ul>
</li>
</ul>
</li>
</ol>
<h4 id="8-2-List集合"><a href="#8-2-List集合" class="headerlink" title="8.2 List集合"></a>8.2 <strong>List集合</strong></h4><ul>
<li><p>java.util.list接口 extends Collection接口</p>
</li>
<li><p>特点：</p>
<ul>
<li>有序的集合，存取元素顺序一致（存123，取123）</li>
<li>有索引，包含了一些带索引的方法</li>
<li>允许存储重复的元素</li>
</ul>
</li>
<li><p>list接口中带索引的方法（特有）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> index, E element)</span>;</span><br><span class="line"><span class="keyword">public</span> E <span class="title function_">get</span><span class="params">(<span class="type">int</span> index)</span>;</span><br><span class="line"><span class="keyword">public</span> E <span class="title function_">remove</span><span class="params">(<span class="type">int</span> index)</span>;</span><br><span class="line"><span class="keyword">public</span> E <span class="title function_">set</span><span class="params">(<span class="type">int</span> index, E element)</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建一个list集合对象，多态：<code>List&lt;String&gt; list = new ArrayList&lt;&gt;();</code></p>
</li>
</ul>
<h4 id="8-3-ArrayList集合"><a href="#8-3-ArrayList集合" class="headerlink" title="8.3 ArrayList集合"></a>8.3 <strong>ArrayList集合</strong></h4><ul>
<li>List接口的数组结构实现</li>
<li>底层数组结构，查询快，增删慢</li>
</ul>
<h4 id="8-4-LinkedList集合"><a href="#8-4-LinkedList集合" class="headerlink" title="8.4 LinkedList集合"></a>8.4 LinkedList集合</h4><ul>
<li><p>List接口的链表列表实现</p>
</li>
<li><p>底层链表结构，查询慢，增删快</p>
</li>
<li><p>里面包含了大量操作首尾元素的方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addFirst</span><span class="params">(E e)</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addLast</span><span class="params">(E e)</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(E e)</span>;<span class="comment">//将元素推入此列表所表示的堆栈</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> E <span class="title function_">getFirst</span><span class="params">()</span>;</span><br><span class="line"><span class="keyword">public</span> E <span class="title function_">getLast</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> E <span class="title function_">removeFirst</span><span class="params">()</span>;</span><br><span class="line"><span class="keyword">public</span> E <span class="title function_">removeLast</span><span class="params">()</span>;</span><br><span class="line"><span class="keyword">public</span> E <span class="title function_">pop</span><span class="params">()</span>;<span class="comment">//从此列表所表示的堆栈处弹出一个元素</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="8-5-Vector集合"><a href="#8-5-Vector集合" class="headerlink" title="8.5 Vector集合"></a>8.5 Vector集合</h4><ul>
<li>可实现可增长的对象数组，即底层也是数组结构，后面被ArrayList取代了</li>
</ul>
<h4 id="8-6-Set集合"><a href="#8-6-Set集合" class="headerlink" title="8.6 Set集合"></a>8.6 Set集合</h4><ul>
<li><p>继承了Collection接口</p>
</li>
<li><p>特点：1.不允许重复元素；2.无索引没有带索引的方法，也不能使用普通的for循环遍历（用迭代器、增强for）</p>
</li>
<li><p>Set集合不允许重复的原理:（前提必须重写hashCode方法和equals方法）</p>
<p>Set集合调用add方法的时候，add会调用元素的hashCode方法和equals方法，判断元素是否重复</p>
<p>先判断有无相同的哈希值，没有则直接存储，有则调用equals方法和哈希值相同元素进行判断，相同则不存储</p>
<p><img src="/TyporaImg/javaSE%E7%AC%94%E8%AE%B0.assets/image-20220712123114894.png" alt="image-20220712123114894"></p>
</li>
</ul>
<h4 id="8-7-HashSet集合"><a href="#8-7-HashSet集合" class="headerlink" title="8.7 HashSet集合"></a>8.7 HashSet集合</h4><ul>
<li><p>Set接口的实现</p>
</li>
<li><p>特点：不重复；无索引；无序；底层是一个哈希表结构（查询快）</p>
</li>
<li><p>哈希值：一个十进制整数，由系统随机给出（对象的地址值，是一个逻辑值，是模拟出来得到地址，不是数据实际存储的物理地址）</p>
<p>获取：Object类中有一个<code>public native int hashCode()</code>（native表示该方法调用的是本地操作系统的方法）</p>
</li>
<li><p>HashSet集合存储数据的结构（哈希表）：</p>
<ul>
<li>jdk1.8之前哈希表 &#x3D; 数组+链表；1.8之后为数组+红黑树（提高查询速度）</li>
<li>数组结构：把元素分组（哈希值相同的为一组），再用链表&#x2F;红黑树把相同哈希值的元素连接到一起</li>
</ul>
</li>
<li><p>注：</p>
<ul>
<li>先用链表，如果链表长度超过8个，则用红黑树</li>
</ul>
</li>
<li><p>HashSet存储自定义类型元素</p>
<ul>
<li>必须重写HashCode和equals方法 &lt;–8.6有说</li>
</ul>
</li>
</ul>
<h4 id="8-8-LinkedHashSet集合"><a href="#8-8-LinkedHashSet集合" class="headerlink" title="8.8 LinkedHashSet集合"></a>8.8 LinkedHashSet集合</h4><ul>
<li>继承了HashSet</li>
<li>底层是哈希表（数组+链表&#x2F;红黑树） + 链表：多了一条链表（记录链表存储顺序），保证元素顺序</li>
<li>特点：有序（因为多了一条链表）</li>
</ul>
<h4 id="8-9-可变参数"><a href="#8-9-可变参数" class="headerlink" title="8.9 可变参数"></a>8.9 可变参数</h4><ul>
<li>JDK1.5之后</li>
<li>前提：参数列表类型确定，个数不确定</li>
<li>格式：<code>修饰符 返回值类型 方法名(数据类型...变量名)&#123;&#125;</code></li>
<li>原理：可变参数底层是一个数组，根据传参不同，创建不同长度的数组，来存储这些数据，传递的参数可以是0,1,2…</li>
<li>注意：<ul>
<li>一个方法的可变参数只能有一个 <code>public void method(Sting...a, int...b)是错误的</code></li>
<li>多个方法参数，那么可变参数必须写在参数列表末尾</li>
</ul>
</li>
</ul>
<h4 id="8-10-Collections集合工具类"><a href="#8-10-Collections集合工具类" class="headerlink" title="8.10 Collections集合工具类"></a>8.10 Collections集合工具类</h4><ul>
<li><p>java.utils.Collections集合工具类，用于操作集合，常用方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="type">boolean</span> <span class="title function_">addAll</span><span class="params">(Collections&lt;T&gt; c, T...elements)</span>;<span class="comment">//往集合加元素</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">shuffle</span><span class="params">(list&lt;?&gt; list)</span>;<span class="comment">//打乱顺序</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(List&lt;T&gt; list)</span>;<span class="comment">//默认规则排序（升序）</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(List&lt;T&gt; list, Comparator&lt;? <span class="built_in">super</span> T&gt;)</span>;<span class="comment">//指定规则排序（方便）</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">Collections.allAll(list, <span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>);</span><br><span class="line">Collections.shuffle(list);</span><br></pre></td></tr></table></figure>
</li>
<li><p>注：</p>
<ul>
<li>使用sort默认排序，被排序的集合里面存储元素，必须实现Comparable，重写接口中的方法compareTo定义排序规则</li>
<li>Comparator和Comparable区别<ul>
<li>Comparable：自己(this)和别人(参数)比较，自己需要实现Comparable接口,重写比较的规则compareTo方法</li>
<li>Comparator：相当于找一个第三方的裁判进行比较</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="8-11-Map集合"><a href="#8-11-Map集合" class="headerlink" title="8.11 Map集合"></a>8.11 Map集合</h4><ul>
<li><p>接口Map&lt;K, V&gt; – 两个泛型，一个元素包含两个值,键和值，故叫双列集合</p>
</li>
<li><p>一个映射不能包含重复的键，一个键最多一个值，通过键找到对应的值（键不能重复，值可以）</p>
</li>
<li><p>常用方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">put</span><span class="params">(K key, V value)</span>;<span class="comment">//放入键值对。注：返回值V当key不重复，返回null，当key重复，使用新的value替换原来的value，并返回原来的value</span></span><br><span class="line"><span class="keyword">public</span> V <span class="title function_">remove</span><span class="params">(Object key)</span>;<span class="comment">//删键值对</span></span><br><span class="line"><span class="keyword">public</span> V <span class="title function_">get</span><span class="params">(Object key)</span>;</span><br><span class="line"><span class="type">boolean</span> <span class="title function_">containsKey</span><span class="params">(Object key)</span>;</span><br><span class="line"><span class="keyword">public</span> Set&lt;K&gt; <span class="title function_">keySet</span><span class="params">()</span>;<span class="comment">//获取所有的键存储在Set中</span></span><br><span class="line"><span class="keyword">public</span> Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet();<span class="comment">//获取Map集合中所有的键值对对象的集合（Set集合）</span></span><br></pre></td></tr></table></figure>

<p>注：Map.Entry&lt;K,V&gt;:在map接口中有一个内部接口Entry</p>
<p>​		作用：在Map集合创建的时候会在Map集合中创建在一个Entry对象，用来记录键与值</p>
</li>
<li><p>遍历Map集合</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用keySet(),entrySet()方法</span></span><br><span class="line"><span class="comment">//通过keySet()，也就是键</span></span><br><span class="line">Set&lt;String&gt; set = map.keySet();</span><br><span class="line">Iterator&lt;String&gt; it = set.iterator();</span><br><span class="line"><span class="keyword">while</span>(it.hasNext())&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> it.next();</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">value</span> <span class="operator">=</span> map.get(key);</span><br><span class="line">&#125;<span class="comment">//用增强for也可以</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//通过entrySet方法</span></span><br><span class="line">Set&lt;Map.Entry&lt;String, Integer&gt;&gt; set = map.entrySet();</span><br><span class="line"><span class="keyword">for</span>(Map.Entry&lt;String, Integer&gt; entry:set)&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> entry.getKey();</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">value</span> <span class="operator">=</span> entry.getValue();</span><br><span class="line">&#125;<span class="comment">//也可用迭代器</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="8-12-HashMap"><a href="#8-12-HashMap" class="headerlink" title="8.12 HashMap"></a>8.12 HashMap</h4><ul>
<li>无序，key不重复</li>
<li>底层是哈希表，查询快。JDK1.8之前为数组+单向链表，JDK1.8之后为数组+单向链表&#x2F;红黑树</li>
<li>也有一个类似与LinkedHashSet的LinkedHashMap子类（有序）</li>
<li>HashMap存储自定义数据类型<ul>
<li>保证key是唯一的，所以要重写key的hashCode和eqauls方法</li>
</ul>
</li>
</ul>
<h4 id="8-13-Hashtable"><a href="#8-13-Hashtable" class="headerlink" title="8.13 Hashtable&lt;K, V&gt;"></a>8.13 Hashtable&lt;K, V&gt;</h4><ul>
<li>不允许存储null（之前的集合都可以存储null）</li>
<li>单线程，速度慢</li>
<li>和Vector一样，后面被HashMap取代</li>
<li>其子类Properties依然使用较多（IO流中）</li>
</ul>
<h4 id="8-14-JDK9对集合添加的优化"><a href="#8-14-JDK9对集合添加的优化" class="headerlink" title="8.14 JDK9对集合添加的优化"></a>8.14 JDK9对集合添加的优化</h4><ul>
<li><p>List Set Map接口添加了一个静态方法of，一次性添加多个元素</p>
<p><code>static &lt;E&gt; list of(E...elements)</code></p>
</li>
<li><p>注：</p>
<ul>
<li>只适用于List Set Map接口，不适用于接口的实现类</li>
<li>of方法返回一个不可变的集合，集合不能再使用add，put方法添加元素，会抛出异常</li>
<li>Set接口和Map接口调用of方法的时候，不能有重复的元素</li>
</ul>
</li>
</ul>
<h4 id="8-15-练习"><a href="#8-15-练习" class="headerlink" title="8.15 练习"></a>8.15 练习</h4><ol>
<li><u><em>练习：day0712&#x2F;CalEachWordNum</em></u>：统计一个字符串中每个字符出现次数</li>
<li><u><em>练习：day0712&#x2F;Fight_The_Landlord_pro</em></u>：斗地主案例（对牌进行了排序）</li>
</ol>
<h3 id="0714-九-异常、线程"><a href="#0714-九-异常、线程" class="headerlink" title="0714 九 异常、线程"></a>0714 九 异常、线程</h3><h4 id="9-1-异常"><a href="#9-1-异常" class="headerlink" title="9.1 异常"></a>9.1 异常</h4><ul>
<li><p>程序在执行过程中，出现的非正常现象</p>
</li>
<li><p>异常的根类为Java.lang.Throwable，下面有两个子类Error和Exception</p>
</li>
<li><p>Exception：编译器异常，（写代码）java程序出现的问题</p>
<ul>
<li>RuntimeException：运行期异常</li>
</ul>
</li>
<li><p>Error：错误。必须修改源代码</p>
</li>
<li><p>异常产生过程解析</p>
<p><img src="/TyporaImg/javaSE%E7%AC%94%E8%AE%B0.assets/image-20220714112238211.png" alt="image-20220714112238211"></p>
</li>
</ul>
<h4 id="9-2-异常处理的关键字"><a href="#9-2-异常处理的关键字" class="headerlink" title="9.2 异常处理的关键字"></a>9.2 异常处理的关键字</h4><ul>
<li><p>throw关键字：在指定的方法中抛出指定的异常</p>
<p>格式：<code>throw new xxxException(&quot;异常产生的原因&quot;)</code></p>
<p>注：</p>
<ul>
<li>throw必须写在方法内部</li>
<li>throw后面new的对象必须是Exception或者Exception的子类对象</li>
<li>throw后抛出的指定异常对象，必须处理这个异常对象<ul>
<li>throw关键字后面创建的是RuntimeException及其子对象，可以不处理，默认给JVM处理（打印并中断）</li>
<li>throw关键字后面创建的是编译异常，就必须处理，用throws或者try…catch</li>
</ul>
</li>
</ul>
</li>
<li><p>throws关键字：当方法内部抛出异常对象的时候，可以使用throws处理，会把异常对象声明抛出给方法的调用者(自己不处理，交给别人处理)，最终交给JVM处理–&gt;中断处理</p>
<ul>
<li><p>格式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">修饰符 返回值类型 方法名(参数列表) <span class="keyword">throws</span> AAAException,BBBException...&#123;</span><br><span class="line">	<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">AAAException</span>(<span class="string">&quot;...&quot;</span>);</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BBBException</span>(<span class="string">&quot;...&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>注：</p>
<ul>
<li>throws必须写在方法声明处</li>
<li>throws关键字后面声明的异常必须是Exception或者其子类</li>
<li>方法内部如果抛出了多个异常对象，那么throws后边必须也声明多个异常，如果是父子关系，明父类即可</li>
</ul>
</li>
</ul>
</li>
<li><p>try…catch与finally</p>
<ul>
<li><p>格式</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    <span class="comment">//可能产生的代码</span></span><br><span class="line">&#125;<span class="keyword">catch</span>(定义一个异常变量用于接收)&#123;</span><br><span class="line">    <span class="comment">//异常的处理逻辑</span></span><br><span class="line">    <span class="comment">//一般会写到工作日志中</span></span><br><span class="line">&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">    <span class="comment">//无论怎么样都会执行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>注</p>
<ul>
<li>try中可能会抛出多个异常对象，可以用多个catch（子类必须写在父类上面）</li>
<li>finally 不能单独使用，得和try一起</li>
<li>finally一般用于资源的释放（资源回收）</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="9-3-Throwable类中的三个处理异常方法"><a href="#9-3-Throwable类中的三个处理异常方法" class="headerlink" title="9.3 Throwable类中的三个处理异常方法"></a>9.3 Throwable类中的三个处理异常方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">getMessage</span><span class="params">()</span>;<span class="comment">//返回该Throwable的简短描述</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printStackTrace</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure>

<h4 id="9-4-子类父类异常"><a href="#9-4-子类父类异常" class="headerlink" title="9.4 子类父类异常"></a>9.4 子类父类异常</h4><ul>
<li>如果父类抛出了多个异常，子类重写方法的时候，抛出和父类相同的异常或者是父类异常的子类或者不抛</li>
<li>父类方法没有异常，子类重写父类方法也不可以抛出异常，此时子类产生异常只能捕获处理不能声明抛出</li>
<li>父亲异常时什么样，子类异常就什么样</li>
</ul>
<h4 id="9-5-自定义异常类"><a href="#9-5-自定义异常类" class="headerlink" title="9.5 自定义异常类"></a>9.5 自定义异常类</h4><ul>
<li><p>java提供的异常类，不够我们自己使用，需要自己定义一些异常类</p>
</li>
<li><p>格式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">XXXException</span> <span class="keyword">extends</span> <span class="title class_">Exception</span>|RuntimeException&#123;</span><br><span class="line">   <span class="comment">//添加一个空参数方法</span></span><br><span class="line">   <span class="comment">//添加一个带异常信息的构造方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>注：</p>
<ul>
<li>一般以Exception结尾</li>
<li>必须继承Exception或者RuntimeException，前者必须throws或者try catch，后面可以不处理</li>
</ul>
</li>
</ul>
<h4 id="9-6-并发与并行"><a href="#9-6-并发与并行" class="headerlink" title="9.6 并发与并行"></a>9.6 并发与并行</h4><ul>
<li><p>并发：两个或多个事件在同一个时间段内发生</p>
</li>
<li><p>并行：两个或多个事情在同一时刻发生（同时）</p>
</li>
<li><p>并行速度快</p>
</li>
</ul>
<h4 id="9-7-进程与线程"><a href="#9-7-进程与线程" class="headerlink" title="9.7 进程与线程"></a>9.7 进程与线程</h4><ul>
<li><p>指一个内存中运行的应用程序，每个进程都有一个独立的空间，一个应用程序可以同时运行多个进程；进程是程序的一次执行过程，是系统运行过程中的基本单位；系统运行一个程序是一个进程从创建运行到死亡的过程</p>
</li>
<li><p>线程：线程是进程中的一个执行单元，负责当前进程中程序的执行，一个进程中至少又一个线程，一个程序中可以有多个线程，这样的程序被称为多线程程序</p>
<p><img src="/TyporaImg/javaSE%E7%AC%94%E8%AE%B0.assets/image-20220714130606307.png" alt="image-20220714130606307"></p>
</li>
<li><p>线程调度</p>
<ul>
<li>分时调度</li>
<li>抢占调度</li>
</ul>
</li>
</ul>
<h4 id="9-8-线程类Thread"><a href="#9-8-线程类Thread" class="headerlink" title="9.8 线程类Thread"></a>9.8 线程类Thread</h4><ul>
<li><p>创建</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//第一种方式：创建Thread类 java.lang.Thread</span></span><br><span class="line"><span class="comment">/*步骤</span></span><br><span class="line"><span class="comment">	创建Thread类；</span></span><br><span class="line"><span class="comment">	重写Thread类种的run方法，设置线程任务</span></span><br><span class="line"><span class="comment">	创建Thread类的子类对象</span></span><br><span class="line"><span class="comment">	调用Thread类的方法start方法，开启新的线程，执行run方法</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//内容</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//主方法中</span></span><br><span class="line"><span class="type">MyThread</span> <span class="variable">mt</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>();</span><br><span class="line">mt.start();</span><br><span class="line"></span><br><span class="line"><span class="comment">//第二种方式：实现Runnable接口，然后重写run()方法，然后作为参数在Thread方法执行</span></span><br><span class="line"><span class="comment">//java.lang.Thread类的构造方法</span></span><br><span class="line"><span class="comment">//	Thread(Runnable target) 分配新的Thread对象</span></span><br><span class="line"><span class="comment">//  Thread(Runnable target, String name)</span></span><br><span class="line"><span class="comment">/*步骤</span></span><br><span class="line"><span class="comment">	创建Runnable接口的实现类</span></span><br><span class="line"><span class="comment">	重写run方法，设置线程任务</span></span><br><span class="line"><span class="comment">	创建Runnable接口实现类对象</span></span><br><span class="line"><span class="comment">	创建Thread类对象，构造方法中传递Runnable接口的实现类对象</span></span><br><span class="line"><span class="comment">	调用Thread类中start方法</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RunnableImpl</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//内容</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//主方法中</span></span><br><span class="line"><span class="type">RunnableImpl</span> <span class="variable">run</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RunnableImpl</span>();</span><br><span class="line"><span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(run);</span><br><span class="line">t.start();</span><br></pre></td></tr></table></figure>
</li>
<li><p>Thread和Runnable的区别（实现Runnable的好处）</p>
<ul>
<li><p>Runnable避免了单继承的局限性，可以继承其他的类，实现其他的接口</p>
</li>
<li><p>增强了程序的扩展性，降低程序的耦合性</p>
<p>​	实现Runnable接口的方式，把设置线程任务和开启线程进行了分离（解耦）</p>
<p>​	实现类中，重写了run方法：用来设置任务</p>
<p>​	创建Thread类对象，调用start方法：用来开启多线程</p>
</li>
</ul>
</li>
<li><p>多线程的随机执行过程</p>
<p><img src="/TyporaImg/javaSE%E7%AC%94%E8%AE%B0.assets/image-20220714134240389.png" alt="image-20220714134240389"></p>
</li>
<li><p>多线程的内存图解</p>
<p><img src="/TyporaImg/javaSE%E7%AC%94%E8%AE%B0.assets/image-20220714134556723.png" alt="image-20220714134556723"></p>
</li>
<li><p>常用方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span>; <span class="comment">//返回线程名称</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Thread <span class="title function_">currentThread</span><span class="params">()</span>; <span class="comment">//返回对当前正在执行的线程对象的引用</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span>; <span class="comment">//设置名称</span></span><br><span class="line">Thread(String name);<span class="comment">//也可以通过构造方法直接设置</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sleep</span><span class="params">(<span class="type">long</span> millis)</span>;<span class="comment">//当前的进程以指定的毫秒暂停，之后再继续执行</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>匿名内部类实现线程的创建</p>
<ul>
<li><p>格式</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//匿名内部类格式</span></span><br><span class="line"><span class="keyword">new</span> 父类/接口()&#123;</span><br><span class="line">    重复父类/接口中的方法</span><br><span class="line">&#125;；</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>()&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//线程任务</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;.start();</span><br><span class="line"></span><br><span class="line"><span class="comment">//方式2</span></span><br><span class="line"><span class="type">Runnable</span> <span class="variable">r</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Runnable</span>()&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//线程任务</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;<span class="comment">//(多态写法，接口=实现类)</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(r).start();</span><br><span class="line"></span><br><span class="line"><span class="comment">//简化方式2</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>()&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//线程任务</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;).start();</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h4 id="9-9-线程安全问题"><a href="#9-9-线程安全问题" class="headerlink" title="9.9 线程安全问题"></a>9.9 线程安全问题</h4><p><img src="/TyporaImg/javaSE%E7%AC%94%E8%AE%B0.assets/image-20220714143918835.png" alt="image-20220714143918835"></p>
<ul>
<li><p>解决方法一：同步代码块</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(同步锁)&#123;</span><br><span class="line">    <span class="comment">//需要同步操作的代码，即可能出现线程安全问题的代码(访问了共享数据的代码)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过代码块中的锁对象，可以使用任意的对象</p>
<p>但是必须保证多个线程使用的锁是同一个</p>
<p>锁对象作用：锁住同步代码块，只让一个线程在同步代码块中执行</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RunnableImpl</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">ticked</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">    <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();<span class="comment">//创建一个锁对象</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (obj)&#123;</span><br><span class="line">                <span class="comment">//判断是否有票</span></span><br><span class="line">                <span class="keyword">if</span>(ticked &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">10</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">                    &#125;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot;正在卖第&quot;</span> + ticked + <span class="string">&quot;张票&quot;</span>);</span><br><span class="line">                    ticked--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//主程序</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">RunnableImpl</span> <span class="variable">run</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RunnableImpl</span>();</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t0</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(run);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(run);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(run);</span><br><span class="line"></span><br><span class="line">        t0.start();</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>同步代码块原理</p>
<p><img src="/TyporaImg/javaSE%E7%AC%94%E8%AE%B0.assets/image-20220714150021020.png" alt="image-20220714150021020"></p>
</li>
<li><p>解决方法二：同步方法</p>
<p>步骤：</p>
<ul>
<li>把访问了共享数据的代码抽取，放到一个方法中</li>
<li>在方法上添加synchronized修饰符 <code>修饰符 synchronized 返回值类型 方法名(参数列表)&#123;&#125;</code></li>
</ul>
</li>
<li><p>静态同步方法</p>
<ul>
<li>锁对象不能是this（this是创建对象后产生的，静态方法优先于对象）</li>
<li>静态方法的锁对象是本类的class属性 ——&gt; .class文件对象(反射)</li>
</ul>
</li>
<li><p>解决方法三：Lock锁</p>
<ul>
<li><p>java.util.concurrent.locks.lock接口</p>
</li>
<li><p>lock接口实现了比synchronized方法和语句更广泛的锁定操作</p>
</li>
<li><p>方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span>;<span class="comment">//获取锁</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span>;<span class="comment">//释放锁</span></span><br></pre></td></tr></table></figure>

<p>java.util.concurrent.locks.Reentrantlock implements lock</p>
</li>
<li><p>使用步骤</p>
<ol>
<li>在成员位置创建一个Reentrantlock对象</li>
<li>在可能会出现安全问题的代码前调用lock()方法</li>
<li>在可能会出现安全问题的代码后调用unlock()方法</li>
</ol>
</li>
</ul>
</li>
</ul>
<h3 id="0715-十-线程池、Lambda表达式"><a href="#0715-十-线程池、Lambda表达式" class="headerlink" title="0715 十 线程池、Lambda表达式"></a>0715 十 线程池、Lambda表达式</h3><h4 id="10-1-线程间通信"><a href="#10-1-线程间通信" class="headerlink" title="10.1 线程间通信"></a>10.1 线程间通信</h4><ul>
<li><p>也叫等待唤醒机制：多个线程处理一个资源，处理的动作不一样，就存在线程之间的通信</p>
</li>
<li><p>为什么要处理线程之间的通信：多线程并发执行的时候，在默认的情况下CPU是随机切换线程的，当我需要多个线程处理一个任务的时候，并且希望他们有规律的执行，那么多线程之间则需要通信（即解决线程对同一个变量的使用和操作）</p>
</li>
<li><p>等待唤醒机制的三个方法：</p>
<ol>
<li>wait：线程不在活动，不去竞争锁，进入wait set集合中，因此不会浪费CPU资源，此时线程的状态是WAITING</li>
<li>notify：选取所通知对象的wait set中的一个线程释放</li>
<li>notifyAll：释放所通知对象的wait set上全部的线程</li>
</ol>
<p>注：</p>
<ol>
<li>wait和notify方法必须要同一个锁对象调用，因为对应的锁对象可以通过notify唤醒使用同一个锁对象调用的wait方法后的线程</li>
<li>wait方法和notify方法是属于Object类的方法</li>
<li>wait方法和notify方法必须在同步代码块或者同步函数中使用，因为必须要通过锁对象调用这两个方法</li>
<li>调用obj.wait()会立即释放锁，以便其他线程可以执行obj.notify()，但是notify()不会立刻释放sycronized（obj）中的obj锁，必须要等notify()所在线程执行完synchronized（obj）块中的所有代码才会释放这把锁.</li>
</ol>
</li>
<li><p><img src="/TyporaImg/javaSE%E7%AC%94%E8%AE%B0.assets/image-20220715120026498.png" alt="image-20220715120026498"></p>
<p><u><em>等待唤醒机制练习：day0715&#x2F;wakeUp</em></u>：生成包子吃包子案例</p>
</li>
</ul>
<p>​		</p>
<h4 id="10-2-线程状态"><a href="#10-2-线程状态" class="headerlink" title="10.2 线程状态"></a>10.2 线程状态</h4><ul>
<li><p>阻塞状态BLOCKED：具有cpu的执行资格，等待cpu空闲执行</p>
</li>
<li><p>休眠状态TIME_WAITING：放弃cpu 的执行资格，cpu空闲也不执行</p>
</li>
<li><p>运行状态RUNNING</p>
</li>
<li><p>死亡状态TERMINATED</p>
</li>
<li><p>等待状态WAITING</p>
<p><img src="/TyporaImg/javaSE%E7%AC%94%E8%AE%B0.assets/image-20220715125651889.png" alt="image-20220715125651889"></p>
</li>
<li><p>注：进入到TimeWaiting(计时等待)有两种方式</p>
<ul>
<li>sleep(long m)方法在毫秒值结束之后，线程睡醒进入Runnable&#x2F;Blocked状态</li>
<li>wait(long m),wait在毫秒值结束后，还没有被notify唤醒，就自动醒来进入Runnable&#x2F;Blocked状态</li>
</ul>
</li>
</ul>
<h4 id="10-3-线程池"><a href="#10-3-线程池" class="headerlink" title="10.3 线程池"></a>10.3 线程池</h4><ul>
<li><p>概念：一个容纳多个线程的容器，其中的线程可以反复利用，省去了频繁创建线程对象的操作而避免了创建线程消耗过多的资源</p>
</li>
<li><p>线程池：容器–&gt;(ArrayList,Hashset,LinkedList<Thread>,HashMap)第三个最好 </p>
</li>
<li><p>当程序第一次启动的时候，创建多个线程，保存到一个集合中，当想要使用的时候，就可以从集合中取出线程<code>Thread t = list.remove(o);//返回的是被移除的元素</code></p>
<p><code>Thread t = linked.remove(o);</code></p>
</li>
<li><p>当使用完毕，归还线程</p>
<p><code>list.add(t);</code></p>
<p><code>linked.addList(t);</code></p>
</li>
<li><p>JDK1.5之后，JDK就内置了线程池，我们可以直接使用</p>
</li>
</ul>
<h4 id="10-4-线程池的代码实现"><a href="#10-4-线程池的代码实现" class="headerlink" title="10.4 线程池的代码实现"></a>10.4 线程池的代码实现</h4><ul>
<li><p>JDK1.5后：java.util.concurrent.Executors</p>
<p><code> static ExecutorService newFixedThreadPool(int nThreads);//生产指定线程数量的线程池</code></p>
<p>返回值：java.util.concurrent.ExecutorService 接口，返回的是ExecutorService接口的实现类对象，我们可以使用ExecutorService 接口接收（面向接口的编程）</p>
<p>其中有两个方法：</p>
<p><code> Future&lt;?&gt; submit(Runnable task);//提交执行一个Runnable任务并返回一个表示该任务的未来</code> </p>
<p><code>void shutdown();//关闭/销毁线程池的方法</code></p>
</li>
<li><p>线程池使用步骤：</p>
<ol>
<li>使用线程池的工厂类Executors里面提供的静态方法newFixedThreadPool生成指定数量的线程池</li>
<li>创建一个类，实现Runnable，重写run方法，设置线程任务</li>
<li>调用ExecutorService 中的方法submit，传递线程任务（实现类），开启线程，执行run方法</li>
<li>调用ExecutorService 中的方法shutdown，销毁线程池（不建议使用）</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">executorService</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">2</span>);</span><br><span class="line">        executorService.submit(<span class="keyword">new</span> <span class="title class_">RunnableImpl</span>());</span><br><span class="line">        executorService.submit(<span class="keyword">new</span> <span class="title class_">RunnableImpl</span>());</span><br><span class="line">        executorService.submit(<span class="keyword">new</span> <span class="title class_">RunnableImpl</span>());</span><br><span class="line">        executorService.submit(<span class="keyword">new</span> <span class="title class_">RunnableImpl</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RunnableImpl</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*输出：</span></span><br><span class="line"><span class="comment">pool-1-thread-1</span></span><br><span class="line"><span class="comment">pool-1-thread-2</span></span><br><span class="line"><span class="comment">pool-1-thread-1</span></span><br><span class="line"><span class="comment">pool-1-thread-2</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="10-5-函数式编程思想"><a href="#10-5-函数式编程思想" class="headerlink" title="10.5 函数式编程思想"></a>10.5 函数式编程思想</h4><ul>
<li>面向对象的思想：做一个事情，找一个能解决这个事情的对象，调用对象的方法完成事情</li>
<li>面向编程的思想：只要获取结果，怎么做的不重要，重视结果不重视过程</li>
<li>冗余的Runnable代码</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 冗余的Runnable代码</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DemoRunnable</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">RunnableImpl</span> <span class="variable">run</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RunnableImpl</span>();</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(run);</span><br><span class="line">        t.start();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//简化：使用匿名内部类,省去了定义RunnableImpl实现类</span></span><br><span class="line">        <span class="type">Runnable</span> <span class="variable">r</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;new Runnable&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(r).start();]</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//继续简化</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;new Runnable&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="10-6-Lambda表达式"><a href="#10-6-Lambda表达式" class="headerlink" title="10.6 Lambda表达式"></a>10.6 Lambda表达式</h4><ul>
<li><p>JDK1.8</p>
</li>
<li><pre><code class="java">public class LambdaDemo &#123;

    public static void main(String[] args) &#123;
        //使用匿名内部类的方法实现
        new Thread(new Runnable() &#123;
            @Override
            public void run() &#123;
                System.out.println(&quot;new Runnable&quot;);
            &#125;
        &#125;).start();

        //使用Lambda表达式实现多线程
        new Thread(()-&gt;&#123;
            System.out.println(&quot;new Runnable&quot;);
        &#125;
        ).start();
    &#125;
&#125;
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- Runnable接口中只有一个run方法的定义：`public abstract void run();`</span><br><span class="line"></span><br><span class="line">  制定了一种做事情的方案（函数）：</span><br><span class="line"></span><br><span class="line">  - 无参数</span><br><span class="line">  - 无返回值</span><br><span class="line">  - 代码块</span><br><span class="line"></span><br><span class="line">  同样的语义在Lambda语法中更简单：`() -&gt; System.out.println(&quot;new Runnable&quot;);  `</span><br><span class="line"></span><br><span class="line">- Lambda表达式的标准格式由三部分：</span><br><span class="line"></span><br><span class="line">  - 一些参数</span><br><span class="line"></span><br><span class="line">  - 一个箭头</span><br><span class="line"></span><br><span class="line">  - 一段代码</span><br><span class="line"></span><br><span class="line">​					`(参数列表) -&gt; &#123;一些重写方法的代码块&#125;`    </span><br><span class="line"></span><br><span class="line">​					注：()是接口中抽象方法的参数列表，没有参数就空着；有参数就写出参数，多个参数用逗号分隔</span><br><span class="line"></span><br><span class="line">​							-&gt;是传递参数的意思</span><br><span class="line"></span><br><span class="line">- ```java</span><br><span class="line">  public interface Cook()&#123;</span><br><span class="line">      public abstract void makefood();</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  punlic class Main()&#123;</span><br><span class="line">      public static void main(String[] args) &#123;</span><br><span class="line">          //使用invokeCook方法，参数为Cook接口，传递Cook接口的匿名内部类对象</span><br><span class="line">          invokeCook(new Cook()&#123;</span><br><span class="line">              @Override</span><br><span class="line">              public void makefood()&#123;</span><br><span class="line">                  System.out.println(&quot;吃饭&quot;);</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;);</span><br><span class="line">          </span><br><span class="line">          //使用Lambda表达式，调用invoke方法，参数是Cook接口，传递Cook接口的匿名内部类对象</span><br><span class="line">          invokeCook(()-&gt;&#123;</span><br><span class="line">              System.out.println(&quot;吃饭&quot;);</span><br><span class="line">          &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      public static void invokeCook(Cook cook)&#123;</span><br><span class="line">          cook.makefood();</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
<li><p><u><em>Lambda表达式练习：day0715&#x2F;LambdaTest</em></u>：使用数组存储多个Person对象，对数组中的Person对象使用Arrays的sort方法通过年龄升序排序</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Person[] arr = &#123;</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;jack&quot;</span>, <span class="number">19</span>),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;mack&quot;</span>, <span class="number">17</span>),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;rose&quot;</span>, <span class="number">18</span>),</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//对数组中的Person对象进行升序排序</span></span><br><span class="line">        Arrays.sort(arr, <span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;Person&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Person o1, Person o2)</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> o1.getAge()-o2.getAge();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Person person : arr) &#123;</span><br><span class="line">            System.out.println(person.toString());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//使用Lambda表达式简化匿名内部类</span></span><br><span class="line">        Arrays.sort(arr,(Person o1, Person o2)-&gt;&#123;</span><br><span class="line">            <span class="keyword">return</span> o1.getAge()-o2.getAge();</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">for</span> (Person person : arr) &#123;</span><br><span class="line">            System.out.println(person.toString());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><u><em>Lambda表达式练习2：day0715&#x2F;LambdaTest&#x2F;DemoInvokeCalc.java</em></u>：给定一个计算器Calculator接口，内含抽象方法calc可以将两个int</p>
<p>数字相加得到和</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DemoInvokeCalc</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        invoke(<span class="number">3</span>, <span class="number">4</span>, <span class="keyword">new</span> <span class="title class_">Calculator</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">calc</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> a+b;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"><span class="comment">//使用Lambda表达式</span></span><br><span class="line">        invoke(<span class="number">3</span>, <span class="number">4</span>, (<span class="type">int</span> a, <span class="type">int</span> b) -&gt;&#123;</span><br><span class="line">            <span class="keyword">return</span> a+b;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">invoke</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, Calculator cal)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> cal.calc(a, b);</span><br><span class="line">        System.out.println(result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="10-7-使用Lambda的前提"><a href="#10-7-使用Lambda的前提" class="headerlink" title="10.7 使用Lambda的前提"></a>10.7 使用Lambda的前提</h4><ul>
<li><p>Lambda表达式是可推导可省略的：凡是根据上下文可以推导出来的内容都可以省略</p>
</li>
<li><p>可以省略的内容：</p>
<ul>
<li><p>(参数列表)：括号中的参数列表的数据类型可以省略不写</p>
</li>
<li><p>(参数列表)：括号中的参数只有一个，那么类型和（）都可以省略不写 </p>
</li>
<li><p>(一些代码)：如果{}中的代码只有一行，无论是否有返回值，都可以省略（{}，return，分号）</p>
<p>注：要省略就一起省略</p>
<p><code>new Thread(()-&gt;System.out.println(&quot;new Runnable&quot;).start();</code></p>
</li>
</ul>
</li>
<li><p>使用前提：</p>
<ul>
<li>使用Lambda必须具有接口，且要求接口中有且仅有一个抽象方法</li>
<li>使用Lambda必须具有上下文推断，也就是方法的参数或局部变量类型必须为Lambda对应的接口类型，才能使用Lambda作为该接口的实例。</li>
</ul>
</li>
</ul>
<h3 id="0718-十一-流"><a href="#0718-十一-流" class="headerlink" title="0718 十一 流"></a>0718 十一 流</h3><h4 id="11-1-File类"><a href="#11-1-File类" class="headerlink" title="11.1 File类"></a>11.1 File类</h4><ul>
<li><p>java.io.file：文件和目录路径名的抽象表示形式</p>
<p>Java把电脑中的文件和文件夹封装为一个File类，可以使用File类对他们进行操作</p>
<p>File类是与系统无关的类，任何操作系统都可以使用</p>
</li>
<li><p>三个单词： file、directory、path</p>
</li>
<li><p>File的静态成员变量</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> String pathSeparator;<span class="comment">//系统依赖路径分隔符的字符，表示为方便的字符串</span></span><br><span class="line"><span class="keyword">static</span> <span class="type">char</span> pathSeparatorChar;<span class="comment">//系统依赖路径分隔符的字符</span></span><br><span class="line"><span class="comment">// 路径分隔符windows:分号 linux:冒号</span></span><br><span class="line"><span class="keyword">static</span> String separator;<span class="comment">//系统依赖的默认名称分隔符字符，表示为方便的字符串</span></span><br><span class="line"><span class="keyword">static</span> <span class="type">char</span> separatorChar; <span class="comment">//系统依赖的默认名称分隔符字符</span></span><br><span class="line"><span class="comment">//文件分隔符 windows:反斜杠/ linux:正斜杠/</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>绝对路径和相对路径</p>
<ul>
<li><p>绝对路径是以盘符开始的完整的路径</p>
</li>
<li><p>相对路径是相对于当前项目的根目录</p>
</li>
<li><p>注：不区分大小写；路径中文件名分隔符windows为反斜杠，反斜杠为转转义字符，两个普通的反斜杠代表一个反斜杠</p>
<p><code>C://Users//ManYile</code></p>
</li>
</ul>
</li>
<li><p>File类的构造方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">File(String pathname);<span class="comment">//通过将给定的路径名的字符串转换成一个抽象路径名创建一个新的 File实例</span></span><br><span class="line">File(File parent, String child);<span class="comment">//创建从一个家长的抽象路径名和一个孩子的路径字符串的新 File实例</span></span><br><span class="line">File(String parent, String child);<span class="comment">//创建从父路径名的字符串和一个孩子的一个新的 File实例文件。</span></span><br><span class="line">File(URI uri);<span class="comment">//通过将给定的 file: URI到一个抽象路径名创建一个新的 File实例。 </span></span><br></pre></td></tr></table></figure>

<p>注：</p>
<ul>
<li>pathname可以是以文件或者文件夹结尾</li>
<li>可以是相对路径&#x2F;绝对路径</li>
<li>可以是存在，也可以是不存在</li>
<li>创建File对象，只是把字符串路径封装为File对象，不考虑路径存在真假情况</li>
</ul>
</li>
<li><p>File类的常用方法</p>
<ul>
<li><p>获取的方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">getAbsolutePath</span><span class="params">()</span>;<span class="comment">//获取绝对路径</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">getPath</span><span class="params">()</span>;<span class="comment">//将此File转换为路径名字符串，绝对就是绝对，相对就是相对</span></span><br><span class="line"><span class="comment">//File类的toString方法用的就是getPath()</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span>;<span class="comment">//将此</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">long</span> <span class="title function_">length</span><span class="params">()</span>;<span class="comment">//返回此File表示的文件长度，以字节为单位，不能获取文件夹大小（文件夹没有大小），若不存在则返回0</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>判断的方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">exists</span><span class="params">()</span>;<span class="comment">//目录是否存在</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isDirectory</span><span class="params">()</span>;<span class="comment">//是否为目录</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isFile</span><span class="params">()</span>;<span class="comment">//是否为文件夹</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>创建删除功能</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">createNewFile</span><span class="params">()</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">delete</span><span class="params">()</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">mkdir</span><span class="params">()</span>;<span class="comment">//创建由此File表示的目录</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">mkdirs</span><span class="params">()</span>;<span class="comment">//创建由此File表示的目录，包括任何必须但不存在的父目录 </span></span><br></pre></td></tr></table></figure>
</li>
<li><p>File类的遍历（文件夹）功能</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String[] list();<span class="comment">//返回一个String数组，表示该File目录中所有的子文件或者目录</span></span><br><span class="line"><span class="keyword">public</span> File[] listFiles();<span class="comment">//返回一个File数组，表示所有的子文件或者目录</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h4 id="11-2-递归"><a href="#11-2-递归" class="headerlink" title="11.2 递归"></a>11.2 递归</h4><ul>
<li>注：<ul>
<li>构造方法禁止递归</li>
<li>递归不宜太多或者无法跳出，否则会导致栈内存溢出</li>
</ul>
</li>
<li><u><em>递归练习：day0718&#x2F;SearchJava.java</em></u>：搜索D盘的.java文件</li>
</ul>
<h4 id="11-3-FileFilter过滤器"><a href="#11-3-FileFilter过滤器" class="headerlink" title="11.3 FileFilter过滤器"></a>11.3 FileFilter过滤器</h4><ul>
<li><p>java.io.FileFilter接口：用于抽象路径名（File对象）的过滤器</p>
</li>
<li><p>抽象方法：用来过滤文件</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="title function_">accept</span><span class="params">(File pathname)</span>;<span class="comment">//测试指定抽象路径名是否应该包含在某个路径名列表中</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="11-4-FileNameFilter"><a href="#11-4-FileNameFilter" class="headerlink" title="11.4 FileNameFilter"></a>11.4 FileNameFilter</h4><ul>
<li><p>java.io.FileNameFilter接口</p>
</li>
<li><p>抽象方法：用于过滤文件</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="title function_">accept</span><span class="params">(File dir, String name)</span>;<span class="comment">//测试文件是否包含在某一文件夹中</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>注：两个过滤器没有实现类，我们需要自己重写实现类，重写accept方法，自己定义规则</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">File[] file = dir.listFiles(<span class="keyword">new</span> <span class="title class_">FileFilter</span>()&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">accept</span><span class="params">(File pathname)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> pathname.isDirectory() || pathname.getName().toLowerCase().endWith(<span class="string">&quot;.java&quot;</span>);<span class="comment">//返回以java结尾的文件</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//lambda</span></span><br><span class="line">File[] file = dir.listFiles(() -&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> pathname.isDirectory() ||pathname.getName().toLowerCase().endWith(<span class="string">&quot;.java&quot;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="11-5-字节流"><a href="#11-5-字节流" class="headerlink" title="11.5 字节流"></a>11.5 字节流</h4><ul>
<li><p>IO：input output</p>
</li>
<li><p>一切皆为字节</p>
</li>
<li><p>字节输出流：OutputStream，一切输出流的父类，是一个抽象类，已知直接子类：</p>
<p>ByteArrayOutputStream，FileOutputStream，FilterOutputStream，ObjectOutputStream，OutputStream，PipedOutputStream </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">flush</span><span class="params">()</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">write</span><span class="params">(<span class="type">byte</span>[] b)</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">write</span><span class="params">(<span class="type">byte</span>[] b, <span class="type">int</span> off, <span class="type">int</span> len)</span>;<span class="comment">//写字节数组的一部分,off为开始索引,len为长度</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">write</span><span class="params">(<span class="type">int</span> b)</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>FileOutputStream</p>
<ul>
<li><p>构造方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">FileOutputStream(String name);</span><br><span class="line">FileOutputStream(File file);</span><br><span class="line">FileOutputStream(String name, <span class="type">boolean</span> append);</span><br><span class="line">FileOutputStream(File name, <span class="type">boolean</span> append);<span class="comment">//第三第四个为追加写</span></span><br><span class="line"><span class="comment">//append为true则不会覆盖，为flase则会覆盖</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>构造方法作用</p>
<ul>
<li>创建一个FileOutputStream对象</li>
<li>会根据构造方法中传递的文件&#x2F;文件路径，创建一个空的文件</li>
<li>会把FileOutputStream对象指向创建好的文件</li>
</ul>
</li>
</ul>
</li>
<li><p>写入数据的原理</p>
<ul>
<li>java程序 -&gt; JVM(java虚拟机) -&gt; OS系统 -&gt; os调用写数据的方法 -&gt; 把数据写入到文件</li>
</ul>
</li>
<li><p>字节输出流的使用步骤</p>
<ol>
<li><p>创建一个FileOutputStream对象，构造方法中传递输入数据目的地</p>
</li>
<li><p>调用FileOutputStream对象方法中的write，写入数据</p>
</li>
<li><p>释放资源（流会占用内存）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">FileOutputStream</span> <span class="variable">fos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;D//a.txt&quot;</span>);</span><br><span class="line">fos.wirte(<span class="number">97</span>);</span><br><span class="line">fos.close();</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><p>一次写多个字节的方法 <code>public void write(byte[] b);</code></p>
<ul>
<li>如果第一个字节为正数（0-127），则显示的时候会查询ASCII表</li>
<li>如果为负数，则第一个字节会和第二个字节，两个字节组成一个中文显示，查询系统默认码表（GBK）</li>
</ul>
</li>
<li><p>写入字符的方法：使用String类中的 <code>byte[] getBytes()</code>将字符串转换为字节数组，然后再输入</p>
</li>
<li><p>字节输出流的续写和换行</p>
<ul>
<li>续写：（第3第4中构造方法）</li>
<li>换行：写换行符号 windows：&#x2F;r&#x2F;n     linux：&#x2F;n       mac:：&#x2F;r     <code>fos.write(&quot;/r/n&quot;.getBytes())</code></li>
</ul>
</li>
<li><p>字节输入流：InputStream ，同OutputSteam</p>
<p>   子类：AudioInputStream，ByteArrayInputStream，FileInputStream，FilterInputStream，InputStream， ObjectInputStream，PipedInputStream，SequenceInputStream，StringBufferInputStream </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">read</span><span class="params">()</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">read</span><span class="params">(<span class="type">byte</span>[] b)</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>FileInputStream：文件字节输入流</p>
<ul>
<li><p>构造方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">FileInputStream(String name);</span><br><span class="line">FileInputStream(File file);</span><br></pre></td></tr></table></figure>
</li>
<li><p>作用类似于FileOutputStream构造方法</p>
</li>
</ul>
</li>
<li><p>读取数据原理与FileOutputStream相似</p>
</li>
<li><p>字节输入流的使用步骤</p>
<ol>
<li>创建一个FileInputStream对象，绑定要读取的数据源</li>
<li>调用FileInputStream对象方法中的read，读取数据</li>
<li>释放资源（流会占用内存）</li>
</ol>
</li>
<li><p>读取文件，while循环</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>((len = fis.read()) != -<span class="number">1</span>)&#123;</span><br><span class="line">    sout(<span class="type">char</span>(len));<span class="comment">//读取文件里面的字节用char表示</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>一次读取多个字节：<code>public int read(byte[] b);</code></p>
<p>注：方法参数byte[]的作用为起到缓冲作用，存储每次读取到的多个字节，数组长度一般定义为1024的整数倍；</p>
<p>​		方法返回值int 是每次读取的有效字节数</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">byte</span>[] bytes = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line"><span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>((len = fis.read(bytes)) != -<span class="number">1</span>)&#123;</span><br><span class="line">    sout(<span class="keyword">new</span> <span class="title class_">String</span>(bytes));<span class="comment">//这样会有很多空格（因为长度为1024，而文件可能没有这么多字节</span></span><br><span class="line">    sout(<span class="keyword">new</span> <span class="title class_">String</span>(bytes, <span class="number">0</span>, len));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
<li><p>String类的构造方法： <code>String(bytes[] bytes):将bytes数组转为String</code>和 <code>String(bytes[] bytes, int off, int length)</code></p>
</li>
</ul>
<p><u><em>字节流练习：day0718&#x2F;Stream.java</em></u>：复制文件</p>
<h4 id="11-6-字符流"><a href="#11-6-字符流" class="headerlink" title="11.6 字符流"></a>11.6 字符流</h4><ul>
<li><p>字节流的缺点：使用字节流读取文件，1个中文在GBK中占两个字节，在UFT-8占用3个字节</p>
</li>
<li><p>字符输入流：java.io.Reader，是字符输入流最顶层的父类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">read</span><span class="params">()</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">read</span><span class="params">(<span class="type">char</span>[] cbuf)</span>;<span class="comment">//一次读取多个字符</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>FileReader：文件字符输入流</p>
<ul>
<li><p><code>FileReader extends InputStreamReader extends Reader</code>	</p>
</li>
<li><p>构造方法： <code>FileReader(String name);FileReader(File file);</code></p>
</li>
<li><p>使用步骤：同字节输出流</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">FileReader</span> <span class="variable">fr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="string">&quot;文件位置&quot;</span>);</span><br><span class="line"><span class="comment">//一个字符一个字符的读取</span></span><br><span class="line"><span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>((len = fr.read()) != -<span class="number">1</span>)&#123;</span><br><span class="line">    sout(<span class="type">char</span>(len));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//以字符数组读取</span></span><br><span class="line"><span class="type">char</span>[] cs = <span class="keyword">new</span> <span class="title class_">char</span>[<span class="number">1024</span>];</span><br><span class="line"><span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>((len = fr.read(cs)) != -<span class="number">1</span>)&#123;</span><br><span class="line">    sout(<span class="keyword">new</span> <span class="title class_">String</span>(cs, <span class="number">0</span>, len));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fr.close();</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>字符输出流：java.io.Writer，是字符输出流最顶层的父类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">write</span><span class="params">(<span class="type">int</span> c)</span>;<span class="comment">//写入单个单词</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">wirte</span><span class="params">(<span class="type">char</span>[] cbuf)</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">write</span><span class="params">(<span class="type">char</span>[] cbuf, <span class="type">int</span> off, <span class="type">int</span> len)</span>; </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">wirte</span><span class="params">(String str)</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">wirte</span><span class="params">(String str, <span class="type">int</span> off, <span class="type">int</span> len)</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">flush</span><span class="params">()</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>FileWriter：FileWriter extends OutputStreamWriter extends Writer</p>
<ul>
<li><p>构造方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">FileWriter(File file);</span><br><span class="line">FileWriter(String name);</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用步骤</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">FileWriter</span> <span class="variable">fw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileWriter</span>(name);</span><br><span class="line">fw.write(<span class="number">97</span>);</span><br><span class="line">fw.flush();<span class="comment">//需要刷新一下</span></span><br><span class="line">fw.close();</span><br></pre></td></tr></table></figure>
</li>
<li><p>字符输出流写数据的其他方法（调用其他方法）</p>
</li>
<li><p>续写和换行</p>
<ul>
<li><p>续写：<code>FileWriter(String name, boolean append)</code>或<code>FileWriter(File name, boolean append)</code></p>
<p>​		append为true则不会创建新的文件覆盖，为false则会覆盖</p>
</li>
<li><p>换行：同字节输入流</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="11-7-JDK7和JDK9中的异常处理"><a href="#11-7-JDK7和JDK9中的异常处理" class="headerlink" title="11.7 JDK7和JDK9中的异常处理"></a>11.7 JDK7和JDK9中的异常处理</h4><ul>
<li><p>JDK7新特性，在try后面可以增加一个()，在括号里面进行对象的定义，那么这个流对象的作用域就在try中有效，try中的代码执行完毕，会自动把流对象释放，不用写finally。</p>
</li>
<li><p>JDK9新特性：try前面可以定义流对象，try后面（）中可以直接引入流对象的名称（变量名），在try代码执行完毕后，流对象也可以释放，不用写finally，格式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">A</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">A</span>();</span><br><span class="line"><span class="type">B</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">B</span>();</span><br><span class="line"><span class="keyword">try</span>(a, b)&#123;</span><br><span class="line">    <span class="comment">//可能出现异常部分;</span></span><br><span class="line">&#125;<span class="keyword">catch</span>(异常类变量 变量名)&#123;</span><br><span class="line">    <span class="comment">//异常处理</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="11-8-属性集"><a href="#11-8-属性集" class="headerlink" title="11.8 属性集"></a>11.8 属性集</h4><ul>
<li><p>java.util.Properties继承于HashTable：表示一个持久的属性集，可保存流中或从流中加载，属性列表中每个键以及对应值都是一个字符串</p>
</li>
<li><p>Properties是唯一一个和IO流相结合的集合</p>
<ul>
<li><p>使用集合中的方法store，把集合中的临时数据，持久化写入到硬盘中存储</p>
<p><code>void store(OutputStream out, String comments);</code></p>
<p><code>void store(Writer writer, String comments);</code></p>
<p>参数说明</p>
<ul>
<li>OutputStream  out：字节输出流，不能写中文</li>
<li>Writer writer：字符输出流，可以写中文</li>
<li>String comments：注释，用来解释说明保存的文件，不能使用中文，一般使用空字符串</li>
</ul>
</li>
<li><p>使用方法load，把硬盘中保存的文件，读取到集合中</p>
</li>
<li><p>双列集合，key和value都是默认字符串</p>
</li>
<li><p>Properties中一些操作字符串的方法</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Object <span class="title function_">setProperties</span><span class="params">(String key, String value)</span>;</span><br><span class="line">String <span class="title function_">getProperties</span><span class="params">(String key)</span>;</span><br><span class="line">Set&lt;String&gt; <span class="title function_">StringPropertyNames</span><span class="params">()</span>;<span class="comment">//返回属性列表中的键集 </span></span><br></pre></td></tr></table></figure>
</li>
<li><p>使用步骤：</p>
<ol>
<li>创建Properties集合对象，添加数据</li>
<li>创建字节&#x2F;字符输出流对象，构造方法中绑定输出目的地</li>
<li>使用Properties集合中的store方法，把集合中的临时数据持久化写入到硬盘中</li>
<li>释放资源</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Properties</span> <span class="variable">prop</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">prop.setProperties(<span class="string">&quot;张三&quot;</span>, <span class="string">&quot;19&quot;</span>);</span><br><span class="line"><span class="type">FileWriter</span> <span class="variable">fw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileWriter</span>(<span class="string">&quot;地址&quot;</span>);</span><br><span class="line">prop.store(fw, <span class="string">&quot;save data&quot;</span>);</span><br><span class="line">fw.close();</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="0719-十二-缓冲流、转换流、序列化"><a href="#0719-十二-缓冲流、转换流、序列化" class="headerlink" title="0719 十二 缓冲流、转换流、序列化"></a>0719 十二 缓冲流、转换流、序列化</h3><h4 id="12-1-缓冲流"><a href="#12-1-缓冲流" class="headerlink" title="12.1 缓冲流"></a>12.1 缓冲流</h4><ul>
<li><p>给基本的字节&#x2F;字符输入&#x2F;输出流增加一个缓冲区（数组），提高字节&#x2F;字符输入&#x2F;输出的效率</p>
<p>注：比使用一个数组更有效率</p>
</li>
<li><p>字节缓冲流：<code>BufferInputStream;BufferOutputStream</code></p>
</li>
<li><p>字符缓冲流：<code>BufferedReader;BufferedWriter</code></p>
</li>
<li><p><code>BufferedOutputStream extends OutputStream</code>：字节缓冲输出流</p>
<ul>
<li>构造方法：<code>BufferedOutputStream(OutputStream out);BufferedOutputStream(OutputStream out,int size) </code>，size为内部缓冲区的大小，不指定则默认</li>
<li>步骤<ol>
<li>创建FileOutputStream对象，构造方法中要绑定输出目的地</li>
<li>创建BufferOutputStream对象，构造方法中传递FileOutputStream，以提高FileOutputStream对象效率</li>
<li>使用BufferOutputStream的write方法，把数据写入到内部缓冲区中</li>
<li>使用BufferOutputStream的flush方法，刷新（可省略）</li>
<li>关闭close</li>
</ol>
</li>
</ul>
</li>
<li><p><code>BufferedInputStream extends inputStream</code>：字节缓冲输入流</p>
<ul>
<li>构造方法：类似</li>
<li>步骤：类似</li>
</ul>
</li>
<li><p><code>BufferedWriter extends Writer</code>：字符缓冲输出流</p>
<ul>
<li>构造方法：<code>BufferedWriter (Writer writer, int size);</code>size可以不写</li>
<li>特有的成员方法：<code>void newLine()://创建行分隔符</code></li>
</ul>
</li>
<li><p><code>BufferedReader extends Reader</code>：字符缓冲输入流</p>
<ul>
<li>构造方法</li>
<li>特有成员方法：<code>String readLine();//读取一个文本行，读取一行数据</code></li>
</ul>
</li>
</ul>
<h4 id="12-2-转换流"><a href="#12-2-转换流" class="headerlink" title="12.2 转换流"></a>12.2 转换流</h4><ul>
<li><p>字符编码和解码</p>
</li>
<li><p>字符集：也叫编码表，常见的有：</p>
<p>​	ASCII字符集（英文）</p>
<p>​	GBK字符集（最常用的中文码表），两个字节一个中文</p>
<pre><code> Unicode字符集（任意语言），三个字节一个中文
</code></pre>
</li>
<li><p>编码引出的问题：FileReader可以读取IDEA默认编码格式（UTF-8）的文件，它读取系统默认的编码格式（中文GBK）文件会产生乱码</p>
</li>
<li><p>转换流原理：</p>
<ul>
<li><p>InputStreamReader：可以指定编码表</p>
<ul>
<li>构造方法：类似下面</li>
<li>步骤：类似下面</li>
</ul>
</li>
<li><p>OutputStreamWriter：可以使用指定的charset将要写入的字符编码成字节</p>
<ul>
<li><p>构造方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">OutputStreamWriter(OutputStream out, String charsetName);</span><br><span class="line"><span class="comment">//charsetName不分大写</span></span><br><span class="line">OutputStreamWriter(OutputStream out);</span><br></pre></td></tr></table></figure>
</li>
<li><p>步骤</p>
<ul>
<li>创建OutputStreamWriter对象</li>
<li>使用OutputStreamWriter的write方法</li>
<li>flush</li>
<li>close</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="12-3-序列化和反序列化"><a href="#12-3-序列化和反序列化" class="headerlink" title="12.3 序列化和反序列化"></a>12.3 序列化和反序列化</h4><ul>
<li>序列化：把对象以流的方式，写入到文件中进行保存，也叫写对象<ul>
<li>对象中包含的不仅仅是字符，所以使用字节流</li>
<li>ObjectOutputStream：对象的序列化流 <code>void writeObject(Object obj)</code></li>
</ul>
</li>
<li>反序列化：读取文件中保存的字节，<ul>
<li>使用字节流</li>
<li>ObjectInputStream：对象的反序列化流 <code>Object readObject()</code></li>
</ul>
</li>
<li><code>java.io.ObjectOutputStream extends OutputStream</code><ul>
<li>构造方法<ul>
<li><code>ObjectOutputStream(OutputStream out)</code></li>
</ul>
</li>
<li>特有的成员方法<ul>
<li><code>void writeObject(Object obj)</code></li>
</ul>
</li>
</ul>
</li>
<li><code>java.io.ObjectInputStream extends InputStream</code><ul>
<li>构造方法<ul>
<li><code>ObjectInputStream(InputStream in)</code></li>
</ul>
</li>
<li>特有的成员方法<ul>
<li><code>Object readObject()</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="12-4-transient关键字"><a href="#12-4-transient关键字" class="headerlink" title="12.4 transient关键字"></a>12.4 transient关键字</h4><ul>
<li>瞬态关键字</li>
<li>static关键字：静态关键字，优先于非静态加载到内存中（静态优先于对象进入到内存中），被static修饰的成员变量不能被序列化，序列化的都是对象</li>
<li>被transient修饰的成员变量不能被序列化、</li>
</ul>
<h4 id="12-5-InvalidClassException异常"><a href="#12-5-InvalidClassException异常" class="headerlink" title="12.5 InvalidClassException异常"></a>12.5 InvalidClassException异常</h4><ul>
<li><p>原理：当JVM反序列化对象时，能找到.class文件，但是.class文件再序列化对象之后发生了修改，那么反序列化的操作也会失败，抛出 <code>InvalidClassException</code>异常</p>
</li>
<li><p>原因：</p>
<ul>
<li>该类的序列版本号于从流中读取的类描述的版本号不匹配</li>
<li>该类包含未知数据类型</li>
<li>该类没有可访问的无参数构造方法</li>
</ul>
</li>
<li><p>解决方案：</p>
<ul>
<li>让相应的类实现Serializable接口，然后 <code>private static final long serialVersionUID = 1L;(随便赋值)</code>（就是为了序列号不改变）</li>
</ul>
<h4 id="12-6-打印流"><a href="#12-6-打印流" class="headerlink" title="12.6 打印流"></a>12.6 打印流</h4></li>
<li><p><code>java.io.PrintStream</code>：打印流</p>
</li>
<li><p>特点：</p>
<ul>
<li>只负责数据的输出，不负责输入</li>
<li>不抛出IOException</li>
<li>特有的方法：print、println，可以输出任意的数据类型</li>
</ul>
</li>
<li><p>构造方法：</p>
<ul>
<li><code>PrintStream(File file)</code></li>
<li><code>PrintStream(String filename)</code></li>
<li><code>PrintStream(OutputStream out)</code></li>
</ul>
</li>
<li><p>注：如果使用继承父类的write()方法，那么查看数据的时候会查询编码表   97-&gt;a</p>
<p>​		如果使用字节的方法print&#x2F;println方法写数据，写的数据原样输出         97-&gt;97</p>
</li>
</ul>
<p><u><em>序列化集合练习：day0719&#x2F;</em></u>：序列化集合（当我们想在文件中保存多个对象的时候，可以把对象存储到一个集合中，对集合进行序列化和反序列化）</p>
<h3 id="0720-十三-网络编程、函数式编程"><a href="#0720-十三-网络编程、函数式编程" class="headerlink" title="0720 十三 网络编程、函数式编程"></a>0720 十三 网络编程、函数式编程</h3><h4 id="13-1-网络编程入门"><a href="#13-1-网络编程入门" class="headerlink" title="13.1 网络编程入门"></a>13.1 网络编程入门</h4><ul>
<li><p>软件结构：C&#x2F;S结构和B&#x2F;S结构</p>
</li>
<li><p>网络通信协议：</p>
<ul>
<li><p>TCP&#x2F;IP协议（Internet最广泛的协议）</p>
</li>
<li><p>四层结构（物理层&#x2F;数据链路层、网络层（核心）、传输层、应用层）</p>
</li>
<li><p>分类：UDP协议（无连接的通信，不能保证数据完整耗资小，一般视频会议用UDP）</p>
<p>​			TCP协议：三次握手，保证数据的安全</p>
</li>
</ul>
</li>
<li><p>IP地址：Ipv4和Ipv6 </p>
</li>
<li><p>端口号：是一个逻辑端口，无法直接看到，可以使用软件看到，当使用网络软件开打，操作系统会随机分配一个端口号，由两个字节组成，范围为：0-65535之前</p>
<p> 注：1024之前的不能使用，已经被系统分配给已知的网络软件了</p>
<ul>
<li>常用端口号： 80端口：网络端口口；数据库：mysql为3306，oracle为1521；Tomcat服务器为8080</li>
</ul>
</li>
</ul>
<h4 id="13-2-TCP通信程序"><a href="#13-2-TCP通信程序" class="headerlink" title="13.2 TCP通信程序"></a>13.2 TCP通信程序</h4><ul>
<li><p>能够实现两台计算机之间的数据交互，要严格分为客户端和服务端，服务端先启动，然后客户端主动连接服务端才能连接成功</p>
</li>
<li><p>TCP通信：面向连接的通信，客户端和服务端必须经过3次握手才能通信（安全）</p>
<ul>
<li>使用IO对象进行通信，为字节流对象（不是字符流，因为不仅仅只有字符）</li>
</ul>
<p><img src="/TyporaImg/javaSE%E7%AC%94%E8%AE%B0.assets/image-20220720144704192.png" alt="image-20220720144704192"></p>
<ul>
<li><p>TCP通信的客户端：想服务器发送连接请求，给服务器发送数据，读取服务器回写的数据</p>
<ul>
<li><p>表示客户端的类：java.net.Socket：此类实现客户端套字（两台机器间通信的端点，包含了IP地址和端口号）                                                                                                  </p>
</li>
<li><p>构造方法： <code>Socket(String host, int port)</code></p>
</li>
<li><p>成员方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">OutputStream <span class="title function_">getOutputStream</span><span class="params">()</span>;<span class="comment">//返回此套接字的输出流</span></span><br><span class="line">InputStream <span class="title function_">getInputStream</span><span class="params">()</span>;</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span>;<span class="comment">//关闭套接字</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>实现步骤：</p>
<ol>
<li>创建一个客户端对象Socket，构造方法绑定服务器和ip地址和端口号</li>
<li>getOutputStream()获取网络字节输出流对象</li>
<li>使用getOutputStream()对象中write方法给服务器发送数据</li>
<li>使用getInputStream()后去网络字节输入流对象，并使用read()方法读取服务器回写的数据</li>
<li>释放资源（Socket）</li>
</ol>
</li>
<li><p>注：</p>
<ul>
<li>客户端和服务器的交互必须使用Socket中提供的网络流，不能使用自己创建的对象</li>
<li>当创建客户端对象Socket对象的时候，就会去请求服务器和服务器经过3次握手建立连接网络，若服务器没有启动，则抛出异常，若服务器启动则可以交互了</li>
</ul>
</li>
</ul>
</li>
<li><p>TCP通信的服务器段：</p>
<ul>
<li>表示服务器端的类：java.net.ServerSocket：此类实现服务器的套接字</li>
<li>构造方法：<code>ServerSocket(int port);//创建绑定到特定端口的雾浮起套接字</code></li>
<li>服务器端必须明确哪一个客户端请求的服务器，所以用accept方法获取到请求的客户端对象Socket</li>
<li>成员方法：<code>Socket accept();</code></li>
<li>实现步骤：<ol>
<li>创建服务器ServerSocket对象和系统指定的端口号</li>
<li>使用accept方法获取请求的客户端对象Socket</li>
<li>使用getInputStream()后去网络字节输入流对象，并使用read()方法读取客户端发送的数据</li>
<li>getOutputStream()获取网络字节输出流对象，使用getOutputStream()对象中write方法给客户端回写数据</li>
<li>释放资源（Socket，ServerSocket）</li>
</ol>
</li>
</ul>
</li>
</ul>
</li>
<li><p><u><em>文件上传练习：day0720&#x2F;FileUpload</em></u>：TCP通信的文件上传</p>
<p><img src="/TyporaImg/javaSE%E7%AC%94%E8%AE%B0.assets/image-20220720151225461.png" alt="image-20220720151225461"></p>
<ul>
<li><p>注：<code>Socket.shutdownOutput();</code>如果不加此代码就会阻塞。因为服务器会一直等待客户端的输出。既然服务器阻塞了，客户端等待着服务器的输出，也会被阻塞，所以导致客户端和服务端都被阻塞。</p>
<p>调用<code>Socket.shutdownOutput()</code>方法后，客户端输出的数据都将被发送，并加上 TCP 的正常连接终止序列（-1，也就是服务端终止循环的判断条件)，这样服务端读取数据时就不会被阻塞了。</p>
</li>
</ul>
</li>
<li><p><u><em>web服务器练习：day0720&#x2F;web</em></u>：web服务器</p>
<p><img src="/TyporaImg/javaSE%E7%AC%94%E8%AE%B0.assets/image-20220720164322212.png" alt="image-20220720164322212"></p>
</li>
</ul>
<h4 id="13-3-函数式接口"><a href="#13-3-函数式接口" class="headerlink" title="13.3 函数式接口"></a>13.3 函数式接口</h4><ul>
<li><p>定义：有且只有一个抽象方法的接口</p>
</li>
<li><p>适用于Lambda使用的接口，就是只有一个抽象方法，所以Lambda才能顺利使用</p>
</li>
<li><p>格式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">修饰符 interface 接口名称&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> 返回值 方法名称(可选参数信息);</span><br><span class="line">    <span class="comment">//其他非抽象方法信息</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>@FunctionalInterface</code>注解：检测接口是否是一个函数式接口</p>
</li>
<li><p>调用函数式接口可以使用lambda表达式</p>
</li>
</ul>
<h4 id="13-4-函数式编程"><a href="#13-4-函数式编程" class="headerlink" title="13.4 函数式编程"></a>13.4 函数式编程</h4><ul>
<li><p>函数式接口作为方法的参数</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">startThread</span><span class="params">(Runnable run)</span>&#123;</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(run).start();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">psvm&#123;</span><br><span class="line">    startThread(<span class="keyword">new</span> <span class="title class_">Runnable</span>()&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">            sout(<span class="string">&quot;开启线程&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">//优化</span></span><br><span class="line">    startThread(()-&gt;&#123;</span><br><span class="line">       sout(<span class="string">&quot;开启线程&quot;</span>); </span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>函数式接口作为方法的返回值</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Comparator&lt;String&gt; <span class="title function_">getComparator</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;String&gt;()&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(String o1, String o2)</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> o2.length()-o1.length();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">//使用lambda</span></span><br><span class="line">    <span class="keyword">return</span>(String o1, String o2) -&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> o2.length()-o1.length();</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//继续优化</span></span><br><span class="line">    <span class="keyword">return</span>(o1, o2) -&gt; o2.length()-o1.length();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="13-5-常用的函数式接口"><a href="#13-5-常用的函数式接口" class="headerlink" title="13.5 常用的函数式接口"></a>13.5 常用的函数式接口</h4><ul>
<li><p>Supplier接口</p>
<ul>
<li><p><code>java.util.function.Supplier&lt;T&gt;</code>:被称为生产型接口，指定的泛型是什么，接口中的get方法就会产生什么类型的数据</p>
</li>
<li><p>仅包含一个无参的方法 <code>T get()</code></p>
</li>
<li><p>使用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">getString</span><span class="params">(Supplier&lt;String&gt; sup)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> suo.get();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">psvm&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> getString(()-&gt;&#123;</span><br><span class="line">       <span class="comment">//重写get方法</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;get方法返回&quot;</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//优化</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> getString(()-&gt;<span class="string">&quot;get方法返回&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p><u><em>Supplier接口练习：day0720&#x2F;SupplierDemo.java</em></u>：使用Supplier接口求数组最大值</p>
</li>
<li><p>Consumer接口</p>
<ul>
<li><p><code>java.util.Consumer&lt;T&gt;</code>：消费型接口，泛型是什么，就使用accpt方法消费什么类型数据</p>
</li>
<li><p><code>void accept()</code></p>
</li>
<li><p>使用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">(String name, Consumer&lt;String&gt; con)</span>&#123;</span><br><span class="line">    co.accept(name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">psvm&#123;</span><br><span class="line">    method(<span class="string">&quot;jack&quot;</span>, <span class="keyword">new</span> <span class="title class_">Consumer</span>&lt;String&gt;&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(String name)</span>&#123;</span><br><span class="line">            sout(name);</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    method(<span class="string">&quot;jack&quot;</span>,(name)-&gt;&#123;</span><br><span class="line">        sout(name);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Consumer接口的默认方法：<code>andThen</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">default</span> Consumer&lt;T&gt; <span class="title function_">andThen</span><span class="params">(Consumer&lt;? <span class="built_in">super</span> T&gt; after)</span>&#123;</span><br><span class="line">    Objects.requireNonNull(after);</span><br><span class="line">    <span class="keyword">return</span> (T t) -&gt; &#123;accept(t);after.accept(t);&#125;;</span><br><span class="line">&#125;<span class="comment">//组合使用两个Consumer接口的accept方法，谁写前面，谁先消费</span></span><br><span class="line"></span><br><span class="line">Consumer&lt;String&gt; con1;</span><br><span class="line">Consumer&lt;String&gt; con2;</span><br><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">那么</span><br><span class="line">con1.accept(s);</span><br><span class="line">con2.accept(s);</span><br><span class="line">等价于</span><br><span class="line">con1.andThen(con2).accept(s);</span><br></pre></td></tr></table></figure>

<p><u><em>Consumer接口练习：day0720&#x2F;ConsumerDemo.java</em></u>：使用Consumer接口拼接字符串</p>
</li>
</ul>
</li>
<li><p>Predicate接口</p>
<ul>
<li><p><code>java.function.Predicate&lt;T&gt;</code>接口：对某种数据类型进行判断，结果返回一个boolean</p>
</li>
<li><p><code>boolean test(T t)</code></p>
</li>
<li><p>默认方法：</p>
<ul>
<li><p><code>and()</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">default</span> Predicate&lt;T&gt; <span class="title function_">and</span><span class="params">(Predicate&lt;? <span class="built_in">super</span> T&gt; other)</span>&#123;</span><br><span class="line">    Objects.requireNonNull(after);</span><br><span class="line">    <span class="keyword">return</span> (t) -&gt; test(t) &amp;&amp; other.test(t);</span><br><span class="line">&#125;<span class="comment">//组合使用两个Consumer接口的accept方法，谁写前面，谁先消费</span></span><br><span class="line"></span><br><span class="line">pre1.and(pre2).test(t);<span class="comment">//t要满足pre1和pre2的两个才为true</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>or()//或者</code></p>
</li>
<li><p><code>negate()//取反</code></p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>Function接口</p>
<ul>
<li><code>java.function.Function&lt;T,R&gt;</code>接口：用来将T类型的数据转换为R类型的数据</li>
<li><code>R apply(T t)</code></li>
<li>默认方法： <code>andThen</code>：用来组合操作</li>
</ul>
</li>
</ul>
<h3 id="0721-十四"><a href="#0721-十四" class="headerlink" title="0721 十四"></a>0721 十四</h3><h4 id="14-1-Stream流"><a href="#14-1-Stream流" class="headerlink" title="14.1 Stream流"></a>14.1 Stream流</h4><ul>
<li><p>传统集合循环遍历的弊端：若有多层条件。则需要多次循环筛选</p>
</li>
<li><p>使用Stream流的方式进行集合的遍历：JDK1.8，关注的是做什么而不是怎么做</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">list.Stream().filter(name -&gt; name.starsWith(<span class="string">&quot;张&quot;</span>))</span><br><span class="line">    		 .fliter(name -&gt; name.length() == <span class="number">3</span>)</span><br><span class="line">      		 .forEach(name -&gt; sout(name));<span class="comment">//筛选出list中以张开头长度为三的对象</span></span><br><span class="line">    <span class="comment">//filter方法内传入的是Predicate接口</span></span><br><span class="line">	<span class="comment">//filter(Predicate&lt;? super T&gt; predicate) </span></span><br><span class="line">    <span class="comment">//forEach(Consumer&lt;? super T&gt; action) </span></span><br></pre></td></tr></table></figure>
</li>
<li><p>使用流：获取数据源 -&gt; 数据转换 -&gt; 执行操作获取想要结果（每次转换原有的Stream对象不变，返回一个新的Stream对象）</p>
</li>
<li><p>获取流；</p>
<ul>
<li>所有的Collection都可以通过<code>default Stream&lt;E&gt; stream()</code>方法获取流（必须是单列集合，Map集合要分别把键值单独生成为相应的单列集合再转换） </li>
<li>Stream接口的静态方法<code>static&lt;T&gt; Stream&lt;T&gt; of(T t)</code>可以获取数组对应的流</li>
</ul>
</li>
<li><p>常用方法：</p>
<ul>
<li><p>延迟方法:可以用来链式编程</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;T&gt; <span class="title function_">filter</span><span class="params">(Predicate&lt;? <span class="built_in">super</span> T&gt; predicate)</span>;</span><br><span class="line">&lt;R&gt; Stream&lt;R&gt; <span class="title function_">map</span><span class="params">(Function&lt;? <span class="built_in">super</span> T,? extends R&gt; mapper)</span>;<span class="comment">//将一个流映射到另一个流中</span></span><br><span class="line">Stream&lt;T&gt; <span class="title function_">limit</span><span class="params">(<span class="type">long</span> maxSize)</span>;<span class="comment">//截取前maxSize个元素</span></span><br><span class="line">Stream&lt;T&gt; <span class="title function_">skip</span><span class="params">(<span class="type">long</span> n)</span>;<span class="comment">//跳过前n个元素</span></span><br><span class="line"><span class="keyword">static</span> &lt;T&gt; Stream&lt;T&gt; <span class="title function_">concat</span><span class="params">(Stream&lt;? extends T&gt; a, Stream&lt;? extends T&gt; b)</span>;<span class="comment">//组合两个流</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;String&gt; stream = Stream.of(<span class="string">&quot;1&quot;</span>, <span class="string">&quot;2&quot;</span>, <span class="string">&quot;3&quot;</span>);</span><br><span class="line"><span class="comment">//使用map方法将其转换为Integer数据类型</span></span><br><span class="line">Stream&lt;Integer&gt; stream2 = stream.map((String s)-&gt;&#123;</span><br><span class="line">    <span class="keyword">return</span> Integer.parseInt(s);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
</li>
<li><p>终结方法：使用之后就不能再使用Stream流的方法了</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">forEach</span><span class="params">(Consumer&lt;? <span class="built_in">super</span> T&gt; action)</span>;<span class="comment">//用来遍历</span></span><br><span class="line"><span class="type">long</span> <span class="title function_">count</span><span class="params">()</span>;<span class="comment">//返回流中的元素个数</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>Stream流的特点：只能被使用一次，第一个Stream流调用方法完毕，返回一个Stream流，此时就不能再用了</p>
</li>
<li><p><u><em>集合元素处理练习：day0721&#x2F;StreamDemo.java</em></u>：使用Stream实现集合的元素处理</p>
</li>
</ul>
<h4 id="14-2-方法引用"><a href="#14-2-方法引用" class="headerlink" title="14.2 方法引用"></a>14.2 方法引用</h4><ul>
<li><p>在使用lambda表达式的时候，我们实际上传递进去的代码是一种解决方案：拿什么参数做什么操作，那么考虑一种情况：我们在lambda中所指定的操作已经有地方存在相同方案，则没有必要再写重复逻辑。</p>
</li>
<li><p>使用前提：对象和方法都是已经存在的</p>
</li>
<li><p><code>::</code> 为引用运算符，它所在的表达式被称为方法引用</p>
<ul>
<li><code>lambda: s-&gt; System.out.println(s);</code></li>
<li><code>方法引用:System.out::println</code></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">printString</span><span class="params">(Printable data)</span>&#123;</span><br><span class="line">    data.print(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">psvm()&#123;</span><br><span class="line">	printString(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>通过对象名引用成员方法（前提：对象存在，成员方法存在）</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">printString</span><span class="params">(Printable p)</span>&#123;</span><br><span class="line">    p.print(<span class="string">&quot;Hello&quot;</span>);<span class="comment">//Printable为一个抽象接口，只有一个print方法</span></span><br><span class="line">&#125;</span><br><span class="line">psvm()&#123;</span><br><span class="line">    printString((s) -&gt; &#123;</span><br><span class="line">        <span class="type">MethodRerObject</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MethodRerObject</span>();</span><br><span class="line">        obj.printUpperCaseString(s);<span class="comment">//方法的作用为将输入的字符串大写打出</span></span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">//采用方法引用优化lambda</span></span><br><span class="line">    <span class="comment">//对象MethodRerObject存在，成员方法printUpperCaseString()也存在</span></span><br><span class="line">    <span class="comment">//所以使用对象名引用成员方法</span></span><br><span class="line">    <span class="type">MethodRerObject</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MethodRerObject</span>();</span><br><span class="line">    printString(obj::printUpperCaseString);</span><br><span class="line">      </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>通过类名引用静态成员方法（前提：类存在，静态成员方法存在）</p>
<p>格式类似于上面，将对象改为类名</p>
</li>
<li><p>通过super引用父类成员方法（前提：super存在，成员方法存在）</p>
<p>格式类似</p>
</li>
<li><p>通过this引用本类成员方法</p>
</li>
<li><p>类的构造器（构造方法）的引用 <code>类名称::new</code></p>
</li>
<li><p>数组的构造器引用</p>
</li>
</ul>
<p>​                                   </p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="http://yileman.github.io">myl</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://yileman.github.io/posts/20250.html">http://yileman.github.io/posts/20250.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://yileman.github.io" target="_blank">myl's blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/java%E5%9F%BA%E7%A1%80/">java基础</a></div><div class="post_share"><div class="social-share" data-image="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/touxiang.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/posts/19451.html" title="多线程与反射"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">多线程与反射</div></div></a></div><div class="next-post pull-right"><a href="/posts/40445.html" title="数据结构与算法"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">数据结构与算法</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/posts/19451.html" title="多线程与反射"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-09-18</div><div class="title">多线程与反射</div></div></a></div><div><a href="/posts/60206.html" title="JavaWeb"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-11-18</div><div class="title">JavaWeb</div></div></a></div></div></div><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="twikoo-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/touxiang.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">myl</div><div class="author-info__description">后端学习</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">19</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">6</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">4</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/yileman"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">写写记记</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#JAVASE-STUDY"><span class="toc-number">1.</span> <span class="toc-text">JAVASE_STUDY</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#0703-%E4%B8%80-%E5%9F%BA%E7%A1%80"><span class="toc-number">1.1.</span> <span class="toc-text">0703 一 基础</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-JDK-JRE-JVM%E5%85%B3%E7%B3%BB"><span class="toc-number">1.1.1.</span> <span class="toc-text">1.1 JDK JRE JVM关系</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-JAVA%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B"><span class="toc-number">1.1.2.</span> <span class="toc-text">1.2 JAVA编译过程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-3-%E5%85%B3%E9%94%AE%E5%AD%97%E3%80%81%E6%A0%87%E8%AF%86%E7%AC%A6"><span class="toc-number">1.1.3.</span> <span class="toc-text">1.3 关键字、标识符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-4-%E5%B8%B8%E9%87%8F%E4%B8%8E%E5%8F%98%E9%87%8F"><span class="toc-number">1.1.4.</span> <span class="toc-text">1.4 常量与变量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-5-%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%BC%95%E7%94%A8%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.1.5.</span> <span class="toc-text">1.5 基本数据类型和引用数据类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-6-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-number">1.1.6.</span> <span class="toc-text">1.6 数据类型转换</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-7-ASCII%E7%BC%96%E7%A0%81"><span class="toc-number">1.1.7.</span> <span class="toc-text">1.7 ASCII编码</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-8-%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">1.1.8.</span> <span class="toc-text">1.8 运算符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-9-%E6%96%B9%E6%B3%95"><span class="toc-number">1.1.9.</span> <span class="toc-text">1.9 方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-10-Jshell"><span class="toc-number">1.1.10.</span> <span class="toc-text">1.10 Jshell</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#0704-%E4%BA%8C-%E7%BB%93%E6%9E%84%E5%8F%8A%E6%96%B9%E6%B3%95"><span class="toc-number">1.2.</span> <span class="toc-text">0704 二 结构及方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-%E9%A1%BA%E5%BA%8F%E7%BB%93%E6%9E%84"><span class="toc-number">1.2.1.</span> <span class="toc-text">2.1 顺序结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-%E9%80%89%E6%8B%A9%E7%BB%93%E6%9E%84"><span class="toc-number">1.2.2.</span> <span class="toc-text">2.2 选择结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-%E5%BE%AA%E7%8E%AF%E7%BB%93%E6%9E%84"><span class="toc-number">1.2.3.</span> <span class="toc-text">2.3 循环结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-4-%E5%BE%AA%E7%8E%AF%E6%8E%A7%E5%88%B6"><span class="toc-number">1.2.4.</span> <span class="toc-text">2.4 循环控制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-5-IDEA"><span class="toc-number">1.2.5.</span> <span class="toc-text">2.5 IDEA</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-6-%E6%96%B9%E6%B3%95%E5%AE%9A%E4%B9%89%E5%8F%8A%E8%B0%83%E7%94%A8%E5%8F%8A%E6%96%B9%E6%B3%95%E7%9A%84%E9%87%8D%E8%BD%BD"><span class="toc-number">1.2.6.</span> <span class="toc-text">2.6 方法定义及调用及方法的重载</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#0705-%E4%B8%89-%E6%95%B0%E7%BB%84%E3%80%81%E5%8F%98%E9%87%8F"><span class="toc-number">1.3.</span> <span class="toc-text">0705 三 数组、变量</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-%E6%95%B0%E7%BB%84%E7%AE%80%E4%BB%8B"><span class="toc-number">1.3.1.</span> <span class="toc-text">3.1 数组简介</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-JAVA%E5%86%85%E5%AD%98%E5%88%92%E5%88%86"><span class="toc-number">1.3.2.</span> <span class="toc-text">3.2 JAVA内存划分</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-%E6%95%B0%E7%BB%84%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98"><span class="toc-number">1.3.3.</span> <span class="toc-text">3.3 数组常见问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-4-%E6%95%B0%E7%BB%84%E5%B8%B8%E7%94%A8"><span class="toc-number">1.3.4.</span> <span class="toc-text">3.4 数组常用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-5-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%80%9D%E6%83%B3"><span class="toc-number">1.3.5.</span> <span class="toc-text">3.5 面向对象的思想</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-6-%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E5%92%8C%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F"><span class="toc-number">1.3.6.</span> <span class="toc-text">3.6 局部变量和成员变量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-7-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%B8%89%E5%A4%A7%E7%89%B9%E6%80%A7"><span class="toc-number">1.3.7.</span> <span class="toc-text">3.7 面向对象的三大特性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-8-private%E5%92%8Cthis%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">1.3.8.</span> <span class="toc-text">3.8 private和this关键字</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-9-%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95"><span class="toc-number">1.3.9.</span> <span class="toc-text">3.9 构造方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-10-%E5%AE%9A%E4%B9%89%E4%B8%80%E4%B8%AA%E6%A0%87%E5%87%86%E7%9A%84%E7%B1%BB"><span class="toc-number">1.3.10.</span> <span class="toc-text">3.10 定义一个标准的类</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#0706-%E5%9B%9B-%E5%AF%B9%E8%B1%A1%E3%80%81%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">1.4.</span> <span class="toc-text">0706 四 对象、字符串</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1-API"><span class="toc-number">1.4.1.</span> <span class="toc-text">4.1 API</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-%E5%8C%BF%E5%90%8D%E5%AF%B9%E8%B1%A1"><span class="toc-number">1.4.2.</span> <span class="toc-text">4.2 匿名对象</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-3-Random%E7%B1%BB"><span class="toc-number">1.4.3.</span> <span class="toc-text">4.3 Random类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-4-%E5%AF%B9%E8%B1%A1%E6%95%B0%E7%BB%84%E4%B8%8EArrayList"><span class="toc-number">1.4.4.</span> <span class="toc-text">4.4 对象数组与ArrayList</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-5-%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">1.4.5.</span> <span class="toc-text">4.5 字符串</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-5-static%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">1.4.6.</span> <span class="toc-text">4.5 static关键字</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-6-%E6%95%B0%E7%BB%84%E5%B7%A5%E5%85%B7%E7%B1%BB-Arrays"><span class="toc-number">1.4.7.</span> <span class="toc-text">4.6 数组工具类 Arrays</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-7-Math%E7%B1%BB"><span class="toc-number">1.4.8.</span> <span class="toc-text">4.7 Math类</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#0707-%E4%BA%94-%E7%BB%A7%E6%89%BF%E3%80%81%E6%8A%BD%E8%B1%A1%E3%80%81%E6%8E%A5%E5%8F%A3%E3%80%81%E5%A4%9A%E6%80%81"><span class="toc-number">1.5.</span> <span class="toc-text">0707 五 继承、抽象、接口、多态</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#5-1-%E7%BB%A7%E6%89%BF"><span class="toc-number">1.5.1.</span> <span class="toc-text">5.1 继承</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-2-super%E3%80%81this%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">1.5.2.</span> <span class="toc-text">5.2 super、this关键字</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-3-%E6%8A%BD%E8%B1%A1"><span class="toc-number">1.5.3.</span> <span class="toc-text">5.3 抽象</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-4-%E6%8E%A5%E5%8F%A3"><span class="toc-number">1.5.4.</span> <span class="toc-text">5.4 接口</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-5-%E7%BB%A7%E6%89%BF%E7%88%B6%E7%B1%BB%E5%B9%B6%E5%AE%9E%E7%8E%B0%E5%A4%9A%E4%B8%AA%E6%8E%A5%E5%8F%A3"><span class="toc-number">1.5.5.</span> <span class="toc-text">5.5 继承父类并实现多个接口</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-6-%E6%8E%A5%E5%8F%A3%E4%B9%8B%E9%97%B4%E7%9A%84%E5%A4%9A%E7%BB%A7%E6%89%BF"><span class="toc-number">1.5.6.</span> <span class="toc-text">5.6 接口之间的多继承</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-7-%E5%A4%9A%E6%80%81"><span class="toc-number">1.5.7.</span> <span class="toc-text">5.7 多态</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-8-%E5%AF%B9%E8%B1%A1%E7%9A%84%E8%BD%AC%E5%9E%8B"><span class="toc-number">1.5.8.</span> <span class="toc-text">5.8 对象的转型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-9-%E6%8E%A5%E5%8F%A3%E5%A4%9A%E6%80%81%E7%BB%83%E4%B9%A0"><span class="toc-number">1.5.9.</span> <span class="toc-text">5.9 接口多态练习</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#0708-%E5%85%AD"><span class="toc-number">1.6.</span> <span class="toc-text">0708 六</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#6-1-final%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">1.6.1.</span> <span class="toc-text">6.1 final关键字</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-2-%E5%9B%9B%E7%A7%8D%E6%9D%83%E9%99%90%E4%BF%AE%E9%A5%B0%E7%AC%A6"><span class="toc-number">1.6.2.</span> <span class="toc-text">6.2 四种权限修饰符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-3-%E5%86%85%E9%83%A8%E7%B1%BB"><span class="toc-number">1.6.3.</span> <span class="toc-text">6.3 内部类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-4-%E7%B1%BB%E4%BD%9C%E4%B8%BA%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.6.4.</span> <span class="toc-text">6.4 类作为成员变量类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-5-%E6%8E%A5%E5%8F%A3%E4%BD%9C%E4%B8%BA%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E7%B1%BB%E5%9E%8B%E3%80%81%E6%96%B9%E6%B3%95%E7%9A%84%E5%8F%82%E6%95%B0%E6%88%96%E8%BF%94%E5%9B%9E%E5%80%BC"><span class="toc-number">1.6.5.</span> <span class="toc-text">6.5 接口作为成员变量类型、方法的参数或返回值</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#0711-%E4%B8%83-%E5%B8%B8%E7%94%A8%E7%B1%BB"><span class="toc-number">1.7.</span> <span class="toc-text">0711 七 常用类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#7-1-Object%E7%B1%BB"><span class="toc-number">1.7.1.</span> <span class="toc-text">7.1 Object类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-2-Date%E7%B1%BB"><span class="toc-number">1.7.2.</span> <span class="toc-text">7.2 Date类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-3-Calendar%E7%B1%BB"><span class="toc-number">1.7.3.</span> <span class="toc-text">7.3 Calendar类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-4-System%E7%B1%BB"><span class="toc-number">1.7.4.</span> <span class="toc-text">7.4 System类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-5-StringBuilder%E7%9A%84%E5%8E%9F%E7%90%86"><span class="toc-number">1.7.5.</span> <span class="toc-text">7.5 StringBuilder的原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-6-%E5%8C%85%E8%A3%85%E7%B1%BB"><span class="toc-number">1.7.6.</span> <span class="toc-text">7.6 包装类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-7-Collection%E9%9B%86%E5%90%88"><span class="toc-number">1.7.7.</span> <span class="toc-text">7.7 Collection集合</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-8-Iterator%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="toc-number">1.7.8.</span> <span class="toc-text">7.8 Iterator迭代器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-9-%E5%A2%9E%E5%BC%BAfor%E5%BE%AA%E7%8E%AF"><span class="toc-number">1.7.9.</span> <span class="toc-text">7.9 增强for循环</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-10-%E6%B3%9B%E5%9E%8B"><span class="toc-number">1.7.10.</span> <span class="toc-text">7.10 泛型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-11-%E5%AE%9A%E4%B9%89%E5%90%AB%E6%9C%89%E6%B3%9B%E5%9E%8B%E7%9A%84%E7%B1%BB%E3%80%81%E6%96%B9%E6%B3%95%E3%80%81%E6%8E%A5%E5%8F%A3"><span class="toc-number">1.7.11.</span> <span class="toc-text">7.11 定义含有泛型的类、方法、接口</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-12-%E6%96%97%E5%9C%B0%E4%B8%BB%E6%A1%88%E4%BE%8B"><span class="toc-number">1.7.12.</span> <span class="toc-text">7.12 斗地主案例</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#0712-%E5%85%AB-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%81%E5%B8%B8%E7%94%A8%E9%9B%86%E5%90%88"><span class="toc-number">1.8.</span> <span class="toc-text">0712 八 数据结构、常用集合</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#8-1-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">1.8.1.</span> <span class="toc-text">8.1 数据结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-2-List%E9%9B%86%E5%90%88"><span class="toc-number">1.8.2.</span> <span class="toc-text">8.2 List集合</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-3-ArrayList%E9%9B%86%E5%90%88"><span class="toc-number">1.8.3.</span> <span class="toc-text">8.3 ArrayList集合</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-4-LinkedList%E9%9B%86%E5%90%88"><span class="toc-number">1.8.4.</span> <span class="toc-text">8.4 LinkedList集合</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-5-Vector%E9%9B%86%E5%90%88"><span class="toc-number">1.8.5.</span> <span class="toc-text">8.5 Vector集合</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-6-Set%E9%9B%86%E5%90%88"><span class="toc-number">1.8.6.</span> <span class="toc-text">8.6 Set集合</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-7-HashSet%E9%9B%86%E5%90%88"><span class="toc-number">1.8.7.</span> <span class="toc-text">8.7 HashSet集合</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-8-LinkedHashSet%E9%9B%86%E5%90%88"><span class="toc-number">1.8.8.</span> <span class="toc-text">8.8 LinkedHashSet集合</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-9-%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0"><span class="toc-number">1.8.9.</span> <span class="toc-text">8.9 可变参数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-10-Collections%E9%9B%86%E5%90%88%E5%B7%A5%E5%85%B7%E7%B1%BB"><span class="toc-number">1.8.10.</span> <span class="toc-text">8.10 Collections集合工具类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-11-Map%E9%9B%86%E5%90%88"><span class="toc-number">1.8.11.</span> <span class="toc-text">8.11 Map集合</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-12-HashMap"><span class="toc-number">1.8.12.</span> <span class="toc-text">8.12 HashMap</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-13-Hashtable"><span class="toc-number">1.8.13.</span> <span class="toc-text">8.13 Hashtable&lt;K, V&gt;</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-14-JDK9%E5%AF%B9%E9%9B%86%E5%90%88%E6%B7%BB%E5%8A%A0%E7%9A%84%E4%BC%98%E5%8C%96"><span class="toc-number">1.8.14.</span> <span class="toc-text">8.14 JDK9对集合添加的优化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-15-%E7%BB%83%E4%B9%A0"><span class="toc-number">1.8.15.</span> <span class="toc-text">8.15 练习</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#0714-%E4%B9%9D-%E5%BC%82%E5%B8%B8%E3%80%81%E7%BA%BF%E7%A8%8B"><span class="toc-number">1.9.</span> <span class="toc-text">0714 九 异常、线程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#9-1-%E5%BC%82%E5%B8%B8"><span class="toc-number">1.9.1.</span> <span class="toc-text">9.1 异常</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-2-%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E7%9A%84%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">1.9.2.</span> <span class="toc-text">9.2 异常处理的关键字</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-3-Throwable%E7%B1%BB%E4%B8%AD%E7%9A%84%E4%B8%89%E4%B8%AA%E5%A4%84%E7%90%86%E5%BC%82%E5%B8%B8%E6%96%B9%E6%B3%95"><span class="toc-number">1.9.3.</span> <span class="toc-text">9.3 Throwable类中的三个处理异常方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-4-%E5%AD%90%E7%B1%BB%E7%88%B6%E7%B1%BB%E5%BC%82%E5%B8%B8"><span class="toc-number">1.9.4.</span> <span class="toc-text">9.4 子类父类异常</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-5-%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BC%82%E5%B8%B8%E7%B1%BB"><span class="toc-number">1.9.5.</span> <span class="toc-text">9.5 自定义异常类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-6-%E5%B9%B6%E5%8F%91%E4%B8%8E%E5%B9%B6%E8%A1%8C"><span class="toc-number">1.9.6.</span> <span class="toc-text">9.6 并发与并行</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-7-%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B"><span class="toc-number">1.9.7.</span> <span class="toc-text">9.7 进程与线程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-8-%E7%BA%BF%E7%A8%8B%E7%B1%BBThread"><span class="toc-number">1.9.8.</span> <span class="toc-text">9.8 线程类Thread</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-9-%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98"><span class="toc-number">1.9.9.</span> <span class="toc-text">9.9 线程安全问题</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#0715-%E5%8D%81-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E3%80%81Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">1.10.</span> <span class="toc-text">0715 十 线程池、Lambda表达式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#10-1-%E7%BA%BF%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1"><span class="toc-number">1.10.1.</span> <span class="toc-text">10.1 线程间通信</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10-2-%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81"><span class="toc-number">1.10.2.</span> <span class="toc-text">10.2 线程状态</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10-3-%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="toc-number">1.10.3.</span> <span class="toc-text">10.3 线程池</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10-4-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.10.4.</span> <span class="toc-text">10.4 线程池的代码实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10-5-%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3"><span class="toc-number">1.10.5.</span> <span class="toc-text">10.5 函数式编程思想</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10-6-Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">1.10.6.</span> <span class="toc-text">10.6 Lambda表达式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10-7-%E4%BD%BF%E7%94%A8Lambda%E7%9A%84%E5%89%8D%E6%8F%90"><span class="toc-number">1.10.7.</span> <span class="toc-text">10.7 使用Lambda的前提</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#0718-%E5%8D%81%E4%B8%80-%E6%B5%81"><span class="toc-number">1.11.</span> <span class="toc-text">0718 十一 流</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#11-1-File%E7%B1%BB"><span class="toc-number">1.11.1.</span> <span class="toc-text">11.1 File类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#11-2-%E9%80%92%E5%BD%92"><span class="toc-number">1.11.2.</span> <span class="toc-text">11.2 递归</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#11-3-FileFilter%E8%BF%87%E6%BB%A4%E5%99%A8"><span class="toc-number">1.11.3.</span> <span class="toc-text">11.3 FileFilter过滤器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#11-4-FileNameFilter"><span class="toc-number">1.11.4.</span> <span class="toc-text">11.4 FileNameFilter</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#11-5-%E5%AD%97%E8%8A%82%E6%B5%81"><span class="toc-number">1.11.5.</span> <span class="toc-text">11.5 字节流</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#11-6-%E5%AD%97%E7%AC%A6%E6%B5%81"><span class="toc-number">1.11.6.</span> <span class="toc-text">11.6 字符流</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#11-7-JDK7%E5%92%8CJDK9%E4%B8%AD%E7%9A%84%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86"><span class="toc-number">1.11.7.</span> <span class="toc-text">11.7 JDK7和JDK9中的异常处理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#11-8-%E5%B1%9E%E6%80%A7%E9%9B%86"><span class="toc-number">1.11.8.</span> <span class="toc-text">11.8 属性集</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#0719-%E5%8D%81%E4%BA%8C-%E7%BC%93%E5%86%B2%E6%B5%81%E3%80%81%E8%BD%AC%E6%8D%A2%E6%B5%81%E3%80%81%E5%BA%8F%E5%88%97%E5%8C%96"><span class="toc-number">1.12.</span> <span class="toc-text">0719 十二 缓冲流、转换流、序列化</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#12-1-%E7%BC%93%E5%86%B2%E6%B5%81"><span class="toc-number">1.12.1.</span> <span class="toc-text">12.1 缓冲流</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#12-2-%E8%BD%AC%E6%8D%A2%E6%B5%81"><span class="toc-number">1.12.2.</span> <span class="toc-text">12.2 转换流</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#12-3-%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96"><span class="toc-number">1.12.3.</span> <span class="toc-text">12.3 序列化和反序列化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#12-4-transient%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">1.12.4.</span> <span class="toc-text">12.4 transient关键字</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#12-5-InvalidClassException%E5%BC%82%E5%B8%B8"><span class="toc-number">1.12.5.</span> <span class="toc-text">12.5 InvalidClassException异常</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#12-6-%E6%89%93%E5%8D%B0%E6%B5%81"><span class="toc-number">1.12.6.</span> <span class="toc-text">12.6 打印流</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#0720-%E5%8D%81%E4%B8%89-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E3%80%81%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B"><span class="toc-number">1.13.</span> <span class="toc-text">0720 十三 网络编程、函数式编程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#13-1-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8"><span class="toc-number">1.13.1.</span> <span class="toc-text">13.1 网络编程入门</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#13-2-TCP%E9%80%9A%E4%BF%A1%E7%A8%8B%E5%BA%8F"><span class="toc-number">1.13.2.</span> <span class="toc-text">13.2 TCP通信程序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#13-3-%E5%87%BD%E6%95%B0%E5%BC%8F%E6%8E%A5%E5%8F%A3"><span class="toc-number">1.13.3.</span> <span class="toc-text">13.3 函数式接口</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#13-4-%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B"><span class="toc-number">1.13.4.</span> <span class="toc-text">13.4 函数式编程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#13-5-%E5%B8%B8%E7%94%A8%E7%9A%84%E5%87%BD%E6%95%B0%E5%BC%8F%E6%8E%A5%E5%8F%A3"><span class="toc-number">1.13.5.</span> <span class="toc-text">13.5 常用的函数式接口</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#0721-%E5%8D%81%E5%9B%9B"><span class="toc-number">1.14.</span> <span class="toc-text">0721 十四</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#14-1-Stream%E6%B5%81"><span class="toc-number">1.14.1.</span> <span class="toc-text">14.1 Stream流</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#14-2-%E6%96%B9%E6%B3%95%E5%BC%95%E7%94%A8"><span class="toc-number">1.14.2.</span> <span class="toc-text">14.2 方法引用</span></a></li></ol></li></ol></li></ol></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2024 By myl</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=4.13.0"></script><script src="/js/main.js?v=4.13.0"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"><script>(() => {
  const getCount = () => {
    const countELement = document.getElementById('twikoo-count')
    if(!countELement) return
    twikoo.getCommentsCount({
      envId: 'https://www.manyile.top',
      region: 'ap-shanghai',
      urls: [window.location.pathname],
      includeReply: false
    }).then(res => {
      countELement.textContent = res[0].count
    }).catch(err => {
      console.error(err)
    })
  }

  const init = () => {
    twikoo.init(Object.assign({
      el: '#twikoo-wrap',
      envId: 'https://www.manyile.top',
      region: 'ap-shanghai',
      onCommentLoaded: () => {
        btf.loadLightbox(document.querySelectorAll('#twikoo .tk-content img:not(.tk-owo-emotion)'))
      }
    }, null))

    GLOBAL_CONFIG_SITE.isPost && getCount()
  }

  const loadTwikoo = () => {
    if (typeof twikoo === 'object') setTimeout(init,0)
    else getScript('https://cdn.jsdelivr.net/npm/twikoo@1.6.31/dist/twikoo.all.min.js').then(init)
  }

  if ('Twikoo' === 'Twikoo' || !true) {
    if (true) btf.loadComment(document.getElementById('twikoo-wrap'), loadTwikoo)
    else loadTwikoo()
  } else {
    window.loadOtherComment = loadTwikoo
  }
})()</script></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>