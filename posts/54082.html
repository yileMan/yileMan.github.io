<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><!-- 百度的html标记--><meta name="baidu-site-verification" content="codeva-bSLYjtWXtR"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>整理 | myl's blog</title><meta name="author" content="myl"><meta name="copyright" content="myl"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="https://pdai.tech https://javaguide.cn https://xiaolincoding.com/ 一 JavaSE1数据类型 8个基本：boolean(1)、byte(8)、char(16)、short(16)、int(32)、float(32)、long(64)、double(64) Integer缓存池范围 -128~127  String的不可变性  可以缓">
<meta property="og:type" content="article">
<meta property="og:title" content="整理">
<meta property="og:url" content="http://yileman.github.io/posts/54082.html">
<meta property="og:site_name" content="myl's blog">
<meta property="og:description" content="https://pdai.tech https://javaguide.cn https://xiaolincoding.com/ 一 JavaSE1数据类型 8个基本：boolean(1)、byte(8)、char(16)、short(16)、int(32)、float(32)、long(64)、double(64) Integer缓存池范围 -128~127  String的不可变性  可以缓">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/cover/article_cover2.png">
<meta property="article:published_time" content="2024-05-12T00:00:00.000Z">
<meta property="article:modified_time" content="2024-08-19T09:58:12.308Z">
<meta property="article:author" content="myl">
<meta property="article:tag" content="基础">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/cover/article_cover2.png"><link rel="shortcut icon" href="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/touxiang.jpg"><link rel="canonical" href="http://yileman.github.io/posts/54082.html"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="preconnect" href="//busuanzi.ibruce.info"><meta name="baidu-site-verification" content="codeva-bSLYjtWXtR"><link rel="stylesheet" href="/css/index.css?v=4.13.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.11.1/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '整理',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-08-19 17:58:12'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><link rel="stylesheet" href="/css/modify.css"><link rel="stylesheet" href="/css/user.css"><link rel="stylesheet" href="/css/rightMenu.css"><link rel="stylesheet" href="/css/iconfont.css"><link rel="stylesheet" href="/css/mouse.css"><link rel="stylesheet" href="https://cdn1.tianli0.top/gh/zhheo/Post-Abstract-AI@0.15.2/tianli_gpt.css"><link rel="stylesheet" href="/css/custom.css" media="defer" onload="this.media='all'"><!-- hexo injector head_end start --><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Zfour/hexo-electric-clock@1.0.6/clock.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Zfour/Butterfly-double-row-display@1.00/cardlistpost.min.css">
<style>#recent-posts > .recent-post-item >.recent-post-info > .article-meta-wrap > .tags:before {content:"\A";
  white-space: pre;}#recent-posts > .recent-post-item >.recent-post-info > .article-meta-wrap > .tags > .article-meta__separator{display:none}</style>
<link rel="stylesheet" href="https://unpkg.com/hexo-butterfly-tag-plugins-plus-chinese@latest/lib/assets/font-awesome-animation.min.css" media="defer" onload="this.media='all'"><link rel="stylesheet" href="https://unpkg.com/hexo-butterfly-tag-plugins-plus-chinese@latest/lib/tag_plugins.css" media="defer" onload="this.media='all'"><script src="https://unpkg.com/hexo-butterfly-tag-plugins-plus-chinese@latest/lib/assets/carousel-touch.js"></script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.1.1"></head><body><div id="loading-box"><div class="pokeball-back"></div><div class="pokeball-loading"><div class="pokeball" id="pokeball-normal"></div><div class="pokeball" id="pokeball-great"></div><div class="pokeball" id="pokeball-ultra"></div><div class="pokeball" id="pokeball-master"></div><div class="pokeball" id="pokeball-safari"></div></div></div><script>(()=>{
  const $loadingBox = document.getElementById('loading-box')
  const $body = document.body
  const preloader = {
    endLoading: () => {
      //- console.log("end")
      $body.style.overflow = 'auto'

      document.getElementById('loading-box').style.transition = 'opacity 3s ease 0s'
      document.getElementById('loading-box').style.opacity = '0'
      setTimeout(function(){
        document.getElementById('loading-box').classList.add("loaded")
      }, 3000);

      //- $loadingBox.classList.add('loaded')
    },
    initLoading: () => {
      $body.style.overflow = ''
      $loadingBox.classList.remove('loaded')
      
    }
  }

  preloader.initLoading()
  //- setTimeout(function(){preloader.endLoading();}, 3000);
  window.addEventListener('load',() => { preloader.endLoading() })
  document.getElementById('loading-box').addEventListener('click',()=> {preloader.endLoading()})

  if (true) {
    document.addEventListener('pjax:send', () => { preloader.initLoading() })
    document.addEventListener('pjax:complete', () => { preloader.endLoading() })
  }
})()</script><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/touxiang.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">23</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">8</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">4</div></a></div><hr class="custom-hr"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page" href="/comments/"><i class="fa-fw fa fa-link"></i><span> 留言板</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/cover/article_cover2.png')"><nav id="nav"><span id="blog-info"><a href="/" title="myl's blog"><span class="site-name">myl's blog</span></a></span><div id="menus"></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page" href="/comments/"><i class="fa-fw fa fa-link"></i><span> 留言板</span></a></div></div><center id="name-container"><a id="page-name" href="javascript:scrollToTop()">PAGE_NAME</a></center><div id="nav-right"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div id="randomPost"><a class="site-page social-icon search" href="javascript:;" onclick="randomPost()" title="随机访问一篇文章"><i class="fas fa-circle-notch fa-fw"></i></a></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">整理</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-05-12T00:00:00.000Z" title="发表于 2024-05-12 08:00:00">2024-05-12</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-08-19T09:58:12.308Z" title="更新于 2024-08-19 17:58:12">2024-08-19</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/study/">study</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="整理"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><div class="top-img" style="background-image: url('https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/cover/article_cover2.png');"></div><article class="post-content" id="article-container"><p><a target="_blank" rel="noopener" href="https://pdai.tech">https://pdai.tech</a></p>
<p><a target="_blank" rel="noopener" href="https://javaguide.cn">https://javaguide.cn</a></p>
<p><a target="_blank" rel="noopener" href="https://xiaolincoding.com/">https://xiaolincoding.com/</a></p>
<h2 id="一-JavaSE"><a href="#一-JavaSE" class="headerlink" title="一 JavaSE"></a>一 JavaSE</h2><h3 id="1数据类型"><a href="#1数据类型" class="headerlink" title="1数据类型"></a>1数据类型</h3><ul>
<li>8个基本：boolean(1)、byte(8)、char(16)、short(16)、int(32)、float(32)、long(64)、double(64)</li>
<li><p>Integer缓存池范围 <code>-128~127</code></p>
</li>
<li><p>String的不可变性</p>
<ul>
<li>可以缓存hash值</li>
<li>线程安全（因为不可改变）</li>
<li><code>StringBuffer</code>是线程安全的，用了<code>synchronized</code>  同步</li>
</ul>
</li>
</ul>
<h3 id="2-接口"><a href="#2-接口" class="headerlink" title="2 接口"></a>2 接口</h3><ul>
<li>java8开始可以拥有默认的实现</li>
</ul>
<h3 id="3-抽象类"><a href="#3-抽象类" class="headerlink" title="3 抽象类"></a>3 抽象类</h3><ul>
<li><code>abstract</code>修饰，不能被实例化，包含了抽象方法 </li>
</ul>
<h3 id="4-Object类通用方法"><a href="#4-Object类通用方法" class="headerlink" title="4 Object类通用方法"></a>4 <code>Object</code>类通用方法</h3><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> Class&lt;?&gt; getClass() </span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> <span class="comment">// 返回散列值，判断对象是否等价</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">// 比较地址，一般重写，重写equals的时候一般也会重写hashCode方法，保证相等的对象hash也一样</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object obj)</span> </span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">native</span> Object <span class="title function_">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">notify</span><span class="params">()</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">notifyAll</span><span class="params">()</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">wait</span><span class="params">(<span class="type">long</span> timeout)</span> <span class="keyword">throws</span> InterruptedException</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">wait</span><span class="params">(<span class="type">long</span> timeout, <span class="type">int</span> nanos)</span> <span class="keyword">throws</span> InterruptedException</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">wait</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable {}</span><br></pre></td></tr></tbody></table></figure>
<h3 id="5-static"><a href="#5-static" class="headerlink" title="5 static"></a>5 static</h3><ul>
<li>初始化顺序：父类静态变量、代码块 ==&gt; 子类… ==&gt; 父类实例变量、代码块 ==&gt; 父类构造函数 ==&gt; 子类… ==&gt; 子类… </li>
</ul>
<h3 id="6-反射"><a href="#6-反射" class="headerlink" title="6 反射"></a>6 反射</h3><ul>
<li><p>相关类</p>
<ul>
<li><p><code>Field</code> ：表示类的成员变量，get set方法可以修改</p>
</li>
<li><p><code>Method</code> ：表示类的成员方法，<code>invoke()</code> 调用</p>
</li>
<li><p><code>Constructor</code> ：表示类的构造方法，新建对象</p>
</li>
</ul>
</li>
<li><p>class获取方式</p>
<ul>
<li><code>类名.class</code></li>
<li><code>对象.getClass()</code></li>
<li><code>Class.forName()</code></li>
</ul>
</li>
</ul>
<h3 id="7-异常"><a href="#7-异常" class="headerlink" title="7 异常"></a>7 异常</h3><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/image-20240514212224245.png" alt="image-20240514212224245" style="zoom:50%;"></p>
<ul>
<li><code>Error</code>：JVM不可捕获，程序崩溃<ul>
<li><code>OutOfMemoryError</code>、<code>StackOverflowError</code>…</li>
</ul>
</li>
<li><code>Exception</code>：<ul>
<li><code>RunTimeException</code></li>
<li><code>IOException</code></li>
</ul>
</li>
<li>尽量使用标准的异常</li>
<li>建立异常对象是建立一个普通Object耗时的约20倍，而抛出、接住一个异常对象，所花费时间大约是建立异常对象的4倍。</li>
</ul>
<h3 id="8-泛型"><a href="#8-泛型" class="headerlink" title="8 泛型"></a>8 泛型</h3><ul>
<li><p>泛型数组声明</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;?&gt;[] lists = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;?&gt;[<span class="number">10</span>]; <span class="comment">//OK </span></span><br><span class="line">List&lt;String&gt;[] lists = <span class="keyword">new</span> <span class="title class_">ArrayList</span>[<span class="number">10</span>]; <span class="comment">//OK，但是会有警告</span></span><br></pre></td></tr></tbody></table></figure>
</li>
</ul>
<h3 id="9-注解"><a href="#9-注解" class="headerlink" title="9 注解"></a>9 注解</h3><p><a target="_blank" rel="noopener" href="https://pdai.tech/md/java/basic/java-basic-x-annotation.html">https://pdai.tech/md/java/basic/java-basic-x-annotation.html</a></p>
<ul>
<li><p>java自带的标准注解</p>
<ul>
<li><p><code>@Override</code> ：标明重写某个方法</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.METHOD)</span> <span class="comment">// 注解作用于方法</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.SOURCE)</span> <span class="comment">// 编译时有效</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Override {</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p><code>@Deprecated</code>：标明方法过时</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Documented</span> <span class="comment">// 会文档化</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span> <span class="comment">// 运行时有效</span></span><br><span class="line"><span class="meta">@Target(value={CONSTRUCTOR, FIELD, LOCAL_VARIABLE, METHOD, PACKAGE, PARAMETER, TYPE})</span></span><br><span class="line"><span class="comment">// 能修饰构造方法，属性，局部变量，方法，包，参数，类型</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Deprecated {</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p><code>@SuppressWarnings</code>：标明要忽略的警告</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target({TYPE, FIELD, METHOD, PARAMETER, CONSTRUCTOR, LOCAL_VARIABLE})</span></span><br><span class="line"><span class="comment">// 类型、属性、方法、参数、构造器、局部变量</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.SOURCE)</span> <span class="comment">// 只能存活在源码时</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> SuppressWarnings {</span><br><span class="line">    String[] value();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
</li>
</ul>
</li>
<li><p>元注解</p>
<ul>
<li><code>@Retention</code>：标明注解被保留的阶段<ul>
<li><code>TYPE</code>、<code>FIELD</code>、<code>METHOD</code>、<code>PARAMETER</code>、<code>CONSTRUCTOR</code>、<code>LOCAL_VARIABLE</code>、<code>ANNOTATION_TYPE</code>、<code>PACKAGE</code>、<code>TYPE_PARAMETER</code>、<code>TYPE_USE</code> </li>
</ul>
</li>
<li><code>@Target</code>：标明注解使用的范围<ul>
<li><code>SOURCE</code>、<code>CLASS</code>、<code>RUNTIME</code>   </li>
</ul>
</li>
<li><code>@Inherited</code>：标明注解可继承</li>
<li><code>@Documented</code>：标明是否生成javadoc文档</li>
</ul>
</li>
<li><p>自定义注解</p>
</li>
</ul>
<h3 id="10-SPI机制"><a href="#10-SPI机制" class="headerlink" title="10 SPI机制"></a>10 SPI机制</h3><ul>
<li><p>整体机制图</p>
<p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/image-20240514231034618.png" alt="image-20240514231034618" style="zoom:50%;"></p>
<ul>
<li>当服务的提供者提供了一种接口的实现之后，需要在classpath下的<code>META-INF/services/</code>目录里创建一个以服务接口命名的文件，这个文件里的内容就是这个接口的具体的实现类。</li>
</ul>
</li>
<li><p>demo</p>
<ul>
<li><p>定义接口与两个实现</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Search</span> {</span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">searchDoc</span><span class="params">(String keyword)</span>;   </span><br><span class="line">}</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileSearch</span> <span class="keyword">implements</span> <span class="title class_">Search</span>{</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">searchDoc</span><span class="params">(String keyword)</span> {</span><br><span class="line">        System.out.println(<span class="string">"文件搜索 "</span> + keyword);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DatabaseSearch</span> <span class="keyword">implements</span> <span class="title class_">Search</span>{</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">searchDoc</span><span class="params">(String keyword)</span> {</span><br><span class="line">        System.out.println(<span class="string">"数据搜索 "</span> + keyword);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>接下来可以在resources下新建META-INF/services/目录，然后新建接口全限定名的文件：<code>com.cainiao.ys.spi.learn.Search</code>，里面加上我们需要用到的实现类</p>
<figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">com.cainiao.ys.spi.learn.FileSearch</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>测试</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestCase</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        ServiceLoader&lt;Search&gt; s = ServiceLoader.load(Search.class);</span><br><span class="line">        Iterator&lt;Search&gt; iterator = s.iterator();</span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext()) {</span><br><span class="line">           <span class="type">Search</span> <span class="variable">search</span> <span class="operator">=</span>  iterator.next();</span><br><span class="line">           search.searchDoc(<span class="string">"hello world"</span>);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="comment">// 最终输出文件搜索</span></span><br></pre></td></tr></tbody></table></figure>
</li>
</ul>
</li>
<li><p>SPI机制的广泛应用</p>
<ul>
<li>JDBC DriverManager<ul>
<li>java中定义了<code>java.sql.Driver</code>但是没有实现（由不同的厂商实现）</li>
<li>mysql的jar包中可以找到<code>META-INF/services</code>目录下有一个<code>java.sql.Driver</code>，文件内容是：<code>com.mysql.cj.jdbc.Driver</code>就是针对Java中定义的接口实现</li>
</ul>
</li>
<li>Spring中的SPI机制<ul>
<li>自动装配中最终会加载<code>META-INF/spring.factories</code>文件</li>
</ul>
</li>
</ul>
</li>
<li><p>SPI机制的一般流程</p>
<ul>
<li>定义标准。比如接口<code>java.sql.Driver</code></li>
<li>具体厂商或框架开发者实现。在<code>META-INF/services</code>目录下定义一个名字为接口全限名的文件，如<code>java.sql.Driver</code>，文件内容是具体的实现名称，比如<code>me.cxis.sql.MyDriver</code>就是对接口的实现</li>
<li>程序的使用：引用具体厂商jar包来实现功能。</li>
</ul>
</li>
<li><p>缺陷</p>
<ul>
<li>不能按需加载，需要遍历所有的实现并实例化</li>
<li>获取某个实现类的方式不够灵活，只能通过 Iterator 形式获取，不能根据某个参数来获取对应的实现类。</li>
<li>多个并发线程使用不安全</li>
</ul>
</li>
</ul>
<h3 id="11-集合框架"><a href="#11-集合框架" class="headerlink" title="11 集合框架"></a>11 集合框架</h3><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/image-20240518130341928.png" alt="image-20240518130341928"></p>
<ul>
<li><p><code>Map</code></p>
<ul>
<li><p><code>TreeMap</code>：base红黑树</p>
</li>
<li><p><code>HashMap</code>：base哈希表,<code>hashCode()</code>和<code>equals()</code>决定了存放的位置</p>
<ul>
<li><p>put过程</p>
<p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/image-20240314172246695.png" alt="image-20240314172246695" style="zoom:67%;"></p>
</li>
</ul>
</li>
<li><p><code>HashTable</code>：base哈希表，线程安全，但是一般使用<code>ConcurrentHashMap</code> （分段锁）</p>
</li>
<li><p><code>LinkedHashSMap</code>：base双向链表，顺序为LRU(最近最少使用)顺序</p>
</li>
</ul>
</li>
<li><p><code>Collection</code></p>
<ul>
<li><p><code>Set</code></p>
<ul>
<li><code>TreeSet</code>：base红黑树，有序，查找时间O(logN)</li>
<li><code>HashSet</code>：base哈希表，无序，查找O(1)</li>
<li><code>LinkedHashSet</code>：base双向链表，有序，查找O(1)</li>
</ul>
</li>
<li><p><code>Queue</code></p>
<ul>
<li><code>LinkedList</code>：双向队列</li>
<li><code>PriorityQueue</code>：base完全二叉树实现的小顶堆，优先级队列，需要自定义一个 <code>Comparator</code>比较器</li>
</ul>
<blockquote>
<p>完全二叉树：除了最后一层,所有层填满,且叶子节点都在左边</p>
<p>小顶堆：特殊的完全二叉树,父节点的值小于子节点的值</p>
<p>移除顶部的过程:</p>
<p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/image-20240518161346769.png" alt="image-20240518161346769" style="zoom: 50%;"></p>
</blockquote>
</li>
<li><p><code>List</code></p>
<ul>
<li><code>ArrayList</code>：base动态数组，扩容代价大(每次扩容1.5)，最好在创建前指定好容量</li>
<li><code>Vector</code>：同上，但是线程安全,但是一般用<code>CopyOnWriteArrayList</code></li>
<li><code>LinkedList</code>：base双向链表，还可以用作栈、队列、双向队列</li>
</ul>
</li>
</ul>
</li>
<li><p><code>PriorityQueue</code>的使用</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">PriorityQueue&lt;Integer&gt; pq = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;Integer&gt;() {</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Integer e1, Integer e2)</span> {</span><br><span class="line">        <span class="comment">//比较方法</span></span><br><span class="line">        <span class="keyword">return</span> e1 - e2;</span><br><span class="line">    }</span><br><span class="line">});</span><br><span class="line"></span><br><span class="line"><span class="comment">// or</span></span><br><span class="line"></span><br><span class="line">PriorityQueue&lt;Integer&gt; pq2 = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;((Integer e1, Integer e2) -&gt; {</span><br><span class="line">	<span class="keyword">return</span> e1 - e2; <span class="comment">// 升序 1 2 3...</span></span><br><span class="line">});</span><br></pre></td></tr></tbody></table></figure>
</li>
</ul>
<h2 id="二-JVM"><a href="#二-JVM" class="headerlink" title="二 JVM"></a>二 JVM</h2><h3 id="1-类加载"><a href="#1-类加载" class="headerlink" title="1 类加载"></a>1 类加载</h3><ul>
<li><p>由JVM将代码生成对应的字节码文件(.class)，有javac编译器、scalac编译器、groovyc编译器、kotlinc编译器，对应不同的编程语言</p>
<ul>
<li>.class文件本质上是8位字节为基础的二进制流</li>
</ul>
</li>
<li><p>.class文件的结构</p>
<ul>
<li>魔数：头4个字节(cafe babe)，作用就是确定是一个class文件（图片的格式也有对应的魔数）</li>
<li>常量池：存储变量/方法的属性、类型、名称</li>
<li>访问标志：表示类的属性和访问类型（接口/类？public？final？）</li>
<li>类索引、父索引、接口索引：用于确定类的继承关系</li>
<li>字段表属性：表示变量的属性和访问类型</li>
<li>方法表属性：表示方法的属性和访问类型</li>
<li>属性表属性：描述某些场景专有的信息</li>
</ul>
</li>
<li><p>反编译字节码：<code>javap &lt;options&gt; &lt;classes&gt;</code></p>
</li>
<li><p>类生命周期</p>
<p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/image-20240526141058649.png" alt="image-20240526141058649" style="zoom:50%;"></p>
<ul>
<li><p>加载：</p>
<ul>
<li>根据类的全限定名来获取定义的二进制字节流</li>
<li>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构</li>
<li>在Java堆中生成一个代表这个类的java.lang.Class对象，作为堆方法区数据的访问入口</li>
</ul>
</li>
<li><p>验证：检查文件格式、字节码等</p>
</li>
<li><p>准备：在方法区为类的静态变量分配内存，并设置为默认值（0，0L，null，false）</p>
</li>
<li><p>解析： 把类中的符号引用转换为直接引用</p>
</li>
<li><p>初始化：为类的静态变量赋值</p>
<blockquote>
<p> 什么时候初始化类？</p>
<ul>
<li>new、访问静态变量/方法、反射、初始化子类，父类也会初始化、启动类</li>
</ul>
</blockquote>
</li>
<li><p>使用：类访问方法内的数据结构的接口，对象是堆的数据</p>
</li>
<li><p>虚拟机结束：执行System.exit()方法、程序结束、程序异常或错误退出、操作系统错误退出程序</p>
</li>
</ul>
</li>
<li><p>类加载器（从上到下）</p>
<ul>
<li>启动类加载器<code>Bootstrap ClassLoader</code>：负责加载JDK\jre\lib下的类</li>
<li>扩展类加载器<code>Extension ClassLoader</code>：负责加载JDK\jre\lib\ext下的类</li>
<li>应用程序类加载器<code>Application ClassLoader</code>：负责加载用户类路径(ClassPath)所指定的类</li>
</ul>
</li>
<li><p>类的加载方式</p>
<ul>
<li>命令行启动应用的时候JVM加载</li>
<li><code>Class.forName()</code>：将类加载到JVM中之后还会执行static块</li>
<li><code>ClassLoader.loadClass()</code>：只加载到JVM中，当newInstance的时候才加载static块</li>
</ul>
</li>
<li><p>类加载机制</p>
<ul>
<li>全盘负责、父类委托、缓存机制、<strong>双亲委派</strong></li>
</ul>
</li>
<li><p>双亲委派：</p>
<ul>
<li>执行loadClass的时候会优先调用父类的<code>loadClass()</code>方法，然后再调用自己的<code>findClass()</code></li>
</ul>
</li>
</ul>
<h3 id="2-内存结构"><a href="#2-内存结构" class="headerlink" title="2 内存结构"></a>2 内存结构</h3><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/image-20240526142905481.png" alt="image-20240526142905481"></p>
<p>线程私有：程序计数器、虚拟机栈、本地方法区</p>
<p>线程共享：堆、方法区、堆外内存（java7的永久代或java8的元空间）</p>
<ul>
<li><p>程序计数器：用于标注当前线程执行的字节码行号（区别于操作系统的PC寄存器）</p>
</li>
<li><p>虚拟机栈：保存局部变量、结果，参与方法的返回和调用</p>
<ul>
<li><p>StackOverflowError 、OutOfMemoryError</p>
</li>
<li><p>存储单位是栈帧</p>
</li>
<li><p>栈帧的内部结构</p>
<p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/image-20240526143620243.png" alt="image-20240526143620243" style="zoom: 50%;"></p>
</li>
</ul>
</li>
<li><p>本地方法区</p>
<ul>
<li>本地方法接口</li>
<li>本地方法栈</li>
</ul>
</li>
<li><p>堆：存储对象实例</p>
<ul>
<li>新生代：分为Eden、S1、S2（8:1:1）<ul>
<li>新生代的GC叫Minor/Young  GC，每次GC从Eden中找幸存者并将他们和S1或者S2的所有对象移到S2或者S1去，并回收S1/S2以及Eden中的剩余对象，多次GC（默认15次）后转移到老年代</li>
</ul>
</li>
<li>老年代<ul>
<li>Major/Old  GC</li>
<li>大对象直接进入老年代</li>
<li>OOM异常</li>
</ul>
</li>
<li>相关JVM参数<ul>
<li><code>-Xmx</code>：堆起始大小，一般为电脑内存/64</li>
<li><code>-Xms</code>：堆最大内存，一般为电脑内存/4</li>
</ul>
</li>
</ul>
</li>
<li><p>方法区：存储类信息、常量池、静态变量、JIT编译后的代码等数据</p>
<ul>
<li>java8之前在堆中(永久代)，java8移到了元空间(本地内存中)</li>
<li>相关JVM参数<ul>
<li><code>-XX:PermSize</code>、<code>-xx:MaxPermSize</code>：永久代空间</li>
<li><code>-XX:MetaspaceSize</code>、<code>-XX:MaxMetaspaceSize</code>：元空间</li>
</ul>
</li>
<li>垃圾回收：常量池中废弃的常量和不再使用的类型</li>
</ul>
</li>
</ul>
<h3 id="3-java内存模型"><a href="#3-java内存模型" class="headerlink" title="3 java内存模型"></a>3 java内存模型</h3><ul>
<li><p>负责实现java线程间的通信(JMM)：决定一个线程对共享变量的写入何时对另一个线程可见。是一个抽象的模型</p>
</li>
<li><p>重排序：导致内存可见性问题</p>
<ul>
<li>编译器优化的重排序：编译器不改变单线程程序语义的前提下做的</li>
<li>指令级并行的重排序：改变语句对应机器指令的执行顺序</li>
<li>内存系统的重排序</li>
</ul>
</li>
</ul>
<h3 id="4-垃圾回收"><a href="#4-垃圾回收" class="headerlink" title="4 垃圾回收"></a>4 垃圾回收</h3><ul>
<li><p>判断对象是否可被回收</p>
<ul>
<li>引用计数算法：计算引用次数，为0就可回收（有循环，所以java不用）</li>
<li>可达性算法：通过GC Root作为起点进行搜索，不可达的就可回收<ul>
<li>虚拟机栈中对象、本地方法栈对象、方法区中类静态属性引用的对象、方法区中常量引用的对象</li>
</ul>
</li>
<li>方法区的回收：主要是常量池和对类的卸载</li>
</ul>
</li>
<li><p>引用类型</p>
<ul>
<li><p>强引用：不会被回收</p>
</li>
<li><p>软引用：内存不足会被回收</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SoftReference&lt;Object&gt; sf = <span class="keyword">new</span> <span class="title class_">SoftReference</span>&lt;Object&gt;(obj);</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>弱引用：一定会被回收，只能存活到下次垃圾回收前</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">WeakReference&lt;Object&gt; wf = <span class="keyword">new</span> <span class="title class_">WeakReference</span>&lt;Object&gt;(obj);</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>虚引用：为一个对象设置虚引用关联的唯一目的就是能在这个对象被回收时收到一个系统通知。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PhantomReference&lt;Object&gt; pf = <span class="keyword">new</span> <span class="title class_">PhantomReference</span>&lt;Object&gt;(obj);</span><br></pre></td></tr></tbody></table></figure>
</li>
</ul>
</li>
<li><p>垃圾回收算法</p>
<ul>
<li>标记-清除</li>
<li>标记-整理</li>
<li>复制：（Eden，S1，S2）</li>
<li>分代收集<ul>
<li>新生代用复制</li>
<li>老年代用标记-清除/整理</li>
</ul>
</li>
</ul>
</li>
<li><p>垃圾收集器</p>
<ul>
<li>Serial 收集器：单线程，GC的时候用户线程停止</li>
<li>ParNew 收集器：新生代多线程，老年代单线程；，GC的时候用户线程停止</li>
<li>Parallel Scavenge 收集器：同上，但是其侧重点在于单次的吞吐量（即减少GC的频率）</li>
<li>Serial Old 收集器：Serial 收集器的老年代版本（不懂）</li>
<li>Parallel Old 收集器：两个都是多线程，Parallel Scavenge 收集器的老年代版本</li>
<li>CMS(Concurrent Mark Sweep) 收集器：多线程，GC和用户线程并行<ul>
<li>初始标记：用户线程暂停，标记GC Root直接关联的对象（很快）</li>
<li>并发标记：用户线程继续，进行GC Root标记</li>
<li>重新标记：用户线程暂停，修正并发时间内的变化</li>
<li>并发清除：用户线程继续</li>
</ul>
</li>
<li>G1 收集器</li>
</ul>
</li>
<li><p>内存分配和回收策略</p>
<ul>
<li>回收策略<ul>
<li>Minor GC/Young GC：新生代</li>
<li>Major GC/Old GC：老年代</li>
<li>Full GC：整个java堆和方法区</li>
</ul>
</li>
<li>内存分配策略<ul>
<li>优先Eden</li>
<li>大对象进入老年代</li>
<li>长期存活进入老年代</li>
</ul>
</li>
<li>Full GC条件<ul>
<li>调用<code>System.gc()</code>不建议使用</li>
<li>老年代空间不足</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="5-JVM参数-调优"><a href="#5-JVM参数-调优" class="headerlink" title="5 JVM参数/调优"></a>5 JVM参数/调优</h3><ul>
<li><p>JVM</p>
<figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-Xms -Xmx					   <span class="comment"># 堆最小/大值</span></span><br><span class="line">-Xmn 						   <span class="comment"># 新生代大小,一般为堆的1/4或者1/3</span></span><br><span class="line">-XX:NewRatio 				   <span class="comment"># 新生代与老年代比值</span></span><br><span class="line">-XX:PermSize  -XX:MaxPermSize  <span class="comment"># 老年代的初始值/最大值</span></span><br><span class="line">-XX:MaxTenuringThreshold 	   <span class="comment"># 新生代存活次数</span></span><br><span class="line">-XX:SurvivorRatio 			   <span class="comment"># Eden区与Subrvivor区大小的比值为8就是8:1:1</span></span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>垃圾回收器</p>
<figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">-XX:+UseSerialGC			   <span class="comment"># 串行回收器</span></span><br><span class="line">-XX:+UseParNewGC			   <span class="comment"># 新生代使用并行，老年代使用串行</span></span><br><span class="line">-XX:+UseConcMarkSweepGC		   <span class="comment"># 新生代使用并行，老年代使用CMS(一般都是使用这种方式)</span></span><br><span class="line">-XX:ParallelGCThreads		   <span class="comment"># 指定并行的垃圾回收线程的数量，最好等于CPU数量</span></span><br><span class="line">-XX:+DisableExplicitGC		   <span class="comment"># 禁用System.gc()，因为它会触发Full GC，这是很浪费性能的</span></span><br><span class="line">-XX:+PrintGCDetails			   <span class="comment"># 开启详细GC日志模式，日志的格式是和所使用的算法有关</span></span><br><span class="line">-XX:+PrintGCDateStamps		   <span class="comment"># 将时间和日期也加入到GC日志中</span></span><br></pre></td></tr></tbody></table></figure>
</li>
</ul>
<h3 id="6-分析工具"><a href="#6-分析工具" class="headerlink" title="6 分析工具"></a>6 分析工具</h3><ul>
<li>堆内存溢出OOM<ul>
<li>添加jvm参数：<code>-XX:+HeapDumpOnOutOfMemoryError</code>：在OutOfMemoryError后获取一份HPROF二进制Heap Dump文件</li>
</ul>
</li>
</ul>
<h3 id="7-JVM远程调试remote-debug"><a href="#7-JVM远程调试remote-debug" class="headerlink" title="7 JVM远程调试remote debug"></a>7 JVM远程调试remote debug</h3><ul>
<li><p>前提：远程服务器项目运行且两边代码一致</p>
</li>
<li><p>远程服务器启动时附带jvm参数</p>
<figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-Xdebug -Xrunjdwp:transport=dt_socket,<span class="built_in">suspend</span>=n,server=y,address=<span class="variable">${debug_port}</span></span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>idea打开，设置启动配置，输入远程机器ip和刚刚设置的端口</p>
<ul>
<li>打断点，如果断点右上角有√就代表成功了</li>
</ul>
</li>
</ul>
<h3 id="8-linux-问题排查"><a href="#8-linux-问题排查" class="headerlink" title="8 linux 问题排查"></a>8 linux 问题排查</h3><ul>
<li>文本<ul>
<li>文本查找 <code>grep</code></li>
<li>文本处理 <code>sed</code>（增删改查）</li>
</ul>
</li>
<li>文件<ul>
<li><code>tail -f filename</code>：循环监听</li>
<li>查找文件 find</li>
</ul>
</li>
<li>网络进程<ul>
<li>netstat</li>
</ul>
</li>
</ul>
<h2 id="三-并发"><a href="#三-并发" class="headerlink" title="三 并发"></a>三 并发</h2><h3 id="1-理论"><a href="#1-理论" class="headerlink" title="1 理论"></a>1 理论</h3><ul>
<li><p>多线程解决的问题（根本原因速度不同：内存 &gt; CPU &gt; IO设备）</p>
<ul>
<li><strong>可见性</strong>：CPU增加了缓存，均衡和内存的速度差异 ==&gt; 同时带来了<strong>可见性</strong>问题：不同线程对变量的修改不会马上被共享</li>
<li><strong>原子性</strong>：操作系统增加了进程、线程，以分时复用IO，均衡CPU与IO设备的差异 ==&gt; 带来了<strong>原子性</strong>问题：一个操作要么全成功/失败</li>
<li><strong>有序性</strong>：编译器优化程序指令，使缓存可以更好的利用 ==&gt; 带来了<strong>有序性</strong>问题</li>
</ul>
</li>
<li><p>Java如何解决并发问题：</p>
<ul>
<li><p>可见性：<code>volatile</code>关键字修饰的变量被所有线程可见</p>
</li>
<li><p>原子性：读取和简单赋值，如果需要更大范围的原子操作可以使用<code>synchronized</code>和<code>Lock</code></p>
</li>
<li><p>有序性：<code>volatile</code>禁止了JVM的指令重排，保证了有序性，<code>synchronized</code>和<code>Lock</code>也是</p>
</li>
</ul>
</li>
<li><p>不可变对象</p>
<ul>
<li>final修饰的基本数据类型(如果是对象的话它的成员变量是可以变的)</li>
<li>String</li>
<li>枚举</li>
<li>Number的部分子类,如Long和Double等,BigInteger和BigDecimal 等</li>
</ul>
</li>
</ul>
<p>​    </p>
<p>​    </p>
<h3 id="2-线程"><a href="#2-线程" class="headerlink" title="2 线程"></a>2 线程</h3><ul>
<li><p>线程状态</p>
<p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/image-20240518171545614.png" alt="image-20240518171545614" style="zoom:50%;"></p>
</li>
<li><p>实现(实现接口更好)</p>
<ul>
<li><code>Runnable</code>接口</li>
<li><code>Callable</code>接口</li>
<li>继承<code>Thread</code>类：三种方法本质都需要Thread类来启动</li>
<li>使用线程池</li>
</ul>
</li>
<li><p>线程安全的方法</p>
<ul>
<li>互斥同步<ul>
<li><code>synchronized</code>（JVM级别） 和 <code>ReentrantLock</code>（JDK级别）。</li>
</ul>
</li>
<li>非阻塞同步<ul>
<li>CAS算法</li>
</ul>
</li>
<li>不涉及共享数据就没有线程安全问题<ul>
<li><code>ThreadLocal</code> </li>
</ul>
</li>
</ul>
</li>
<li><p><code>Executor</code>（看不懂）</p>
</li>
<li><p><code>synchronized</code>和<code>ReentrantLock</code></p>
<ul>
<li>前者是JVM实现，后者是JDK实现</li>
<li>两者性能大致相同（因为新版本JVM对<code>synchronized</code>进行了优化，也支持了自旋锁等</li>
<li>前者不可中断，后者可以</li>
<li>优先使用前者，因为是JVM原生支持，且不用担心死锁问题，因为JVM会保证锁的释放</li>
</ul>
</li>
<li><p>线程池</p>
<ul>
<li>创建<ul>
<li><code>ThreadPoolExecutor</code>创建（推荐）</li>
<li>通过<code>Executor</code>框架的工具类 <code>Executors</code> 来创建。</li>
</ul>
</li>
<li>线程池参数：<ul>
<li>corePoolSize : 任务队列未达到队列容量时，最大可以同时运行的线程数量。</li>
<li>maximumPoolSize : 任务队列中存放的任务达到队列容量的时候，当前可以同时运行的线程数量变为最大线程数。</li>
<li>workQueue: 新任务来的时候会先判断当前运行的线程数量是否达到核心线程数，如果达到的话，新任务就会被存放在队列中。</li>
<li>keepAliveTime：当线程数大于corePoolSize 且没有新的任务提交，多余的空闲线程的等待时间</li>
<li>unit : keepAliveTime 参数的时间单位。</li>
<li>threadFactory :executor 创建新线程的时候会用到。</li>
<li>handler :饱和策略<ul>
<li><code>ThreadPoolExecutor.AbortPolicy</code>： 抛出 <code>RejectedExecutionException</code>来拒绝新任务的处理。<ul>
<li>推荐使用，让业务感知异常</li>
</ul>
</li>
<li><code>ThreadPoolExecutor.DiscardPolicy</code>：不处理新任务，直接丢弃掉。</li>
<li><code>ThreadPoolExecutor.DiscardOldestPolicy</code>： 此策略将丢弃最早的未处理的任务请求。</li>
<li><code>ThreadPoolExecutor.CallerRunsPolicy</code>：由调用线程处理该任务。如果执行程序已关闭，则会丢弃该任务</li>
</ul>
</li>
</ul>
</li>
<li>参数设置原则<ul>
<li>最佳corePoolSize ，N为CPU的核数<ul>
<li>如果是IO密集型（CPU计算时间短，而等待IO操作（如读写文件、网络通信等）的时间长）的任务就设置为2N</li>
<li>文件处理，数据库读写，网络操作等</li>
<li>如果是CPU密集型（几乎没有IO等待）就设置为N+1</li>
<li>数值计算、图像视频处理、加密解密、模型训练等</li>
<li>还可以这样计算：<code>((线程等待时间+线程CPU时间) / 线程CPU时间)* CPU数目</code></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>线程池解决了什么问题</p>
<ul>
<li>频繁申请/销毁资源和调度资源，将带来额外的消耗</li>
<li>对资源无限申请缺少抑制手段，易引发系统资源耗尽的风险</li>
<li>系统无法合理管理内部的资源分布，会降低系统的稳定性</li>
</ul>
</li>
<li>实际使用的问题：参数不好配置<ul>
<li>最大核心数设置偏小容易导致抛出拒绝异常，触发接口降级</li>
<li>队列设置过长，大量任务堆积在队列中，任务执行时间长，导致超时</li>
</ul>
</li>
</ul>
<h3 id="3-锁"><a href="#3-锁" class="headerlink" title="3 锁"></a>3 锁</h3><ul>
<li><p>Java的锁分类</p>
<ul>
<li><p>线程是否锁同步资源</p>
<ul>
<li>乐观锁：采用无锁编程实现，CAS算法</li>
<li>悲观锁：<code>synchronized</code>关键字和<code>Lock</code>的实现类实现<ul>
<li><code>ReentrantLock</code>、<code>ReadLock</code>、<code>WriteLock</code>（后两者是<code>ReentrantReadWriteLock</code>内部类）</li>
</ul>
</li>
</ul>
</li>
<li><p>锁住同步资源失败时，线程要不要阻塞</p>
<blockquote>
<p>为什么要非阻塞？阻塞线程要切换CPU的状态，耗时，自旋就是不让线程阻塞（及不放弃CPU的时间片）</p>
</blockquote>
<ul>
<li>阻塞</li>
<li>非阻塞<ul>
<li>自旋锁</li>
<li>适应性自旋锁</li>
</ul>
</li>
</ul>
</li>
<li><p>多个线程竞争同步资源的流程细节</p>
<ul>
<li>这是针对<code>synchronized</code>的优化，表示锁的四个状态</li>
<li>无锁</li>
<li>偏向锁：同一个线程执行同步资源时自动获取资源</li>
<li>轻量级锁：多个线程竞争时，没获取资源的线程自旋等待所释放</li>
<li>重量级锁：多个线程竞争时，没获取资源的线程阻塞等待被唤醒</li>
</ul>
</li>
<li><p>多个线程竞争锁时要不要排队</p>
<ul>
<li>公平锁</li>
<li>非公平锁：先尝试插队，失败了再排队</li>
</ul>
</li>
<li><p>一个线程的多个流程能不能获取同一把锁（前提是锁的是同一个对象或者class）</p>
<ul>
<li>可重入锁：<code>ReentrantLock</code>和<code>synchronized</code></li>
<li>不可重入锁</li>
</ul>
</li>
<li><p>多个线程能否共享锁</p>
<ul>
<li>共享锁：<code>ReentrantReadWriteLock</code>，本质是里面的两把锁，读锁和写锁</li>
<li>排他锁：<code>synchronized</code>和JUC中<code>Lock</code>的实现类就是互斥锁。</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li><p>死锁的四大条件</p>
<ul>
<li>互斥条件：一个资源每次只能被一个进程使用。</li>
<li>请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。</li>
<li>不剥夺/非抢占条件:进程已获得的资源，在末使用完之前，不能强行剥夺。</li>
<li>循环等待条件:若干进程之间形成一种头尾相接的循环等待资源关系。</li>
</ul>
</li>
</ul>
<ul>
<li><p>死锁的解决</p>
<ul>
<li>破坏互斥：让资源可以同时访问（往往行不通）</li>
<li>破坏非抢占：剥夺式调度算法，但是会导致资源利用率低（不怎么用）</li>
<li>破坏请求与保持：静态分配策略：在进程执行之前先获取到他需要的所有资源，如果不满足就不开启（会导致资源利用率低，因为部分资源可能在进程后期才会用）</li>
<li>破坏循环等待：层次分配策略：将资源分层，先释放低层次的资源再获取高层次的资源</li>
</ul>
</li>
</ul>
<h3 id="4-关键字"><a href="#4-关键字" class="headerlink" title="4 关键字"></a>4 关键字</h3><ul>
<li><p><code>Synchronized</code></p>
<ul>
<li>基于JVM，本质是根据<code>monitorenter</code>和<code>monitorexit</code>指令来控制程序执行</li>
<li>两个指令是依赖于操作系统的Mutex Lock实现，而Mutex Lock要切换到内核态才能执行，代价昂贵</li>
</ul>
</li>
<li><p><code>volatile</code></p>
<ul>
<li><p>作用：防止重排、保证线程之间的可见性、保证原子性(32位系统的long、double的单次读/写)</p>
<blockquote>
<p>32位系统一次读/写32位，而long和double是64位的</p>
</blockquote>
</li>
</ul>
</li>
<li><p><code>final</code></p>
<ul>
<li><p>如果要扩展<code>final</code>关键字修饰的类的功能，怎么做？ <code>final</code>无法继承/实现，所以通过组合</p>
</li>
<li><p>关于final的指令重排序（因为final字段必须在构造函数执行完成之前初始化完成）</p>
<ul>
<li>对于基本数据类型<ul>
<li>写：禁止final域写与构造方法重排序(禁止final域写重排序到构造方法之外，保证对象初始化完后，final已经全部初始化)</li>
<li>读：禁止初次读对象的引用与读该对象包含的final域的重排序。</li>
</ul>
</li>
<li>对于引用数据类型<ul>
<li>额外增加：禁止在构造函数对一个final修饰的对象的成员域的写入与随后将这个被构造的对象的引用赋值给引用变量 重排序</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="5-JUC框架"><a href="#5-JUC框架" class="headerlink" title="5 JUC框架"></a>5 JUC框架</h3><ul>
<li><p>即java.util.concurrent包</p>
</li>
<li><p>主要部分：Lock框架和Tools类、Collections(并发集合)、Atomic(原子类)、Executors(线程池)</p>
</li>
<li><p>原子类<code>Atomic</code></p>
<ul>
<li>本质是CAS算法(乐观锁)</li>
<li>如<code>AtomicInteger</code> 有<code>add()</code>方法可以实现不加锁的情况下并发数据的一致性</li>
<li>还有<code>AtomicBoolean</code>、<code>AtomicLong</code>、<code>AtomicIntegerArray</code>、<code>AtomicLongArray</code>、<code>AtomicReferenceArray</code>等</li>
<li>如何解决ABA问题？<code>AtomicStampedReference.compareAndSet()</code>方法可以检查</li>
</ul>
</li>
<li><p><code>LockSupport</code>：用来创建锁和其他同步类的基本线程阻塞</p>
<ul>
<li><code>park()</code>函数：阻塞线程</li>
<li><code>unpark()</code>函数：激活线程</li>
<li><code>Thread.sleep()</code>和<code>LockSupport.park()</code><ul>
<li>都阻塞当前线程，且都不会释放资源</li>
<li>前者不能通过外部唤醒，只能自己苏醒；后者可以通过另外一个线程的unpark唤醒</li>
<li>前者需要抛出InterruptedException中断异常；后者没有</li>
<li>前者本身是一个native方法；后者底层是调用Unsafe的native方法</li>
</ul>
</li>
</ul>
</li>
<li><p>锁的核心类AQS(<code>AbstractQueuedSynchronizer</code>)</p>
<ul>
<li>核心思想：如果资源空闲，如果空闲则将请求资源的线程设置为有效的工作线程并锁定资源；如果资源被占用，则将线程加入到CLH队列等待</li>
<li>AQS定义的资源共享方式：<ul>
<li>独占：只有一个线程能获取资源，如<code>ReentrantLock</code>，分为公平锁/非公平锁</li>
<li>共享：多个线程可以同时执行，如<code>Semaphore/CountDownLatch</code>、<code>Semaphore</code>、<code>CountDownLatCh</code>、 <code>CyclicBarrier</code>、<code>ReadWriteLock</code></li>
</ul>
</li>
</ul>
</li>
<li><p><code>ReentrantLock</code>：独占锁</p>
<ul>
<li>里面有三个内部类<code>Sync extends AQS</code>及其两个子类：<code>NonfairSync</code>、<code>FairSync</code>，分别实现公平/非公平策略</li>
<li>构造函数默认使用的是<code>NonfairSync</code></li>
<li>对其操作都转化为了对<code>Sync</code>对象的操作，进而转换为对<code>AQS</code>的操作</li>
</ul>
</li>
<li><p><code>ReentrantReadWriteLock</code>：读写锁(满足多读的场景)</p>
<ul>
<li>除了<code>ReentrantLock</code>里面的三个内部类外，还有<code>ReadLock</code>和<code>WriteLock</code>均是<code>Lock</code>的实现</li>
</ul>
</li>
</ul>
<ul>
<li><p><code>ConcurrentHashMap</code> </p>
<ul>
<li>保存了一个<code>Segment</code>数组，将hash表划分为多段来实现分段锁。每个<code>segment</code>通过<code>ReentrantLock</code></li>
<li>每个分段里面是数组+链表+红黑树(jdk1.8引进)的方式</li>
<li>扩容：segment不能扩容(初始默认值是16，也就是16个并发量)，扩容是segment里面的数组扩容</li>
</ul>
</li>
<li><p><code>CopyOnWriteArrayList</code></p>
<ul>
<li>属性中有一个<code>ReentrantLock</code>可重入锁，保证线程访问的安全</li>
<li>写操作的时候，拷贝数组，可能会导致young gc或者full gc</li>
</ul>
</li>
<li><p><code>ConcurrentLinkedQueue</code></p>
</li>
<li><p>线程池<code>ThreadPoolExecutor</code></p>
<ul>
<li><p>本质是维护一个线程集合和一个阻塞工作队列</p>
</li>
<li><p>参数：见 2 线程部分</p>
</li>
<li>三种类型<ul>
<li><code>newFixedThreadPool</code><ul>
<li>线程池数达到corePoolSize后，即使没有可执行任务也不会释放线程 — <code>maximumPoolSize</code>、<code>keepAliveTime</code>参数无效</li>
<li>工作队列为无界队列 — 饱和策略参数无效</li>
</ul>
</li>
<li><code>newSingleThreadExecutor</code><ul>
<li>初始化的线程池只有一个线程，如果该线程异常结束，则会创建一个新的</li>
<li>工作队列为无界队列 — 饱和策略参数无效</li>
</ul>
</li>
<li><code>newCachedThreadPool</code><ul>
<li>线程池数量可达到<code>Integer.MAX_VALUE</code>(2147483647)</li>
<li>正常理解的线程池</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p><code>CountDownLatch</code></p>
<ul>
<li>目的是实现不同之间的线程同步</li>
<li>内部类<code>Sync extends AbstractQueuedSynchronizer</code> </li>
</ul>
</li>
<li><p><code>ThreadLocal</code></p>
<ul>
<li><p>线程安全：互斥同步(synchronized 和 ReentrantLock)、非阻塞同步(CAS, AtomicXXXX)、无同步本地存储(ThreadLocal)</p>
</li>
<li><p>内部类<code>ThreadLocalMap</code></p>
<ul>
<li><p>没有实现Map接口</p>
</li>
<li><p>没有public方法</p>
</li>
<li><p><code>ThreadLocalMap</code>的<code>Entry</code>实现继承了<code>WeakReference&lt;ThreadLocal&lt;?&gt;&gt;</code></p>
</li>
<li><p>该方法仅仅用了一个<code>Entry</code>数组来存储Key, Value; Entry并不是链表形式, 而是每个bucket里面仅仅放一个Entry;</p>
<p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/image-20240315170346022.png" alt="image-20240315170346022" style="zoom: 25%;"></p>
</li>
</ul>
</li>
<li><p>内存泄漏问题：使用线程池的时候可能会出现</p>
<p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/image-20240315170633122.png" alt="image-20240315170633057" style="zoom: 50%;"></p>
<ul>
<li><code>ThreadLocalMap</code> 中使用的 key 为 <code>ThreadLocal</code> 的弱引用，而 value 是强引用。所以，如果 <code>ThreadLocal</code> 没有被外部强引用的情况下，在垃圾回收的时候，key 会被清理掉，而 value 不会被清理掉。</li>
<li>如果<code>ThreadLocal</code>没有外部强引用，那么在发生垃圾回收的时候，<code>ThreadLocal</code>就必定会被回收，而<code>ThreadLocal</code>又作为Map中的key，<code>ThreadLocal</code>被回收就会导致一个key为null的entry，外部就无法通过key来访问这个entry，垃圾回收也无法回收，这就造成了内存泄漏</li>
<li>如何防止：<code>ThreadLocal</code>的<code>remove()</code>方法<ul>
<li>在get和set的方法中可能会调用这个remove方法</li>
<li>ThreadLocal虽然提供了避免内存泄露的方法，但是ThreadLocal不会主动去执行这些方法，需要我们在使用完ThreadLocal对象中保存的数据后，在<strong>finally{}代码块中调用ThreadLocal的remove()方法</strong>，加快GC自动垃圾回收，避免内存泄露。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="四-IO"><a href="#四-IO" class="headerlink" title="四 IO"></a>四 IO</h2><h3 id="1-JavaIO"><a href="#1-JavaIO" class="headerlink" title="1 JavaIO"></a>1 JavaIO</h3><ul>
<li><p>javaIO从传输方式来说主要分为两大类：字节流(InputStream/OutputStream)和字符流(Reader/Writer)</p>
</li>
<li><p>从数据操作来说：</p>
<ul>
<li>文件：FileInputStream/OutputStream、FileReader/Writer</li>
<li>数组：ByteArrayInputStream/OutputStream、CharArrayReader/Writer</li>
<li>管道：PipedInputStream/OutputStream、PipedReader/Writer</li>
<li>基本数据类型：DataInputStream/OutputStream、DataReader/Writer</li>
<li>缓冲操作：BufferInputStream/OutputStream、BufferReader/Writer</li>
<li>打印：PrintStream/Writer</li>
<li>对象序列化反序列化：ObjectInputStream/OutputStream</li>
<li>字节字符流转换：InputStreamReader/OutputStreamWriter</li>
</ul>
</li>
</ul>
<h3 id="2-JavaIO设计模式—装饰者"><a href="#2-JavaIO设计模式—装饰者" class="headerlink" title="2 JavaIO设计模式—装饰者"></a>2 JavaIO设计模式—装饰者</h3><ul>
<li><p>装饰者模式</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">CompInterface</span> { <span class="comment">// 顶层</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">action</span><span class="params">()</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Comp1</span> <span class="keyword">implements</span> <span class="title class_">CompInterface</span> { <span class="comment">// 组件1</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">action</span><span class="params">()</span> {</span><br><span class="line">        <span class="comment">// ...行为1</span></span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">CompDecorator</span> <span class="keyword">implements</span> <span class="title class_">CompInterface</span> { <span class="comment">// 顶层抽象装饰器</span></span><br><span class="line">    <span class="keyword">protected</span> CompInterface comp;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Decorator1</span> <span class="keyword">extends</span> <span class="title class_">CompDecorator</span> { <span class="comment">// 装饰器1</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Decorator1</span><span class="params">(CompInterface comp)</span> {</span><br><span class="line">        <span class="built_in">this</span>.comp = comp;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">action</span><span class="params">()</span> {</span><br><span class="line">        comp.action();</span><br><span class="line">        <span class="comment">// 自己的动作</span></span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Decorator2</span> <span class="keyword">extends</span> <span class="title class_">CompDecorator</span> { <span class="comment">// 装饰器2</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Decorator2</span><span class="params">(CompInterface comp)</span> {</span><br><span class="line">        <span class="built_in">this</span>.comp = comp;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">action</span><span class="params">()</span> {</span><br><span class="line">        comp.action();</span><br><span class="line">        <span class="comment">// 自己的动作</span></span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">Comp1</span> <span class="variable">comp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Comp1</span>();    <span class="comment">// 声明组件1</span></span><br><span class="line">comp = <span class="keyword">new</span> <span class="title class_">Decorator1</span>(comp); <span class="comment">// 装饰上Decorator1</span></span><br><span class="line">comp = <span class="keyword">new</span> <span class="title class_">Decorator2</span>(comp); <span class="comment">// 装饰上Decorator2</span></span><br><span class="line">comp.action; <span class="comment">// 执行Comp1、Decorator1、Decorator2的action</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/image-20240601151606748.png" alt="image-20240601151606748" style="zoom:50%;"></p>
</li>
<li><p>在IO流相关类的表现：</p>
<p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/image-20240601151715251.png" alt="image-20240601151715251" style="zoom:50%;"></p>
<ul>
<li><p>FilterInputStream是一个抽象组件，类似于上文的CompDecorator，使用Buffer对FileInputStream进行增加，实现缓冲</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">FileInputStream</span> <span class="variable">fileInputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(filePath);</span><br><span class="line"><span class="type">BufferedInputStream</span> <span class="variable">bufferedInputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedInputStream</span>(fileInputStream);</span><br></pre></td></tr></tbody></table></figure>
</li>
</ul>
</li>
</ul>
<h3 id="3-IO中常见类的使用"><a href="#3-IO中常见类的使用" class="headerlink" title="3 IO中常见类的使用"></a>3 IO中常见类的使用</h3><ul>
<li><p>磁盘操作：File</p>
</li>
<li><p>字节操作：Input/OutputStream</p>
</li>
<li><p>字符操作：Reader/Writer</p>
</li>
<li><p>对象操作：</p>
<ul>
<li>Serializable(一个空接口，只是一个标准，不实现它就进行序列化会抛异常)</li>
<li>transient关键字修饰的对象/属性不会被序列化</li>
</ul>
</li>
<li><p>网络操作：</p>
<ul>
<li><p>InetAddress：用来表示IP地址</p>
</li>
<li><p>URL：统一资源定位符</p>
</li>
<li><p>Sockets：使用 TCP 协议实现网络通信</p>
</li>
<li><p>Datagram：使用 UDP 协议实现网络通信</p>
</li>
</ul>
</li>
</ul>
<h3 id="4-Unix-IO模型"><a href="#4-Unix-IO模型" class="headerlink" title="4 Unix IO模型"></a>4 Unix IO模型</h3><p>一个输入操作通常包括：1. 等待数据准备好  2. 从内核向进程复制数据</p>
<ul>
<li>阻塞式I/O：应用进程(不是整个操作系统)被阻塞，直到数据复制到应用进程缓冲区中才返回，执行效率会比较高。</li>
<li>非阻塞式I/O：应用进程执行系统调用后，内核返回一个错误码，应用进程继续执行，但不断的执行系统调用（轮询polling）来获取IO是否完成。对CPU的利用率较低（因为CPU要不断的处理系统调用）</li>
<li><p>I/O复用：应用进程使用select或者poll等待数据并阻塞，当一个套接字变为可读时再调用recvfrom复制数据</p>
<ul>
<li>单个线程处理多个套接字，即多个IO事件</li>
</ul>
</li>
<li><p>信号驱动I/O：应用进程使用sigaction系统调用，内核立即返回信息，应用进程继续执行，数据准备完毕后内核向应用程序发送SIGIO信号，之后应用进程调用recvfrom获取数据</p>
</li>
<li>异步I/O：应用进程使用aio_read系统调用后立即返回，内核准备完数据后向应用进程发送信号</li>
</ul>
<blockquote>
<p>和信号驱动 I/O 的区别在于，异步 I/O 的信号是通知应用进程 I/O 完成，而信号驱动 I/O 的信号是通知应用进程可以开始 I/O。</p>
</blockquote>
<ul>
<li><p>同步IO（前4个）和异步IO区别：同步IO应用进程在调用 recvfrom 操作时会阻塞，</p>
</li>
<li><p>4个同步IO的区别主要在于执行recvfrom之前的第一阶段不一样</p>
<p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/image-20240601222244744.png" alt="image-20240601222244744" style="zoom:50%;"></p>
</li>
</ul>
<ul>
<li>select/poll/epoll<ul>
<li>select 可移植性更好，几乎被所有主流平台所支持。数组结构，最多监听1048个文件描述符</li>
<li>poll 没有最大描述符数量的限制，如果平台支持并且对实时性要求不高，应该使用 poll 而不是 select。长链表结构</li>
<li>只需要运行在 Linux 平台上，并且有非常大量的描述符需要同时轮询，而且这些连接最好是长连接。红黑树结构，O(logn)</li>
</ul>
</li>
</ul>
<h3 id="5-NIO"><a href="#5-NIO" class="headerlink" title="5 NIO"></a>5 NIO</h3><ul>
<li>特点：非阻塞；面向块传输，普通IO是面向流</li>
<li><p>BIO即阻塞式IO，需要一个服务线程监听一个用户线程，使用多线程技术来实现对不用用户的“异步”，对服务器资源消耗大（线程多了之后CPU切换线程开销大），且利用率不高（阻塞等待的时候客户端不能作别的）。</p>
</li>
<li><p>Java NIO：和标准IO不同的是，NIO把IO抽象成了块(一个byte[])，一次可以读取多个字节</p>
</li>
<li>几个要素<ul>
<li>通道Channel：类似于流，但是是双向的。有FileChannel、DatagramChannel、SocketChannel等</li>
<li>缓冲区Buffer：本质是一个数组，所有数据要先放到buffer中才能传输。有ByteBuffer、CharBuffer、LongBuffer等<ul>
<li>状态变量：最大容量、当前已读取的字节数、还可以读取的字节数（有点类似于滑动窗口）</li>
</ul>
</li>
<li>选择器：NIO 实现了 IO 多路复用中的 Reactor 模型，一个线程 Thread 使用一个选择器 Selector 通过轮询的方式去监听多个通道 Channel 上的事件，从而让一个线程就可以处理多个事件。</li>
</ul>
</li>
</ul>
<h2 id="五-数据库"><a href="#五-数据库" class="headerlink" title="五 数据库"></a>五 数据库</h2><h3 id="1-概述"><a href="#1-概述" class="headerlink" title="1 概述"></a>1 概述</h3><p><a target="_blank" rel="noopener" href="https://dsf.berkeley.edu/papers/fntdb07-architecture.pdf">https://dsf.berkeley.edu/papers/fntdb07-architecture.pdf</a></p>
<ul>
<li>核心组件<ul>
<li>进程管理器</li>
<li>网络管理器</li>
<li>文件系统管理器</li>
<li>内存管理器</li>
<li>安全管理器</li>
<li>客户端管理器</li>
</ul>
</li>
<li><p>工具</p>
<ul>
<li>备份恢复管理器</li>
<li>查询管理器（解析、重写、优化、执行）</li>
<li>数据管理器（事务）</li>
</ul>
</li>
<li><p>联接运算符</p>
<ul>
<li>合并联接：用于排序的字段比较好</li>
<li>哈希联接：比较消耗内存，因为要用额外内存存储哈希</li>
<li>嵌套循环联接（复杂度O(m*n)）：类似于双循环来匹配查询</li>
</ul>
<blockquote>
<p>实际使用的时候采用动态规划、贪心算法、启发式算法来确定用哪些</p>
</blockquote>
</li>
</ul>
<h3 id="2-关系型数据库—MySQL"><a href="#2-关系型数据库—MySQL" class="headerlink" title="2 关系型数据库—MySQL"></a>2 关系型数据库—MySQL</h3><ul>
<li><p>为什么需要范式？</p>
<p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/image-20240602140006102.png" alt="image-20240602140006102" style="zoom:50%;"></p>
<ul>
<li>冗余数据：学生2</li>
<li>修改异常：修改一个记录中的信息，但是另一个记录的相同信息没有被修改：修改学生2Snam</li>
<li>删除异常：删除一个信息，会丢失其他信息：删除课程1，学生1也不见了</li>
<li>插入异常：插入一个学生，但是如果这个学生没选课，就无法插入</li>
</ul>
</li>
<li><p>三大范式</p>
<ul>
<li>第一范式：属性不可分</li>
<li>第二范式：每个非主属性完全函数依赖于键码<ul>
<li>分解后两个表：Sno-Sname-Sdept-Mname 和 Sno-Cname-Grade</li>
</ul>
</li>
<li>第三范式：非主属性不传递函数依赖于键码（上述关系中Sno -&gt; Sdept -&gt;Mname）<ul>
<li>分解后变为三个表：Sno-Sname-Sdept、Sdept-Mname、Sno-Cname-Grade</li>
</ul>
</li>
</ul>
</li>
<li><p>事务：满足 ACID 特性的一组操作，可以通过Commit提交事务，也可以通过Rollback回滚（通过日志）</p>
<ul>
<li>原子性（Atomicity）：所有操作要么全部提交成功，要么全部失败回滚。</li>
<li>一致性（Consistency）：数据库在事务执行前后都保持一致性状态</li>
<li>隔离性（Isolation）：一个事务所做的修改在最终提交以前，对其它事务是不可见的。</li>
<li>持久性（Durability）：一旦事务提交，则其所做的修改将会永远保存到数据库中</li>
</ul>
</li>
<li><p>并发一致性问题：</p>
<ul>
<li>修改丢失：两个事务修改数据，后面的事务修改覆盖了前面的事务（貌似不算?）</li>
<li><strong>脏读</strong>：A修改数据(50-&gt;100)，B读取到新数据后(100)，A回滚数据(50)，此时B读到了脏数据</li>
<li><strong>不可重复读</strong>：B读取数据(50)，A修改数据(100)，B再读(100)前后不一致</li>
<li><strong>幻读</strong>：B读取数据(100行)，A插入一行，B再读取(101行)前后不一致</li>
</ul>
</li>
<li><p>隔离级别：</p>
<ul>
<li>未提交读(READ UNCOMMITTED)</li>
<li>提交读(READ COMMITTED)：解决了脏读</li>
<li>可重复读(REPEATABLE READ)：解决了不可重复读</li>
<li>可串行化(SERIALIZABLE)：解决了幻读</li>
</ul>
</li>
<li><p>锁</p>
<ul>
<li>从粒度上划分：行级锁、表级锁</li>
<li>类型上划分：读写锁(排它锁/写锁/X锁、共享锁/读锁/S 锁)、意向锁(X/S锁要扫描行耗时，所以搞了IS/IX表锁，即意向锁，要获取X/S锁之前必须先获取IX/IS锁)</li>
<li>临键锁Next-Key Locks：<ul>
<li>记录锁Record Locks：锁定一个记录上的索引，如果没有设置索引，InnoDB 会自动在主键上创建隐藏的聚簇索引</li>
<li>间隙锁Gap Locks：锁定索引之间的间隙，但是不包含索引本身</li>
<li>Next-Key Locks就是记录锁和间隙锁的结合</li>
</ul>
</li>
</ul>
</li>
<li><p>MVCC：多版本并发控制</p>
<ul>
<li>是Mysql的InnoDB实现隔离级别的一种方式，实现提交读和可重复读这两种隔离级别。（可串行化需要对所有读取的行都加锁，单纯使用 MVCC 无法实现）</li>
<li>如何解决幻读：MVCC + 间隙锁(Next-Key Locks)</li>
<li>版本号：系统版本号（每开始一个新的事务，系统版本号就会自动递增）、事务版本号（创建/删除）</li>
<li><p>针对可重复读隔离级别的执行：</p>
<ul>
<li>Insert：将当前系统版本号作为数据行快照的创建版本号。</li>
<li>Delete：将当前系统版本号作为数据行快照的删除版本号。</li>
<li>Update：将当前系统版本号作为更新前的数据行快照的删除版本号，并将当前系统版本号作为更新后的数据行快照的创建版本号。（先delete再update）</li>
<li>Select：如果是正在修改的事务T在读取就不管。如果是不修改数据的事务B要读取，B读取的数据行快照的创建版本号必须小于 B的版本号，且删除版本号必须大于 B 的版本号</li>
</ul>
</li>
<li><p>MVCC原理</p>
<ul>
<li><p><strong>4个隐式字段</strong></p>
<ul>
<li>DB_ROW_ID：如果没有主键就会自动创建，并加一个聚餐索引(索引结构和数据一起存放的索引)</li>
<li>DB_TRX_ID：最近修改/插入的事务ID</li>
<li>DB_ROLL_PTR：回滚指针，指向这条记录的上一个版本</li>
<li>DELETED_BIT：记录被更新或删除并不代表真的删除，而是删除flag变了</li>
</ul>
</li>
<li><p><strong>undolog</strong>：只记录insert、update、delete操作</p>
<ul>
<li>Insert undo log，至少记录主键，回滚的时候直接删除就行了</li>
<li>Update undo log，至少要把修改这条记录前的旧值都记录下来</li>
<li>Delete undo log，至少要把这条记录中的内容都记下来</li>
</ul>
</li>
<li><p><strong>read view</strong>：主要是用来做可见性判断的</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>Mysql架构：</p>
<p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/image-20240602145759098.png" alt="image-20240602145759098" style="zoom:67%;"></p>
</li>
<li><p>存储引擎：MyISAM和InnoDB</p>
<ul>
<li>事务：MyISAM不支持事务，后者可以commit和rollback（undo log）</li>
<li>并发：MyISAM 只支持表级锁，而 InnoDB 还支持行级锁</li>
<li>崩溃恢复能力：InnoDB独有redo log</li>
</ul>
</li>
<li><p>日志</p>
<ul>
<li>binlog</li>
<li>undolog：写的是逻辑上的事务，用于事务回滚</li>
<li>redolog：两阶段提交(保证和binlog的一致性)：先写redolog，再写binlog，最后将redolog设置为commit状态</li>
</ul>
</li>
<li><p>索引——数据结构：</p>
<ul>
<li>hash表：快，但是不支持范围查询</li>
<li>二叉查找树：性能很依赖其平衡性</li>
<li>AVL树(高度差不超过1)：需要频繁地进行旋转操作来保持平衡，且一个节点只存一个数据，磁盘IO性能开销大</li>
<li>红黑树：自平衡二叉查找树，平衡性稍弱（不追求完全的平衡）所以有些查询效率较低(多次IO)，但是增删效率高</li>
<li>B树：所有节点既存放key又存放date</li>
<li><strong>B+树</strong>：多路平衡查找树，更稳定快速。原因：数据存放在叶子节点，保证了其他节点能够存放更多的索引，大大压缩了树的高度，减少磁盘IO次数；且叶子节点之间用双向链表连接</li>
</ul>
</li>
<li>索引——分类<ul>
<li>主键索引：加速查询 + 列值唯一（不可以有 NULL）+ 表中只有一个<ul>
<li>除了这个其他的索引都是二级索引，二级索引数据位置存储的是主键</li>
</ul>
</li>
<li>普通索引：加速查询</li>
<li>唯一索引：加速查询 + 列值唯一（可以有 NULL）</li>
<li>覆盖索引：一个索引包含（或者说覆盖）所有需要查询的字段的值</li>
<li>联合索引：多列值组成一个索引，专门用于组合搜索，其效率大于索引合并</li>
<li>全文索引：对文本的内容进行分词，一般不会使用，效率较低，通常使用搜索引擎如 ElasticSearch 代替</li>
</ul>
</li>
<li>Mysql性能优化<ul>
<li>优化数据访问：<ul>
<li>减少请求数据量：列用select，行用limit，使用缓存</li>
<li>减少服务端扫描的行数：索引来覆盖查询</li>
</ul>
</li>
<li>重构查询方式：<ul>
<li>切分大查询，防止锁住很多的数据</li>
<li>分解大查询，分解为单表查询，在业务逻辑中关联</li>
</ul>
</li>
</ul>
</li>
<li>Mysql分库分表：垂直/水平<ul>
<li>Sharding策略(水平)：哈希取模、范围切分、映射表</li>
<li>Sharding策略的问题及解决<ul>
<li>事务：使用分布式事务解决</li>
<li>链接：JOIN变为多个单表查询，在业务代码中链接</li>
<li>ID唯一性：全局唯一ID/每个分片指定ID范围/分布式ID生成器（Snowflake 算法）</li>
</ul>
</li>
</ul>
</li>
<li><p>Mysql主从复制和读写分离</p>
<ul>
<li>binlog线程：负责将主服务器上的数据更改写入二进制日志中。</li>
<li>I/O线程：负责从主服务器上读取二进制日志，并写入从服务器的中继日志中。</li>
<li>SQL线程：负责读取中继日志并重放其中的 SQL 语句。</li>
</ul>
</li>
<li><p>SQL执行过程</p>
<ul>
<li>java业务端的数据库连接池：Druid、C3P0、DBCP。数据库也有类似的池子</li>
<li>查询缓存池</li>
<li>分析器</li>
<li>查询优化器：选择查询成本最小的索引<ul>
<li>IO成本：即从磁盘把数据加载到内存的成本</li>
<li>CPU成本：与行数有关</li>
</ul>
</li>
<li>执行器：调用存储引擎的接口完成执行</li>
<li>存储引擎：InnoDB</li>
</ul>
</li>
<li><p>慢查询</p>
<ul>
<li>explain命令：<code>EXPLAIN SELECT * FROM t1</code></li>
</ul>
</li>
</ul>
<h3 id="3-NoSQL—Redis"><a href="#3-NoSQL—Redis" class="headerlink" title="3 NoSQL—Redis"></a>3 NoSQL—Redis</h3><ul>
<li><p>redis：Remote Dictionary Server</p>
</li>
<li><p>特点：</p>
<ul>
<li>读写性能优异</li>
<li>数据类型丰富</li>
<li>原子性：redis所有操作都是原子性的，同时支持几个操作全合并后的原子性执行</li>
<li>持久化：RDB，AOF持久化方式</li>
<li>发布/订阅模式</li>
<li>分布式：redis cluster</li>
</ul>
</li>
<li><p>使用场景：</p>
<ul>
<li>热点数据缓存</li>
<li>限时业务</li>
<li>计数器相关（incrby命令可以实现原子性的递增）</li>
<li>分布式锁：setnx</li>
<li>延时操作（一般用mq）</li>
<li>排行榜（Zset）</li>
<li>点赞、好友等相互关系的存储（集合命令求交并差集）</li>
<li>队列</li>
</ul>
</li>
<li><p>3.1 数据类型</p>
<p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/image-20240623194222947.png" alt="image-20240623194222947" style="zoom: 50%;"></p>
<ul>
<li><p>基本数据类型</p>
<ul>
<li>String</li>
<li>List</li>
<li>Set</li>
<li>Zset</li>
<li>Hash</li>
</ul>
</li>
<li><p>特殊数据类型</p>
<ul>
<li>HyperLogLogs（基数统计）：用来算两个set中的不重复元素数量(会有一定的误差量)，用于网站的注册IP数，每日IP数等统计</li>
<li>Bitmap （位存储）：用于统计用户活跃度等（0，1）</li>
<li>geospatial (地理位置)</li>
<li><p>redis-stream：redis5.0新增的数据结构，是redis对消息队列的完善</p>
<ul>
<li><p>redis实现消息队列</p>
<ul>
<li>发布/订阅模式，缺点是无法持久化，如果网络断开、redis宕机消息会丢失</li>
<li>基于List LPUSH+BRPOP 或者 基于Sorted-Set的实现，缺点是不支持多播、分组广播</li>
</ul>
</li>
<li><p>针对上述不足提出了stream结构</p>
</li>
<li><p>key：唯一的索引，首次使用xadd时自动创建</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">XADD：添加消息</span><br><span class="line">XTRIM：修剪消息，限制长度</span><br><span class="line">XDEL：删除消息</span><br><span class="line">XLEN：获取流长度</span><br><span class="line">XRANGE：获取消息列表</span><br><span class="line">XREVRANGE：反向获取，id由大到小</span><br><span class="line">XREAD：以阻塞/非阻塞获取消息列表</span><br></pre></td></tr></tbody></table></figure>
</li>
</ul>
</li>
</ul>
</li>
<li><p>操作</p>
<figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># string</span></span><br><span class="line"><span class="built_in">set</span> counter 2</span><br><span class="line">incr/decr counter <span class="comment"># +/- 1</span></span><br><span class="line">incrby/decrby counter 100 <span class="comment"># 加/减100</span></span><br><span class="line"><span class="comment"># List</span></span><br><span class="line">增:rpush, lpush ,linsert </span><br><span class="line">查:lrange,lindex,llen </span><br><span class="line">删:lpop,rpop,ltrim,ltrim </span><br><span class="line">阻塞操作:blpop,brpop</span><br><span class="line"><span class="comment"># Set</span></span><br><span class="line">增：sadd myset hao hao1 xiaohao hao</span><br><span class="line">删：srem key member1 [member2]</span><br><span class="line">查：smembers myset(返回成员) scard myset(返回数量)</span><br><span class="line"><span class="comment"># Hash</span></span><br><span class="line">增：hset myHash sub-key1 value1</span><br><span class="line">查：hget myHash sub-key1</span><br><span class="line">删：hdel myHash sub-key1</span><br><span class="line"><span class="comment"># Zset</span></span><br><span class="line">增：zadd myscoreset 100 hao 90 xiaohao</span><br><span class="line">查：zscore myscoreset hao <span class="comment"># 100 </span></span><br><span class="line">   zrange myscoreset 0 10 WITHSCORES <span class="comment"># hao xiaohao</span></span><br><span class="line">删：zrem myscoreset hao</span><br><span class="line"><span class="comment"># HyperLogLogs</span></span><br><span class="line">pfadd key1 a b c</span><br><span class="line">pfadd key2 c d e</span><br><span class="line">pfmerge key3 key1 key2 <span class="comment"># 合并key1 key2</span></span><br><span class="line">pfcount key3 <span class="comment"># 5</span></span><br><span class="line"><span class="comment"># Bitmap</span></span><br><span class="line">setbit key sub-key1 0</span><br><span class="line">setbit key sub-key2 1</span><br><span class="line">getbit key sub-key1</span><br><span class="line">bitcount key <span class="comment"># 1</span></span><br></pre></td></tr></tbody></table></figure>
</li>
</ul>
</li>
<li><p>3.2 redis底层数据结构</p>
<ul>
<li><p>SDS 简单动态字符串：redis是C语言写的，但是其字符串对象不是，是SDS，分为头部、数据和结尾标识\0（C语言是以空字符结尾）</p>
<blockquote>
<p>为什么设计SDS？O(1)获取长度；避免内存溢出；空间预分配</p>
</blockquote>
<p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/image-20240623210112381.png" alt="image-20240623210112381" style="zoom:50%;"></p>
<ul>
<li>特点：字符长度len在头部，O(1)时间就可以获取，也杜绝了缓存区溢出</li>
</ul>
</li>
<li><p>ZipList 压缩列表</p>
<p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/image-20240623210707073.png" alt="image-20240623210707073" style="zoom:50%;"></p>
<p>​    </p>
<ul>
<li>从左到右含义：整个ZipList所占内存字节数、最后一个entry的偏移量(以快速完成pop)、entry总量、列表内部数据、终止标识</li>
<li>为什么ZipList省内存：不同的entry存储空间不同(一般的list是以最大的entry大小为单位存储)，这样一来如何遍历？增加了一个prelen字段记录上一个entry的长度</li>
<li>缺点：因为每个entry都没有预留空间，所以修改节点导致容量变大时最坏会导致所有entry重新计算内存O(N)</li>
</ul>
</li>
<li><p>QuickList 快表：以ZipList为节点的双端链表</p>
</li>
<li><p>HashTable 字典/哈希表</p>
<ul>
<li>哈希冲突怎么解决：链地址法</li>
</ul>
</li>
<li><p>IntSet 整数集</p>
<p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/image-20240623211639543.png" alt="image-20240623211639543" style="zoom:50%;"></p>
<ul>
<li>int16 or int32：优先int16，当插入一个int32时，所有的修改为int32(删除最后一个int32的时候不会变回int16，节省开支)</li>
</ul>
</li>
<li><p>ZSkipList 跳表：只在ZSet中使用，log(N)的增删查</p>
<p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/image-20240623212155416.png" alt="image-20240623212155416" style="zoom:50%;"></p>
<ul>
<li>缺点是存储空间大</li>
<li>with 平衡树(AVL、红黑树)：范围查找平衡树复杂，且增删可能会触发自平衡</li>
<li>with B+树：B+的核心是减少IO过程快速定位到索引，不是redis的关注方式</li>
</ul>
</li>
</ul>
</li>
<li><p>3.3 redis持久化</p>
<ul>
<li>RDB(Redis DataBase )：快照<ul>
<li>触发方式：<ul>
<li>手动触发：<code>save</code>和<code>bgsave</code>，前者会阻塞主进程，后者fork一个子进程</li>
<li>自动触发：redis.conf中配置<code>save m n</code>，m秒有n次修改会触发；主从复制时会触发；执行debug reload命令重新加载redis时；执行shutdown命令时，如果没有开启AOF持久化会触发</li>
</ul>
</li>
<li>如何保持数据一致性？（进行RDB的时候发送了数据的写）<ul>
<li>Copy-on-Write，复制一个副本来写</li>
</ul>
</li>
<li>优劣：redis加载RDB速度快，文件体积小；无法做到秒级持久化，每次bgsave都要fork进程开销大，二进制文件难读</li>
</ul>
</li>
<li>AOF<ul>
<li>写后日志，先写内存后写日志。（mysql就是写前）<ul>
<li>好处是：避免了额外的检查开销(写进来的日志都是成功执行的)；不会阻塞当前的写操作</li>
<li>风险是：写完然后还没写日志发生宕机丢失数据；主线程写磁盘压力大，导致写盘慢，阻塞后续操作</li>
</ul>
</li>
<li>实现：<ul>
<li>命令追加(append)：开启AOF后，将被执行写命令追加到服务器aof_buf缓冲区</li>
<li>文件写入(write)：分为同步写回、每秒写回、操作系统控制的写回</li>
<li>和文件同步(sync)</li>
</ul>
</li>
<li>AOF重写：优化一些冗余的AOF操作，减少AOF文件的大小。<ul>
<li>后台fork一个bgrewriteaof进程来进行，数据是写时复制，fork子进程时会复制父进程的页表(类似于指针)</li>
<li>什么时候会阻塞主进程：fork子进程拷贝页表；主进程有bigkey写入操作系统会创建页面的副本，并拷贝原有的数据；子进程重写日志完成后，主进程追加aof重写缓冲区时可能会对主线程阻塞</li>
</ul>
</li>
</ul>
</li>
<li>AOF和RDB混用：redis4.0推出<ul>
<li>内存快照以一定的频率执行，在两次快照之间，使用 AOF 日志记录这期间的所有命令操作。</li>
<li>避免了AOF文件过大</li>
</ul>
</li>
<li>redis启动：<ul>
<li>判断有无AOF？有则加载AOF启动</li>
<li>判断有无RDB？有则加载RDB启动</li>
<li>都没有就直接启动</li>
</ul>
</li>
</ul>
</li>
<li><p>3.4 redis事件机制</p>
<ul>
<li>文件事件：用于处理 Redis 服务器和客户端之间的网络IO（基于IO多路复用）<ul>
<li>redis单线程：指的是网络IO和键值对读取是由一个线程完成，但是其他的(持久化、异步删除、集群数据同步等是fork的进程完成)</li>
<li>文件事件是对套接字操作的抽象，每当一个套接字准备好执行 <code>accept</code>、<code>read</code>、<code>write</code>和 <code>close</code> 等操作时，就会产生一个文件事件</li>
</ul>
</li>
<li>时间事件：redis服务中的一些定时操作<ul>
<li>定时事件、周期事件</li>
</ul>
</li>
</ul>
</li>
<li><p>3.5 redis事务</p>
<ul>
<li><p>本质是一组命令的集合</p>
</li>
<li><p>使用</p>
<figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">MULTI：开启事务</span><br><span class="line">EXEC：执行事务</span><br><span class="line">DISCARD：取消事务</span><br><span class="line">WATCH：监视一个或多个key</span><br><span class="line">UNWATCH：取消监视</span><br><span class="line"></span><br><span class="line"><span class="comment"># 例子</span></span><br><span class="line"><span class="built_in">set</span> k1 v1</span><br><span class="line"><span class="built_in">set</span> k2 v2</span><br><span class="line">MULTI</span><br><span class="line"><span class="built_in">set</span> k1 12</span><br><span class="line"><span class="built_in">set</span> k2 24</span><br><span class="line">EXEC</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>lua脚本：Redis可以保证脚本内的命令一次性、按顺序地执行，其同时也不提供事务运行错误的回滚，执行过程中如果部分命令运行错误，剩下的命令还是会继续运行完</p>
</li>
</ul>
</li>
<li><p>3.6 redis高可用</p>
<ul>
<li><p>主从：故障恢复、负载均衡、高可用</p>
<ul>
<li>读写分离：主库读写，从库读</li>
<li>全量同步：主要依靠RDB文件</li>
<li>增量同步：slave提交自己的offset到master，master获取repl_baklog中从offset之后的命令给slave</li>
</ul>
</li>
<li><p>哨兵机制：监控、自动故障转移、通知</p>
<ul>
<li>哨兵如何监控主从集群：哨兵向主库发送info，主库返回所有slave列表，从而可以与从库通信</li>
<li>哨兵集群：基于redis的 pub/sub 机制来互相获取IP的端口进行通信</li>
<li>哨兵如何判断主库下线？主观下线(任何一个哨兵判断)、客观下线(哨兵集群判断)</li>
<li>哨兵集群的选举：raft算法：拿到半数赞成，拿到的赞成票大于配置的quorum 值</li>
<li>哨兵leader完成主从切换：主库客观下线后，过滤掉不健康的从库，选择优先级最大的，然后向别的从库发送消息新的主库</li>
</ul>
</li>
<li><p>redis cluster：弥补主从和哨兵的不足：写能力和存储能力依赖于主库的问题</p>
<ul>
<li><p>哈希槽(Hash Slot)：有16384(即2的14次方）个哈希槽，每个key通过对16384取模后来决定放哪里，cluster每个节点负责一部分hash槽(只有master才可以占据槽)</p>
<blockquote>
<p>普通的哈希算法的缺陷：如果节点增加或减少，之前的缓存就失效了需要重新计算存储位置(即重新set)，容易引发雪崩</p>
<p>一致性哈希算法：普通哈希算法是对服务器数量取模，一致性哈希算法是对 2^32 取模(形成一个哈希环)，对服务器ip或者其他关键字段进行hash后确定其在环上的位置，然后插入新数据的时候计算hash后对2^32 取模得到其在哈希环上的位置，并顺时针找，找到的第一个服务器就是其存储的服务器</p>
<p>为什么不用一致性哈希算法？增删节点可能会带来雪崩(会对相邻的节点产生影响)、也可能会出现数据倾斜的状况</p>
<p>为什么是16384？为了发送槽的全量状态，用bitmap发送，16384只需要2k的空间(16384 / 8 / 1024 = 2k)</p>
</blockquote>
</li>
</ul>
</li>
<li><p>缓存问题</p>
<ul>
<li><p>一致性问题：最佳实践：先写DB再删缓存</p>
<ul>
<li><p><a target="_blank" rel="noopener" href="https://itwanger.gitee.io/tobebetterjavaer/#/docs/mysql/redis-shuju-yizhixing">https://itwanger.gitee.io/tobebetterjavaer/#/docs/mysql/redis-shuju-yizhixing</a></p>
<p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/image-20240311214614711.png" alt="image-20240311214614711" style="zoom:67%;"></p>
</li>
</ul>
</li>
<li><p>缓存击穿：缓存失效后大量请求打在DB上（同一个key）</p>
<ul>
<li>热点数据不过期；加互斥锁；接口限流；熔断降级</li>
</ul>
</li>
<li><p>缓存穿透：频繁访问一个DB和缓存都不存在的key</p>
<ul>
<li>增加入口校验；DB中未取到可以设置到缓存中为null(有效时间短一点)；布隆过滤器</li>
</ul>
<blockquote>
<p>布隆过滤器</p>
<p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/image-20240629162249949.png" style="zoom:50%;"></p>
</blockquote>
</li>
<li><p>缓存雪崩：大量数据过期，过多请求打在DB上</p>
<ul>
<li>缓存过期时间随机；热点数据部署在不同缓存数据库中；设置热点数据不过期</li>
</ul>
</li>
</ul>
</li>
<li><p>缓存淘汰策略：不淘汰、设置过期时间、LRU</p>
</li>
</ul>
</li>
<li><p>3.7 解决方案——大value、多key合并方案</p>
<ul>
<li><p>单key存储的value大</p>
<ul>
<li><p>如果是每次都整存整取：可以尝试将对象拆分为几个kv，用multiGet获取值，这样做的意义在于分拆单次操作压力，将操作压力平摊到多个redis实例中，降低对单个redis的IO影响</p>
</li>
<li><p>如果是每次只读取部分数据：可以将这个存储在一个hash中，每个field代表一个具体的属性</p>
</li>
</ul>
</li>
<li><p>hash、set、zset、list存储过多的元素：</p>
<ul>
<li>分拆，用取模的方式（比如固定一个桶的数量）确定key，然后将field放在计算出的key中</li>
</ul>
</li>
<li>一个集群存储了上亿的key<ul>
<li>带来的问题：key占存储空间大；集群模式中服务端需要建立slot2key的映射，这些指针也会占用大量空间</li>
<li>key如果有很强的关联关系：就可以放在hash中</li>
<li>key如果没有很强的关联关系：还是放在hash中，但是key是由桶的数量取模来计算得到的</li>
</ul>
</li>
<li>大Bitmap或者布隆过滤器拆分</li>
</ul>
</li>
<li><p>美团squirrel：基于redis</p>
<ul>
<li><p>如何保证数据可靠性</p>
<ul>
<li>多副本存储策略：同一份数据的多副本存储，保证一个副本宕机的情况下其他副本依旧有全量数据</li>
<li>多机房部署容灾策略：将多个副本部署在不同的机房中，避免机房掉电以及断网带来的数据丢失</li>
<li>持久化</li>
</ul>
</li>
<li><p>主从一致：弱一致性，为了保证高性能</p>
</li>
</ul>
</li>
</ul>
<h3 id="4-NoSQL—ES"><a href="#4-NoSQL—ES" class="headerlink" title="4 NoSQL—ES"></a>4 NoSQL—ES</h3><ul>
<li><p>一般语法</p>
<figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 一般索引查询</span></span><br><span class="line">GET /bank/_search</span><br><span class="line">{</span><br><span class="line">  <span class="string">"query"</span>: { </span><br><span class="line">    <span class="string">"match_all"</span>: {</span><br><span class="line">    } </span><br><span class="line">  },</span><br><span class="line">  <span class="string">"sort"</span>: [</span><br><span class="line">    { </span><br><span class="line">      <span class="string">"account_number"</span>: <span class="string">"asc"</span> </span><br><span class="line">    }</span><br><span class="line">  ],</span><br><span class="line">  <span class="string">"from"</span>: 10, </span><br><span class="line">  <span class="string">"size"</span>: 10</span><br><span class="line">} </span><br><span class="line"></span><br><span class="line"><span class="comment"># 特定字段查询：match_all就改为"match": { "address": "mill lane" } 意思为address中包含mill或者lane</span></span><br><span class="line"><span class="comment"># 							"match_phrase": { "address": "mill lane" } address包含mill lane</span></span><br><span class="line"><span class="comment"># 条件查询：</span></span><br><span class="line"><span class="string">"query"</span>: {</span><br><span class="line">  <span class="string">"bool"</span>: {</span><br><span class="line">    <span class="string">"must"</span>: [</span><br><span class="line">      { <span class="string">"match"</span>: { <span class="string">"age"</span>: <span class="string">"40"</span> } }</span><br><span class="line">    ],</span><br><span class="line">    <span class="string">"must_not"</span>: [</span><br><span class="line">      { <span class="string">"match"</span>: { <span class="string">"state"</span>: <span class="string">"ID"</span> } }</span><br><span class="line">    ]</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>聚合查询，类似于mysql的group by</p>
<figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">{</span><br><span class="line">  <span class="string">"size"</span>: 0, <span class="comment"># 返回的文档数为0</span></span><br><span class="line">  <span class="string">"aggs"</span>: { <span class="comment"># 标识聚合查询</span></span><br><span class="line">    <span class="string">"group_by_state"</span>: { <span class="comment"># 自定义名称，用于标识聚合查询的结果</span></span><br><span class="line">      <span class="string">"terms"</span>: { <span class="comment"># 定义了一个聚合</span></span><br><span class="line">        <span class="string">"field"</span>: <span class="string">"state.keyword"</span> <span class="comment"># 根据state进行分组</span></span><br><span class="line">      }</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line">ps: 字符串类型有text和keyword，后者不会分词</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>基本概念</p>
<ul>
<li>文档：一条完整的数据，包括索引、名称等，以json方式存储</li>
<li>字段：文档中的具体字段，类似于表格的列</li>
<li>索引：就是相同类型的文档的集合，类似于表。eg：用户的索引、商品的索引、订单的索引…</li>
<li>映射(mapping)：索引中字段的约束信息，类似于表的结构约束。</li>
</ul>
</li>
<li><p>倒排索引</p>
</li>
</ul>
<h2 id="六-计算机网络"><a href="#六-计算机网络" class="headerlink" title="六 计算机网络"></a>六 计算机网络</h2><h3 id="6-1-base"><a href="#6-1-base" class="headerlink" title="6.1 base"></a>6.1 base</h3><ul>
<li><p>网络模型</p>
<ul>
<li>应用层：HTTP、websocket、FTP、Telnet、DNS、SMTP等协议（传输单位是消息或报文message）</li>
<li>传输层：TCP(面向字节流)、UDP（面向报文，传输单位是段segment）</li>
<li>网络层：IP(寻址和路由)（传输单位是包packet）</li>
<li>网络接口层：ARP协议（传输单位是数据帧frame）</li>
</ul>
<p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/image-20240707162501116.png" alt="image-20240707162501116" style="zoom: 33%;"></p>
</li>
<li><p>从键入网址到网页显示，发生了什么</p>
<ul>
<li><p>解析url</p>
<p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/image-20240707162735960.png" alt="image-20240707162735960" style="zoom: 67%;"></p>
</li>
<li><p>生成http请求信息，<strong>Http报文</strong></p>
<p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/image-20240428104302925.png" alt="image-20240428104302925" style="zoom:67%;"></p>
</li>
<li><p>查询服务器域名对应的 IP 地址（DNS）</p>
</li>
<li>TCP建立可靠传输，如果Http消息过大会切分数据分块发送，组装好<strong>TCP头部</strong>交给下一层</li>
<li>根据IP协议，生成<strong>IP头部</strong>组装后交给下一层</li>
<li>根据ARP协议，获取到两点MAC地址，组装<strong>MAC头部</strong></li>
<li>通过网卡将包数据转为电信号，通过网线发送</li>
<li>交换机基于mac地址进行路由发送到路由器（之后mac头部就没用了，就会被丢弃）</li>
<li>路由器基于ip发送转发内容</li>
<li>数据包抵达服务端进行数据处理，并发送响应数据，完成数据传输</li>
</ul>
</li>
</ul>
<h3 id="6-2-Http"><a href="#6-2-Http" class="headerlink" title="6.2 Http"></a>6.2 Http</h3><ul>
<li>为什么不直接使用TCP呢？为了防止<strong>粘包</strong>：区分出不同批次的数据包，by header</li>
<li>超文本传输协议，<strong>H</strong>yper<strong>T</strong>ext <strong>T</strong>ransfer <strong>P</strong>rotocol</li>
<li>状态码<ul>
<li>1xx</li>
<li>2xx：成功 200</li>
<li>3xx：重定向，需要客户端重新发送请求</li>
<li>4xx：客户端错误，请求报文有误  400请求报文有误；403服务端禁止访问资源；404请求资源在服务端找不到</li>
<li>5xx：服务端错误 500服务端错误；501请求的功能尚未开放；502通常是网关或者代理时返回；503服务器忙无法处理</li>
</ul>
</li>
<li>http字段<ul>
<li>Host字段：客户端发送请求的时候，用于表示服务端域名</li>
<li>Content-Length：服务端返回响应的时候，用于表明数据长度</li>
<li>Connection：通常用于表示是长连接(<code>Connection: Keep-Alive</code>)<ul>
<li>http/1.1默认长连接，这个字段是为了兼容老版本http</li>
</ul>
</li>
<li>Content-Type：用于告诉客户端，本次数据的格式</li>
<li>Content-Encoding：用于说明数据的压缩方式</li>
<li>Accept-Encoding：用于客户端表示自己可以接收的压缩方式</li>
</ul>
</li>
<li>版本发展<ul>
<li>Http/1.0：无状态</li>
<li>Http/1.1：长连接</li>
<li>Http/2.0：基于http1进行了数据压缩(二进制)，并发设计(多个stream复用一条TCP连接)</li>
<li>Http/3.0</li>
</ul>
</li>
<li>Http和Https：HTTPS 协议需要向 CA（证书权威机构）申请数字证书<ul>
<li>对称加密和非对称加密结合的「混合加密」</li>
<li>Https默认端口是443，http是80</li>
<li>多了一个TLS握手的过程。目的是为了通过非对称加密握手协商或者交换出对称加密密钥</li>
</ul>
</li>
<li><p>如何优化https</p>
<ul>
<li>硬件方面：是计算密集型任务，所以增强CPU，加速TLS过程</li>
<li>软件方面：协议优化升级，linux内核升级</li>
<li>协议方面：优化密钥交换算法</li>
<li>证书优化：</li>
</ul>
</li>
<li><p>为什么有了HTTP还有websocket</p>
<ul>
<li>为了解决服务器向客户端主动推送数据的需求(也可能通过客户端轮询http请求实现)</li>
<li>基于TCP全双工的特性，设计出来的一种新协议，即websocket</li>
<li>为了兼容http使用场景，三次握手建立连接后，如果是普通的http请求则维持原状，反之则在http请求头中增强特殊的header，开始进行websocket握手连接，此后就是websocket了。</li>
</ul>
</li>
</ul>
<h3 id="6-3-TCP"><a href="#6-3-TCP" class="headerlink" title="6.3 TCP"></a>6.3 TCP</h3><ul>
<li><p>抓包工具：Wireshark    </p>
</li>
<li><p>特点：面向连接、可靠、基于字节流。</p>
</li>
<li><p>结构</p>
<p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/image-20240423172112523.png" alt="image-20240423172112523" style="zoom:67%;"></p>
<ul>
<li>序号（sequence number）：标识本报文段所发送数据的第一个字节的序号</li>
<li>确认序列（acknowledgement number）：期望收到对方下一个报文段的第一个数据字节序号，只有ACK为1的时候才生效</li>
<li>数据偏移：TCP报文段数据起始举例TCP报文段起始有多远</li>
<li>6个控制位<ul>
<li>URG：紧急位，=1时可以插队</li>
<li>ACK：确认位，连接后置为1</li>
<li>PSH：推送位，=1时，接收方尽快交付接收应用进程，不再等到缓存填满再向上交付</li>
<li>RST：复位，=1时，表明TCP连接中出现严重差错，必须释放连接再重新建立连接 </li>
<li>SYN：同步位，=1时表明是一个连接请求/连接接收报文</li>
<li>FIN：终止位，=1时候表明此报文发送方数据已发送完，要求释放连接</li>
</ul>
</li>
<li>窗口：发送方发送窗口的大小，用来给接收方来调整接收窗口大小</li>
</ul>
</li>
<li><p>三次握手</p>
<ul>
<li>客户端发送连接请求报文段，无应用层数据<ul>
<li>SYN=1，seq=x，seq是序号</li>
</ul>
</li>
<li>服务端为改TCP连接分配缓存和变量，并给客户端返回确认报文，无应用层数据<ul>
<li>SYN=1，ACK=1，seq=y，ack=x+1，ack是确认序列</li>
</ul>
</li>
<li>客户端为该TCP连接分配缓存和变量，并给客户端发送确认，可以携带数据<ul>
<li>SYN=0，ACK=1，seq=x+1,ack=y+1</li>
</ul>
</li>
</ul>
</li>
<li><p>四次挥手</p>
<p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/image-20240809224708031.png" alt="image-20240809224708031" style="zoom:33%;"></p>
<ul>
<li>主动方发送连接释放报文段。进入状态FIN_WAIT_1<ul>
<li>FIN=1，seq=u</li>
</ul>
</li>
<li>被动方回送一个确认报文段。进入CLOSED_WAIT状态，主动方接收后进入FIN_WAIT_2<ul>
<li>ACK=1，seq=v，ack=u+1</li>
</ul>
</li>
<li>被动方发送完数据，发出连接释放报文段。进入LAST_ACK状态。<ul>
<li>FIN=1，ACK=1，seq=w，ack=u+1</li>
</ul>
</li>
<li>主动方回送一个确认报文段。进入TIME_WAIT状态。再等待时间计时器设置的2MSL（最长报文段寿命）后进入CLOSE。<ul>
<li>ACK=1，seq=u+1，ack=w+1</li>
</ul>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>为什么需要四次挥手？</p>
<ul>
<li>TCP的半关闭造成的</li>
</ul>
<p>为什么中间的ACK和FIN不可以像三次握手那样合为一个报文段呢？</p>
<ul>
<li>socket网络编程中，执行close()方法会触发内核发送FIN报文（用户态调用的close()）,但是如果被动关闭方还有数据要处理，会等数据处理完毕后再调用close()，而ACK报文是系统内核完成，过程很快，所以ACK和FIN不能和为一个包</li>
</ul>
<p>为什么TIME_WAIT是2MSL？</p>
<ul>
<li>保证最后的ACK可以送达到被动关闭方，能够正常关闭</li>
</ul>
</blockquote>
<ul>
<li><p>可靠传输：</p>
<ul>
<li>校验：与UDP一样，增加伪首部</li>
<li>序号：一个报文段第一个字节的序号</li>
<li>确认：累计确认机制</li>
<li>重传：超时重传</li>
</ul>
</li>
<li><p>重传机制：</p>
<ul>
<li><p>超时重传：超时未收到指定的ACK报文就再发送，略大于RTT(一个往返时间)</p>
</li>
<li><p>快速重传：服务A发送seq1~6给服务B，但是seq2丢失，服务A只会收到ACK2，然后就再发送seq2</p>
<blockquote>
<p>A只知道seq2未送达，所以发seq2，是否需要一起发送seq3~6？引入SACK</p>
</blockquote>
</li>
<li><p>SACK：双方开启，在TCP头部加入SACK，可以将已接收的信息发送到发送方，避免少发或者多发</p>
</li>
<li><p>D-SACK(Duplicate )：</p>
</li>
</ul>
</li>
<li><p>滑动窗口：</p>
<ul>
<li>已发送且收到ACK确认</li>
<li>已发送但未收到ACK确认</li>
<li>未发送但大小在接收方处理范围</li>
<li>未发送但总大小超过接收方处理范围</li>
</ul>
</li>
<li><p>流量控制：控制接收方窗口，为了防止接收方爆炸</p>
<ul>
<li>通过设置报文段中的窗口字段来实现动态控制</li>
<li>零窗口问题：发送方收到了接收方的零窗口通知，启动计时器，一段时间后再询问接收方窗口大小(防止接收方窗口变更消息丢失而引发的死锁)</li>
<li>小窗口问题(糊涂窗口综合症)：由于接收方处理数据能力，导致缓冲区的大小越来越小(20,10,5,4,2,1…)，进而发送方可发送的数据量也越来越小，最终造成流量的浪费。解决：设置最小窗口阈值</li>
</ul>
</li>
<li><p>拥塞控制：控制发送方窗口cwnd，为了防止网络环境爆炸</p>
<ul>
<li><p>慢启动：建立连接后，先发送1个单位，接收ack应答后再发送2个单位，接收后再发送4个单位，直到达到慢启动门限，一般是2^16：65535字节</p>
</li>
<li><p>拥塞避免：达到慢启动门限后，指数增长变成线性（收到一个ack增加一个字节）</p>
</li>
<li><p>超时重传：cwdn变为1，再重新慢启动</p>
</li>
<li><p>快恢复</p>
<p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/image-20240714112452253.png" alt="image-20240714112452253" style="zoom:50%;"></p>
</li>
</ul>
</li>
<li><p>TCP的半连接队列(SYN队列)和全连接队列(accept 队列)</p>
<ul>
<li><p>建立握手前，服务端接收到客户端请求后，内核会将连接存储在半连接队列中，并发送SYN+ACK</p>
</li>
<li><p>接收到客户端的第三次握手后，内核会移除SYN队列，创建完全的连接，加入到accept队列中</p>
</li>
<li><p>半连接队列满之后，就无法接收新的TCP连接了（SYN洪泛攻击就是利用这个特性）</p>
<blockquote>
<p>SYN洪泛攻击如何解决？</p>
<p>利用SYN cookie：不保存半连接队列，生成一个序列(cookie)发送给请求连接方，cookie为由源IP、目的IP、源端口、目的端口以及一个服务器密钥组合后生成的hash，请求方第三次的握手需要携带这个序列，然后再由服务端来解析判断是不是同一组请求，如果第三次握手没有携带这个序列，则被判断为是攻击者，不做任何处理，也就避免了半连接队列爆</p>
</blockquote>
</li>
</ul>
</li>
<li><p>如何优化TCP连接？</p>
<ul>
<li><p>三次握手的优化</p>
<ul>
<li>客户端：SYN重传次数</li>
<li>服务端：SYN半连接队列、accept 全连接队列长度、ACK+SYN的重传次数</li>
</ul>
</li>
<li><p>四次挥手的优化</p>
<ul>
<li>主动方：FIN报文重传次数、FIN_WAIT_2状态时间、TIME_WAIT状态上限</li>
<li>被动方：</li>
</ul>
</li>
<li><p>数据传输的优化：主要是针对滑动窗口</p>
<ul>
<li>扩大窗口大小：连接的缓存区（滑动窗口）根据网络传输能力设置</li>
<li>调整发送方缓存区范围</li>
<li>调整接收方缓存区范围</li>
<li>打开缓存区动态调节</li>
<li>调整内存范围</li>
</ul>
</li>
</ul>
</li>
<li><p>怎么理解TCP是面向字节流的传输？（UDP是面向报文）</p>
<ul>
<li>一次消息通过多次发送——粘包问题</li>
<li>解决粘包：固定长度、特殊字符(HTTP)、自定义消息结构体</li>
</ul>
</li>
<li><p>为什么TCP每次建立连接的时候，初始化序列号不一样？</p>
<ul>
<li>防止历史报文被错误接收。四次挥手的时候不是有一个2MSL的时长吗？（如果没有正常的断开，有错误的可能）</li>
<li>随机生成的序列号会冲突吗？是基于时钟计时器递增的，基本不会出现</li>
</ul>
</li>
<li><p>syn包什么时候会被丢弃</p>
<ul>
<li>TCP两个队列满了（半连接SYN队列和全连接accpet队列），造成SYN报文丢弃</li>
</ul>
</li>
<li><p>已建立连接的TCP，客户端突然掉线了，服务端不知道，客户端再上线的时候发起SYN握手，服务器怎么做？</p>
<ul>
<li>客户端的 IP、服务端 IP、目的端口都没变，关键看源端口和上次是否一致？<ul>
<li>一致：但是大概率与服务端的期望SYN不一致，服务端会返回期望的ACK报文，客户端收到后发现也不是期望的报文，于是回RST报文，释放连接</li>
<li>不一致：相当于建立一个新的连接。原来的连接由客户端内核返回一个RST报文，兜底是服务端检测客户端没有活动，释放连接</li>
</ul>
</li>
</ul>
</li>
<li><p>四次挥手的时候如果FIN报文比ACK先到达主动方会发生什么（第三次比第二次快到）</p>
<ul>
<li>在FIN_WAIT_2状态的时候收到了乱序的FIN报文，会被加入到乱序队列中，并不会加入到TIME_WAIT状态，等再次收到数据包的时候（第二次挥手的包），会从乱序队列中找对应的乱序的FIN报文（有FIN标志），则进入TIME_WAIT状态</li>
</ul>
</li>
<li><p>拔掉网线后，之前的TCP连接还在吗</p>
<ul>
<li>拔掉网线后，有数据传输：如果在超时重传阈值之前恢复，则没有影响，反之服务端会断开连接，客户端再次发送的时候，服务端内核就会恢复RST报文</li>
<li>拔掉网线后没有数据传输：没有开启TCP保活机制，则会一直存在，开启的话会探活，超出次数则断开</li>
</ul>
</li>
<li><p>HTTPS中TCP和TLS顺序？</p>
<ul>
<li>先TCP三次握手再TLS</li>
</ul>
</li>
<li><p>TCP协议的缺点</p>
<ul>
<li>升级困难，因为是在内核中的，应用程序无法升级</li>
<li>TCP建立连接延迟：三次握手</li>
<li>TCP存在队头阻塞的情况：如果seq1~5中seq2丢失，内核是无法处理seq3~5的</li>
<li>网络迁移需要重新建立TCP连接：四元组发生了变化（源 IP、源端口、目的 IP、目的端口）</li>
</ul>
</li>
<li><p>如何基于UDP实现可靠传输？<strong>QUIC</strong>协议</p>
</li>
<li><p>UDP和TCP可以使用同样的端口吗？可以，因为在内核中是两个完全独立的软件模块。</p>
</li>
</ul>
<h3 id="6-4-IP"><a href="#6-4-IP" class="headerlink" title="6.4 IP"></a>6.4 IP</h3><ul>
<li><p>类型</p>
<ul>
<li>A类：      0 +   7位网络号 + 24位主机号</li>
<li>B类：    10 + 14位网络号 + 16位主机号</li>
<li>C类：  110 + 21位网络号 +   8位主机号</li>
<li>D类：1110 + 28位组播地址，多用于多播</li>
<li>E类： 1111 + 预留后用</li>
</ul>
</li>
<li><p>主机号全为0指某个网络，全为1指定某个网络下的所有主机，用于广播</p>
</li>
<li><p>优点：简单明了、选路（基于网络地址）简单（因为可以通过前3位快速判断是ABC类）</p>
</li>
<li><p>缺点：</p>
<ul>
<li>同一网络下没有地址层次</li>
<li>ABC不能很好的与现实匹配，C类地址的主机只有254，B类却有65534</li>
</ul>
</li>
<li><p>无分类地址CIDR：表示形式 <code>a.b.c.d/x</code>，前x位为网络号</p>
</li>
<li><p>子网划分：将主机号部分再分为子网网络号 + 子网主机号</p>
<p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/image-20240715221921171.png" alt="image-20240715221921171" style="zoom:50%;"> </p>
</li>
<li><p>IPv6：128位，每16位作为一组 </p>
</li>
<li><p>NAT技术：IP地址有32位，最多只能 2 ^ 32 = 4294967296 台设备加入互联网，为了解决地址不足的问题，引入NAT</p>
</li>
<li><p>IP协议的相关技术</p>
<ul>
<li><p>DNS 域名解析：越往右层级越高</p>
<ul>
<li>查缓存 ==&gt; 查操作系统本机域名解析文件 <code>hosts</code> ==&gt; 进行DNS域名查询</li>
</ul>
</li>
<li><p>ARP 与 RARP 协议：查询IP地址的下一跳对应的MAC地址，RARP相反</p>
<ul>
<li>主机广播发送ARP请求 ==&gt; 同一链路的所有设备查询如果有就返回ARP响应</li>
</ul>
</li>
<li><p>DHCP 动态获取 IP 地址</p>
<ul>
<li>DHCP 客户端进程监听的是 68 端口号，DHCP 服务端进程监听的是 67 端口号</li>
<li>客户端发起<strong>DHCP发现报文</strong>，但是此时客户端没有IP地址，也不知道DHCP服务器IP地址，就通过广播发送UDP</li>
<li>服务端收到后发送<strong>DHCP 提供报文</strong>，也是广播发送：提供可租约的 IP 地址、子网掩码、默认网关、DNS 服务器以及 IP 地址租用期。</li>
<li>客户端收到一个或多个报文后，选择一个服务端，发送<strong>DHCP 请求报文</strong></li>
<li>服务端 DHCP ACK 报文对 DHCP 请求报文进行响应，应答所要求的参数</li>
</ul>
</li>
<li><p>NAT 网络地址转换：IP 地址 + 端口号一起进行转换</p>
<p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/image-20240715223854138.png" alt="image-20240715223854138" style="zoom:50%;"></p>
<ul>
<li>缺点：<ul>
<li>外部无法主动与NAT内部服务建立连接，因为没有转换记录</li>
<li>转换地址的性能开销</li>
<li>依赖于转换表，如果NAT路由器重启了，所有TCP连接都将会重置</li>
</ul>
</li>
<li>如何解决？<ul>
<li>Ipv6</li>
<li>NAT穿透技术</li>
</ul>
</li>
</ul>
</li>
<li><p>ICMP 互联网控制报文协议：确认 IP 包是否成功送达目标地址、报告发送过程中 IP 包被废弃的原因和改善网络设置等。</p>
<ul>
<li>查询报文（诊断）和差错报文（通知出错原因）</li>
<li>常见差错报文类型<ul>
<li>目标不可达消息 —— 类型 为 <code>3</code></li>
<li>原点抑制消息 —— 类型 <code>4</code></li>
<li>重定向消息 —— 类型 <code>5</code></li>
<li>超时消息 —— 类型 <code>11</code></li>
</ul>
</li>
</ul>
</li>
<li><p>IGMP 因特网组管理协议：管理D类地址，组播</p>
</li>
</ul>
</li>
<li><p>Ping的原理：基于ICMP协议进行</p>
</li>
<li><p>断网了还能ping 127.0.0.1吗？可以</p>
</li>
<li><p>localhost 和 127.0.0.1</p>
<ul>
<li>本质上localhost 是域名，是在本机中的hosts文件中定义的指向127.0.0.1</li>
</ul>
</li>
</ul>
<h2 id="七-操作系统"><a href="#七-操作系统" class="headerlink" title="七 操作系统"></a>七 操作系统</h2><h3 id="7-1-硬件结构"><a href="#7-1-硬件结构" class="headerlink" title="7.1 硬件结构"></a>7.1 硬件结构</h3><ul>
<li><p>内存；CPU；总线；输入、输出设备</p>
</li>
<li><p>存储器的结构：寄存器、CPU Cache(L1,L2,L3)、内存、SSD/HDD 硬盘</p>
<ul>
<li>L1 L2是各核心独有的</li>
</ul>
</li>
<li><p>多核心CPU的缓存一致性(L1 L2)</p>
<ul>
<li>通过写传播和事务的串行化</li>
</ul>
</li>
<li><p>总线嗅探：写传播的实现，通过广播来告诉其他核心数据变化</p>
</li>
<li><p>MESI协议</p>
<ul>
<li><em>Modified</em>，已修改</li>
<li><em>Exclusive</em>，独占</li>
<li><em>Shared</em>，共享</li>
<li><em>Invalidated</em>，已失效</li>
</ul>
</li>
<li><p>CPU如何执行任务的</p>
<ul>
<li>如何读写数据：CPU三级缓存<ul>
<li>伪共享问题：CPU从内存中读取数据是Cache Line 为单位(一组数据)，如果两个核AB读取了空间上连续的变量ab，分别只修改了a、b，但是会造成数据的不一致问题</li>
<li>如何避免：多个线程共享的热点数据，避免这些数据在同一个Cache Line中</li>
</ul>
</li>
<li>如何选择线程：linux内核中，线程和进程都是 <code>task_struct</code> 结构体<ul>
<li>调度算法</li>
</ul>
</li>
</ul>
</li>
<li><p><code>0.1 + 0.2 == 0.3?</code></p>
<ul>
<li><p>负数的二进制：1(符号位，正数是0) +( 正数部分的补码+1)</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-1 : 1 1111111 11111111 11111111</span><br><span class="line">1  : 0 0000000 00000000 00000001 (int类型)</span><br><span class="line">补码: 1 1111111 11111111 11111110</span><br><span class="line">再+1: 1 1111111 11111111 11111111</span><br></pre></td></tr></tbody></table></figure>
</li>
</ul>
</li>
</ul>
<h3 id="7-2-操作系统结构"><a href="#7-2-操作系统结构" class="headerlink" title="7.2 操作系统结构"></a>7.2 操作系统结构</h3><ul>
<li>内核的能力<ul>
<li>管理进程、线程，决定哪个进程、线程使用 CPU，也就是进程调度的能力；</li>
<li>管理内存，决定内存的分配和回收，也就是内存管理的能力；</li>
<li>管理硬件设备，为进程与硬件设备之间提供通信能力，也就是硬件通信能力；</li>
<li>提供系统调用，如果应用程序要运行更高权限运行的服务，那么就需要有系统调用，它是用户程序与操作系统之间的接口。</li>
</ul>
</li>
</ul>
<h3 id="7-3-内存管理"><a href="#7-3-内存管理" class="headerlink" title="7.3 内存管理"></a>7.3 内存管理</h3><ul>
<li><p>虚拟内存：为了让不同的进程同时运行而互不干涉，操作系统提供一种映射，将不同进程的虚拟地址和物理地址映射</p>
<ul>
<li>如果没有虚拟内存，同一个代码多线程运行的时候就会产生物理地址冲突</li>
<li>虚拟内存可以使得<strong>进程对运行内存超过物理内存大小</strong>，因为程序运行符合局部性原理，CPU 访问内存会有很明显的重复访问的倾向性，对于那些没有被经常使用到的内存，我们可以把它换出到物理内存之外，比如硬盘上的 swap 区域。</li>
<li>由于每个进程都有自己的页表，所以每个进程的虚拟内存空间就是相互独立的。进程也没有办法访问其他进程的页表，所以这些页表是私有的，这就<strong>解决了多进程之间地址冲突的问题</strong>。</li>
<li>页表里的页表项中除了物理地址之外，还有一些标记属性的比特，比如控制一个页的读写权限，标记该页是否存在等。在内存访问方面，操作系统提供了<strong>更好的安全性</strong>。</li>
</ul>
</li>
<li><p>如何管理虚拟地址和物理地址之间的关系</p>
<ul>
<li><p>内存分段：带来内存外碎片和内存交换效率低(解决碎片进行swap重分配的过程)的问题</p>
<p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/image-20240717222754454.png" alt="image-20240717222754454" style="zoom:33%;"></p>
</li>
<li><p>内存分页：会出现内存内碎片、对进程来说不太友好</p>
<ul>
<li>换入Swap In和换出Swap Out是指操作系统内存不够时候将页表写到硬盘暂时释放的过程，因为一次只写几页，所以效率较高</li>
</ul>
<p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/image-20240717223025442.png" alt="image-20240717223025442" style="zoom:33%;"></p>
<ul>
<li>带来的问题：页表内存大 ==&gt; 多级页表</li>
</ul>
</li>
<li><p>段页式内存管理：对于进程来说看到的是段表，对物理内存来说看到的是页表</p>
<p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/image-20240717223731697.png" alt="image-20240717223731697" style="zoom:50%;"></p>
</li>
</ul>
</li>
<li><p>操作系统怎么分配内存的？ <code>malloc()</code>：分配的是虚拟内存，如果没有被访问是不会映射到物理内存的，当程序开始读写的时候才分配</p>
</li>
<li><p>内存满了怎么办？当物理内存满了，会发送<strong>缺页中断</strong>，进程切换到内核态</p>
<ul>
<li>后台内存回收：异步的，不阻塞进程</li>
<li>直接内存回收：同步的，会阻塞进程，后台回收更不上的时候触发</li>
<li>触发OOM机制：根据算法kill占用物理内存高的进程</li>
</ul>
</li>
<li><p>回收哪些文件？文件页、匿名页</p>
</li>
<li><p>4GB的物理内存机器申请8GB的内存</p>
<ul>
<li>32位操作系统：无法申请，最多3GB（内核1GB，用户3GB）</li>
<li>64位操作系统：可以，但是如果使用的时候超出了4GB，且没有开启swap机制，会OOM</li>
</ul>
</li>
<li><p>如何避免预读失效和缓存污染的问题？本质是LRU算法</p>
<ul>
<li>Redis的做法是LRU，Mysql和Linux的做法是改进的LRU算法</li>
<li>Linux读取：在文件系统中增加Page Cache页缓存，属于内存里的数据，加快访问速度</li>
<li><p>Mysqld读取：Innodb存储引擎中设计了一个Buffer Pool缓冲池，属于内存里的数据，修改数据直接修改缓冲池，后台再写入磁盘</p>
</li>
<li><p>Linux和Mysql的LRU操作单位都是页</p>
</li>
<li>什么是预读？如果需要磁盘A的0-3kb数据，linux会读取一个页(0-4kb)，为了减少将来的IO次数，会预读3个page，也就是0-16kb都会读取。</li>
<li>什么是预读失效？就是后面预读的数据没有被用到</li>
<li>如何避免预读失效？改进的LRU<ul>
<li>Linux：实现两个LRU链表，活跃LRU、非活跃LRU链表</li>
<li>Mysql：在一个LRU链表中划分为：young 区域 和 old 区域</li>
<li>预读的数据就放在非活跃链表/old区域即可</li>
</ul>
</li>
<li>什么是缓存污染？只访问一次的数据放到链表头部，多了之后就会淘汰热点数据，如果这些数据长时间不被访问就会造成污染，导致下次访问热点数据的时候产生大量的IO</li>
<li>如何解决缓存污染？<ul>
<li>Linux：非活跃链表的数据读取两次才进入活跃LRU头部</li>
<li>Mysql：old区域被访问两次且两次时间间隔在1s以上才会进入young区域</li>
</ul>
</li>
</ul>
</li>
<li><p>深入理解虚拟内存</p>
<ul>
<li><p>划分：</p>
<p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/image-20240718220702762.png" alt="image-20240718220702762" style="zoom:33%;"></p>
<ul>
<li>代码段：用户的代码</li>
<li>数据段：代码中指定的初始值的全局变量和静态变量</li>
<li>BSS段：没有指定初始值的全局变量和静态变量，加载进内存后初始化为0</li>
<li>堆：以上是编译阶段申请的，堆是用于存放运行过程中动态生成的内存</li>
<li>文件映射与匿名映射区：动态链接库中的代码段、数据段、BSS段，以及内存映射区域的文件映射与匿名映射区</li>
<li>栈：程序调用函数过程中使用到的局部方法和函数参数</li>
</ul>
</li>
<li><p>范围</p>
<ul>
<li>32位系统中指针的寻址范围是2^32，所能表达的区域大小就是4GB，其中用户态3GB，内核空间1GB</li>
<li>64位系统中指针的寻址范围是2^64，但是只用了48位来描述空间，也就是256TB，内核、用户各一半</li>
</ul>
</li>
<li><p>内核是如何划分和管理的？</p>
<ul>
<li><p><code>mm_struct</code> 结构体定义上述不同区域的范围，通过task_size 域来划分用户和内核空间</p>
</li>
<li><p>若干个<code>vm_area_struct</code>结构体一一对应了上述的区域</p>
<p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/image-20240718222727080.png" alt="image-20240718222727080" style="zoom: 50%;"></p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="7-4-进程管理"><a href="#7-4-进程管理" class="headerlink" title="7.4 进程管理"></a>7.4 进程管理</h3><ul>
<li><p>进程：代码编译为二进制可执行文件，运行文件后装载进入内存，CPU会执行程序中的命令，运行中的命令就是进程</p>
</li>
<li><p>线程：进程由若干个线程组成，操作系统中执独立运行的最小单位</p>
</li>
<li><p>并发：单个CPU一个时间段执行了多个进程</p>
</li>
<li><p>并行：多个CPU一个时间点执行了多个进程</p>
</li>
<li><p>进程状态：</p>
<p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/image-20240719201817005.png" alt="image-20240719201817005" style="zoom: 50%;"></p>
<ul>
<li>多个进程阻塞的时候，会占用物理内存空间，所以在虚拟内存管理的操作系统中，会把阻塞状态的进程的物理内存换出到磁盘，这个时候进程的状态就变成了<strong>挂起</strong></li>
</ul>
</li>
<li><p>PCB(process control block)：进程控制块，用于描述进程，1对1</p>
<ul>
<li>进程描述信息：进程标识符、用户标识符(进程归属的进程)</li>
<li>进程控制和管理信息：当前进程的状态、进程优先级</li>
<li>资源分配清单：有关内存地址空间或虚拟地址空间的信息</li>
<li>CPU相关信息：CPU中各个寄存器的值，进程被切换的时候需要保存CPU的状态信息</li>
</ul>
</li>
<li><p>多个PCB通过链表的结构把状态相同的进程串在一起，组成各种队列：阻塞队列、就绪队列等</p>
</li>
<li><p>进程的控制</p>
<ul>
<li>创建进程：申请一个空白的PCB，填入相关信息，分配内存资源，并加入到就绪队列中</li>
<li>终止进程（正常结束、异常结束以及外界干预(信号 <code>kill</code> 掉)）：查找PCB、如果处于执行状态，就立即结束、如果有子进程就交给1号进程管理、归还资源给操作系统、从PCB队列删除</li>
<li>阻塞进程：找到PCB、阻塞、插入到阻塞队列中</li>
<li>唤醒进程：找到PCB、设置状态为就绪、插入就绪队列</li>
</ul>
</li>
<li><p>进程的上下文切换：一个进程切换到另一个进程运行</p>
<ul>
<li>CPU 寄存器和程序计数是 CPU 在运行任何任务前，所必须依赖的环境，这些环境就叫做 <strong>CPU 上下文</strong>。</li>
<li>所以就是存储和读取PCB中的CPU相关信息的过程，</li>
</ul>
</li>
<li><p>线程和进程</p>
<ul>
<li>进程是资源（包括内存、打开的文件等）分配的单位，线程是 CPU 调度的单位；</li>
<li>进程拥有一个完整的资源平台，而线程只独享必不可少的资源，如寄存器和栈；</li>
<li>线程同样具有就绪、阻塞、执行三种基本状态，同样具有状态之间的转换关系；</li>
<li>线程能减少并发执行的时间和空间开销；</li>
</ul>
<blockquote>
<p>为什么线程能减少并发执行的时间和空间开销？</p>
<ul>
<li>线程的<strong>创建时间</strong>比进程快，因为进程在创建的过程中，还需要资源管理信息，比如内存管理信息、文件管理信息，而线程在创建的过程中，不会涉及这些资源管理信息，而是共享它们；</li>
<li>线程的<strong>终止时间</strong>比进程快，因为线程释放的资源相比进程少很多；</li>
<li>同一个进程内的线程切换比进程切换快，因为线程具有相同的地址空间（虚拟内存共享），这意味着同一个进程的线程都具有同一个页表，那么在切换的时候<strong>不需要切换页表</strong>。而对于进程之间的切换，切换的时候要把页表给切换掉，而页表的切换过程开销是比较大的；</li>
<li>由于同一进程的各线程间共享内存和文件资源，那么在线程之间数据传递的时候，就<strong>不需要经过内核</strong>了，这就使得线程之间的数据交互效率更高了；</li>
</ul>
</blockquote>
</li>
<li><p>线程的上下文切换和进程的区别</p>
<ul>
<li>如果是不同进程的线程切换，就和切换进程一样</li>
<li>如果是同一进程内的线程切换，只需要切换线程的私有数据、寄存器等不共享的数据，开销会小很多(没了虚拟内存等资源切换)</li>
</ul>
</li>
<li><p>线程的实现：</p>
<ul>
<li>用户线程：在用户空间实现的线程</li>
<li>内核线程：在内核中实现的线程，是由内核管理的线程，多个用户线程对1个内核线程</li>
<li>轻量级线程：在内核中来支持用户线程；</li>
</ul>
</li>
<li><p>用户线程的管理：基于用户态的线程管理库来实现的。线程控制块（Thread Control Block, TCB） 也是在库里面来实现的，</p>
<ul>
<li>对于操作系统而言是看不到这个TCB的，TCB是进程的私有</li>
<li>TCB中跟踪记录了各个线程的状态信息（PC、栈指针、寄存器）</li>
<li>优点：切换由线程管理库实现，不用用户态和内核态切换，速度快；由TCB记录线程信息</li>
<li>缺点：操作系统不参与其调度，如果一个线程发起系统调用而阻塞，那进程所包含的用户线程都不能执行了；</li>
</ul>
</li>
<li><p>内核线程的管理：也是通过TCB</p>
<ul>
<li>内核线程的TCB是操作系统来管理的</li>
<li>优点：如果某个内核线程发起系统调用而被阻塞，并不会影响其他内核线程的运行；</li>
<li>缺点：内核来维护进程和线程的上下文信息，如 PCB 和 TCB；线程的创建、终止和切换都是通过系统调用的方式来进行，开销大</li>
</ul>
</li>
<li><p>进程之间的通信：关键是如何通过内核空间来通信</p>
<p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/image-20240803220346902.png" alt="image-20240803220346902" style="zoom:50%;"></p>
<ul>
<li><p>管道：<code>mkfifo myPipe</code>创建一个管道，本质是内核空间里面的内存（队列），两端分别实现读写</p>
<ul>
<li>如果是父子进程，在fork的时候就会创建管道，并绑定到</li>
<li>如果不是父子进程，则是通过共同父进程例如shell</li>
<li>但是效率低</li>
</ul>
</li>
<li><p>消息队列：本质是保存在内核中的消息链表</p>
<ul>
<li>通信异步但是不适合大数据的传输    </li>
<li>还存在用户态到内核态的数据拷贝开销</li>
</ul>
</li>
<li><p>共享内存</p>
<ul>
<li>解决用户态、内核态的开销，虚拟内存映射到相同的物理内存中即可</li>
<li>带来了写写问题</li>
</ul>
</li>
<li><p>信号量：表示资源的数量 <code>&gt;= 0</code> 表示可以访问</p>
<ul>
<li>用于进程之间的互斥和同步</li>
</ul>
</li>
<li><p>信号：<code>kill -l</code> 查看所有的信号</p>
<ul>
<li>用于异常情况下的工作模式，比如shell中<code>ctrl + C</code> 产生<code>SIGINT</code>信号，表示终止进程</li>
</ul>
</li>
<li><p>socket：用于跨网络与不同主机的进程通信</p>
<ul>
<li><p>系统调用：<code>int socket(int domain, int type, int protocal)</code></p>
</li>
<li><p>简述TCP</p>
<p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/image-20240803223017983.png" alt="image-20240803223017983" style="zoom: 50%;"></p>
<ul>
<li>服务端、客户端初始化socket，得到文件描述符</li>
<li>服务端调用<code>bind</code>，绑定IP和端口</li>
<li>服务端调用<code>listen</code>，进行监听</li>
<li>服务端调用<code>accept</code>，等待客户端连接</li>
<li>客户端调用<code>connet</code>，请求连接</li>
<li>服务端调用<code>accept</code>，返回用于传输<code>socket</code>的文件描述符</li>
<li>客户端调用<code>write</code>写数据，服务端调用<code>read</code>读数据</li>
<li>客户端调用<code>close</code>断开，服务端<code>read</code>的时候就会读到<code>EOF</code>，处理完毕后，服务端调用<code>close</code>，关闭</li>
</ul>
</li>
</ul>
</li>
<li><p>多线程冲突问题</p>
<ul>
<li>锁：加锁、解锁</li>
<li>信号量：P(-1)、V(+1)操作,实现对临界区的互斥访问</li>
</ul>
</li>
<li><p>死锁问题</p>
<ul>
<li>互斥条件：多个线程不能同时使用同一个资源</li>
<li>持有并等待条件：线程在等待资源的同时不会释放自己持有的资源</li>
<li>不可剥夺条件：线程正在使用的资源不可被剥夺</li>
<li><p>循环等待条件：死锁发生时，两个线程获取资源构成了链</p>
</li>
<li><p>从以上四个条件进行破坏</p>
</li>
</ul>
</li>
<li><p>锁分类</p>
<ul>
<li>乐观锁：CAS</li>
<li>悲观锁：互斥锁、自旋锁</li>
</ul>
</li>
<li><p>一个进程可以创建多少线程</p>
<ul>
<li>进程虚拟内存空间的上限（32位3G，64位128T）</li>
<li>系统参数的限制</li>
</ul>
</li>
<li><p>线程崩溃进程也会崩溃吗？不一定，比如线程崩溃不会导致JVM进程崩溃</p>
<ul>
<li>线程崩溃后通过信号（SIGSEGV ）来告诉进程，JVM自定义了自己的信号处理函数，拦截了SIGSEGV 信号</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="7-5-调度算法"><a href="#7-5-调度算法" class="headerlink" title="7.5 调度算法"></a>7.5 调度算法</h3><ul>
<li>进程调度算法<ul>
<li>先到先服务</li>
<li>最短作业时间</li>
<li>高响应比优先调度算法：优先权= (等待时间 + 要求服务时间) / 要求服务时间</li>
<li>时间片轮转调度算法</li>
<li>最高优先级调度算法</li>
<li>多级反馈队列调度算法：时间片+ 优先级<ul>
<li>优先级越高时间片越短，最开始进入优先级最高的队列，没执行完进入下一级队列</li>
</ul>
</li>
</ul>
</li>
<li>内存页面置换算法：当出现缺页异常，需调入新页面而内存已满时，选择被置换的物理页面<ul>
<li>最佳页面置换算法：选择未来最长时间不访问的页面。</li>
<li>先进先出置换算法：选择在内存驻留时间很长的页面进行中置换</li>
<li>最近最久未使用的置换算法（LRU）</li>
<li>时钟页面置换算法</li>
</ul>
</li>
<li>磁盘调度算法：优化磁盘的访问请求顺序<ul>
<li>先来先服务</li>
<li>最短寻道时间优先算法</li>
<li>扫描算法：避免磁头在一个小区域来回扫动</li>
<li>循环扫描算法</li>
<li>LOOK 与 C-LOOK算法</li>
</ul>
</li>
</ul>
<h3 id="7-6-文件系统"><a href="#7-6-文件系统" class="headerlink" title="7.6 文件系统"></a>7.6 文件系统</h3><ul>
<li><p>linux文件数据结构</p>
<ul>
<li>索引节点<em>inode</em>：记录文件的元信息，唯一标识，会被存储于硬盘</li>
<li>目录项<em>dentry</em>：记录文件名、与其他目录项的层级关系，由内核维护，缓存于内存（与inode多对一）</li>
</ul>
</li>
<li><p>文件如何存储在硬盘？</p>
<ul>
<li><p>磁盘最小读取单位是扇区 512B，为提高效率，linux以逻辑块为单位：8个扇区 4KB</p>
<p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/image-20240804120447481.png" alt="image-20240804120447481" style="zoom:50%;"></p>
</li>
</ul>
</li>
<li><p>虚拟文件系统（Virtual File System，VFS）</p>
<ul>
<li>针对文件系统种类繁多(磁盘、内存、网络)，为给用户提供统一的接口，在用户层和文件系统中提供的中间层</li>
</ul>
</li>
<li><p>文件存储</p>
<ul>
<li>连续存储</li>
<li>非连续：链表+索引(指向文件头)</li>
</ul>
</li>
<li><p>空闲空间管理</p>
<ul>
<li><p>空闲表法</p>
</li>
<li><p>空闲链表法</p>
</li>
<li><p>位图（linux使用），每位代表 块</p>
<ul>
<li><p>假设是在一个块中，共可以表示 <code>4 * 1024 * 8 = 2^15</code> 个空闲块，最大的空间是 <code>2^15 * 4 * 1024 = 2^27</code> 个 byte，也就是 128M。</p>
</li>
<li><p>N个 一个块的位图 + 一系列的块 称为块组，用来表示文件</p>
<p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/image-20240804124456116.png" alt="image-20240804124456116" style="zoom:50%;"></p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>软链接和硬链接：给某个文件取个别名</p>
<ul>
<li>硬链接：多个目录项中的「索引节点」指向一个文件，删除所有的硬链接以及源文件才彻底删除</li>
<li>软链接：相当于重新创建一个文件，有独立的inode，内容是另一个文件的路径</li>
</ul>
</li>
<li><p>文件IO</p>
<ul>
<li>缓存IO/非缓存IO：前者是通过标准库的缓存实现文件的加速访问，标准库再通过系统调用访问文件。</li>
<li>直接与非直接 IO：是否使用了内核缓存</li>
<li><p>阻塞与非阻塞IO：用户线程执行<code>read</code>线程是否会被阻塞</p>
<ul>
<li>阻塞等待的是「内核数据准备好」和「数据从内核态拷贝到用户态」这两个过程</li>
</ul>
</li>
<li><p>同步与异步IO：</p>
</li>
</ul>
</li>
</ul>
<h3 id="7-7-设备管理"><a href="#7-7-设备管理" class="headerlink" title="7.7 设备管理"></a>7.7 设备管理</h3><ul>
<li><p>从键盘敲入字母发生了什么</p>
<p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/image-20240804133806467.png" alt="image-20240804133806467" style="zoom:50%;"></p>
<ul>
<li>输入字符后，<strong>键盘控制器</strong>就会产生扫描码数据，并将其缓冲在键盘控制器的寄存器中，紧接着键盘控制器通过总线给 CPU 发送<strong>中断请求</strong></li>
<li>CPU 收到中断请求后，操作系统会<strong>保存被中断进程的 CPU 上下文</strong>，然后调用键盘的<strong>中断处理程序</strong></li>
<li>键盘中断处理程序：<strong>键盘驱动程序</strong>初始化注册的，功能是从键盘控制器的寄存器缓冲区读取扫描码，再根据扫描码找到字符，并翻译为对应的ASCII码,放到显示字符读缓冲区队列,由显示器读取</li>
</ul>
</li>
</ul>
<h3 id="7-8-网络管理"><a href="#7-8-网络管理" class="headerlink" title="7.8 网络管理"></a>7.8 网络管理</h3><ul>
<li><p>DMA—直接内存访问(Direct Memory Access) 技术</p>
<p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/image-20240804135136727.png" alt="image-20240804135136727" style="zoom: 67%;"></p>
<ul>
<li>为了解决CPU读取磁盘内容带来的CPU中断问题,DMA读取完数据后发送中断信号给CPU,让CPU读数据</li>
</ul>
</li>
<li><p>传统的文件传输</p>
<p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/image-20240804135524908.png" alt="image-20240804135524908" style="zoom:50%;"></p>
<ul>
<li>发生了4次用户态内核态的转换以及4次数据拷贝,如何优化?<ul>
<li>减少切换次数和数据拷贝次数</li>
</ul>
</li>
</ul>
</li>
<li><p>零拷贝技术（kafka，nginx使用）</p>
<ul>
<li><code>mmap()</code>：将<code>read()</code> 改为<code>mmap()</code> 。改进是在内存中建立一个到磁盘的映射，数据直接同步在内存，由操作系统异步同步内存到硬盘的数据。适合小数据的传输，rocketMQ<ul>
<li>4次上下文切换(用户态 -&gt; 内核态 -&gt; 用户态 -&gt; 内核态 -&gt; 用户态)和3次拷贝(磁盘DMA拷贝到内核缓冲区 -&gt; 内核缓冲区CPU拷贝到socket缓冲区 -&gt; socket缓冲区DMA拷贝到协议引擎)</li>
</ul>
</li>
<li><code>sendfile()</code>：将<code>read()</code> 改为<code>sendfile()</code>。 改进是直接在内核态中进行缓存区到socket缓冲区的数据拷贝<ul>
<li>2次上下文切换(用户态 -&gt; 内核态 -&gt; 用户态)和2次拷贝(磁盘DMA拷贝到内核缓冲区 -&gt; 内核缓冲区DMA拷贝到协议引擎)</li>
</ul>
</li>
</ul>
</li>
<li><p><code>page cache</code>：缓存最近被访问的数据，零拷贝技术的基础</p>
<ul>
<li>解决机械硬盘寻址慢的问题</li>
</ul>
</li>
<li><p>网络socket基本过程：见进程管理部分</p>
<ul>
<li>最大连接数限制：文件描述符(socket也是文件)限制1024默认、系统内存限制</li>
</ul>
</li>
<li><p>IO多路复用：一个进程维护多个Socket</p>
<ul>
<li><p>select：将socket放到一个文件描述符集合（固定长度1024的 BitsMap）。需要2次遍历文件描述符集合，2次拷贝文件描述符集合</p>
</li>
<li><p>poll：bitsMap变为了链表</p>
</li>
<li><p>epoll：</p>
<ul>
<li><p>文件描述符使用红黑树O(logn),只在内核维护，减少了很多的遍历和复制</p>
</li>
<li><p>使用事件驱动机制，内核维护了一个链表记录就绪事件，当有socket事件发生的时候，通过回调函数内核将其加入到列表中，当用户调用 <code>epoll_wait()</code> 函数时，只会返回有事件发生的文件描述符的个数（<strong>但是还是会拷贝</strong>），不需要像select/poll那样轮询整个socket集合</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li><p>Reactor/Proactor：对IO多路复用的封装</p>
<ul>
<li>Reactor(同步非阻塞)、Proactor(异步)</li>
<li>对象<ul>
<li>reactor：监听和分发事件</li>
<li>acceptor：获取事件</li>
<li>handler：处理业务</li>
</ul>
</li>
<li>单reactor/单进程线程模型<ul>
<li>只有一个进程；handler处理业务的时候进程无法处理其他的连接</li>
</ul>
</li>
<li>单reactor/多线程进程模型<ul>
<li>reactor通过select（IO多路复用接口）监听，根据事件类型分发给handler和acceptor</li>
</ul>
</li>
<li>多reactor/多线程进程模型（nginx）<ul>
<li>主线程接收连接，子线程处理连接</li>
</ul>
</li>
<li>Proactor</li>
</ul>
</li>
<li><p>一致性哈希：解决多个请求分配客户端请求的问题</p>
<ul>
<li><p>哈希算法的不足：比如取模，如果节点的数量发生变化，则需要进行额外的数据迁移</p>
</li>
<li><p>一致性哈希算法解决的问题：分布式系统扩容或缩容的数据迁移问题</p>
</li>
<li><p>步骤：计算在哈希环中的位置，顺时针取遇到的第一个节点</p>
<p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/image-20240804150519055.png" alt="image-20240804150519055" style="zoom: 33%;"></p>
<ul>
<li>如果发生节点的增删，只影响前后节点，对全局其他节点无影响</li>
</ul>
</li>
<li><p>问题：</p>
<ul>
<li>不保证数据的均匀性</li>
</ul>
</li>
<li><p>改进：增加虚拟节点，环上的点就是虚拟节点，增加一个映射到真实节点</p>
</li>
</ul>
</li>
</ul>
<h2 id="八-工具"><a href="#八-工具" class="headerlink" title="八 工具"></a>八 工具</h2><h3 id="1-git"><a href="#1-git" class="headerlink" title="1 git"></a>1 git</h3><ul>
<li><p>命令</p>
<figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">git init</span><br><span class="line"></span><br><span class="line">git status</span><br><span class="line"></span><br><span class="line">git <span class="built_in">clone</span> url <span class="comment"># 支持http(s) ssh git等协议</span></span><br><span class="line"></span><br><span class="line">git checkout branch|tag|commit <span class="comment"># 切换到指定分支</span></span><br><span class="line"></span><br><span class="line">git merge branchName <span class="comment"># 将branchName的修改合并到当前分支中</span></span><br><span class="line"></span><br><span class="line">git add .</span><br><span class="line"></span><br><span class="line">git commit -m <span class="string">"message"</span></span><br><span class="line"></span><br><span class="line">git push origin master <span class="comment"># 将本地的 master 分支推送到 origin 主机的 master 分支</span></span><br><span class="line"></span><br><span class="line">git reset HEAD <span class="comment"># 取消已经暂存的文件</span></span><br><span class="line"></span><br><span class="line">git revert HEAD <span class="comment"># 撤销前一次操作</span></span><br><span class="line">git revert commit <span class="comment"># 撤销指定操作 </span></span><br><span class="line"></span><br><span class="line">git remote add origin git@github.com:JSLite/test.git <span class="comment"># 添加一个新的远程仓库 add &lt;remote_name&gt; &lt;remote_url&gt;</span></span><br><span class="line"></span><br><span class="line">git diff --<span class="built_in">stat</span>   <span class="comment"># 查看简单的diff结果   </span></span><br><span class="line">git diff branch     <span class="comment"># 比较Worktree和branch之间的差异 </span></span><br><span class="line"></span><br><span class="line">git merge --squash branchName <span class="comment"># 将branchName的多次提交统一变更到当分支（此后还需要再add commit push）</span></span><br><span class="line"></span><br><span class="line">git <span class="built_in">log</span> <span class="comment"># 日志相关</span></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>已经push的操作如何回退？</p>
<p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/image-20240519144816183.png" alt="image-20240519144816183"></p>
<ul>
<li><p>要回到vesion2</p>
</li>
<li><p>不保留git记录</p>
<ul>
<li><p>先reset到要回退的版本：<code>git reset commitID</code></p>
</li>
<li><p>然后强制push上去： <code>git push origin master:master -f</code> </p>
<p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/image-20240519145122665.png" alt="image-20240519145122665" style="zoom:33%;"></p>
</li>
</ul>
</li>
<li><p>保留git记录</p>
<ul>
<li><p><code>git revert commitID</code>，选择merge</p>
</li>
<li><p>然后push</p>
<p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/image-20240519145010549.png" alt="image-20240519145010549" style="zoom:33%;"></p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>分支的多次commit变成一次提交到master</p>
<ul>
<li><p>方法一：先从版本库回退内容到暂存区，再重新提交工作区的内容</p>
<ul>
<li><code>git reset --soft commitID</code>，此时版本回到commitID对应的状态，但是保留了改动(也就是之后多次的commit修改内容)</li>
<li>然后git add commit push</li>
</ul>
</li>
<li><p>方法二：rebase</p>
<ul>
<li><p>git log 查看提交记录，找到最早的那次提交的commitID的前一次</p>
<ul>
<li>我想合并commit1678 就找到commit1的前一次的id</li>
</ul>
<p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/image-20240519155033222.png" alt="image-20240519155033222"></p>
</li>
<li><p><code>git rebase -i commitID</code>，随后在vim编辑器中修改前面的提交由pick变为fixup</p>
<ul>
<li>fixup：使用commit，丢弃commit信息。</li>
<li>pick：使用commit。</li>
<li>squash：使用commit，将commit信息合入上一个commit。</li>
<li>reword：使用commit，修改commit信息。</li>
</ul>
<p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/image-20240519154428674.png" alt="image-20240519154428674" style="zoom:67%;"><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/image-20240519155543233.png" alt="image-20240519155543233" style="zoom: 67%;"></p>
<ul>
<li>可以通过<code>git reflog</code>取消rebase</li>
</ul>
</li>
<li><p>最后<code>git push --force</code>即可</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="2-maven"><a href="#2-maven" class="headerlink" title="2 maven"></a>2 maven</h3><h2 id="九-Spring"><a href="#九-Spring" class="headerlink" title="九 Spring"></a>九 Spring</h2><h3 id="9-1-简介"><a href="#9-1-简介" class="headerlink" title="9.1 简介"></a>9.1 简介</h3><ul>
<li>特性：<ul>
<li>非侵入</li>
<li>控制反转IOC：由框架管理bean，是一种思想</li>
<li>依赖注入DI：控制反转的实现方式，是一种实现方式</li>
<li>切面AOP</li>
<li>容器管理</li>
</ul>
</li>
</ul>
<p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/image-20240706162256753.png" alt="image-20240706162256753" style="zoom:50%;"></p>
<ul>
<li>core container：spring核心容器，由Beans、Core、Context、SpEL模块组成<ul>
<li>Beans：基础，提供了控制反转和依赖注入</li>
<li>Core：封装了底层，包括资源访问、类型转化等工具</li>
<li>Context上下文：ApplicationContext接口</li>
<li>SpEL：语言表达式支持</li>
</ul>
</li>
<li>Data Access/Integration：数据访问/集成<ul>
<li>JDBC：提供了JDBC模块，</li>
<li>ORM：提供了ORM框架集成的API，包括JPA、JDO、Hibernate 和 MyBatis 等</li>
<li>OXM：提供了XML与Java对象的转化功能</li>
<li>JMS：Java消息服务，异步通信</li>
<li>Transactions：编程和声明式事务的管理</li>
</ul>
</li>
<li>Web：web模块<ul>
<li>Web</li>
<li>Servlet：提供了spring mvc web框架实现</li>
<li>WebSocket：实现双向通信</li>
<li>Webflux</li>
<li>Portlet 模块</li>
</ul>
</li>
<li>AOP、Aspects、Instrumentation和Messaging</li>
<li>Test模块：支持Junit 和 TestNG 测试框架，还有模型http请求等功能</li>
</ul>
<h3 id="9-2-控制反转IOC、及DI"><a href="#9-2-控制反转IOC、及DI" class="headerlink" title="9.2 控制反转IOC、及DI"></a>9.2 控制反转IOC、及DI</h3><ul>
<li><p>三种配置方式</p>
<ul>
<li><p>xml</p>
<figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag"> http://www.springframework.org/schema/beans/spring-beans.xsd"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- services --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"userService"</span> <span class="attr">class</span>=<span class="string">"tech.pdai.springframework.service.UserServiceImpl"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"userDao"</span> <span class="attr">ref</span>=<span class="string">"userDao"</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- additional collaborators and configuration for this bean go here --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- more bean definitions for services go here --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>java配置：创建配置类，<code>@Configuration</code>注解声明，在bean中用<code>@bean</code>声明</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BeansConfig</span> {</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> user dao</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean("userDao")</span></span><br><span class="line">    <span class="keyword">public</span> UserDaoImpl <span class="title function_">userDao</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">UserDaoImpl</span>();</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> user service</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean("userService")</span></span><br><span class="line">    <span class="keyword">public</span> UserServiceImpl <span class="title function_">userService</span><span class="params">()</span> {</span><br><span class="line">        <span class="type">UserServiceImpl</span> <span class="variable">userService</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserServiceImpl</span>();</span><br><span class="line">        userService.setUserDao(userDao());</span><br><span class="line">        <span class="keyword">return</span> userService;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>注解配置：<code>@Component</code>，<code>@Controller</code>，<code>@Service</code>，<code>@Repository</code>，但是要配置spring 的注解扫描器ComponentScan</p>
</li>
</ul>
</li>
<li><p>依赖注入的三种方式</p>
<ul>
<li><p>构造方法注入，xml中<code>&lt;constructor-arg&gt;</code></p>
</li>
<li><p>setter注入，xml中的<code>&lt;property&gt;</code></p>
</li>
<li><p>注解注入，<code>@Autowired</code>，三个属性Constructor，byType，byName，默认byType(查找set方法)</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="meta">@Qualifier("helloWorldDao")</span> <span class="comment">// byName,如果没有找到会抛异常，防止这个可以@Autowired(required = false)</span></span><br><span class="line"><span class="keyword">private</span> HelloDao helloDao;</span><br></pre></td></tr></tbody></table></figure>
<p>ps：@Resource是J2EE提供，默认byName匹配</p>
</li>
</ul>
</li>
<li><p>spring IOC的设计</p>
<ul>
<li>加载Bean的配置(如xml)</li>
<li>根据bean定义加载生成bean的实例，并放置在容器中</li>
<li>统一管理bean(工厂模式)</li>
</ul>
</li>
<li><code>interface BeanFactory</code></li>
<li><p><code>interface ApplicationContext</code>：IoC容器的接口类</p>
<ul>
<li>除了对bean的管理外，还包括了资源访问、国际化、应用事件</li>
</ul>
</li>
<li><p>循环依赖：三级缓存</p>
<ul>
<li><p>一级缓存singletonObjects：已经初始化好的bean，即已经完成初始化好的注入对象的代理</p>
</li>
<li><p>二级缓存earlySingletonObjects：还没有完全被初始化好的中间对象代理</p>
</li>
<li><p>三级缓存singletonFactory：存放的是还未初始化完的bean，不是代理对象</p>
</li>
<li><p>过程：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/daimzh/p/13256413.html">https://www.cnblogs.com/daimzh/p/13256413.html</a></p>
<p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/image-20240321165705162.png" alt="image-20240321165705162" style="zoom: 50%;"></p>
</li>
<li><p>ps：</p>
<ul>
<li>不能解决构造器的依赖（使用<code>@Lazy</code>解决）</li>
<li>只能解决单例bean的循环依赖（多实例Bean是每次调用一次getBean都会执行一次构造方法并且给属性赋值，根本没有三级缓存，因此不能解决循环依赖）</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="9-3-AOP"><a href="#9-3-AOP" class="headerlink" title="9.3 AOP"></a>9.3 AOP</h3><ul>
<li>目的：AOP 的目的是将横切关注点（如日志记录、事务管理、权限控制、接口限流、接口幂等等）从核心业务逻辑中分离出来，通过动态代理、字节码操作等技术，实现代码的复用和解耦，提高代码的可维护性和可扩展性。</li>
<li>概念：<ul>
<li>连接点：表示需要在程序中插入横切关注点的扩展点</li>
<li>切入点：选择一组相关连接点的模式，即可以认为连接点的集合</li>
<li>通知：前置通知、后置通知、环绕通知、最终通知、异常通知<ul>
<li><code>@After @Around @Before @AfterReturning @AfterThrowing</code></li>
</ul>
</li>
<li>切面：公共代码</li>
<li>引入：引入允许我们向现有的类添加新方法或属性</li>
<li>织入：把切面应用到目标对象并创建新的代理对象的过程<ul>
<li>动态织入：通过动态代理完成，运行期织入（Spring AOP采用的方式）</li>
<li>静态织入：AspectJ，编译期织入</li>
</ul>
</li>
<li>AOP代理：JDK(反射)和CGLib(继承)两种方式<ul>
<li>都是运行期间生成字节码，jdk直接生成class字节码，cglib使用ASM框架写的class字节码。后者更加复杂，代理类生成效率更低</li>
<li>jdk动态代理是通过反射机制来执行方法，cglib是通过FastClass机制（索引分配直接调用）直接调用方法，后者动态代理类执行效率更高，但是cglib无法增强final方法(AspectJ可以)</li>
</ul>
</li>
</ul>
</li>
<li><p>最佳实践</p>
<ul>
<li><code>@Aspect</code>：定义切面</li>
<li><code>@pointcut</code>：定义切点</li>
<li><code>@After @Around @Before @AfterReturning @AfterThrowing</code>：定义通知</li>
</ul>
</li>
<li><p>Spring AOP和AspectJ关系：Spring AOP更易用，AspectJ更强大</p>
</li>
</ul>
<h3 id="9-4-Sping-MVC"><a href="#9-4-Sping-MVC" class="headerlink" title="9.4 Sping MVC"></a>9.4 Sping MVC</h3><ul>
<li><p>Spring MVC是Spring在Spring Container Core和AOP等技术基础上，遵循上述Web MVC的规范推出的web开发框架，目的是为了简化Java栈的web开发</p>
<p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/image-20240706173809020.png" alt="image-20240706173809020" style="zoom: 67%;"></p>
<ul>
<li>HandlerAdapter是适配处理器，用来找到Controller方法</li>
</ul>
</li>
</ul>
<h3 id="9-5-Bean生命周期"><a href="#9-5-Bean生命周期" class="headerlink" title="9.5 Bean生命周期"></a>9.5 Bean生命周期</h3><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/image-20240706180733761.png" alt="image-20240706180733761"></p>
<ul>
<li><code>BeanFactoryPostProcessor</code>如果和bean关联，则postProcessBeanFactory()：尝试从Bean工厂中获取Bean</li>
<li><code>InstantiationAwareBeanPostProcessor</code> <ul>
<li>postProcessBeforeInstantiation()，如果这里返回了bean实例，就会直接跳到postProcessAfterInitialization()</li>
<li>postProcessAfterInstantiation()，bean实例化完后调用</li>
</ul>
</li>
<li>bean构造函数</li>
<li>bean调用setter方法初始化</li>
<li>调用<code>xxxAware</code>接口(bean需要实现这些接口)<ul>
<li>BeanNameAware()传入当前 Bean 的 id 值</li>
<li>BeanClassLoaderAware()传入classLoader的引用</li>
<li>BeanFactoryAware()传入当前工厂实例的引用</li>
<li>EnvironmentAware()传入当前 Environment 实例的引用</li>
<li>ApplicationContextAware()传入当前 ApplicationContext 实例的引用</li>
</ul>
</li>
<li><code>BeanPostProcessor</code><ul>
<li>postProcessBeforeInitialzation()，bean的init方法之前，Spring 的 AOP 就是利用它实现的</li>
</ul>
</li>
<li>如果实现了<code>InitializingBean</code>接口(或者@PostConstruct) ，则调用<code>afterPropertiesSet()</code>方法</li>
<li>调用bean自身的init方法</li>
<li><p><code>BeanPostProcessor</code></p>
<ul>
<li>postProcessAfterInitialization()，bean初始化后</li>
</ul>
</li>
<li><p>使用bean</p>
</li>
<li>如果实现了<code>DisposableBean</code>接口，则销毁的时候调用<code>destroy()</code>方法</li>
<li>执行bean自身的<code>destroy()</code>方法 </li>
</ul>
<h2 id="十-Spring-Boot"><a href="#十-Spring-Boot" class="headerlink" title="十 Spring Boot"></a>十 Spring Boot</h2><ul>
<li>解决spring配置重量级的问题，约定大于配置</li>
</ul>
<h3 id="10-1-常用注解"><a href="#10-1-常用注解" class="headerlink" title="10.1 常用注解"></a>10.1 常用注解</h3><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span> <span class="comment">// main</span></span><br><span class="line"><span class="meta">@EnableAutoConfiguration</span> <span class="comment">// 自动装配 src/main/resources的META-INF/spring.factories 的bean</span></span><br><span class="line"><span class="meta">@ImportResource</span> <span class="comment">// 加载xml 启动类上</span></span><br><span class="line"><span class="meta">@Value</span> <span class="comment">// application.properties的属性</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping("/api/demo")</span></span><br><span class="line"><span class="meta">@RequestParam(value = "demo", required = false)</span> <span class="comment">// 作用于request入参 https://www.d.com/info?demo=ddd</span></span><br><span class="line"><span class="meta">@PathVariable("name")</span> <span class="comment">// 用于获取url请求中的参数 https://www.d.com/name/info</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="meta">@Bean(name = "xxx", initMethod = "xxx", destoryMethod = "xxx")</span></span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@Repository</span> <span class="comment">// 用于标注数据访问组件</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@ComponentScan</span></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="meta">@Qualifier("beanName")</span> <span class="comment">// 和@Autowired一起使用，表示byName方式加载bean</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@Import(Config.class)</span></span><br><span class="line"><span class="meta">@ControllerAdvice</span></span><br></pre></td></tr></tbody></table></figure>
<h3 id="10-2-开发实践"><a href="#10-2-开发实践" class="headerlink" title="10.2 开发实践"></a>10.2 开发实践</h3><ul>
<li><p>对参数进行统一校验：为了解决在Controller中频繁对入参对象校验的不优雅</p>
<figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- spring validation是对hibernate validation的二次封装，后者是对validation-api标准的实现 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-validation<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span> </span><br></pre></td></tr></tbody></table></figure>
<p>定义入参对象类，在字段中添加相关注解</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@NotEmpty(message = "xxx")</span></span><br><span class="line"><span class="meta">@Email(message = "xxx")</span></span><br><span class="line"><span class="meta">@Pattern(regexp = "xxx", message = "xxx")</span> <span class="comment">// 正则匹配</span></span><br><span class="line"><span class="meta">@Length(min = 0, max = 10, message = "xxx")</span></span><br><span class="line"><span class="meta">@Range(min = 0, max = 10, message = "xxx")</span></span><br></pre></td></tr></tbody></table></figure>
<p>Controller中入参添加<code>@Valid</code>注释</p>
</li>
<li><p>统一异常处理：<code>@ControllerAdvice</code>及<code>@ExceptionHandler</code></p>
</li>
<li><p>接口版本控制：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">相同URL，用不同的版本参数区分</span><br><span class="line">	api.man.tech/user?version=v1 </span><br><span class="line">	api.man.tech/user?version=v2 </span><br><span class="line">区分不同的接口域名，不同的版本有不同的子域名, 路由到不同的实例:</span><br><span class="line">	v1.man.pdai.tech/user </span><br><span class="line">	v2.man.pdai.tech/user </span><br><span class="line">网关路由不同子目录到不同的实例</span><br><span class="line">	api.man.tech/v1/user</span><br><span class="line">	api.man.tech/v2/user</span><br><span class="line">同一实例，用注解隔离不同版本控制</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>接口文档生成swagger</p>
</li>
<li><p>访问外部接口（调三方服务）</p>
<ul>
<li>采用原生http请求</li>
<li>feign消费（依赖 + <code>@EnableFeignClients</code>）：本质也是http</li>
<li>采用RestTemplate方法</li>
</ul>
</li>
<li><p>保证接口的幂等性：</p>
<blockquote>
<p> 哪些操作需要保证幂等性？PUT和POST，DELETE如果需要返回删除的行数则也需要</p>
</blockquote>
<ul>
<li>数据库加悲观锁</li>
<li>唯一索引：注意是分布式ID，针对插入操作</li>
<li>乐观锁：版本号，针对更新操作</li>
<li>分布式锁：redis</li>
</ul>
</li>
<li><p>针对接口进行签名：防篡改</p>
<ul>
<li><p>认证和授权</p>
</li>
<li><p>https</p>
</li>
<li><p>接口签名(加密)：1. 对请求参数按key进行字母排序 2. 排序完连接用&amp; 3. 加密字符串得到sig，拼接到后面</p>
<p><code>https://man.xxxx.com/info?key=value&amp;timetamp=xxxx&amp;sign=xxxx-xxx-xxx-xxxx</code></p>
</li>
</ul>
</li>
<li><p>接口限流</p>
<ul>
<li>单实例：限流总资源数、总并发数、某接口的请求总量、某个时间窗的请求数</li>
<li>分布式：redis+lua 或者 nginx+lua</li>
</ul>
</li>
<li><p>跨域请求</p>
<ul>
<li><p><code>@Configuration</code>实现WebMvcConfigurer接口，重写addCorsMappings方法，</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyWebMvcConfigurer</span> <span class="keyword">implements</span> <span class="title class_">WebMvcConfigurer</span> {</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addCorsMappings</span><span class="params">(CorsRegistry registry)</span> {</span><br><span class="line">        registry.addMapping(<span class="string">"/user/*"</span>)</span><br><span class="line">            	.allowedOrigins(<span class="string">"http://localhost:8080"</span>)</span><br><span class="line">            	.allowedMethods(<span class="string">"GET"</span>, <span class="string">"POST"</span>, <span class="string">"PUT"</span>, <span class="string">"DELETE"</span>);</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
</li>
</ul>
</li>
</ul>
<h3 id="10-3-其他"><a href="#10-3-其他" class="headerlink" title="10.3 其他"></a>10.3 其他</h3><ul>
<li><p>自动装配——SpringBoot约定大于配置的理念的产物</p>
<ul>
<li>依赖注入的plus，简化了依赖注入的配置而生成的</li>
<li>主启动类上的注解<strong><code>@SpringbootApplication</code></strong>是一个复合注解，其中比较重要的<ul>
<li><code>@SpringbootConfiguration</code>：springboot的相关配置</li>
<li><code>@EnableAutoConfiguration</code></li>
<li><code>@ComponentScan</code>：扫描一些包并注入</li>
</ul>
</li>
<li>重点<strong><code>@EnableAutoConfiguration</code></strong>，也是一个复合注解<ul>
<li><code>@import(AutoConfigurationImportSelect.class)</code></li>
</ul>
</li>
<li><p><code>AutoConfigurationImportSelect</code> implements了<strong><code>DeferredImportSelector</code></strong></p>
<ul>
<li><p>因为是Deferred,所以自动配置类会放在最后加载,方便扩展和覆盖</p>
</li>
<li><p>其中重写了<strong><code>selectImports()</code></strong>方法：获取所有符合条件的类的全限定类名，加载到IOC容器中</p>
<ul>
<li><p>判断是否开启了自动装配：<code>spring.boot.enableautoconfiguration=true</code></p>
</li>
<li><p>获取<code>@EnableAutoConfiguration</code>中的<code>exclude</code>和<code>excludeName</code></p>
</li>
<li><p>读取所有spring boot start下面的classpath:/META-INF/spring.factories文件(key-value形式)</p>
</li>
<li><p>通过<code>@ConditionalOn</code>排除无效的自动配置类</p>
</li>
</ul>
</li>
</ul>
</li>
<li>配置文件的信息如何加载到bean中：classpath:/META-INF/spring.factories文件存储了一些键信息（<strong>SpringBoot约定大于配置的理念</strong>），然后加载的时候配置文件的值就被加载到这个文件中了</li>
<li>两种<ul>
<li><code>@Autowired</code>：根据类型自动注入<ul>
<li><code>@Qualifier</code>：格外指定bean的id（当IOC根据属性类型去容器中找找到多个相同类型的组件的时候需要使用）</li>
</ul>
</li>
<li><code>@Resource</code>：根据bean的名称自动注入<ul>
<li>这个是Java规范</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="十一-其他中间件"><a href="#十一-其他中间件" class="headerlink" title="十一 其他中间件"></a>十一 其他中间件</h2><h3 id="1-Mybatis"><a href="#1-Mybatis" class="headerlink" title="1 Mybatis"></a>1 Mybatis</h3><ul>
<li>一种半自动ORM：查询关联对象或关联集合对象时，需要手动编写 sql 来完成</li>
<li><p>全自动ORM查询时可以不再写SQL。典型的框架如Hibernate</p>
</li>
<li><p>xml开发方式</p>
<ul>
<li>定义xml</li>
</ul>
<figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">"tech.pdai.springboot.mysql57.mybatis.xml.dao.IUserDao"</span>&gt;</span>  定义mapper关联的dao</span><br><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">type</span>=<span class="string">"tech.pdai.springboot.mysql57.mybatis.xml.entity.User"</span> <span class="attr">id</span>=<span class="string">"UserResult"</span>&gt;</span>  定义sql返回对象</span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"findById"</span> <span class="attr">parameterType</span>=<span class="string">"Long"</span> <span class="attr">resultMap</span>=<span class="string">"UserResult"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">delete</span> <span class="attr">...</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">update</span> <span class="attr">...</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">insert</span> <span class="attr">...</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>定义dao：<code>IUserDao</code>，使用<code>@mapper</code>注解关联，定义xml中相关的对应方法</li>
<li>定义service及实现类调用dao</li>
<li>定义controller调用service</li>
</ul>
</li>
<li><p>注解开发</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Results(</span></span><br><span class="line"><span class="meta">        id = "UserResult1",</span></span><br><span class="line"><span class="meta">        value = {</span></span><br><span class="line"><span class="meta">                @Result(id = true, property = "id", column = "id"),</span></span><br><span class="line"><span class="meta">                @Result(property = "userName", column = "user_name"),</span></span><br><span class="line"><span class="meta">                @Result(property = "password", column = "password")</span></span><br><span class="line"><span class="meta">        }</span></span><br><span class="line"><span class="meta">)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@ResultMap("UserResult1")</span></span><br><span class="line"><span class="meta">@Select("select u.id, u.password, u.user_name from tb_user u")</span></span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>PageHelper：底层是使用的ThreadLocal存储分页数据-</p>
<ul>
<li>只有紧跟在PageHelper.startPage方法后的第一个Mybatis的查询（Select）方法会被分页</li>
</ul>
</li>
<li><p>数据库连接池：C3P0、DBCP、BoneCP、Druid(best)</p>
</li>
<li><p>文件上传：异步、分片、断点续传、秒传(如果之前上传过就马上到100%)</p>
<ul>
<li>异步：<code>@EnableAsync</code>开启异步，<code>@Async</code>作用于方法，开启子线程执行</li>
<li>分片：先切割再上传</li>
<li>断点续传：将分片的chuck md5信息保存在db中，记录上传记录</li>
<li>秒传：类似断点续传</li>
</ul>
</li>
</ul>
<h3 id="2-RabbitMQ"><a href="#2-RabbitMQ" class="headerlink" title="2 RabbitMQ"></a>2 RabbitMQ</h3><ul>
<li>优势在于稳定</li>
<li>命名中心：namesrv，存储broker、主题、生产消费信息</li>
<li>路由键、绑定键</li>
<li>对象<ul>
<li>producer</li>
<li>consumer</li>
<li>exchange：不存储消息，只是用来转发消息<ul>
<li>direct exchange：根据消息路由键精确匹配队列</li>
<li>fanout exchange：消息广播</li>
<li>topic exchange：根据消息路由键匹配队列（通配符* #）</li>
<li>headers exchange：根据消息头匹配队列</li>
</ul>
</li>
<li>queue</li>
<li>brocker</li>
</ul>
</li>
<li>如何进入死信队列？<ul>
<li>消息被拒绝，且requeue参数为false</li>
<li>消息在队列中过期（TTL）未消费</li>
<li>队列超出长度限制</li>
</ul>
</li>
<li><p>消息如何路由</p>
<ul>
<li>生产者发送消息到交换机</li>
<li>交换机根据路由键和绑定键发送到一个或多个队内中</li>
</ul>
</li>
<li><p>消息的持久化</p>
<ul>
<li><p>将队列和交换机的Durable设置为True</p>
<p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/image-20240819175128997.png" alt="image-20240819175128997"></p>
</li>
</ul>
</li>
<li><p>不足</p>
<ul>
<li>性能：相比于kafka来说性能较低，常用于中小企业</li>
<li>开发语言限制，是erlang</li>
</ul>
</li>
<li>rabbitMQ实现延迟队列<ul>
<li>本身不支持，通过TTL（消息存活时间） 和 DLX（死信交换机）</li>
</ul>
</li>
</ul>
<h3 id="3-kafka"><a href="#3-kafka" class="headerlink" title="3 kafka"></a>3 kafka</h3><ul>
<li>优势在于快、吞吐量大</li>
<li>命名中心：zookeeper，存储broker、主题、生产消费信息，协调服务实现故障监听与转移<ul>
<li>特点：强一致性，zookeeper中某个节点发生数据变化，会通知其他节点通知更新，超过半数更新完毕才算写入完成</li>
</ul>
</li>
</ul>
<ul>
<li><p>对象：</p>
<ul>
<li>producer</li>
<li>consumer</li>
<li>brocker：服务器，多个brocker组成集群</li>
<li>castle：生产消费调度</li>
<li>topic：消息主题</li>
<li><p>partition：主题内分区，物理上分区，实现负载均衡</p>
<ul>
<li>写入规则：</li>
</ul>
</li>
<li><p>groups：消费者组，一个group内的消费者消费一个topic</p>
</li>
</ul>
</li>
<li>特性<ul>
<li>高吞吐、低延迟，收发消息很快（零拷贝技术<code>sendfile()</code>）</li>
<li>高伸缩性：每个主题topic包含多个分区partition，主题中的分区可以分布在不同的主机brocker中</li>
<li>持久行、可靠性：可持久化数据，底层十基于Zookeeper存储的</li>
<li>容错性：允许集群中的节点失败，某个节点宕机、kafka集群能够正常工作</li>
</ul>
</li>
<li>使用场景<ul>
<li>活动跟踪：跟踪用户行为，浏览数据发送的kafka，生成报告进行个性化展示</li>
<li>传递消息</li>
<li>日志记录：把数据库的更新发送到Kafka上，用来记录数据库更新，落hive表等</li>
<li>流式处理</li>
<li>限流、削峰、解耦</li>
</ul>
</li>
<li>模式<ul>
<li>点对点</li>
<li>发布订阅模式</li>
</ul>
</li>
<li><strong>为什么kafka快？</strong><ul>
<li>顺序读写：<ul>
<li>kafka将来自product的数据，顺序追加在partition，partition就是一个文件，以此实现顺序写入</li>
<li>consumer从broker读取数据时，因为自带了偏移量，接着上次读取的位置继续读，以此是实现顺序读</li>
</ul>
</li>
<li>零拷贝<code>sendfile()</code>。最重要<ul>
<li>为什么rocketmq不用<code>sendfile</code>而用<code>mmap</code>，因为其将所有的队列的数据都写入了commitLog，消费者批量消费时需要读出来进行应用层过滤(要进入用户态)，所以不用</li>
</ul>
</li>
<li>页缓存(page cache)：消息写道page cache中，等系统统一写入磁盘（可能会有丢失，比如断电）</li>
<li>批量接收和发送消息。减少网络开销</li>
</ul>
</li>
<li><p>美团mafka相对于kafka的改进</p>
<ul>
<li>多租户支持，隔离流量</li>
<li>性能优化</li>
<li>内支持运维工具，兼容性</li>
</ul>
</li>
<li><p>如何保证消息不丢失？</p>
<ul>
<li>从生产者到broker：做好try catch，以及重试</li>
<li>brocker存储消息：在消息刷盘后再给生产者响应，集群部署的话还需要写到副本</li>
<li>从broker到消费者：保证消费者消费完业务后再返回给brocker信息，然后是注意消息消费的幂等性（版本号、唯一键、关键key等）</li>
</ul>
</li>
<li>消息堆积问题？</li>
<li>kafka的事务？让插入的多个topic要么全成功，要么全失败</li>
</ul>
<h2 id="十二-RPC"><a href="#十二-RPC" class="headerlink" title="十二 RPC"></a>十二 RPC</h2><ul>
<li><strong>RPC</strong>（<strong>R</strong>emote <strong>P</strong>rocedure <strong>C</strong>all），又叫做<strong>远程过程调用</strong>。它本身并不是一个具体的协议，而是一种<strong>调用方式</strong><ul>
<li>gRPC，thrift</li>
</ul>
</li>
<li>发展历史：TCP ==&gt; RPC ==&gt; HTTP</li>
<li>为什么有了RPC还要有HTTP？<ul>
<li>RPC 是针对于Client/Server (C/S) 架构下使用的，如果只需要连接自家的服务器，用RPC是足够的，但是浏览器Browser/Server (B/S)架构，需要访问其他公司的服务器，所以诞生了HTTP</li>
</ul>
</li>
<li><p>为什么有了HTTP还在使用RPC？</p>
<ul>
<li>服务发现：http中通过DNS解析域名对应的IP，RPC中是通过专门的中间服务来保存其信息的</li>
<li>底层连接：http/1.1底层建立TCP后会一直保持长连接，之后复用，RPC会有一个连接池，有助于提升网络性能</li>
<li>传输内容：header + body，主要差异体现在header中，RPC有更高的定制化，体积更小</li>
</ul>
</li>
<li><p>RPC框架</p>
<ul>
<li>Dubbo：阿里巴巴开源，仅支持java</li>
<li>Spring Cloud：仅支持java</li>
<li>gRPC：google开源，多语言</li>
<li>Thrift：facebook开源，多语言</li>
</ul>
</li>
<li>Thrift组件<ul>
<li>Transport：传输组件，负责网络读写相关</li>
<li>Protocol：协议和解编码组件，负责对网络数据传输的序列/反序列化</li>
<li>Processor：服务调用组件</li>
<li>Server：服务器</li>
</ul>
</li>
<li>泛化调用<ul>
<li>在不依赖服务A（没有服务A提供的接口）情况下远程调用服务A的接口</li>
<li>只要调用端将服务需要知道的信息：接口名、业务分组名、参数等封装为请求发送给服务器，服务端解析并处理即可</li>
<li>实现：<ul>
<li>通过一个<code>GenericService</code>来生成动态代理，来实现在没有接口情况下的RPC调用</li>
<li>对于服务端，在获取Tprotocol时，会判断是否泛化调用，如果是泛化调用，会向泛化调用，会向链路中添加泛化调用标识，用于服务端判断是否是泛化调用</li>
<li>在调用时，与普通的调用基本一致，会在请求中额外添加被调用的服务名、方法名等信息在请求header中，用于服务端处理时查找相应的类信息</li>
<li>处理请求时，根据客户端传递的标识，判断是否是泛化调用，如果是则使用<code>GenericServiceTProcessor</code>处理请求</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="十三-异步"><a href="#十三-异步" class="headerlink" title="十三 异步"></a>十三 异步</h2><ul>
<li>为什么需要异步？<ul>
<li>调用多个下游服务，串行调用容易导致时间过长的问题</li>
</ul>
</li>
</ul>
<h3 id="13-1-CompletableFuture"><a href="#13-1-CompletableFuture" class="headerlink" title="13.1 CompletableFuture"></a>13.1 CompletableFuture</h3><p><a target="_blank" rel="noopener" href="https://tech.meituan.com/2022/05/12/principles-and-practices-of-completablefuture.html">https://tech.meituan.com/2022/05/12/principles-and-practices-of-completablefuture.html</a></p>
<ul>
<li><p>实现了两个接口：<code>Future</code> 和 <code>Completionstage</code>，前者是java5引入的异步计算，后者用于表示异步执行过程中的一个步骤(<code>thenApply()</code>、<code>thenCombine()</code>等都是<code>Completionstage</code>的方法)</p>
</li>
<li><p>原理：观察者模式</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CompletableFuture</span>&lt;T&gt; <span class="keyword">implements</span> <span class="title class_">Future</span>&lt;T&gt;, CompletionStage&lt;T&gt; {</span><br><span class="line">    <span class="keyword">volatile</span> Object result; 	<span class="comment">// 存储CF执行结果</span></span><br><span class="line">    <span class="keyword">volatile</span> Completion stack;	<span class="comment">// 栈结构，stack为栈顶。表示当前CF当前完成后需要触发的依赖动作</span></span><br><span class="line">    <span class="comment">// CompletableFuture中的每个方法都对应了一个Completion子类，Completion本身是观察者的基类</span></span><br><span class="line">    ...</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p><code>Future</code>的局限性</p>
<ul>
<li>向线程池提交异步任务发起RPC调用，主线程只能阻塞获取Future结果</li>
<li>调用RPC服务通常需要回调的方法完成Future，Future的执行结果依赖向线程池提交的任务返回结果，不支持通过回调的方式来设置返回结果</li>
<li>多个RPC串行执行，后一个RPC依赖前一个响应结果，主线程阻塞组装调用关系，没有回调唤醒机制，主线程反复被阻塞</li>
<li>多个RPC串行执行，后面的RPC依赖前两个RPC的结果作为入参。主线程阻塞等待，当相互依赖的RPC较多时，代码可读性差</li>
<li>Future提供的接口没有异常处理的功能，不能异步处理异常，只能try检查get方法是否抛出异常</li>
</ul>
</li>
<li><p>使用</p>
<ul>
<li><p>创建</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> CompletableFuture&lt;Void&gt; <span class="title function_">runAsync</span><span class="params">(Runnable runnable)</span>; <span class="comment">// 创建无返回任务的异步任务</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> CompletableFuture&lt;Void&gt; <span class="title function_">runAsync</span><span class="params">(Runnable runnable, Executor ex)</span>; <span class="comment">// 指定线程池</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;U&gt; CompletableFuture&lt;U&gt; <span class="title function_">supplyAsync</span><span class="params">(Supplier&lt;U&gt; supplier)</span>; <span class="comment">// 创建有返回值的...</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;U&gt; CompletableFuture&lt;U&gt; <span class="title function_">supplyAsync</span><span class="params">(Supplier&lt;U&gt; supplier, Executor ex)</span>; <span class="comment">// </span></span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>异步回调</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;U&gt; CompletionStage&lt;U&gt; <span class="title function_">thenApply</span><span class="params">(Function&lt;? <span class="built_in">super</span> T, ? extends U&gt; var1)</span>; <span class="comment">// 串行</span></span><br><span class="line">CompletionStage&lt;Void&gt; <span class="title function_">thenAccept</span><span class="params">(Consumer&lt;? <span class="built_in">super</span> T&gt; var1)</span>; <span class="comment">// 串行，无返回值</span></span><br><span class="line">thenCombine <span class="comment">// 二元依赖 A B都执行完再到C</span></span><br><span class="line">thenCompose <span class="comment">// 串行执行</span></span><br><span class="line">allOf</span><br><span class="line">anyOf</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>异常处理</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">handle</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>结果获取(注意设置超时时间)</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">join</span><br><span class="line">get</span><br></pre></td></tr></tbody></table></figure>
</li>
</ul>
</li>
</ul>
<h3 id="13-2-Loader"><a href="#13-2-Loader" class="headerlink" title="13.2 Loader"></a>13.2 Loader</h3><ul>
<li>为解决代码难以读懂的问题，一个Loader加载若干个异步调用，通过Loader工厂加载loader</li>
</ul>
<h3 id="13-3-Director"><a href="#13-3-Director" class="headerlink" title="13.3 Director"></a>13.3 Director</h3><ul>
<li>为解决代码难以调试的问题，本质是维护一个有向无环图，来实现异步调用的加载</li>
</ul>
<link rel="stylesheet" href="https://cdn1.tianli0.top/gh/zhheo/Post-Abstract-AI@0.15.2/tianli_gpt.css">

<script>
let tianliGPT_postSelector = '#post #article-container';
let tianliGPT_key = 'c9b7741d290063ab872e';
</script>
<script src="https://cdn1.tianli0.top/gh/zhheo/Post-Abstract-AI@0.15.2/tianli_gpt.js"></script>



</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="http://yileman.github.io">myl</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://yileman.github.io/posts/54082.html">http://yileman.github.io/posts/54082.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://yileman.github.io" target="_blank">myl's blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E5%9F%BA%E7%A1%80/">基础</a></div><div class="post_share"><div class="social-share" data-image="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/cover/article_cover2.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer=""></script></div></div><nav class="pagination-post" id="pagination"><div class="next-post pull-full"><a href="/posts/28758.html" title="计算机网络"><img class="cover" src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/cover/article_cover19.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">计算机网络</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/posts/1079.html" title="操作系统"><img class="cover" src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/cover/article_cover20.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-04-08</div><div class="title">操作系统</div></div></a></div><div><a href="/posts/28758.html" title="计算机网络"><img class="cover" src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/cover/article_cover19.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-04-18</div><div class="title">计算机网络</div></div></a></div></div></div><hr class="custom-hr"><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="twikoo-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/touxiang.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"></div><div class="author-info__name">myl</div><div class="author-info__description">后端学习</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">23</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">8</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">4</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/yileman"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">写写记记</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80-JavaSE"><span class="toc-number">1.</span> <span class="toc-text">一 JavaSE</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.1.</span> <span class="toc-text">1数据类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E6%8E%A5%E5%8F%A3"><span class="toc-number">1.2.</span> <span class="toc-text">2 接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E6%8A%BD%E8%B1%A1%E7%B1%BB"><span class="toc-number">1.3.</span> <span class="toc-text">3 抽象类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-Object%E7%B1%BB%E9%80%9A%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-number">1.4.</span> <span class="toc-text">4 Object类通用方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-static"><span class="toc-number">1.5.</span> <span class="toc-text">5 static</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E5%8F%8D%E5%B0%84"><span class="toc-number">1.6.</span> <span class="toc-text">6 反射</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-%E5%BC%82%E5%B8%B8"><span class="toc-number">1.7.</span> <span class="toc-text">7 异常</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-%E6%B3%9B%E5%9E%8B"><span class="toc-number">1.8.</span> <span class="toc-text">8 泛型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-%E6%B3%A8%E8%A7%A3"><span class="toc-number">1.9.</span> <span class="toc-text">9 注解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-SPI%E6%9C%BA%E5%88%B6"><span class="toc-number">1.10.</span> <span class="toc-text">10 SPI机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6"><span class="toc-number">1.11.</span> <span class="toc-text">11 集合框架</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C-JVM"><span class="toc-number">2.</span> <span class="toc-text">二 JVM</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E7%B1%BB%E5%8A%A0%E8%BD%BD"><span class="toc-number">2.1.</span> <span class="toc-text">1 类加载</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84"><span class="toc-number">2.2.</span> <span class="toc-text">2 内存结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B"><span class="toc-number">2.3.</span> <span class="toc-text">3 java内存模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6"><span class="toc-number">2.4.</span> <span class="toc-text">4 垃圾回收</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-JVM%E5%8F%82%E6%95%B0-%E8%B0%83%E4%BC%98"><span class="toc-number">2.5.</span> <span class="toc-text">5 JVM参数/调优</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7"><span class="toc-number">2.6.</span> <span class="toc-text">6 分析工具</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-JVM%E8%BF%9C%E7%A8%8B%E8%B0%83%E8%AF%95remote-debug"><span class="toc-number">2.7.</span> <span class="toc-text">7 JVM远程调试remote debug</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-linux-%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5"><span class="toc-number">2.8.</span> <span class="toc-text">8 linux 问题排查</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89-%E5%B9%B6%E5%8F%91"><span class="toc-number">3.</span> <span class="toc-text">三 并发</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E7%90%86%E8%AE%BA"><span class="toc-number">3.1.</span> <span class="toc-text">1 理论</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E7%BA%BF%E7%A8%8B"><span class="toc-number">3.2.</span> <span class="toc-text">2 线程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E9%94%81"><span class="toc-number">3.3.</span> <span class="toc-text">3 锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">3.4.</span> <span class="toc-text">4 关键字</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-JUC%E6%A1%86%E6%9E%B6"><span class="toc-number">3.5.</span> <span class="toc-text">5 JUC框架</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B-IO"><span class="toc-number">4.</span> <span class="toc-text">四 IO</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-JavaIO"><span class="toc-number">4.1.</span> <span class="toc-text">1 JavaIO</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-JavaIO%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E2%80%94%E8%A3%85%E9%A5%B0%E8%80%85"><span class="toc-number">4.2.</span> <span class="toc-text">2 JavaIO设计模式—装饰者</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-IO%E4%B8%AD%E5%B8%B8%E8%A7%81%E7%B1%BB%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">4.3.</span> <span class="toc-text">3 IO中常见类的使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-Unix-IO%E6%A8%A1%E5%9E%8B"><span class="toc-number">4.4.</span> <span class="toc-text">4 Unix IO模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-NIO"><span class="toc-number">4.5.</span> <span class="toc-text">5 NIO</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94-%E6%95%B0%E6%8D%AE%E5%BA%93"><span class="toc-number">5.</span> <span class="toc-text">五 数据库</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E6%A6%82%E8%BF%B0"><span class="toc-number">5.1.</span> <span class="toc-text">1 概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93%E2%80%94MySQL"><span class="toc-number">5.2.</span> <span class="toc-text">2 关系型数据库—MySQL</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-NoSQL%E2%80%94Redis"><span class="toc-number">5.3.</span> <span class="toc-text">3 NoSQL—Redis</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-NoSQL%E2%80%94ES"><span class="toc-number">5.4.</span> <span class="toc-text">4 NoSQL—ES</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AD-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C"><span class="toc-number">6.</span> <span class="toc-text">六 计算机网络</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-1-base"><span class="toc-number">6.1.</span> <span class="toc-text">6.1 base</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-2-Http"><span class="toc-number">6.2.</span> <span class="toc-text">6.2 Http</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-3-TCP"><span class="toc-number">6.3.</span> <span class="toc-text">6.3 TCP</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-4-IP"><span class="toc-number">6.4.</span> <span class="toc-text">6.4 IP</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%83-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F"><span class="toc-number">7.</span> <span class="toc-text">七 操作系统</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#7-1-%E7%A1%AC%E4%BB%B6%E7%BB%93%E6%9E%84"><span class="toc-number">7.1.</span> <span class="toc-text">7.1 硬件结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-2-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84"><span class="toc-number">7.2.</span> <span class="toc-text">7.2 操作系统结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-3-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86"><span class="toc-number">7.3.</span> <span class="toc-text">7.3 内存管理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-4-%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86"><span class="toc-number">7.4.</span> <span class="toc-text">7.4 进程管理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-5-%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95"><span class="toc-number">7.5.</span> <span class="toc-text">7.5 调度算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-6-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F"><span class="toc-number">7.6.</span> <span class="toc-text">7.6 文件系统</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-7-%E8%AE%BE%E5%A4%87%E7%AE%A1%E7%90%86"><span class="toc-number">7.7.</span> <span class="toc-text">7.7 设备管理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-8-%E7%BD%91%E7%BB%9C%E7%AE%A1%E7%90%86"><span class="toc-number">7.8.</span> <span class="toc-text">7.8 网络管理</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AB-%E5%B7%A5%E5%85%B7"><span class="toc-number">8.</span> <span class="toc-text">八 工具</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-git"><span class="toc-number">8.1.</span> <span class="toc-text">1 git</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-maven"><span class="toc-number">8.2.</span> <span class="toc-text">2 maven</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B9%9D-Spring"><span class="toc-number">9.</span> <span class="toc-text">九 Spring</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#9-1-%E7%AE%80%E4%BB%8B"><span class="toc-number">9.1.</span> <span class="toc-text">9.1 简介</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-2-%E6%8E%A7%E5%88%B6%E5%8F%8D%E8%BD%ACIOC%E3%80%81%E5%8F%8ADI"><span class="toc-number">9.2.</span> <span class="toc-text">9.2 控制反转IOC、及DI</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-3-AOP"><span class="toc-number">9.3.</span> <span class="toc-text">9.3 AOP</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-4-Sping-MVC"><span class="toc-number">9.4.</span> <span class="toc-text">9.4 Sping MVC</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-5-Bean%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-number">9.5.</span> <span class="toc-text">9.5 Bean生命周期</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%81-Spring-Boot"><span class="toc-number">10.</span> <span class="toc-text">十 Spring Boot</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#10-1-%E5%B8%B8%E7%94%A8%E6%B3%A8%E8%A7%A3"><span class="toc-number">10.1.</span> <span class="toc-text">10.1 常用注解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-2-%E5%BC%80%E5%8F%91%E5%AE%9E%E8%B7%B5"><span class="toc-number">10.2.</span> <span class="toc-text">10.2 开发实践</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-3-%E5%85%B6%E4%BB%96"><span class="toc-number">10.3.</span> <span class="toc-text">10.3 其他</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%81%E4%B8%80-%E5%85%B6%E4%BB%96%E4%B8%AD%E9%97%B4%E4%BB%B6"><span class="toc-number">11.</span> <span class="toc-text">十一 其他中间件</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-Mybatis"><span class="toc-number">11.1.</span> <span class="toc-text">1 Mybatis</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-RabbitMQ"><span class="toc-number">11.2.</span> <span class="toc-text">2 RabbitMQ</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-kafka"><span class="toc-number">11.3.</span> <span class="toc-text">3 kafka</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%81%E4%BA%8C-RPC"><span class="toc-number">12.</span> <span class="toc-text">十二 RPC</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%81%E4%B8%89-%E5%BC%82%E6%AD%A5"><span class="toc-number">13.</span> <span class="toc-text">十三 异步</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#13-1-CompletableFuture"><span class="toc-number">13.1.</span> <span class="toc-text">13.1 CompletableFuture</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-2-Loader"><span class="toc-number">13.2.</span> <span class="toc-text">13.2 Loader</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-3-Director"><span class="toc-number">13.3.</span> <span class="toc-text">13.3 Director</span></a></li></ol></li></ol></div></div></div></div></main><footer id="footer" style="background: transparent"><div id="footer-wrap"><div class="copyright">©2024 By myl</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=4.13.0"></script><script src="/js/main.js?v=4.13.0"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"><script>(() => {
  const getCount = () => {
    const countELement = document.getElementById('twikoo-count')
    if(!countELement) return
    twikoo.getCommentsCount({
      envId: 'https://comments.manyile.top/',
      region: 'ap-shanghai',
      urls: [window.location.pathname],
      includeReply: false
    }).then(res => {
      countELement.textContent = res[0].count
    }).catch(err => {
      console.error(err)
    })
  }

  const init = () => {
    twikoo.init(Object.assign({
      el: '#twikoo-wrap',
      envId: 'https://comments.manyile.top/',
      region: 'ap-shanghai',
      onCommentLoaded: () => {
        btf.loadLightbox(document.querySelectorAll('#twikoo .tk-content img:not(.tk-owo-emotion)'))
      }
    }, null))

    GLOBAL_CONFIG_SITE.isPost && getCount()
  }

  const loadTwikoo = () => {
    if (typeof twikoo === 'object') setTimeout(init,0)
    else getScript('https://cdn.jsdelivr.net/npm/twikoo@1.6.31/dist/twikoo.all.min.js').then(init)
  }

  if ('Twikoo' === 'Twikoo' || !true) {
    if (true) btf.loadComment(document.getElementById('twikoo-wrap'), loadTwikoo)
    else loadTwikoo()
  } else {
    window.loadOtherComment = loadTwikoo
  }
})()</script></div><script type="text/javascript" src="https://unpkg.zhimg.com/jquery@latest/dist/jquery.min.js"></script><script data-pjax="" type="text/javascript" src="/js/nav.js"></script><div class="aplayer no-destroy" data-id="2664875269" data-server="netease" data-type="playlist" data-fixed="true" data-mini="true" data-listfolded="false" data-order="random" data-preload="none" data-autoplay="false" muted=""></div><script data-pjax="" type="text/javascript" src="/js/randomPaper.js"></script><script type="text/javascript" src="/js/rightMenu.js"></script><script>let tianliGPT_postSelector = '\#post \#article-container';let tianliGPT_key = 'c9b7741d290063ab872e';</script><script src="https://cdn1.tianli0.top/gh/zhheo/Post-Abstract-AI@0.15.2/tianli_gpt.js"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer@1.10.1/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/aplayer@1.10.1/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/metingjs/dist/Meting.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax@0.2.8/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {

  // removeEventListener
  btf.removeGlobalFnEvent('pjax')
  btf.removeGlobalFnEvent('themeChange')

  document.getElementById('rightside').classList.remove('rightside-show')
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

  typeof disqusjs === 'object' && disqusjs.destroy()
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', e => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async="" data-pjax="" src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"></div></div><hr><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js?v=4.13.0"></script></div></div><div class="js-pjax" id="rightMenu"><div class="rightMenu-group rightMenu-small"><a class="rightMenu-item" href="javascript:window.history.back();"><i class="fa fa-arrow-left"></i></a><a class="rightMenu-item" href="javascript:window.history.forward();"><i class="fa fa-arrow-right"></i></a><a class="rightMenu-item" href="javascript:window.location.reload();"><i class="fa fa-refresh"></i></a><a class="rightMenu-item" href="javascript:rmf.scrollToTop();"><i class="fa fa-arrow-up"></i></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-text"><a class="rightMenu-item" href="javascript:rmf.copySelect();"><i class="fa fa-copy"></i><span>复制</span></a><a class="rightMenu-item" href="javascript:window.open(&quot;https://www.baidu.com/s?wd=&quot;+window.getSelection().toString());window.location.reload();"><i class="iconfont icon-baidu"></i><span>百度搜索</span></a><a class="rightMenu-item" href="javascript:rmf.searchinThisPage();"><i class="fas fa-search"></i><span>站内搜索</span></a><a class="rightMenu-item" href="#post-comment" onclick="rmf.yinyong()"><i class="fa-solid fa-message"></i><span>引用文本评论</span></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-too"><a class="rightMenu-item" href="javascript:window.open(window.getSelection().toString());window.location.reload();"><i class="fa fa-link"></i><span>转到链接</span></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-paste"><a class="rightMenu-item" href="javascript:rmf.paste()"><i class="fa fa-copy"></i><span>粘贴</span></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-post"><a class="rightMenu-item" href="#post-comment"><i class="fas fa-comment"></i><span>空降评论</span></a><a class="rightMenu-item" href="javascript:switchCommentBarrage()"><i class="iconfont icon-danmu"></i><span>开/关评论弹幕</span></a><a class="rightMenu-item" href="javascript:rmf.copyWordsLink()"><i class="fa fa-link"></i><span>复制本文地址</span></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-to"><a class="rightMenu-item" href="javascript:rmf.openWithNewTab()"><i class="fa fa-window-restore"></i><span>新窗口打开</span></a><a class="rightMenu-item" id="menu-too" href="javascript:rmf.open()"><i class="fa fa-link"></i><span>转到链接</span></a><a class="rightMenu-item" href="javascript:rmf.copyLink()"><i class="fa fa-copy"></i><span>复制链接</span></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-img"><a class="rightMenu-item" href="javascript:rmf.saveAs()"><i class="fa fa-download"></i><span>保存图片</span></a><a class="rightMenu-item" href="javascript:rmf.openWithNewTab()"><i class="fa fa-window-restore"></i><span>在新窗口打开</span></a><a class="rightMenu-item" href="javascript:rmf.click()"><i class="fa fa-arrows-alt"></i><span>全屏显示</span></a><a class="rightMenu-item" href="javascript:rmf.copyLink()"><i class="fa fa-copy"></i><span>复制图片链接</span></a></div><div class="rightMenu-group rightMenu-line"><a class="rightMenu-item" href="javascript:randomPost()"><i class="fa fa-paper-plane"></i><span>随便逛逛</span></a><a class="rightMenu-item" href="javascript:rmf.switchDarkMode();"><i class="fa fa-moon"></i><span>昼夜切换</span></a><a class="rightMenu-item" href="javascript:fullScreen();"><i class="fas fa-expand"></i><span>进入全屏</span></a></div></div><!-- hexo injector body_end start --><script data-pjax="">function electric_clock_injector_config(){
                var parent_div_git = document.getElementsByClassName('sticky_layout')[0];
                var item_html = '<div class="card-widget card-clock"><div class="card-glass"><div class="card-background"><div class="card-content"><div id="hexo_electric_clock"><img id="card-clock-loading" src="https://cdn.jsdelivr.net/gh/Zfour/Butterfly-clock/clock/images/weather/loading.gif" style="height: 120px; width: 100%;" data-ll-status="loading" class="entered loading"></div></div></div></div></div>';
                console.log('已挂载electric_clock')
                // parent_div_git.innerHTML=item_html+parent_div_git.innerHTML // 无报错，但不影响使用(支持pjax跳转)
                parent_div_git.insertAdjacentHTML("afterbegin",item_html) // 有报错，但不影响使用(支持pjax跳转)
            }if( document.getElementsByClassName('sticky_layout')[0] && (location.pathname ==='all'|| 'all' ==='all')){

            electric_clock_injector_config()
        } </script><script src="https://pv.sohu.com/cityjson?ie=utf-8"></script><script data-pjax="" src="https://cdn.jsdelivr.net/gh/Zfour/hexo-electric-clock@1.0.6/clock.js"></script><script async="" src="//at.alicdn.com/t/font_2032782_8d5kxvn09md.js"></script><!-- hexo injector body_end end --></body></html>