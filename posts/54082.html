<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><!-- 百度的html标记--><meta name="baidu-site-verification" content="codeva-bSLYjtWXtR"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>整理 | myl's blog</title><meta name="author" content="myl"><meta name="copyright" content="myl"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="https://pdai.tech https://javaguide.cn https://xiaolincoding.com/ https://www.mianshiya.com/ 一 JavaSE1数据类型 8个基本：boolean(1)、byte(8)、char(16)、short(16)、int(32)、float(32)、long(64)、double(64) Integer缓存池范围">
<meta property="og:type" content="article">
<meta property="og:title" content="整理">
<meta property="og:url" content="http://yileman.github.io/posts/54082.html">
<meta property="og:site_name" content="myl's blog">
<meta property="og:description" content="https://pdai.tech https://javaguide.cn https://xiaolincoding.com/ https://www.mianshiya.com/ 一 JavaSE1数据类型 8个基本：boolean(1)、byte(8)、char(16)、short(16)、int(32)、float(32)、long(64)、double(64) Integer缓存池范围">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/cover/article_cover2.png">
<meta property="article:published_time" content="2024-05-12T00:00:00.000Z">
<meta property="article:modified_time" content="2024-09-03T06:39:16.000Z">
<meta property="article:author" content="myl">
<meta property="article:tag" content="基础">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/cover/article_cover2.png"><link rel="shortcut icon" href="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/touxiang.jpg"><link rel="canonical" href="http://yileman.github.io/posts/54082.html"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="preconnect" href="//busuanzi.ibruce.info"><meta name="baidu-site-verification" content="codeva-bSLYjtWXtR"><link rel="stylesheet" href="/css/index.css?v=4.13.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.11.1/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '整理',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-09-03 14:39:16'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><link rel="stylesheet" href="/css/modify.css"><link rel="stylesheet" href="/css/user.css"><link rel="stylesheet" href="/css/rightMenu.css"><link rel="stylesheet" href="/css/iconfont.css"><link rel="stylesheet" href="/css/mouse.css"><link rel="stylesheet" href="https://cdn1.tianli0.top/gh/zhheo/Post-Abstract-AI@0.15.2/tianli_gpt.css"><link rel="stylesheet" href="/css/custom.css" media="defer" onload="this.media='all'"><!-- hexo injector head_end start --><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Zfour/hexo-electric-clock@1.0.6/clock.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Zfour/Butterfly-double-row-display@1.00/cardlistpost.min.css">
<style>#recent-posts > .recent-post-item >.recent-post-info > .article-meta-wrap > .tags:before {content:"\A";
  white-space: pre;}#recent-posts > .recent-post-item >.recent-post-info > .article-meta-wrap > .tags > .article-meta__separator{display:none}</style>
<link rel="stylesheet" href="https://unpkg.com/hexo-butterfly-tag-plugins-plus-chinese@latest/lib/assets/font-awesome-animation.min.css" media="defer" onload="this.media='all'"><link rel="stylesheet" href="https://unpkg.com/hexo-butterfly-tag-plugins-plus-chinese@latest/lib/tag_plugins.css" media="defer" onload="this.media='all'"><script src="https://unpkg.com/hexo-butterfly-tag-plugins-plus-chinese@latest/lib/assets/carousel-touch.js"></script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.1.1"></head><body><div id="loading-box"><div class="pokeball-back"></div><div class="pokeball-loading"><div class="pokeball" id="pokeball-normal"></div><div class="pokeball" id="pokeball-great"></div><div class="pokeball" id="pokeball-ultra"></div><div class="pokeball" id="pokeball-master"></div><div class="pokeball" id="pokeball-safari"></div></div></div><script>(()=>{
  const $loadingBox = document.getElementById('loading-box')
  const $body = document.body
  const preloader = {
    endLoading: () => {
      //- console.log("end")
      $body.style.overflow = 'auto'

      document.getElementById('loading-box').style.transition = 'opacity 3s ease 0s'
      document.getElementById('loading-box').style.opacity = '0'
      setTimeout(function(){
        document.getElementById('loading-box').classList.add("loaded")
      }, 3000);

      //- $loadingBox.classList.add('loaded')
    },
    initLoading: () => {
      $body.style.overflow = ''
      $loadingBox.classList.remove('loaded')
      
    }
  }

  preloader.initLoading()
  //- setTimeout(function(){preloader.endLoading();}, 3000);
  window.addEventListener('load',() => { preloader.endLoading() })
  document.getElementById('loading-box').addEventListener('click',()=> {preloader.endLoading()})

  if (true) {
    document.addEventListener('pjax:send', () => { preloader.initLoading() })
    document.addEventListener('pjax:complete', () => { preloader.endLoading() })
  }
})()</script><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/touxiang.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">23</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">8</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">4</div></a></div><hr class="custom-hr"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page" href="/comments/"><i class="fa-fw fa fa-link"></i><span> 留言板</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/cover/article_cover2.png')"><nav id="nav"><span id="blog-info"><a href="/" title="myl's blog"><span class="site-name">myl's blog</span></a></span><div id="menus"></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page" href="/comments/"><i class="fa-fw fa fa-link"></i><span> 留言板</span></a></div></div><center id="name-container"><a id="page-name" href="javascript:scrollToTop()">PAGE_NAME</a></center><div id="nav-right"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div id="randomPost"><a class="site-page social-icon search" href="javascript:;" onclick="randomPost()" title="随机访问一篇文章"><i class="fas fa-circle-notch fa-fw"></i></a></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">整理</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-05-12T00:00:00.000Z" title="发表于 2024-05-12 08:00:00">2024-05-12</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-09-03T06:39:16.000Z" title="更新于 2024-09-03 14:39:16">2024-09-03</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/study/">study</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="整理"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><div class="top-img" style="background-image: url('https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/cover/article_cover2.png');"></div><article class="post-content" id="article-container"><p><a target="_blank" rel="noopener" href="https://pdai.tech">https://pdai.tech</a></p>
<p><a target="_blank" rel="noopener" href="https://javaguide.cn">https://javaguide.cn</a></p>
<p><a target="_blank" rel="noopener" href="https://xiaolincoding.com/">https://xiaolincoding.com/</a></p>
<p><a target="_blank" rel="noopener" href="https://www.mianshiya.com/">https://www.mianshiya.com/</a></p>
<h2 id="一-JavaSE"><a href="#一-JavaSE" class="headerlink" title="一 JavaSE"></a>一 JavaSE</h2><h3 id="1数据类型"><a href="#1数据类型" class="headerlink" title="1数据类型"></a>1数据类型</h3><ul>
<li>8个基本：boolean(1)、byte(8)、char(16)、short(16)、int(32)、float(32)、long(64)、double(64)</li>
<li><p>Integer缓存池范围 <code>-128~127</code></p>
</li>
<li><p>String的不可变性</p>
<ul>
<li>可以缓存hash值</li>
<li>线程安全（因为不可改变）</li>
<li><code>StringBuffer</code>是线程安全的，用了<code>synchronized</code>  同步</li>
</ul>
</li>
</ul>
<h3 id="2-接口"><a href="#2-接口" class="headerlink" title="2 接口"></a>2 接口</h3><ul>
<li>java8开始可以拥有默认的实现</li>
</ul>
<h3 id="3-抽象类"><a href="#3-抽象类" class="headerlink" title="3 抽象类"></a>3 抽象类</h3><ul>
<li><code>abstract</code>修饰，不能被实例化，包含了抽象方法 </li>
</ul>
<h3 id="4-Object类通用方法"><a href="#4-Object类通用方法" class="headerlink" title="4 Object类通用方法"></a>4 <code>Object</code>类通用方法</h3><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> Class&lt;?&gt; getClass() </span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> <span class="comment">// 返回散列值，判断对象是否等价</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">// 比较地址，一般重写，重写equals的时候一般也会重写hashCode方法，保证相等的对象hash也一样</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object obj)</span> </span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">native</span> Object <span class="title function_">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">notify</span><span class="params">()</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">notifyAll</span><span class="params">()</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">wait</span><span class="params">(<span class="type">long</span> timeout)</span> <span class="keyword">throws</span> InterruptedException</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">wait</span><span class="params">(<span class="type">long</span> timeout, <span class="type">int</span> nanos)</span> <span class="keyword">throws</span> InterruptedException</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">wait</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable {}</span><br></pre></td></tr></tbody></table></figure>
<h3 id="5-static"><a href="#5-static" class="headerlink" title="5 static"></a>5 static</h3><ul>
<li>初始化顺序：父类静态变量、代码块 ==&gt; 子类… ==&gt; 父类实例变量、代码块 ==&gt; 父类构造函数 ==&gt; 子类… ==&gt; 子类… </li>
</ul>
<h3 id="6-反射"><a href="#6-反射" class="headerlink" title="6 反射"></a>6 反射</h3><ul>
<li><p>相关类</p>
<ul>
<li><p><code>Field</code> ：表示类的成员变量，get set方法可以修改</p>
</li>
<li><p><code>Method</code> ：表示类的成员方法，<code>invoke()</code> 调用</p>
</li>
<li><p><code>Constructor</code> ：表示类的构造方法，新建对象</p>
</li>
</ul>
</li>
<li><p>class获取方式</p>
<ul>
<li><code>类名.class</code></li>
<li><code>对象.getClass()</code></li>
<li><code>Class.forName()</code><ul>
<li>classloader.load 类全限定名</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="7-异常"><a href="#7-异常" class="headerlink" title="7 异常"></a>7 异常</h3><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/image-20240514212224245.png" alt="image-20240514212224245" style="zoom:50%;"></p>
<ul>
<li><code>Error</code>：JVM不可捕获，程序崩溃<ul>
<li><code>OutOfMemoryError</code>、<code>StackOverflowError</code>…</li>
</ul>
</li>
<li><code>Exception</code>：<ul>
<li><code>RunTimeException</code></li>
<li><code>IOException</code></li>
</ul>
</li>
<li>尽量使用标准的异常</li>
<li>建立异常对象是建立一个普通Object耗时的约20倍，而抛出、接住一个异常对象，所花费时间大约是建立异常对象的4倍。</li>
</ul>
<h3 id="8-泛型"><a href="#8-泛型" class="headerlink" title="8 泛型"></a>8 泛型</h3><ul>
<li><p>泛型数组声明</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;?&gt;[] lists = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;?&gt;[<span class="number">10</span>]; <span class="comment">//OK </span></span><br><span class="line">List&lt;String&gt;[] lists = <span class="keyword">new</span> <span class="title class_">ArrayList</span>[<span class="number">10</span>]; <span class="comment">//OK，但是会有警告</span></span><br></pre></td></tr></tbody></table></figure>
</li>
</ul>
<h3 id="9-注解"><a href="#9-注解" class="headerlink" title="9 注解"></a>9 注解</h3><p><a target="_blank" rel="noopener" href="https://pdai.tech/md/java/basic/java-basic-x-annotation.html">https://pdai.tech/md/java/basic/java-basic-x-annotation.html</a></p>
<ul>
<li><p>java自带的标准注解</p>
<ul>
<li><p><code>@Override</code> ：标明重写某个方法</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.METHOD)</span> <span class="comment">// 注解作用于方法</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.SOURCE)</span> <span class="comment">// 编译时有效</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Override {</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p><code>@Deprecated</code>：标明方法过时</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Documented</span> <span class="comment">// 会文档化</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span> <span class="comment">// 运行时有效</span></span><br><span class="line"><span class="meta">@Target(value={CONSTRUCTOR, FIELD, LOCAL_VARIABLE, METHOD, PACKAGE, PARAMETER, TYPE})</span></span><br><span class="line"><span class="comment">// 能修饰构造方法，属性，局部变量，方法，包，参数，类型</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Deprecated {</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p><code>@SuppressWarnings</code>：标明要忽略的警告</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target({TYPE, FIELD, METHOD, PARAMETER, CONSTRUCTOR, LOCAL_VARIABLE})</span></span><br><span class="line"><span class="comment">// 类型、属性、方法、参数、构造器、局部变量</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.SOURCE)</span> <span class="comment">// 只能存活在源码时</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> SuppressWarnings {</span><br><span class="line">    String[] value();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
</li>
</ul>
</li>
<li><p>元注解</p>
<ul>
<li><code>@Retention</code>：标明注解被保留的阶段<ul>
<li><code>TYPE</code>、<code>FIELD</code>、<code>METHOD</code>、<code>PARAMETER</code>、<code>CONSTRUCTOR</code>、<code>LOCAL_VARIABLE</code>、<code>ANNOTATION_TYPE</code>、<code>PACKAGE</code>、<code>TYPE_PARAMETER</code>、<code>TYPE_USE</code> </li>
</ul>
</li>
<li><code>@Target</code>：标明注解使用的范围<ul>
<li><code>SOURCE</code>、<code>CLASS</code>、<code>RUNTIME</code>   </li>
</ul>
</li>
<li><code>@Inherited</code>：标明注解可继承</li>
<li><code>@Documented</code>：标明是否生成javadoc文档</li>
</ul>
</li>
<li><p>自定义注解</p>
</li>
</ul>
<h3 id="10-SPI机制"><a href="#10-SPI机制" class="headerlink" title="10 SPI机制"></a>10 SPI机制</h3><ul>
<li><p>整体机制图</p>
<p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/image-20240514231034618.png" alt="image-20240514231034618" style="zoom:50%;"></p>
<ul>
<li>当服务的提供者提供了一种接口的实现之后，需要在classpath下的<code>META-INF/services/</code>目录里创建一个以服务接口命名的文件，这个文件里的内容就是这个接口的具体的实现类。</li>
</ul>
</li>
<li><p>demo</p>
<ul>
<li><p>定义接口与两个实现</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Search</span> {</span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">searchDoc</span><span class="params">(String keyword)</span>;   </span><br><span class="line">}</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileSearch</span> <span class="keyword">implements</span> <span class="title class_">Search</span>{</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">searchDoc</span><span class="params">(String keyword)</span> {</span><br><span class="line">        System.out.println(<span class="string">"文件搜索 "</span> + keyword);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DatabaseSearch</span> <span class="keyword">implements</span> <span class="title class_">Search</span>{</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">searchDoc</span><span class="params">(String keyword)</span> {</span><br><span class="line">        System.out.println(<span class="string">"数据搜索 "</span> + keyword);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>接下来可以在resources下新建META-INF/services/目录，然后新建接口全限定名的文件：<code>com.cainiao.ys.spi.learn.Search</code>，里面加上我们需要用到的实现类</p>
<figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">com.cainiao.ys.spi.learn.FileSearch</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>测试</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestCase</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        ServiceLoader&lt;Search&gt; s = ServiceLoader.load(Search.class);</span><br><span class="line">        Iterator&lt;Search&gt; iterator = s.iterator();</span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext()) {</span><br><span class="line">           <span class="type">Search</span> <span class="variable">search</span> <span class="operator">=</span>  iterator.next();</span><br><span class="line">           search.searchDoc(<span class="string">"hello world"</span>);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="comment">// 最终输出文件搜索</span></span><br></pre></td></tr></tbody></table></figure>
</li>
</ul>
</li>
<li><p>SPI机制的广泛应用</p>
<ul>
<li>JDBC DriverManager<ul>
<li>java中定义了<code>java.sql.Driver</code>但是没有实现（由不同的厂商实现）</li>
<li>mysql的jar包中可以找到<code>META-INF/services</code>目录下有一个<code>java.sql.Driver</code>，文件内容是：<code>com.mysql.cj.jdbc.Driver</code>就是针对Java中定义的接口实现</li>
</ul>
</li>
<li>Spring中的SPI机制<ul>
<li>自动装配中最终会加载<code>META-INF/spring.factories</code>文件</li>
</ul>
</li>
</ul>
</li>
<li><p>SPI机制的一般流程</p>
<ul>
<li>定义标准。比如接口<code>java.sql.Driver</code></li>
<li>具体厂商或框架开发者实现。在<code>META-INF/services</code>目录下定义一个名字为接口全限名的文件，如<code>java.sql.Driver</code>，文件内容是具体的实现名称，比如<code>me.cxis.sql.MyDriver</code>就是对接口的实现</li>
<li>程序的使用：引用具体厂商jar包来实现功能。</li>
</ul>
</li>
<li><p>缺陷</p>
<ul>
<li>不能按需加载，需要遍历所有的实现并实例化</li>
<li>获取某个实现类的方式不够灵活，只能通过 Iterator 形式获取，不能根据某个参数来获取对应的实现类。</li>
<li>多个并发线程使用不安全</li>
</ul>
</li>
</ul>
<h3 id="11-集合框架"><a href="#11-集合框架" class="headerlink" title="11 集合框架"></a>11 集合框架</h3><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/image-20240518130341928.png" alt="image-20240518130341928"></p>
<ul>
<li><p><code>Map</code></p>
<ul>
<li><p><code>TreeMap</code>：base红黑树</p>
</li>
<li><p><code>HashMap</code>：base哈希表,<code>hashCode()</code>和<code>equals()</code>决定了存放的位置</p>
<ul>
<li><p>put过程</p>
<p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/image-20240314172246695.png" alt="image-20240314172246695" style="zoom:67%;"></p>
</li>
<li><p>不考虑内存，1000亿数据要插入到hashmap中，怎么做</p>
<ul>
<li>预先申请好hashmap容量，避免频繁的扩容（注意负载因子设置为1，否则750亿左右的时候就扩容了）</li>
<li>多线程：concurrentHashMap，或者根据hashmap 的哈希函数，预先对数据进行分组，由不同的线程负责不同组，也能避免并发冲突</li>
</ul>
</li>
</ul>
</li>
<li><p><code>HashTable</code>：base哈希表，线程安全，但是一般使用<code>ConcurrentHashMap</code> （分段锁）</p>
</li>
<li><p><code>LinkedHashSMap</code>：base双向链表，顺序为LRU(最近最少使用)顺序</p>
</li>
</ul>
</li>
<li><p><code>Collection</code></p>
<ul>
<li><p><code>Set</code></p>
<ul>
<li><code>TreeSet</code>：base红黑树，有序，查找时间O(logN)</li>
<li><code>HashSet</code>：base哈希表，无序，查找O(1)</li>
<li><code>LinkedHashSet</code>：base双向链表，有序，查找O(1)</li>
</ul>
</li>
<li><p><code>Queue</code></p>
<ul>
<li><code>LinkedList</code>：双向队列</li>
<li><code>PriorityQueue</code>：base完全二叉树实现的小顶堆，优先级队列，需要自定义一个 <code>Comparator</code>比较器</li>
</ul>
<blockquote>
<p>完全二叉树：除了最后一层,所有层填满,且叶子节点都在左边</p>
<p>小顶堆：特殊的完全二叉树,父节点的值小于子节点的值</p>
<p>移除顶部的过程:</p>
<p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/image-20240518161346769.png" alt="image-20240518161346769" style="zoom: 50%;"></p>
</blockquote>
</li>
<li><p><code>List</code></p>
<ul>
<li><code>ArrayList</code>：base动态数组，扩容代价大(每次扩容1.5)，最好在创建前指定好容量</li>
<li><code>Vector</code>：同上，但是线程安全,但是一般用<code>CopyOnWriteArrayList</code></li>
<li><code>LinkedList</code>：base双向链表，还可以用作栈、队列、双向队列</li>
</ul>
</li>
</ul>
</li>
<li><p><code>PriorityQueue</code>的使用</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">PriorityQueue&lt;Integer&gt; pq = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;Integer&gt;() {</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Integer e1, Integer e2)</span> {</span><br><span class="line">        <span class="comment">//比较方法</span></span><br><span class="line">        <span class="keyword">return</span> e1 - e2;</span><br><span class="line">    }</span><br><span class="line">});</span><br><span class="line"></span><br><span class="line"><span class="comment">// or</span></span><br><span class="line"></span><br><span class="line">PriorityQueue&lt;Integer&gt; pq2 = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;((Integer e1, Integer e2) -&gt; {</span><br><span class="line">	<span class="keyword">return</span> e1 - e2; <span class="comment">// 升序 1 2 3...</span></span><br><span class="line">});</span><br><span class="line"></span><br><span class="line"><span class="comment">// or </span></span><br><span class="line">PriorityQueue&lt;Integer&gt; pq3 = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;((a, b) -&gt; a - b);</span><br></pre></td></tr></tbody></table></figure>
</li>
</ul>
<h3 id="12-设计模式"><a href="#12-设计模式" class="headerlink" title="12 设计模式"></a>12 设计模式</h3><ul>
<li><p>创建模式</p>
<ul>
<li>工厂模式</li>
<li>单例模式</li>
<li>建造者模式：封装一个复杂对象构造过程，并允许按步骤构造。<code>.build()</code>类似</li>
<li>原型模式</li>
</ul>
</li>
<li><p>结构模式</p>
<ul>
<li>适配器模式</li>
<li>装饰者模式</li>
<li>代理模式</li>
<li>门面模式</li>
<li>桥接模式</li>
<li>组合模式</li>
</ul>
</li>
<li><p>关系模式</p>
<ul>
<li><p>策略模式</p>
</li>
<li><p>模板模式</p>
</li>
<li><p>观察者模式</p>
</li>
<li><p>责任链模式</p>
</li>
</ul>
</li>
</ul>
<h2 id="二-JVM"><a href="#二-JVM" class="headerlink" title="二 JVM"></a>二 JVM</h2><h3 id="1-类加载"><a href="#1-类加载" class="headerlink" title="1 类加载"></a>1 类加载</h3><ul>
<li><p>由JVM将代码生成对应的字节码文件(.class)，有javac编译器、scalac编译器、groovyc编译器、kotlinc编译器，对应不同的编程语言</p>
<ul>
<li>.class文件本质上是8位字节为基础的二进制流</li>
</ul>
</li>
<li><p>.class文件的结构</p>
<ul>
<li>魔数：头4个字节(cafe babe)，作用就是确定是一个class文件（图片的格式也有对应的魔数）</li>
<li>常量池：存储变量/方法的属性、类型、名称</li>
<li>访问标志：表示类的属性和访问类型（接口/类？public？final？）</li>
<li>类索引、父索引、接口索引：用于确定类的继承关系</li>
<li>字段表属性：表示变量的属性和访问类型</li>
<li>方法表属性：表示方法的属性和访问类型</li>
<li>属性表属性：描述某些场景专有的信息</li>
</ul>
</li>
<li><p>反编译字节码：<code>javap &lt;options&gt; &lt;classes&gt;</code></p>
</li>
<li><p>类生命周期</p>
<p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/image-20240526141058649.png" alt="image-20240526141058649" style="zoom:50%;"></p>
<ul>
<li><p>加载：</p>
<ul>
<li>根据类的全限定名来获取定义的二进制字节流</li>
<li>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构</li>
<li>在Java堆中生成一个代表这个类的java.lang.Class对象，作为堆方法区数据的访问入口</li>
</ul>
</li>
<li><p>验证：检查文件格式、字节码等</p>
</li>
<li><p>准备：在方法区为类的静态变量分配内存，并设置为默认值（0，0L，null，false）</p>
</li>
<li><p>解析： 把类中的符号引用转换为直接引用</p>
</li>
<li><p>初始化：为类的静态变量赋值</p>
<blockquote>
<p> 什么时候初始化类？</p>
<ul>
<li>new、访问静态变量/方法、反射、初始化子类，父类也会初始化、启动类</li>
</ul>
</blockquote>
</li>
<li><p>使用：类访问方法内的数据结构的接口，对象是堆的数据</p>
</li>
<li><p>虚拟机结束：执行System.exit()方法、程序结束、程序异常或错误退出、操作系统错误退出程序</p>
</li>
</ul>
</li>
<li><p>类加载器（从上到下）</p>
<ul>
<li>启动类加载器<code>Bootstrap ClassLoader</code>：负责加载JDK\jre\lib下的类</li>
<li>扩展类加载器<code>Extension ClassLoader</code>：负责加载JDK\jre\lib\ext下的类</li>
<li>应用程序类加载器<code>Application ClassLoader</code>：负责加载用户类路径(ClassPath)所指定的类</li>
</ul>
</li>
<li><p>类的加载方式</p>
<ul>
<li>命令行启动应用的时候JVM加载</li>
<li><code>Class.forName()</code>：将类加载到JVM中之后还会执行static块</li>
<li><code>ClassLoader.loadClass()</code>：只加载到JVM中，当newInstance的时候才加载static块</li>
</ul>
</li>
<li><p>类加载机制</p>
<ul>
<li>全盘负责、父类委托、缓存机制、<strong>双亲委派</strong></li>
</ul>
</li>
<li><p>双亲委派：</p>
<ul>
<li>执行loadClass的时候会优先调用父类的<code>loadClass()</code>方法，然后再调用自己的<code>findClass()</code></li>
</ul>
</li>
<li><p>JVM判断两个对象是否相等的规则：</p>
<ul>
<li>类的全类名是否一致</li>
<li>类的加载器是否一致（保证Java的核心API不会被篡改）</li>
</ul>
</li>
</ul>
<h3 id="2-内存结构"><a href="#2-内存结构" class="headerlink" title="2 内存结构"></a>2 内存结构</h3><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/image-20240526142905481.png" alt="image-20240526142905481"></p>
<p>线程私有：程序计数器、虚拟机栈、本地方法区</p>
<p>线程共享：堆、方法区、堆外内存（java7的永久代或java8的元空间）</p>
<ul>
<li><p>程序计数器：用于标注当前线程执行的字节码行号（区别于操作系统的PC寄存器）</p>
</li>
<li><p>虚拟机栈：保存局部变量、结果，参与方法的返回和调用</p>
<ul>
<li><p>StackOverflowError 、OutOfMemoryError</p>
</li>
<li><p>存储单位是栈帧</p>
</li>
<li><p>栈帧的内部结构</p>
<p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/image-20240526143620243.png" alt="image-20240526143620243" style="zoom: 50%;"></p>
</li>
</ul>
</li>
<li><p>本地方法区</p>
<ul>
<li>本地方法接口</li>
<li>本地方法栈</li>
</ul>
</li>
<li><p>堆：存储对象实例</p>
<ul>
<li>新生代：分为Eden、S1、S2（8:1:1）<ul>
<li>新生代的GC叫Minor/Young  GC，每次GC从Eden中找幸存者并将他们和S1或者S2的所有对象移到S2或者S1去，并回收S1/S2以及Eden中的剩余对象，多次GC（默认15次）后转移到老年代</li>
</ul>
</li>
<li>老年代<ul>
<li>Major/Old  GC</li>
<li>大对象直接进入老年代</li>
<li>OOM异常</li>
</ul>
</li>
<li>相关JVM参数<ul>
<li><code>-Xmx</code>：堆起始大小，一般为电脑内存/64</li>
<li><code>-Xms</code>：堆最大内存，一般为电脑内存/4</li>
</ul>
</li>
</ul>
</li>
<li><p>方法区：存储类信息、常量池、静态变量、JIT编译后的代码等数据</p>
<ul>
<li>java8之前在堆中(永久代)，java8移到了元空间(本地内存中)</li>
<li>相关JVM参数<ul>
<li><code>-XX:PermSize</code>、<code>-xx:MaxPermSize</code>：永久代空间</li>
<li><code>-XX:MetaspaceSize</code>、<code>-XX:MaxMetaspaceSize</code>：元空间</li>
<li><code>-XX:+HeapDumpBeforeFullGC</code>、<code>-XX:HeapDumpPath=/httx/logs/dump</code>：OOM的时候自动dump JVM </li>
</ul>
</li>
<li>垃圾回收：常量池中废弃的常量和不再使用的类型</li>
</ul>
</li>
</ul>
<h3 id="3-java内存模型"><a href="#3-java内存模型" class="headerlink" title="3 java内存模型"></a>3 java内存模型</h3><ul>
<li><p>负责实现java线程间的通信(JMM)：决定一个线程对共享变量的写入何时对另一个线程可见。是一个抽象的模型</p>
</li>
<li><p>重排序：导致内存可见性问题</p>
<ul>
<li>编译器优化的重排序：编译器不改变单线程程序语义的前提下做的</li>
<li>指令级并行的重排序：改变语句对应机器指令的执行顺序</li>
<li>内存系统的重排序</li>
</ul>
</li>
</ul>
<h3 id="4-垃圾回收"><a href="#4-垃圾回收" class="headerlink" title="4 垃圾回收"></a>4 垃圾回收</h3><ul>
<li><p>判断对象是否可被回收</p>
<ul>
<li>引用计数算法：计算引用次数，为0就可回收（有循环，所以java不用）</li>
<li>可达性算法：通过GC Root作为起点进行搜索，不可达的就可回收<ul>
<li>虚拟机栈中对象、本地方法栈对象、方法区中类静态属性引用的对象、方法区中常量引用的对象、所有被同步锁持有的对象、JNI引用的对象</li>
</ul>
</li>
<li>方法区的回收：主要是常量池和对类的卸载</li>
</ul>
</li>
<li><p>引用类型</p>
<ul>
<li><p>强引用：不会被回收</p>
</li>
<li><p>软引用：内存不足会被回收</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SoftReference&lt;Object&gt; sf = <span class="keyword">new</span> <span class="title class_">SoftReference</span>&lt;Object&gt;(obj);</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>弱引用：一定会被回收，只能存活到下次垃圾回收前</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">WeakReference&lt;Object&gt; wf = <span class="keyword">new</span> <span class="title class_">WeakReference</span>&lt;Object&gt;(obj);</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>虚引用：为一个对象设置虚引用关联的唯一目的就是能在这个对象被回收时收到一个系统通知。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PhantomReference&lt;Object&gt; pf = <span class="keyword">new</span> <span class="title class_">PhantomReference</span>&lt;Object&gt;(obj);</span><br></pre></td></tr></tbody></table></figure>
</li>
</ul>
</li>
<li><p>垃圾回收算法</p>
<ul>
<li>标记-清除</li>
<li>标记-整理</li>
<li>复制：（Eden，S1，S2）</li>
<li>分代收集<ul>
<li>新生代用复制</li>
<li>老年代用标记-清除/整理</li>
</ul>
</li>
</ul>
</li>
<li><p>垃圾收集器</p>
<ul>
<li>Serial 收集器：单线程，GC的时候用户线程停止</li>
<li>ParNew 收集器：新生代多线程，老年代单线程；，GC的时候用户线程停止</li>
<li>Parallel Scavenge 收集器：同上，但是其侧重点在于单次的吞吐量（即减少GC的频率）</li>
<li>Serial Old 收集器：Serial 收集器的老年代版本（不懂）</li>
<li>Parallel Old 收集器：两个都是多线程，Parallel Scavenge 收集器的老年代版本</li>
<li>CMS(Concurrent Mark Sweep) 收集器：多线程，GC和用户线程并行<ul>
<li>初始标记：用户线程暂停，标记GC Root直接关联的对象（很快）</li>
<li>并发标记：用户线程继续，进行GC Root标记</li>
<li>重新标记：用户线程暂停，修正并发时间内的变化</li>
<li>并发清除：用户线程继续</li>
</ul>
</li>
<li>G1 收集器：引入了分区的概念，不再使用新生老年代的划分，将堆区划分为若干等分<ul>
<li>启发式算法收集高效益的分区</li>
</ul>
</li>
</ul>
</li>
<li><p>三色标记法：黑：自身和成员都被标记；灰：自身被标记，成员未被；白：未被标记，最终回收白色的</p>
<ul>
<li><p>如何防止在并发标记的时候错删、漏删对象？漏删还好，下次回收即可，错删会引发npe</p>
<p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/image-20240821180153853.png" style="zoom:33%;"></p>
</li>
<li><p>CMS：写屏障 + 增量更新</p>
<ul>
<li>黑色对象建立对白色对象的引用时，把该黑色对象标记为灰色，缺点是会造成重复标记（只记录增加的引用）</li>
</ul>
</li>
<li><p>G1：写屏障 + 原始快照 SATB</p>
<ul>
<li>灰色对象断开对白色对象的引用时，把被删除的灰色对象到白色对象的引用记录下来，把白色对象修改为灰色。（只记录删除的引用）</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li><p>内存分配和回收策略</p>
<ul>
<li>回收策略<ul>
<li>Minor GC/Young GC：新生代</li>
<li>Major GC/Old GC：老年代</li>
<li>Full GC：整个java堆和方法区</li>
</ul>
</li>
<li>内存分配策略<ul>
<li>优先Eden</li>
<li>大对象进入老年代</li>
<li>长期存活进入老年代</li>
</ul>
</li>
<li>Full GC条件<ul>
<li>调用<code>System.gc()</code>不建议使用</li>
<li>老年代空间不足</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="5-JVM参数-调优"><a href="#5-JVM参数-调优" class="headerlink" title="5 JVM参数/调优"></a>5 JVM参数/调优</h3><ul>
<li><p>JVM</p>
<figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">-Xms -Xmx					   		<span class="comment"># 堆最小/大值</span></span><br><span class="line">-Xmn 						   		<span class="comment"># 新生代大小,一般为堆的1/4或者1/3</span></span><br><span class="line">-XX:NewRatio 				   		<span class="comment"># 新生代与老年代比值</span></span><br><span class="line">-XX:PermSize  -XX:MaxPermSize  		<span class="comment"># 老年代的初始值/最大值</span></span><br><span class="line">-XX:MaxTenuringThreshold 	   		<span class="comment"># 新生代存活次数</span></span><br><span class="line">-XX:SurvivorRatio 			   		<span class="comment"># Eden区与Subrvivor区大小的比值为8就是8:1:1</span></span><br><span class="line">-XX:+HeapDumpBeforeFullGC			<span class="comment"># OOM的时候自动dump JVM </span></span><br><span class="line">-XX:HeapDumpPath=/httx/logs/dump    <span class="comment"># dump地址 </span></span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>垃圾回收器</p>
<figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">-XX:+UseSerialGC			   <span class="comment"># 串行回收器</span></span><br><span class="line">-XX:+UseParNewGC			   <span class="comment"># 新生代使用并行，老年代使用串行</span></span><br><span class="line">-XX:+UseConcMarkSweepGC		   <span class="comment"># 新生代使用并行，老年代使用CMS(一般都是使用这种方式)</span></span><br><span class="line">-XX:ParallelGCThreads		   <span class="comment"># 指定并行的垃圾回收线程的数量，最好等于CPU数量</span></span><br><span class="line">-XX:+DisableExplicitGC		   <span class="comment"># 禁用System.gc()，因为它会触发Full GC，这是很浪费性能的</span></span><br><span class="line">-XX:+PrintGCDetails			   <span class="comment"># 开启详细GC日志模式，日志的格式是和所使用的算法有关</span></span><br><span class="line">-XX:+PrintGCDateStamps		   <span class="comment"># 将时间和日期也加入到GC日志中</span></span><br></pre></td></tr></tbody></table></figure>
</li>
</ul>
<h3 id="6-分析工具"><a href="#6-分析工具" class="headerlink" title="6 分析工具"></a>6 分析工具</h3><ul>
<li>堆内存溢出OOM<ul>
<li>添加jvm参数：<code>-XX:+HeapDumpOnOutOfMemoryError</code>：在OutOfMemoryError后获取一份HPROF二进制Heap Dump文件</li>
</ul>
</li>
</ul>
<h3 id="7-JVM远程调试remote-debug"><a href="#7-JVM远程调试remote-debug" class="headerlink" title="7 JVM远程调试remote debug"></a>7 JVM远程调试remote debug</h3><ul>
<li><p>前提：远程服务器项目运行且两边代码一致</p>
</li>
<li><p>远程服务器启动时附带jvm参数</p>
<figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-Xdebug -Xrunjdwp:transport=dt_socket,<span class="built_in">suspend</span>=n,server=y,address=<span class="variable">${debug_port}</span></span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>idea打开，设置启动配置，输入远程机器ip和刚刚设置的端口</p>
<ul>
<li>打断点，如果断点右上角有√就代表成功了</li>
</ul>
</li>
</ul>
<h3 id="8-linux-问题排查"><a href="#8-linux-问题排查" class="headerlink" title="8 linux 问题排查"></a>8 linux 问题排查</h3><ul>
<li>文本<ul>
<li>文本查找 <code>grep</code></li>
<li>文本处理 <code>sed</code>（增删改查）</li>
</ul>
</li>
<li>文件<ul>
<li><code>tail -f filename</code>：循环监听</li>
<li>查找文件 find</li>
</ul>
</li>
<li>网络进程<ul>
<li>netstat</li>
</ul>
</li>
</ul>
<h2 id="三-并发"><a href="#三-并发" class="headerlink" title="三 并发"></a>三 并发</h2><h3 id="1-理论"><a href="#1-理论" class="headerlink" title="1 理论"></a>1 理论</h3><ul>
<li><p>多线程解决的问题（根本原因速度不同：内存 &gt; CPU &gt; IO设备）</p>
<ul>
<li><strong>可见性</strong>：CPU增加了缓存，均衡和内存的速度差异 ==&gt; 同时带来了<strong>可见性</strong>问题：不同线程对变量的修改不会马上被共享</li>
<li><strong>原子性</strong>：操作系统增加了进程、线程，以分时复用IO，均衡CPU与IO设备的差异 ==&gt; 带来了<strong>原子性</strong>问题：一个操作要么全成功/失败</li>
<li><strong>有序性</strong>：编译器优化程序指令，使缓存可以更好的利用 ==&gt; 带来了<strong>有序性</strong>问题</li>
</ul>
</li>
<li><p>Java如何解决并发问题：</p>
<ul>
<li><p>可见性：<code>volatile</code>关键字修饰的变量被所有线程可见</p>
</li>
<li><p>原子性：读取和简单赋值，如果需要更大范围的原子操作可以使用<code>synchronized</code>和<code>Lock</code></p>
</li>
<li><p>有序性：<code>volatile</code>禁止了JVM的指令重排，保证了有序性，<code>synchronized</code>和<code>Lock</code>也是</p>
</li>
</ul>
</li>
<li><p>不可变对象</p>
<ul>
<li>final修饰的基本数据类型(如果是对象的话它的成员变量是可以变的)</li>
<li>String</li>
<li>枚举</li>
<li>Number的部分子类,如Long和Double等,BigInteger和BigDecimal 等</li>
</ul>
</li>
</ul>
<p>​    </p>
<h3 id="2-线程"><a href="#2-线程" class="headerlink" title="2 线程"></a>2 线程</h3><ul>
<li><p>线程状态</p>
<p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/image-20240518171545614.png" alt="image-20240518171545614" style="zoom:50%;"></p>
</li>
<li><p>实现(实现接口更好)</p>
<ul>
<li><code>Runnable</code>接口</li>
<li><code>Callable</code>接口</li>
<li>继承<code>Thread</code>类：三种方法本质都需要Thread类来启动</li>
<li>使用线程池</li>
</ul>
</li>
<li><p>线程安全的方法</p>
<ul>
<li>互斥同步<ul>
<li><code>synchronized</code>（JVM级别） 和 <code>ReentrantLock</code>（JDK级别）。</li>
</ul>
</li>
<li>非阻塞同步<ul>
<li>CAS算法</li>
</ul>
</li>
<li>不涉及共享数据就没有线程安全问题<ul>
<li><code>ThreadLocal</code> </li>
</ul>
</li>
</ul>
</li>
<li><p><code>Executor</code>（看不懂）</p>
</li>
<li><p><code>synchronized</code>和<code>ReentrantLock</code></p>
<ul>
<li>前者是JVM实现，后者是JDK实现</li>
<li>两者性能大致相同（因为新版本JVM对<code>synchronized</code>进行了优化，也支持了自旋锁等</li>
<li>前者不可中断，后者可以</li>
<li>优先使用前者，因为是JVM原生支持，且不用担心死锁问题，因为JVM会保证锁的释放</li>
</ul>
</li>
<li><p>线程池</p>
<ul>
<li>创建<ul>
<li><code>ThreadPoolExecutor</code>创建（推荐）</li>
<li>通过<code>Executor</code>框架的工具类 <code>Executors</code> 来创建。</li>
</ul>
</li>
<li>线程池参数：<ul>
<li>corePoolSize : 任务队列未达到队列容量时，最大可以同时运行的线程数量。</li>
<li>maximumPoolSize : 任务队列中存放的任务达到队列容量的时候，当前可以同时运行的线程数量变为最大线程数。</li>
<li>workQueue: 新任务来的时候会先判断当前运行的线程数量是否达到核心线程数，如果达到的话，新任务就会被存放在队列中。</li>
<li>keepAliveTime：当线程数大于corePoolSize 且没有新的任务提交，多余的空闲线程的等待时间</li>
<li>unit : keepAliveTime 参数的时间单位。</li>
<li>threadFactory :executor 创建新线程的时候会用到。</li>
<li>handler :饱和策略<ul>
<li><code>ThreadPoolExecutor.AbortPolicy</code>： 抛出 <code>RejectedExecutionException</code>来拒绝新任务的处理。<ul>
<li>推荐使用，让业务感知异常</li>
</ul>
</li>
<li><code>ThreadPoolExecutor.DiscardPolicy</code>：不处理新任务，直接丢弃掉。</li>
<li><code>ThreadPoolExecutor.DiscardOldestPolicy</code>： 此策略将丢弃最早的未处理的任务请求。</li>
<li><code>ThreadPoolExecutor.CallerRunsPolicy</code>：由调用线程处理该任务。如果执行程序已关闭，则会丢弃该任务</li>
</ul>
</li>
</ul>
</li>
<li>参数设置原则<ul>
<li>最佳corePoolSize ，N为CPU的核数<ul>
<li>如果是IO密集型（CPU计算时间短，而等待IO操作（如读写文件、网络通信等）的时间长）的任务就设置为2N</li>
<li>文件处理，数据库读写，网络操作等</li>
<li>如果是CPU密集型（几乎没有IO等待）就设置为N+1</li>
<li>数值计算、图像视频处理、加密解密、模型训练等</li>
<li>还可以这样计算：<code>((线程等待时间+线程CPU时间) / 线程CPU时间)* CPU数目</code></li>
</ul>
</li>
</ul>
</li>
<li>常用四大线程池<ul>
<li>newCachedThreadPool——可缓存线程池<ul>
<li>线程数量无上线，coresize = 0</li>
</ul>
</li>
<li>newFixedThreadPool——指定线程数量<ul>
<li>不会释放线程</li>
</ul>
</li>
<li>newSingleThreadExecutor——单线程的Executor</li>
<li>newScheduleThreadPool——定时线程池</li>
</ul>
</li>
</ul>
</li>
<li><p>线程池解决了什么问题</p>
<ul>
<li>频繁申请/销毁资源和调度资源，将带来额外的消耗</li>
<li>对资源无限申请缺少抑制手段，易引发系统资源耗尽的风险</li>
<li>系统无法合理管理内部的资源分布，会降低系统的稳定性</li>
</ul>
</li>
<li>实际使用的问题：参数不好配置<ul>
<li>最大核心数设置偏小容易导致抛出拒绝异常，触发接口降级</li>
<li>队列设置过长，大量任务堆积在队列中，任务执行时间长，导致超时</li>
</ul>
</li>
</ul>
<h3 id="3-锁"><a href="#3-锁" class="headerlink" title="3 锁"></a>3 锁</h3><ul>
<li><p>Java的锁分类</p>
<ul>
<li><p>线程是否锁同步资源</p>
<ul>
<li>乐观锁：采用无锁编程实现，CAS算法</li>
<li>悲观锁：<code>synchronized</code>关键字和<code>Lock</code>的实现类实现<ul>
<li><code>ReentrantLock</code>、<code>ReadLock</code>、<code>WriteLock</code>（后两者是<code>ReentrantReadWriteLock</code>内部类）</li>
</ul>
</li>
</ul>
</li>
<li><p>锁住同步资源失败时，线程要不要阻塞</p>
<blockquote>
<p>为什么要非阻塞？阻塞线程要切换CPU的状态，耗时，自旋就是不让线程阻塞（及不放弃CPU的时间片）</p>
</blockquote>
<ul>
<li>阻塞</li>
<li>非阻塞<ul>
<li>自旋锁</li>
<li>适应性自旋锁</li>
</ul>
</li>
</ul>
</li>
<li><p>多个线程竞争同步资源的流程细节</p>
<ul>
<li>这是针对<code>synchronized</code>的优化，表示锁的四个状态</li>
<li>无锁</li>
<li>偏向锁：同一个线程执行同步资源时自动获取资源</li>
<li>轻量级锁：多个线程竞争时，没获取资源的线程自旋等待所释放</li>
<li>重量级锁：多个线程竞争时，没获取资源的线程阻塞等待被唤醒</li>
</ul>
</li>
<li><p>多个线程竞争锁时要不要排队</p>
<ul>
<li>公平锁</li>
<li>非公平锁：先尝试插队，失败了再排队</li>
</ul>
</li>
<li><p>一个线程的多个流程能不能获取同一把锁（前提是锁的是同一个对象或者class）</p>
<ul>
<li>可重入锁：<code>ReentrantLock</code>(底层是AQS的state变量)和<code>synchronized</code></li>
<li>不可重入锁</li>
</ul>
</li>
<li><p>多个线程能否共享锁</p>
<ul>
<li>共享锁：<code>ReentrantReadWriteLock</code>，本质是里面的两把锁，读锁和写锁</li>
<li>排他锁：<code>synchronized</code>和JUC中<code>Lock</code>的实现类就是互斥锁。</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li><p><code>synchronized</code>原理：依赖于对象的<strong>Markword</strong>。（对象在内存的信息分为三段:对象头(包含了Markword)，实例数据，对齐填充）</p>
<p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/image-20240821230808058.png" alt="image-20240821230808058" style="zoom:50%;"></p>
<ul>
<li><strong>偏向锁</strong>就是就是将hash值设置为线程id，是否偏向置为1，之后的时间如果这个线程再获取这个锁就不用再加锁了</li>
<li>如果出现了另一个线程需要找个锁，就会进行<strong>锁膨胀</strong>为<strong>轻量级锁</strong>，自旋等待 </li>
<li>再膨胀就变为重量级锁，也就是<strong>互斥锁</strong></li>
</ul>
</li>
<li><p>死锁的四大条件</p>
<ul>
<li>互斥条件：一个资源每次只能被一个进程使用。</li>
<li>请求与保持条件：一个进程因请求资源而阻时，对已获得的资源保持不放。</li>
<li>不剥夺/非抢占条件:进程已获得的资源，在末使用完之前，不能强行剥夺。</li>
<li>循环等待条件:若干进程之间形成一种头尾相接的循环等待资源关系。</li>
</ul>
</li>
</ul>
<ul>
<li><p>死锁的解决</p>
<ul>
<li>破坏互斥：让资源可以同时访问（往往行不通）</li>
<li>破坏非抢占：剥夺式调度算法，但是会导致资源利用率低（不怎么用）</li>
<li>破坏请求与保持：静态分配策略：在进程执行之前先获取到他需要的所有资源，如果不满足就不开启（会导致资源利用率低，因为部分资源可能在进程后期才会用）</li>
<li>破坏循环等待：层次分配策略：将资源分层，先释放低层次的资源再获取高层次的资源</li>
</ul>
</li>
</ul>
<h3 id="4-关键字"><a href="#4-关键字" class="headerlink" title="4 关键字"></a>4 关键字</h3><ul>
<li><p><code>Synchronized</code></p>
<ul>
<li>基于JVM，本质是根据<code>monitorenter</code>和<code>monitorexit</code>指令来控制程序执行</li>
<li>两个指令是依赖于操作系统的Mutex Lock实现，而Mutex Lock要切换到内核态才能执行，代价昂贵</li>
</ul>
</li>
<li><p><code>volatile</code></p>
<ul>
<li><p>作用：防止重排、保证线程之间的可见性、保证原子性(32位系统的long、double的单次读/写)</p>
<blockquote>
<p>32位系统一次读/写32位，而long和double是64位的</p>
</blockquote>
</li>
</ul>
</li>
<li><p><code>final</code></p>
<ul>
<li><p>如果要扩展<code>final</code>关键字修饰的类的功能，怎么做？ <code>final</code>无法继承/实现，所以通过组合</p>
</li>
<li><p>关于final的指令重排序（因为final字段必须在构造函数执行完成之前初始化完成）</p>
<ul>
<li>对于基本数据类型<ul>
<li>写：禁止final域写与构造方法重排序(禁止final域写重排序到构造方法之外，保证对象初始化完后，final已经全部初始化)</li>
<li>读：禁止初次读对象的引用与读该对象包含的final域的重排序。</li>
</ul>
</li>
<li>对于引用数据类型<ul>
<li>额外增加：禁止在构造函数对一个final修饰的对象的成员域的写入与随后将这个被构造的对象的引用赋值给引用变量 重排序</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="5-JUC框架"><a href="#5-JUC框架" class="headerlink" title="5 JUC框架"></a>5 JUC框架</h3><ul>
<li><p>即java.util.concurrent包</p>
</li>
<li><p>主要部分：Lock框架和Tools类、Collections(并发集合)、Atomic(原子类)、Executors(线程池)</p>
</li>
<li><p>原子类<code>Atomic</code></p>
<ul>
<li>本质是CAS算法(乐观锁)</li>
<li>如<code>AtomicInteger</code> 有<code>add()</code>方法可以实现不加锁的情况下并发数据的一致性</li>
<li>还有<code>AtomicBoolean</code>、<code>AtomicLong</code>、<code>AtomicIntegerArray</code>、<code>AtomicLongArray</code>、<code>AtomicReferenceArray</code>等</li>
<li>如何解决ABA问题？<code>AtomicStampedReference.compareAndSet()</code>方法可以检查</li>
</ul>
</li>
<li><p><code>LockSupport</code>：用来创建锁和其他同步类的基本线程阻塞</p>
<ul>
<li><code>park()</code>函数：阻塞线程</li>
<li><code>unpark()</code>函数：激活线程</li>
<li><code>Thread.sleep()</code>和<code>LockSupport.park()</code><ul>
<li>都阻塞当前线程，且都不会释放资源</li>
<li>前者不能通过外部唤醒，只能自己苏醒；后者可以通过另外一个线程的unpark唤醒</li>
<li>前者需要抛出InterruptedException中断异常；后者没有</li>
<li>前者本身是一个native方法；后者底层是调用Unsafe的native方法</li>
</ul>
</li>
</ul>
</li>
<li><p>锁的核心类AQS(<code>AbstractQueuedSynchronizer</code>)</p>
<ul>
<li>核心思想：如果资源空闲，如果空闲则将请求资源的线程设置为有效的工作线程并锁定资源；如果资源被占用，则将线程加入到CLH队列等待</li>
<li>AQS定义的资源共享方式：<ul>
<li>独占：只有一个线程能获取资源，如<code>ReentrantLock</code>，分为公平锁/非公平锁</li>
<li>共享：多个线程可以同时执行，如<code>Semaphore/CountDownLatch</code>、<code>Semaphore</code>、<code>CountDownLatCh</code>、 <code>CyclicBarrier</code>、<code>ReadWriteLock</code></li>
</ul>
</li>
</ul>
</li>
<li><p><code>ReentrantLock</code>：独占锁</p>
<ul>
<li>里面有三个内部类<code>Sync extends AQS</code>及其两个子类：<code>NonfairSync</code>、<code>FairSync</code>，分别实现公平/非公平策略</li>
<li>构造函数默认使用的是<code>NonfairSync</code></li>
<li>对其操作都转化为了对<code>Sync</code>对象的操作，进而转换为对<code>AQS</code>的操作</li>
</ul>
</li>
<li><p><code>ReentrantReadWriteLock</code>：读写锁(满足多读的场景)</p>
<ul>
<li>除了<code>ReentrantLock</code>里面的三个内部类外，还有<code>ReadLock</code>和<code>WriteLock</code>均是<code>Lock</code>的实现</li>
</ul>
</li>
</ul>
<ul>
<li><p><code>ConcurrentHashMap</code> </p>
<ul>
<li>保存了一个<code>Segment</code>数组，将hash表划分为多段来实现分段锁。每个<code>segment</code>通过<code>ReentrantLock</code></li>
<li>每个分段里面是数组+链表+红黑树(jdk1.8引进)的方式</li>
<li>扩容：segment不能扩容(初始默认值是16，也就是16个并发量)，扩容是segment里面的数组扩容</li>
</ul>
</li>
<li><p><code>CopyOnWriteArrayList</code></p>
<ul>
<li>属性中有一个<code>ReentrantLock</code>可重入锁，保证线程访问的安全</li>
<li>写操作的时候，拷贝数组，可能会导致young gc或者full gc</li>
</ul>
</li>
<li><p><code>ConcurrentLinkedQueue</code></p>
</li>
<li><p>线程池<code>ThreadPoolExecutor</code></p>
<ul>
<li><p>本质是维护一个线程集合和一个阻塞工作队列</p>
</li>
<li><p>参数：见 2 线程部分</p>
</li>
<li>三种类型<ul>
<li><code>newFixedThreadPool</code><ul>
<li>线程池数达到corePoolSize后，即使没有可执行任务也不会释放线程 — <code>maximumPoolSize</code>、<code>keepAliveTime</code>参数无效</li>
<li>工作队列为无界队列 — 饱和策略参数无效</li>
</ul>
</li>
<li><code>newSingleThreadExecutor</code><ul>
<li>初始化的线程池只有一个线程，如果该线程异常结束，则会创建一个新的</li>
<li>工作队列为无界队列 — 饱和策略参数无效</li>
</ul>
</li>
<li><code>newCachedThreadPool</code><ul>
<li>线程池数量可达到<code>Integer.MAX_VALUE</code>(2147483647)</li>
<li>正常理解的线程池</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p><code>CountDownLatch</code></p>
<ul>
<li>目的是实现不同之间的线程同步</li>
<li>内部类<code>Sync extends AbstractQueuedSynchronizer</code> </li>
</ul>
</li>
<li><p><code>ThreadLocal</code></p>
<ul>
<li><p>线程安全：互斥同步(synchronized 和 ReentrantLock)、非阻塞同步(CAS, AtomicXXXX)、无同步本地存储(ThreadLocal)</p>
</li>
<li><p>内部类<code>ThreadLocalMap</code></p>
<ul>
<li><p>没有实现Map接口</p>
</li>
<li><p>没有public方法</p>
</li>
<li><p><code>ThreadLocalMap</code>的<code>Entry</code>实现继承了<code>WeakReference&lt;ThreadLocal&lt;?&gt;&gt;</code></p>
</li>
<li><p>该方法仅仅用了一个<code>Entry</code>数组来存储Key, Value; Entry并不是链表形式, 而是每个bucket里面仅仅放一个Entry;</p>
<p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/image-20240315170346022.png" alt="image-20240315170346022" style="zoom: 25%;"></p>
</li>
</ul>
</li>
<li><p>内存泄漏问题：使用线程池的时候可能会出现</p>
<p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/image-20240315170633122.png" alt="image-20240315170633057" style="zoom: 50%;"></p>
<ul>
<li><code>ThreadLocalMap</code> 中使用的 key 为 <code>ThreadLocal</code> 的弱引用，而 value 是强引用。所以，如果 <code>ThreadLocal</code> 没有被外部强引用的情况下，在垃圾回收的时候，key 会被清理掉，而 value 不会被清理掉。</li>
<li>如果<code>ThreadLocal</code>没有外部强引用，那么在发生垃圾回收的时候，<code>ThreadLocal</code>就必定会被回收，而<code>ThreadLocal</code>又作为Map中的key，<code>ThreadLocal</code>被回收就会导致一个key为null的entry，外部就无法通过key来访问这个entry，垃圾回收也无法回收，这就造成了内存泄漏</li>
<li>如何防止：<code>ThreadLocal</code>的<code>remove()</code>方法<ul>
<li>在get和set的方法中可能会调用这个remove方法</li>
<li>ThreadLocal虽然提供了避免内存泄露的方法，但是ThreadLocal不会主动去执行这些方法，需要我们在使用完ThreadLocal对象中保存的数据后，在<strong>finally{}代码块中调用ThreadLocal的remove()方法</strong>，加快GC自动垃圾回收，避免内存泄露。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="四-IO"><a href="#四-IO" class="headerlink" title="四 IO"></a>四 IO</h2><h3 id="1-JavaIO"><a href="#1-JavaIO" class="headerlink" title="1 JavaIO"></a>1 JavaIO</h3><ul>
<li><p>javaIO从传输方式来说主要分为两大类：字节流(InputStream/OutputStream)和字符流(Reader/Writer)</p>
</li>
<li><p>从数据操作来说：</p>
<ul>
<li>文件：FileInputStream/OutputStream、FileReader/Writer</li>
<li>数组：ByteArrayInputStream/OutputStream、CharArrayReader/Writer</li>
<li>管道：PipedInputStream/OutputStream、PipedReader/Writer</li>
<li>基本数据类型：DataInputStream/OutputStream、DataReader/Writer</li>
<li>缓冲操作：BufferInputStream/OutputStream、BufferReader/Writer</li>
<li>打印：PrintStream/Writer</li>
<li>对象序列化反序列化：ObjectInputStream/OutputStream</li>
<li>字节字符流转换：InputStreamReader/OutputStreamWriter</li>
</ul>
</li>
</ul>
<h3 id="2-JavaIO设计模式—装饰者"><a href="#2-JavaIO设计模式—装饰者" class="headerlink" title="2 JavaIO设计模式—装饰者"></a>2 JavaIO设计模式—装饰者</h3><ul>
<li><p>装饰者模式</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">CompInterface</span> { <span class="comment">// 顶层</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">action</span><span class="params">()</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Comp1</span> <span class="keyword">implements</span> <span class="title class_">CompInterface</span> { <span class="comment">// 组件1</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">action</span><span class="params">()</span> {</span><br><span class="line">        <span class="comment">// ...行为1</span></span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">CompDecorator</span> <span class="keyword">implements</span> <span class="title class_">CompInterface</span> { <span class="comment">// 顶层抽象装饰器</span></span><br><span class="line">    <span class="keyword">protected</span> CompInterface comp;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Decorator1</span> <span class="keyword">extends</span> <span class="title class_">CompDecorator</span> { <span class="comment">// 装饰器1</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Decorator1</span><span class="params">(CompInterface comp)</span> {</span><br><span class="line">        <span class="built_in">this</span>.comp = comp;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">action</span><span class="params">()</span> {</span><br><span class="line">        comp.action();</span><br><span class="line">        <span class="comment">// 自己的动作</span></span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Decorator2</span> <span class="keyword">extends</span> <span class="title class_">CompDecorator</span> { <span class="comment">// 装饰器2</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Decorator2</span><span class="params">(CompInterface comp)</span> {</span><br><span class="line">        <span class="built_in">this</span>.comp = comp;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">action</span><span class="params">()</span> {</span><br><span class="line">        comp.action();</span><br><span class="line">        <span class="comment">// 自己的动作</span></span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">Comp1</span> <span class="variable">comp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Comp1</span>();    <span class="comment">// 声明组件1</span></span><br><span class="line">comp = <span class="keyword">new</span> <span class="title class_">Decorator1</span>(comp); <span class="comment">// 装饰上Decorator1</span></span><br><span class="line">comp = <span class="keyword">new</span> <span class="title class_">Decorator2</span>(comp); <span class="comment">// 装饰上Decorator2</span></span><br><span class="line">comp.action; <span class="comment">// 执行Comp1、Decorator1、Decorator2的action</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/image-20240601151606748.png" alt="image-20240601151606748" style="zoom:50%;"></p>
</li>
<li><p>在IO流相关类的表现：</p>
<p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/image-20240601151715251.png" alt="image-20240601151715251" style="zoom:50%;"></p>
<ul>
<li><p>FilterInputStream是一个抽象组件，类似于上文的CompDecorator，使用Buffer对FileInputStream进行增加，实现缓冲</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">FileInputStream</span> <span class="variable">fileInputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(filePath);</span><br><span class="line"><span class="type">BufferedInputStream</span> <span class="variable">bufferedInputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedInputStream</span>(fileInputStream);</span><br></pre></td></tr></tbody></table></figure>
</li>
</ul>
</li>
</ul>
<h3 id="3-IO中常见类的使用"><a href="#3-IO中常见类的使用" class="headerlink" title="3 IO中常见类的使用"></a>3 IO中常见类的使用</h3><ul>
<li><p>磁盘操作：File</p>
</li>
<li><p>字节操作：Input/OutputStream</p>
</li>
<li><p>字符操作：Reader/Writer</p>
</li>
<li><p>对象操作：</p>
<ul>
<li>Serializable(一个空接口，只是一个标准，不实现它就进行序列化会抛异常)</li>
<li>transient关键字修饰的对象/属性不会被序列化</li>
</ul>
</li>
<li><p>网络操作：</p>
<ul>
<li><p>InetAddress：用来表示IP地址</p>
</li>
<li><p>URL：统一资源定位符</p>
</li>
<li><p>Sockets：使用 TCP 协议实现网络通信</p>
</li>
<li><p>Datagram：使用 UDP 协议实现网络通信</p>
</li>
</ul>
</li>
</ul>
<h3 id="4-Unix-IO模型"><a href="#4-Unix-IO模型" class="headerlink" title="4 Unix IO模型"></a>4 Unix IO模型</h3><p>一个输入操作通常包括：1. 等待数据准备好  2. 从内核向进程复制数据</p>
<ul>
<li>阻塞式I/O：应用进程(不是整个操作系统)被阻塞，直到数据复制到应用进程缓冲区中才返回，执行效率会比较高。</li>
<li>非阻塞式I/O：应用进程执行系统调用后，内核返回一个错误码，应用进程继续执行，但不断的执行系统调用（轮询polling）来获取IO是否完成。对CPU的利用率较低（因为CPU要不断的处理系统调用）</li>
<li><p>I/O复用：应用进程使用select或者poll等待数据并阻塞，当一个套接字变为可读时再调用recvfrom复制数据</p>
<ul>
<li>单个线程处理多个套接字，即多个IO事件</li>
</ul>
</li>
<li><p>信号驱动I/O：应用进程使用sigaction系统调用，内核立即返回信息，应用进程继续执行，数据准备完毕后内核向应用程序发送SIGIO信号，之后应用进程调用recvfrom获取数据</p>
</li>
<li>异步I/O：应用进程使用aio_read系统调用后立即返回，内核准备完数据后向应用进程发送信号</li>
</ul>
<blockquote>
<p>和信号驱动 I/O 的区别在于，异步 I/O 的信号是通知应用进程 I/O 完成，而信号驱动 I/O 的信号是通知应用进程可以开始 I/O。</p>
</blockquote>
<ul>
<li><p>同步IO（前4个）和异步IO区别：同步IO应用进程在调用 recvfrom 操作时会阻塞，</p>
</li>
<li><p>4个同步IO的区别主要在于执行recvfrom之前的第一阶段不一样</p>
<p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/image-20240601222244744.png" alt="image-20240601222244744" style="zoom:50%;"></p>
</li>
<li><p>select/poll/epoll</p>
<ul>
<li>select：将socket放到一个文件描述符集合（固定长度1024的 BitsMap）。需要2次遍历文件描述符集合，2次拷贝文件描述符集合</li>
<li><p>poll：bitsMap变为了链表</p>
</li>
<li><p>epoll：</p>
<ul>
<li><p>文件描述符使用红黑树O(logn),只在内核维护，减少了很多的遍历和复制</p>
</li>
<li><p>使用事件驱动机制，内核维护了一个链表记录就绪事件，当有socket事件发生的时候，通过回调函数内核将其加入到列表中，当用户调用 <code>epoll_wait()</code> 函数时，只会返回有事件发生的文件描述符的个数（<strong>但是还是会拷贝</strong>），不需要像select/poll那样轮询整个socket集合</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="5-NIO"><a href="#5-NIO" class="headerlink" title="5 NIO"></a>5 NIO</h3><ul>
<li>特点：非阻塞；面向块传输，普通IO是面向流</li>
<li><p>BIO即阻塞式IO，需要一个服务线程监听一个用户线程，使用多线程技术来实现对不用用户的“异步”，对服务器资源消耗大（线程多了之后CPU切换线程开销大），且利用率不高（阻塞等待的时候客户端不能作别的）。</p>
</li>
<li><p>Java NIO：和标准IO不同的是，NIO把IO抽象成了块(一个byte[])，一次可以读取多个字节</p>
</li>
<li>几个要素<ul>
<li>通道Channel：类似于流，但是是双向的。有FileChannel、DatagramChannel、SocketChannel等</li>
<li>缓冲区Buffer：本质是一个数组，所有数据要先放到buffer中才能传输。有ByteBuffer、CharBuffer、LongBuffer等<ul>
<li>状态变量：最大容量、当前已读取的字节数、还可以读取的字节数（有点类似于滑动窗口）</li>
</ul>
</li>
<li>选择器Selector：NIO 实现了 IO 多路复用中的 Reactor 模型，一个线程 Thread 使用一个选择器 Selector 通过轮询的方式去监听多个通道 Channel 上的事件，从而让一个线程就可以处理多个事件。</li>
</ul>
</li>
</ul>
<h2 id="五-数据库"><a href="#五-数据库" class="headerlink" title="五 数据库"></a>五 数据库</h2><h3 id="1-概述"><a href="#1-概述" class="headerlink" title="1 概述"></a>1 概述</h3><p><a target="_blank" rel="noopener" href="https://dsf.berkeley.edu/papers/fntdb07-architecture.pdf">https://dsf.berkeley.edu/papers/fntdb07-architecture.pdf</a></p>
<ul>
<li>核心组件<ul>
<li>进程管理器</li>
<li>网络管理器</li>
<li>文件系统管理器</li>
<li>内存管理器</li>
<li>安全管理器</li>
<li>客户端管理器</li>
</ul>
</li>
<li><p>工具</p>
<ul>
<li>备份恢复管理器</li>
<li>查询管理器（解析、重写、优化、执行）</li>
<li>数据管理器（事务）</li>
</ul>
</li>
<li><p>联接运算符</p>
<ul>
<li>合并联接：用于排序的字段比较好</li>
<li>哈希联接：比较消耗内存，因为要用额外内存存储哈希</li>
<li>嵌套循环联接（复杂度O(m*n)）：类似于双循环来匹配查询</li>
</ul>
<blockquote>
<p>实际使用的时候采用动态规划、贪心算法、启发式算法来确定用哪些</p>
</blockquote>
</li>
</ul>
<h3 id="2-关系型数据库—MySQL"><a href="#2-关系型数据库—MySQL" class="headerlink" title="2 关系型数据库—MySQL"></a>2 关系型数据库—MySQL</h3><ul>
<li><p>为什么需要范式？</p>
<p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/image-20240602140006102.png" alt="image-20240602140006102" style="zoom:50%;"></p>
<ul>
<li>冗余数据：学生2</li>
<li>修改异常：修改一个记录中的信息，但是另一个记录的相同信息没有被修改：修改学生2Snam</li>
<li>删除异常：删除一个信息，会丢失其他信息：删除课程1，学生1也不见了</li>
<li>插入异常：插入一个学生，但是如果这个学生没选课，就无法插入</li>
</ul>
</li>
<li><p>三大范式</p>
<ul>
<li>第一范式：属性不可分</li>
<li>第二范式：每个非主属性完全函数依赖于键码<ul>
<li>分解后两个表：Sno-Sname-Sdept-Mname 和 Sno-Cname-Grade</li>
</ul>
</li>
<li>第三范式：非主属性不传递函数依赖于键码（上述关系中Sno -&gt; Sdept -&gt;Mname）<ul>
<li>分解后变为三个表：Sno-Sname-Sdept、Sdept-Mname、Sno-Cname-Grade</li>
</ul>
</li>
</ul>
</li>
<li><p>事务：满足 ACID 特性的一组操作，可以通过Commit提交事务，也可以通过Rollback回滚（通过日志）</p>
<ul>
<li>原子性（Atomicity）：所有操作要么全部提交成功，要么全部失败回滚。</li>
<li>一致性（Consistency）：数据库在事务执行前后都保持一致性状态</li>
<li>隔离性（Isolation）：一个事务所做的修改在最终提交以前，对其它事务是不可见的。</li>
<li>持久性（Durability）：一旦事务提交，则其所做的修改将会永远保存到数据库中</li>
</ul>
</li>
<li><p>并发一致性问题：</p>
<ul>
<li>修改丢失：两个事务修改数据，后面的事务修改覆盖了前面的事务（貌似不算?）</li>
<li><strong>脏读</strong>：A修改数据(50-&gt;100)，B读取到新数据后(100)，A回滚数据(50)，此时B读到了脏数据</li>
<li><strong>不可重复读</strong>：B读取数据(50)，A修改数据(100)，B再读(100)前后不一致</li>
<li><strong>幻读</strong>：B读取数据(100行)，A插入一行，B再读取(101行)前后不一致</li>
</ul>
</li>
<li><p>隔离级别：</p>
<ul>
<li>未提交读(READ UNCOMMITTED)</li>
<li>提交读(READ COMMITTED)：解决了脏读</li>
<li>可重复读(REPEATABLE READ)：解决了不可重复读</li>
<li>可串行化(SERIALIZABLE)：解决了幻读</li>
</ul>
</li>
<li><p>锁</p>
<ul>
<li>从粒度上划分：行级锁、表级锁</li>
<li>类型上划分：读写锁(排它锁/写锁/X锁、共享锁/读锁/S 锁)、意向锁(X/S锁要扫描行耗时，所以搞了IS/IX表锁，即意向锁，要获取X/S锁之前必须先获取IX/IS锁)</li>
<li>临键锁Next-Key Locks：<ul>
<li>记录锁Record Locks：锁定一个记录上的索引，如果没有设置索引，InnoDB 会自动在主键上创建隐藏的聚簇索引</li>
<li>间隙锁Gap Locks：锁定索引之间的间隙，但是不包含索引本身</li>
<li>Next-Key Locks就是记录锁和间隙锁的结合</li>
</ul>
</li>
</ul>
</li>
<li><p>MVCC：多版本并发控制</p>
<ul>
<li>是Mysql的InnoDB实现隔离级别的一种方式，实现提交读和可重复读这两种隔离级别。（可串行化需要对所有读取的行都加锁，单纯使用 MVCC 无法实现）</li>
<li>如何解决幻读：MVCC + 间隙锁(Next-Key Locks)</li>
<li>版本号：系统版本号（每开始一个新的事务，系统版本号就会自动递增）、事务版本号（创建/删除）</li>
<li><p>针对可重复读隔离级别的执行：</p>
<ul>
<li>Insert：将当前系统版本号作为数据行快照的创建版本号。</li>
<li>Delete：将当前系统版本号作为数据行快照的删除版本号。</li>
<li>Update：将当前系统版本号作为更新前的数据行快照的删除版本号，并将当前系统版本号作为更新后的数据行快照的创建版本号。（先delete再update）</li>
<li>Select：如果是正在修改的事务T在读取就不管。如果是不修改数据的事务B要读取，B读取的数据行快照的创建版本号必须小于 B的版本号，且删除版本号必须大于 B 的版本号</li>
</ul>
</li>
<li><p>MVCC原理</p>
<ul>
<li><p><strong>4个隐式字段</strong></p>
<ul>
<li>DB_ROW_ID：如果没有主键就会自动创建，并加一个聚餐索引(索引结构和数据一起存放的索引)</li>
<li>DB_TRX_ID：最近修改/插入的事务ID</li>
<li>DB_ROLL_PTR：回滚指针，指向这条记录的上一个版本</li>
<li>DELETED_BIT：记录被更新或删除并不代表真的删除，而是删除flag变了</li>
</ul>
</li>
<li><p><strong>undolog</strong>：只记录insert、update、delete操作</p>
<ul>
<li>Insert undo log，至少记录主键，回滚的时候直接删除就行了</li>
<li>Update undo log，至少要把修改这条记录前的旧值都记录下来</li>
<li>Delete undo log，至少要把这条记录中的内容都记下来</li>
</ul>
</li>
<li><p><strong>read view</strong>：主要是用来做可见性判断的</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>Mysql架构：</p>
<p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/image-20240602145759098.png" alt="image-20240602145759098" style="zoom:67%;"></p>
</li>
<li><p>存储引擎：MyISAM和InnoDB</p>
<ul>
<li>事务：MyISAM不支持事务，后者可以commit和rollback（undo log）</li>
<li>并发：MyISAM 只支持表级锁，而 InnoDB 还支持行级锁</li>
<li>崩溃恢复能力：InnoDB依靠redo log</li>
</ul>
</li>
<li><p>日志</p>
<ul>
<li>binlog</li>
<li>undolog：写的是逻辑上的事务，用于事务回滚</li>
<li>redolog：两阶段提交(保证和binlog的一致性)：先写redolog，再写binlog，最后将redolog设置为commit状态</li>
</ul>
</li>
<li><p>索引——数据结构：</p>
<ul>
<li>hash表：快，但是不支持范围查询</li>
<li>二叉查找树：性能很依赖其平衡性</li>
<li>AVL树(高度差不超过1)：需要频繁地进行旋转操作来保持平衡，且一个节点只存一个数据，磁盘IO性能开销大</li>
<li>红黑树：自平衡二叉查找树，平衡性稍弱（不追求完全的平衡）所以有些查询效率较低(多次IO)，但是增删效率高</li>
<li>B树：所有节点既存放key又存放date</li>
<li><strong>B+树</strong>：多路平衡查找树，更稳定快速。原因：数据存放在叶子节点，保证了其他节点能够存放更多的索引，大大压缩了树的高度，减少磁盘IO次数；且叶子节点之间用双向链表连接</li>
</ul>
</li>
<li><p>索引的优缺点</p>
<ul>
<li><p>优点：加快搜索；唯一索引可以保证唯一性</p>
</li>
<li><p>缺点：创建索引需要时间空间；修改数据需要额外维护索引</p>
</li>
</ul>
</li>
<li><p>索引——分类</p>
<ul>
<li><p>主键索引：加速查询 + 列值唯一（不可以有 NULL）+ 表中只有一个</p>
<ul>
<li>除了这个其他的索引都是二级索引，二级索引数据位置存储的是主键</li>
</ul>
</li>
<li><p>普通索引：加速查询</p>
</li>
<li><p>唯一索引：加速查询 + 列值唯一（可以有 NULL）</p>
</li>
<li><p>覆盖索引：一个索引包含（或者说覆盖）所有需要查询的字段的值</p>
</li>
<li><p>联合索引：多列值组成一个索引，专门用于组合搜索，其效率大于索引合并（最左匹配原则）</p>
<ul>
<li><p>最左匹配原则：如果建立了(a,b,c)索引，查表的时候需要包含 a 或者 ab 或者abc，顺序无所谓，优化器会自动优化</p>
<ul>
<li>如果是(a,c)也会走索引，只不过只会走a索引</li>
</ul>
</li>
<li><p>索引下推：通过联合索引对索引进行过滤，减少回表的次数（ 5.6版本）</p>
<figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span>  <span class="keyword">from</span> t_user <span class="keyword">where</span> name <span class="keyword">like</span> <span class="string">'l%'</span> <span class="keyword">and</span> age <span class="operator">=</span> <span class="number">17</span>; # 索引是(name, age)</span><br><span class="line"><span class="comment">-- 第一步：取name 比如得到 li lisi lisa ll 四个</span></span><br><span class="line"><span class="comment">-- 第二步：在这四个中取 age = 17的 得到li，对应id为123</span></span><br><span class="line"><span class="comment">-- 第三步：回表去找id=123的数据</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 如果没有开启索引下推，会回表4次</span></span><br></pre></td></tr></tbody></table></figure>
</li>
</ul>
</li>
<li><p>全文索引：对文本的内容进行分词，一般不会使用，效率较低，通常使用搜索引擎如 ElasticSearch 代替</p>
</li>
</ul>
</li>
<li><p>Mysql性能优化</p>
<ul>
<li>优化数据访问：<ul>
<li>减少请求数据量：列用select，行用limit，使用缓存</li>
<li>减少服务端扫描的行数：索引来覆盖查询</li>
</ul>
</li>
<li>重构查询方式：<ul>
<li>切分大查询，防止锁住很多的数据</li>
<li>分解大查询，分解为单表查询，在业务逻辑中关联</li>
</ul>
</li>
</ul>
</li>
<li><p>Mysql分库分表：垂直/水平</p>
<ul>
<li>Sharding策略(水平)：哈希取模、范围切分、映射表</li>
<li>Sharding策略的问题及解决<ul>
<li>事务：使用分布式事务解决</li>
<li>链接：JOIN变为多个单表查询，在业务代码中链接</li>
<li>ID唯一性：全局唯一ID/每个分片指定ID范围/分布式ID生成器（Snowflake 算法）</li>
</ul>
</li>
</ul>
</li>
<li><p>Mysql主从复制和读写分离</p>
<ul>
<li>binlog线程：负责将主服务器上的数据更改写入二进制日志中。</li>
<li>I/O线程：负责从主服务器上读取二进制日志，并写入从服务器的中继日志中。</li>
<li>SQL线程：负责读取中继日志并重放其中的 SQL 语句。</li>
</ul>
</li>
<li><p>SQL执行过程</p>
<ul>
<li>java业务端的数据库连接池：Druid、C3P0、DBCP。数据库也有类似的池子</li>
<li>查询缓存池</li>
<li>分析器</li>
<li>查询优化器：选择查询成本最小的索引<ul>
<li>IO成本：即从磁盘把数据加载到内存的成本</li>
<li>CPU成本：与行数有关</li>
</ul>
</li>
<li>执行器：调用存储引擎的接口完成执行</li>
<li>存储引擎：InnoDB</li>
</ul>
</li>
<li><p>慢查询问题</p>
<ul>
<li>定位：开启慢查询：<code>slow_query_log = ON</code>、<code>slow_query_log</code>为时间</li>
<li>分析：explain命令：<code>EXPLAIN SELECT * FROM t1</code></li>
<li>优化：<ul>
<li>不使用子查询</li>
<li>读取适当的记录，limit M, N</li>
<li>分组统计禁止排序</li>
<li>联表放到业务代码</li>
<li>varchar字段建立索引指定索引长度</li>
<li>避免索引失效（最左匹配原则）</li>
<li>左模糊查询匹配不了索引</li>
<li>回表的性能评估</li>
</ul>
</li>
</ul>
</li>
<li><p>索引实验 2838426行数据</p>
<p>是否使用索引是由查询优化器决定</p>
</li>
</ul>
<figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">-- EXPLAIN SELECT from_date, salary from salaries WHERE salary &gt; 50000; </span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- SELECT salary from salaries WHERE salary &gt; 50000; # &gt; 时间: 1.351s 索引前</span></span><br><span class="line"><span class="comment">-- SELECT from_date, salary from salaries WHERE salary &gt; 50000; # 时间: 1.407s 索引前</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># salary加普通索引</span><br><span class="line"><span class="comment">-- ALTER TABLE `salaries` ADD INDEX (`salary`) # 时间: 9.011s</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> from_date, salary <span class="keyword">from</span> salaries <span class="keyword">WHERE</span> salary <span class="operator">&gt;</span> <span class="number">50000</span>; # 时间: <span class="number">1.082</span>s 索引后</span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> from_date, salary <span class="keyword">from</span> salaries <span class="keyword">WHERE</span> salary <span class="operator">&gt;</span> <span class="number">50000</span>; #  发生了回表:extra列中有<span class="keyword">Using</span> <span class="keyword">where</span> 和 <span class="keyword">Using</span> index</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> salary <span class="keyword">from</span> salaries <span class="keyword">WHERE</span> salary <span class="operator">&gt;</span> <span class="number">50000</span>; # <span class="operator">&gt;</span> 时间: <span class="number">0.993</span>s 索引后</span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> from_date, salary <span class="keyword">from</span> salaries <span class="keyword">WHERE</span> salary <span class="operator">&gt;</span> <span class="number">50000</span>; #  发生了回表:extra列中有<span class="keyword">Using</span> <span class="keyword">where</span> 和 <span class="keyword">Using</span> index</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="operator">-</span> <span class="keyword">Using</span> <span class="keyword">where</span></span><br><span class="line">	表示查询需要通过索引回表查询数据。</span><br><span class="line"><span class="operator">-</span> <span class="keyword">Using</span> index</span><br><span class="line">	表示查询需要通过索引，索引就可以满足所需数据。</span><br><span class="line"><span class="operator">-</span> <span class="keyword">Using</span> filesort</span><br><span class="line">	表示查询出来的结果需要额外排序，数据量小在内存，大的话在磁盘，因此有<span class="keyword">Using</span> filesort建议优化。</span><br><span class="line"><span class="operator">-</span> <span class="keyword">Using</span> temprorary</span><br><span class="line">	查询使用到了临时表，一般出现于去重、分组等操作。</span><br></pre></td></tr></tbody></table></figure>
<h3 id="3-NoSQL—Redis"><a href="#3-NoSQL—Redis" class="headerlink" title="3 NoSQL—Redis"></a>3 NoSQL—Redis</h3><ul>
<li><p>redis：Remote Dictionary Server</p>
</li>
<li><p>特点：</p>
<ul>
<li>读写性能优异</li>
<li>数据类型丰富</li>
<li>原子性：redis所有操作都是原子性的，同时支持几个操作全合并后的原子性执行</li>
<li>持久化：RDB，AOF持久化方式</li>
<li>发布/订阅模式</li>
<li>分布式：redis cluster</li>
</ul>
</li>
<li><p>使用场景：</p>
<ul>
<li>热点数据缓存</li>
<li>限时业务</li>
<li>计数器相关（incrby命令可以实现原子性的递增）</li>
<li>分布式锁：setnx</li>
<li>延时操作（一般用mq）</li>
<li>排行榜（Zset）</li>
<li>点赞、好友等相互关系的存储（集合命令求交并差集）</li>
<li>队列</li>
</ul>
</li>
<li><p>redis三种高效缓存读写策略</p>
<ul>
<li><p>旁路缓存（常用）</p>
<ul>
<li><p>写：先写数据库再删缓存</p>
</li>
<li><p>读：先读缓存：未命中再读数据库，随后写入缓存再返回</p>
</li>
</ul>
</li>
<li><p>读写穿透</p>
<ul>
<li><p>写：先读缓存：未命中则更新数据库，命中则更新缓存，利用cache服务同步更新数据库</p>
</li>
<li><p>读：先读缓存：未命中再读数据库，随后写入缓存再返回</p>
</li>
</ul>
</li>
<li><p>异步缓存写入</p>
<ul>
<li>写：只更新缓存，异步批量更新数据库</li>
</ul>
</li>
</ul>
</li>
<li><p>3.1 数据类型</p>
<p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/image-20240623194222947.png" alt="image-20240623194222947" style="zoom: 50%;"></p>
<ul>
<li><p>基本数据类型</p>
<ul>
<li>String</li>
<li>List</li>
<li>Set</li>
<li>Zset</li>
<li>Hash</li>
</ul>
</li>
<li><p>特殊数据类型</p>
<ul>
<li>HyperLogLogs（基数统计）：用来算两个set中的不重复元素数量(会有一定的误差量)，用于网站的注册IP数，每日IP数等统计</li>
<li>Bitmap （位存储）：用于统计用户活跃度等（0，1）</li>
<li>geospatial (地理位置)</li>
<li><p>redis-stream：redis5.0新增的数据结构，是redis对消息队列的完善</p>
<ul>
<li><p>redis实现消息队列</p>
<ul>
<li>发布/订阅模式，缺点是无法持久化，如果网络断开、redis宕机消息会丢失</li>
<li>基于List LPUSH+BRPOP 或者 基于Sorted-Set的实现，缺点是不支持多播、分组广播</li>
</ul>
</li>
<li><p>针对上述不足提出了stream结构</p>
</li>
<li><p>key：唯一的索引，首次使用xadd时自动创建</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">XADD：添加消息</span><br><span class="line">XTRIM：修剪消息，限制长度</span><br><span class="line">XDEL：删除消息</span><br><span class="line">XLEN：获取流长度</span><br><span class="line">XRANGE：获取消息列表</span><br><span class="line">XREVRANGE：反向获取，id由大到小</span><br><span class="line">XREAD：以阻塞/非阻塞获取消息列表</span><br></pre></td></tr></tbody></table></figure>
</li>
</ul>
</li>
</ul>
</li>
<li><p>操作</p>
<figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># string</span></span><br><span class="line"><span class="built_in">set</span> counter 2</span><br><span class="line">incr/decr counter <span class="comment"># +/- 1</span></span><br><span class="line">incrby/decrby counter 100 <span class="comment"># 加/减100</span></span><br><span class="line"><span class="comment"># List</span></span><br><span class="line">增:rpush, lpush ,linsert </span><br><span class="line">查:lrange,lindex,llen </span><br><span class="line">删:lpop,rpop,ltrim,ltrim </span><br><span class="line">阻塞操作:blpop,brpop</span><br><span class="line"><span class="comment"># Set</span></span><br><span class="line">增：sadd myset hao hao1 xiaohao hao</span><br><span class="line">删：srem key member1 [member2]</span><br><span class="line">查：smembers myset(返回成员) scard myset(返回数量)</span><br><span class="line"><span class="comment"># Hash</span></span><br><span class="line">增：hset myHash sub-key1 value1</span><br><span class="line">查：hget myHash sub-key1</span><br><span class="line">删：hdel myHash sub-key1</span><br><span class="line"><span class="comment"># Zset</span></span><br><span class="line">增：zadd myscoreset 100 hao 90 xiaohao</span><br><span class="line">查：zscore myscoreset hao <span class="comment"># 100 </span></span><br><span class="line">   zrange myscoreset 0 10 WITHSCORES <span class="comment"># hao xiaohao</span></span><br><span class="line">删：zrem myscoreset hao</span><br><span class="line"><span class="comment"># HyperLogLogs</span></span><br><span class="line">pfadd key1 a b c</span><br><span class="line">pfadd key2 c d e</span><br><span class="line">pfmerge key3 key1 key2 <span class="comment"># 合并key1 key2</span></span><br><span class="line">pfcount key3 <span class="comment"># 5</span></span><br><span class="line"><span class="comment"># Bitmap</span></span><br><span class="line">setbit key sub-key1 0</span><br><span class="line">setbit key sub-key2 1</span><br><span class="line">getbit key sub-key1</span><br><span class="line">bitcount key <span class="comment"># 1</span></span><br></pre></td></tr></tbody></table></figure>
</li>
</ul>
</li>
<li><p>3.2 redis底层数据结构</p>
<ul>
<li><p>SDS 简单动态字符串：redis是C语言写的，但是其字符串对象不是，是SDS，分为头部、数据和结尾标识\0（C语言是以空字符结尾）</p>
<blockquote>
<p>为什么设计SDS？O(1)获取长度；避免内存溢出；空间预分配</p>
</blockquote>
<p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/image-20240623210112381.png" alt="image-20240623210112381" style="zoom:50%;"></p>
<ul>
<li>特点：字符长度len在头部，O(1)时间就可以获取，也杜绝了缓存区溢出</li>
</ul>
</li>
<li><p>ZipList 压缩列表</p>
<p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/image-20240623210707073.png" alt="image-20240623210707073" style="zoom:50%;"></p>
<p>​    </p>
<ul>
<li>从左到右含义：整个ZipList所占内存字节数、最后一个entry的偏移量(以快速完成pop)、entry总量、列表内部数据、终止标识</li>
<li>为什么ZipList省内存：不同的entry存储空间不同(一般的list是以最大的entry大小为单位存储)，这样一来如何遍历？增加了一个prelen字段记录上一个entry的长度</li>
<li>缺点：因为每个entry都没有预留空间，所以修改节点导致容量变大时最坏会导致所有entry重新计算内存O(N)</li>
</ul>
</li>
<li><p>QuickList 快表：以ZipList为节点的双端链表</p>
</li>
<li><p>HashTable 字典/哈希表</p>
<ul>
<li>哈希冲突怎么解决：链地址法</li>
</ul>
</li>
<li><p>IntSet 整数集</p>
<p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/image-20240623211639543.png" alt="image-20240623211639543" style="zoom:50%;"></p>
<ul>
<li>int16 or int32：优先int16，当插入一个int32时，所有的修改为int32(删除最后一个int32的时候不会变回int16，节省开支)</li>
</ul>
</li>
<li><p>ZSkipList 跳表：只在ZSet中使用，log(N)的增删查</p>
<p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/image-20240623212155416.png" alt="image-20240623212155416" style="zoom:50%;"></p>
<ul>
<li>缺点是存储空间大</li>
<li>with 平衡树(AVL、红黑树)：范围查找平衡树复杂，且增删可能会触发自平衡</li>
<li>with B+树：B+的核心是减少IO过程快速定位到索引，不是redis的关注方式</li>
</ul>
</li>
</ul>
</li>
<li><p>3.3 redis持久化</p>
<ul>
<li>RDB(Redis DataBase )：快照<ul>
<li>触发方式：<ul>
<li>手动触发：<code>save</code>和<code>bgsave</code>，前者会阻塞主进程，后者fork一个子进程</li>
<li>自动触发：redis.conf中配置<code>save m n</code>，m秒有n次修改会触发；主从复制时会触发；执行debug reload命令重新加载redis时；执行shutdown命令时，如果没有开启AOF持久化会触发</li>
</ul>
</li>
<li>如何保持数据一致性？（进行RDB的时候发送了数据的写）<ul>
<li>Copy-on-Write，复制一个副本来写</li>
</ul>
</li>
<li>优劣：redis加载RDB速度快，文件体积小；无法做到秒级持久化，每次bgsave都要fork进程开销大，二进制文件难读</li>
</ul>
</li>
<li>AOF<ul>
<li>写后日志，先写内存后写日志。（mysql就是写前）<ul>
<li>好处是：避免了额外的检查开销(写进来的日志都是成功执行的)；不会阻塞当前的写操作</li>
<li>风险是：写完然后还没写日志发生宕机丢失数据；主线程写磁盘压力大，导致写盘慢，阻塞后续操作</li>
</ul>
</li>
<li>实现：<ul>
<li>命令追加(append)：开启AOF后，将被执行写命令追加到服务器aof_buf缓冲区</li>
<li>文件写入(write)：分为同步写回、每秒写回、操作系统控制的写回</li>
<li>和文件同步(sync)</li>
</ul>
</li>
<li>AOF重写：优化一些冗余的AOF操作，减少AOF文件的大小。<ul>
<li>后台fork一个bgrewriteaof进程来进行，数据是写时复制，fork子进程时会复制父进程的页表(类似于指针)</li>
<li>什么时候会阻塞主进程：fork子进程拷贝页表；主进程有bigkey写入操作系统会创建页面的副本，并拷贝原有的数据；子进程重写日志完成后，主进程追加aof重写缓冲区时可能会对主线程阻塞</li>
</ul>
</li>
</ul>
</li>
<li>AOF和RDB混用：redis4.0推出<ul>
<li>内存快照以一定的频率执行，在两次快照之间，使用 AOF 日志记录这期间的所有命令操作。</li>
<li>避免了AOF文件过大</li>
</ul>
</li>
<li>redis启动：<ul>
<li>判断有无AOF？有则加载AOF启动</li>
<li>判断有无RDB？有则加载RDB启动</li>
<li>都没有就直接启动</li>
</ul>
</li>
</ul>
</li>
<li><p>3.4 redis事件机制</p>
<ul>
<li>文件事件：用于处理 Redis 服务器和客户端之间的网络IO（基于IO多路复用）<ul>
<li>redis单线程：指的是网络IO和键值对读取是由一个线程完成，但是其他的(持久化、异步删除、集群数据同步等是fork的进程完成)</li>
<li>文件事件是对套接字操作的抽象，每当一个套接字准备好执行 <code>accept</code>、<code>read</code>、<code>write</code>和 <code>close</code> 等操作时，就会产生一个文件事件</li>
</ul>
</li>
<li>时间事件：redis服务中的一些定时操作<ul>
<li>定时事件、周期事件</li>
</ul>
</li>
</ul>
</li>
<li><p>3.5 redis事务</p>
<ul>
<li><p>本质是一组命令的集合</p>
</li>
<li><p>使用</p>
<figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">MULTI：开启事务</span><br><span class="line">EXEC：执行事务</span><br><span class="line">DISCARD：取消事务</span><br><span class="line">WATCH：监视一个或多个key</span><br><span class="line">UNWATCH：取消监视</span><br><span class="line"></span><br><span class="line"><span class="comment"># 例子</span></span><br><span class="line"><span class="built_in">set</span> k1 v1</span><br><span class="line"><span class="built_in">set</span> k2 v2</span><br><span class="line">MULTI</span><br><span class="line"><span class="built_in">set</span> k1 12</span><br><span class="line"><span class="built_in">set</span> k2 24</span><br><span class="line">EXEC</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>lua脚本：Redis可以保证脚本内的命令一次性、按顺序地执行，其同时也不提供事务运行错误的回滚，执行过程中如果部分命令运行错误，剩下的命令还是会继续运行完</p>
</li>
</ul>
</li>
<li><p>3.6 redis高可用</p>
<ul>
<li><p>主从：故障恢复、负载均衡、高可用</p>
<ul>
<li>读写分离：主库读写，从库读</li>
<li>全量同步：主要依靠RDB文件</li>
<li>增量同步：slave提交自己的offset到master，master获取repl_baklog中从offset之后的命令给slave</li>
</ul>
</li>
<li><p>哨兵机制：监控、自动故障转移、通知</p>
<ul>
<li>哨兵如何监控主从集群：哨兵向主库发送info，主库返回所有slave列表，从而可以与从库通信</li>
<li>哨兵集群：基于redis的 pub/sub 机制来互相获取IP的端口进行通信</li>
<li>哨兵如何判断主库下线？主观下线(任何一个哨兵判断)、客观下线(哨兵集群判断)</li>
<li>哨兵集群的选举：raft算法：拿到半数赞成，拿到的赞成票大于配置的quorum 值</li>
<li>哨兵leader完成主从切换：主库客观下线后，过滤掉不健康的从库，选择优先级最大的，然后向别的从库发送消息新的主库</li>
</ul>
</li>
<li><p>redis cluster：弥补主从和哨兵的不足：写能力和存储能力依赖于主库的问题</p>
<ul>
<li><p>哈希槽(Hash Slot)：有16384(即2的14次方）个哈希槽，每个key通过对16384取模后来决定放哪里，cluster每个节点负责一部分hash槽(只有master才可以占据槽)</p>
<blockquote>
<p>普通的哈希算法的缺陷：如果节点增加或减少，之前的缓存就失效了需要重新计算存储位置(即重新set)，容易引发雪崩</p>
<p>一致性哈希算法：普通哈希算法是对服务器数量取模，一致性哈希算法是对 2^32 取模(形成一个哈希环)，对服务器ip或者其他关键字段进行hash后确定其在环上的位置，然后插入新数据的时候计算hash后对2^32 取模得到其在哈希环上的位置，并顺时针找，找到的第一个服务器就是其存储的服务器</p>
<p>为什么不用一致性哈希算法？增删节点可能会带来雪崩(会对相邻的节点产生影响)、也可能会出现数据倾斜的状况</p>
<p>为什么是16384？为了发送槽的全量状态，用bitmap发送，16384只需要2k的空间(16384 / 8 / 1024 = 2k)</p>
</blockquote>
</li>
</ul>
</li>
<li><p>缓存问题</p>
<ul>
<li><p>一致性问题：最佳实践：先写DB再删缓存</p>
<ul>
<li><p><a target="_blank" rel="noopener" href="https://itwanger.gitee.io/tobebetterjavaer/#/docs/mysql/redis-shuju-yizhixing">https://itwanger.gitee.io/tobebetterjavaer/#/docs/mysql/redis-shuju-yizhixing</a></p>
<p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/image-20240311214614711.png" alt="image-20240311214614711" style="zoom:67%;"></p>
</li>
</ul>
</li>
<li><p>缓存击穿：缓存失效后大量请求打在DB上（同一个key）</p>
<ul>
<li>热点数据不过期；加互斥锁；接口限流；熔断降级</li>
</ul>
</li>
<li><p>缓存穿透：频繁访问一个DB和缓存都不存在的key</p>
<ul>
<li>增加入口校验；DB中未取到可以设置到缓存中为null(有效时间短一点)；布隆过滤器</li>
</ul>
<blockquote>
<p>布隆过滤器</p>
<p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/image-20240629162249949.png" style="zoom:50%;"></p>
</blockquote>
</li>
<li><p>缓存雪崩：大量数据过期，过多请求打在DB上</p>
<ul>
<li>缓存过期时间随机；热点数据部署在不同缓存数据库中；设置热点数据不过期</li>
</ul>
</li>
</ul>
</li>
<li><p>缓存淘汰策略：不淘汰、设置过期时间、LRU</p>
</li>
</ul>
</li>
<li><p>3.7 解决方案——大value、多key合并方案</p>
<ul>
<li><p>单key存储的value大</p>
<ul>
<li><p>如果是每次都整存整取：可以尝试将对象拆分为几个kv，用multiGet获取值，这样做的意义在于分拆单次操作压力，将操作压力平摊到多个redis实例中，降低对单个redis的IO影响</p>
</li>
<li><p>如果是每次只读取部分数据：可以将这个存储在一个hash中，每个field代表一个具体的属性</p>
</li>
</ul>
</li>
<li><p>hash、set、zset、list存储过多的元素：</p>
<ul>
<li>分拆，用取模的方式（比如固定一个桶的数量）确定key，然后将field放在计算出的key中</li>
</ul>
</li>
<li>一个集群存储了上亿的key<ul>
<li>带来的问题：key占存储空间大；集群模式中服务端需要建立slot2key的映射，这些指针也会占用大量空间</li>
<li>key如果有很强的关联关系：就可以放在hash中</li>
<li>key如果没有很强的关联关系：还是放在hash中，但是key是由桶的数量取模来计算得到的</li>
</ul>
</li>
<li>大Bitmap或者布隆过滤器拆分</li>
</ul>
</li>
<li><p>美团squirrel：基于redis</p>
<ul>
<li><p>如何保证数据可靠性</p>
<ul>
<li>多副本存储策略：同一份数据的多副本存储，保证一个副本宕机的情况下其他副本依旧有全量数据</li>
<li>多机房部署容灾策略：将多个副本部署在不同的机房中，避免机房掉电以及断网带来的数据丢失</li>
<li>持久化</li>
</ul>
</li>
<li><p>主从一致：弱一致性，为了保证高性能</p>
</li>
</ul>
</li>
</ul>
<h3 id="4-NoSQL—ES"><a href="#4-NoSQL—ES" class="headerlink" title="4 NoSQL—ES"></a>4 NoSQL—ES</h3><ul>
<li><p>一般语法</p>
<figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 一般索引查询</span></span><br><span class="line">GET /bank/_search</span><br><span class="line">{</span><br><span class="line">  <span class="string">"query"</span>: { </span><br><span class="line">    <span class="string">"match_all"</span>: {</span><br><span class="line">    } </span><br><span class="line">  },</span><br><span class="line">  <span class="string">"sort"</span>: [</span><br><span class="line">    { </span><br><span class="line">      <span class="string">"account_number"</span>: <span class="string">"asc"</span> </span><br><span class="line">    }</span><br><span class="line">  ],</span><br><span class="line">  <span class="string">"from"</span>: 10, </span><br><span class="line">  <span class="string">"size"</span>: 10</span><br><span class="line">} </span><br><span class="line"></span><br><span class="line"><span class="comment"># 特定字段查询：match_all就改为"match": { "address": "mill lane" } 意思为address中包含mill或者lane</span></span><br><span class="line"><span class="comment"># 							"match_phrase": { "address": "mill lane" } address包含mill lane</span></span><br><span class="line"><span class="comment"># 条件查询：</span></span><br><span class="line"><span class="string">"query"</span>: {</span><br><span class="line">  <span class="string">"bool"</span>: {</span><br><span class="line">    <span class="string">"must"</span>: [</span><br><span class="line">      { <span class="string">"match"</span>: { <span class="string">"age"</span>: <span class="string">"40"</span> } }</span><br><span class="line">    ],</span><br><span class="line">    <span class="string">"must_not"</span>: [</span><br><span class="line">      { <span class="string">"match"</span>: { <span class="string">"state"</span>: <span class="string">"ID"</span> } }</span><br><span class="line">    ]</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>聚合查询，类似于mysql的group by</p>
<figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">{</span><br><span class="line">  <span class="string">"size"</span>: 0, <span class="comment"># 返回的文档数为0</span></span><br><span class="line">  <span class="string">"aggs"</span>: { <span class="comment"># 标识聚合查询</span></span><br><span class="line">    <span class="string">"group_by_state"</span>: { <span class="comment"># 自定义名称，用于标识聚合查询的结果</span></span><br><span class="line">      <span class="string">"terms"</span>: { <span class="comment"># 定义了一个聚合</span></span><br><span class="line">        <span class="string">"field"</span>: <span class="string">"state.keyword"</span> <span class="comment"># 根据state进行分组</span></span><br><span class="line">      }</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line">ps: 字符串类型有text和keyword，后者不会分词</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>基本概念</p>
<ul>
<li>文档：一条完整的数据，包括索引、名称等，以json方式存储</li>
<li>字段：文档中的具体字段，类似于表格的列</li>
<li>索引：就是相同类型的文档的集合，类似于表。eg：用户的索引、商品的索引、订单的索引…</li>
<li>映射(mapping)：索引中字段的约束信息，类似于表的结构约束。</li>
</ul>
</li>
<li><p>倒排索引</p>
</li>
</ul>
<h2 id="六-计算机网络"><a href="#六-计算机网络" class="headerlink" title="六 计算机网络"></a>六 计算机网络</h2><h3 id="6-1-base"><a href="#6-1-base" class="headerlink" title="6.1 base"></a>6.1 base</h3><ul>
<li><p>网络模型</p>
<ul>
<li>应用层：HTTP、websocket、FTP、Telnet、DNS、SMTP等协议（传输单位是消息或报文message）</li>
<li>传输层：TCP(面向字节流)、UDP（面向报文，传输单位是段segment）</li>
<li>网络层：IP(寻址和路由)（传输单位是包packet）</li>
<li>网络接口层：ARP协议（传输单位是数据帧frame）</li>
</ul>
<p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/image-20240707162501116.png" alt="image-20240707162501116" style="zoom: 33%;"></p>
</li>
<li><p>从键入网址到网页显示，发生了什么</p>
<ul>
<li><p>解析url</p>
<p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/image-20240707162735960.png" alt="image-20240707162735960" style="zoom: 67%;"></p>
</li>
<li><p>生成http请求信息，<strong>Http报文</strong></p>
<p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/image-20240428104302925.png" alt="image-20240428104302925" style="zoom:67%;"></p>
</li>
<li><p>查询服务器域名对应的 IP 地址（DNS）</p>
</li>
<li>TCP建立可靠传输，如果Http消息过大会切分数据分块发送，组装好<strong>TCP头部</strong>交给下一层</li>
<li>根据IP协议，生成<strong>IP头部</strong>组装后交给下一层</li>
<li>根据ARP协议，获取到两点MAC地址，组装<strong>MAC头部</strong></li>
<li>通过网卡将包数据转为电信号，通过网线发送</li>
<li>交换机基于mac地址进行路由发送到路由器（之后mac头部就没用了，就会被丢弃）</li>
<li>路由器基于ip发送转发内容</li>
<li>数据包抵达服务端进行数据处理，并发送响应数据，完成数据传输</li>
</ul>
</li>
</ul>
<h3 id="6-2-Http"><a href="#6-2-Http" class="headerlink" title="6.2 Http"></a>6.2 Http</h3><ul>
<li>为什么不直接使用TCP呢？为了防止<strong>粘包</strong>：区分出不同批次的数据包，by header</li>
<li>超文本传输协议，<strong>H</strong>yper<strong>T</strong>ext <strong>T</strong>ransfer <strong>P</strong>rotocol</li>
<li>状态码<ul>
<li>1xx</li>
<li>2xx：成功 200</li>
<li>3xx：重定向，需要客户端重新发送请求</li>
<li>4xx：客户端错误，请求报文有误  400请求报文有误；403服务端禁止访问资源；404请求资源在服务端找不到</li>
<li>5xx：服务端错误 500服务端错误；501请求的功能尚未开放；502通常是网关或者代理时返回；503服务器忙无法处理</li>
</ul>
</li>
<li>http字段<ul>
<li>Host字段：客户端发送请求的时候，用于表示服务端域名</li>
<li>Content-Length：服务端返回响应的时候，用于表明数据长度</li>
<li>Connection：通常用于表示是长连接(<code>Connection: Keep-Alive</code>)<ul>
<li>http/1.1默认长连接，这个字段是为了兼容老版本http</li>
</ul>
</li>
<li>Content-Type：用于告诉客户端，本次数据的格式</li>
<li>Content-Encoding：用于说明数据的压缩方式</li>
<li>Accept-Encoding：用于客户端表示自己可以接收的压缩方式</li>
</ul>
</li>
<li>版本发展<ul>
<li>Http/1.0：无状态</li>
<li>Http/1.1：长连接；body压缩</li>
<li>Http/2.0：多路复用；二进制帧；header压缩；服务器推送（客户端请求1个资源的时候服务端一起发送其他的）</li>
<li>Http/3.0：对udp进行改进，引入quic协议，无需建立连接；</li>
</ul>
</li>
<li>Http和Https：HTTPS 协议需要向 CA（证书权威机构）申请数字证书<ul>
<li>对称加密和非对称加密结合的「混合加密」</li>
<li>Https默认端口是443，http是80</li>
<li>多了一个TLS握手的过程。目的是为了通过非对称加密握手协商或者交换出对称加密密钥</li>
</ul>
</li>
<li><p>如何优化https</p>
<ul>
<li>硬件方面：是计算密集型任务，所以增强CPU，加速TLS过程</li>
<li>软件方面：协议优化升级，linux内核升级</li>
<li>协议方面：优化密钥交换算法</li>
<li>证书优化：</li>
</ul>
</li>
<li><p>为什么有了HTTP还有websocket</p>
<ul>
<li>为了解决服务器向客户端主动推送数据的需求(也可能通过客户端轮询http请求实现)</li>
<li>基于TCP全双工的特性，设计出来的一种新协议，即websocket</li>
<li>为了兼容http使用场景，三次握手建立连接后，如果是普通的http请求则维持原状，反之则在http请求头中增强特殊的header，开始进行websocket握手连接，此后就是websocket了。</li>
</ul>
</li>
</ul>
<h3 id="6-3-TCP"><a href="#6-3-TCP" class="headerlink" title="6.3 TCP"></a>6.3 TCP</h3><ul>
<li><p>抓包工具：Wireshark    </p>
</li>
<li><p>特点：面向连接、可靠、基于字节流。</p>
</li>
<li><p>结构</p>
<p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/image-20240423172112523.png" alt="image-20240423172112523" style="zoom:67%;"></p>
<ul>
<li>序号（sequence number）：标识本报文段所发送数据的第一个字节的序号</li>
<li>确认序列（acknowledgement number）：期望收到对方下一个报文段的第一个数据字节序号，只有ACK为1的时候才生效</li>
<li>数据偏移：TCP报文段数据起始举例TCP报文段起始有多远</li>
<li>6个控制位<ul>
<li>URG：紧急位，=1时可以插队</li>
<li>ACK：确认位，连接后置为1</li>
<li>PSH：推送位，=1时，接收方尽快交付接收应用进程，不再等到缓存填满再向上交付</li>
<li>RST：复位，=1时，表明TCP连接中出现严重差错，必须释放连接再重新建立连接 </li>
<li>SYN：同步位，=1时表明是一个连接请求/连接接收报文</li>
<li>FIN：终止位，=1时候表明此报文发送方数据已发送完，要求释放连接</li>
</ul>
</li>
<li>窗口：发送方发送窗口的大小，用来给接收方来调整接收窗口大小</li>
</ul>
</li>
<li><p>三次握手</p>
<ul>
<li>客户端发送连接请求报文段，无应用层数据<ul>
<li>SYN=1，seq=x，seq是序号</li>
</ul>
</li>
<li>服务端为改TCP连接分配缓存和变量，并给客户端返回确认报文，无应用层数据<ul>
<li>SYN=1，ACK=1，seq=y，ack=x+1，ack是确认序列</li>
</ul>
</li>
<li>客户端为该TCP连接分配缓存和变量，并给客户端发送确认，可以携带数据<ul>
<li>SYN=0，ACK=1，seq=x+1,ack=y+1</li>
</ul>
</li>
</ul>
</li>
<li><p>四次挥手</p>
<p>·1  <img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/image-20240809224708031.png" alt="image-20240809224708031" style="zoom:33%;"></p>
<ul>
<li>主动方发送连接释放报文段。进入状态FIN_WAIT_1<ul>
<li>FIN=1，seq=u</li>
</ul>
</li>
<li>被动方回送一个确认报文段。进入CLOSED_WAIT状态，主动方接收后进入FIN_WAIT_2<ul>
<li>ACK=1，seq=v，ack=u+1</li>
</ul>
</li>
<li>被动方发送完数据，发出连接释放报文段。进入LAST_ACK状态。<ul>
<li>FIN=1，ACK=1，seq=w，ack=u+1</li>
</ul>
</li>
<li>主动方回送一个确认报文段。进入TIME_WAIT状态。再等待时间计时器设置的2MSL（最长报文段寿命）后进入CLOSE。<ul>
<li>ACK=1，seq=u+1，ack=w+1</li>
</ul>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>为什么需要四次挥手？</p>
<ul>
<li>TCP的半关闭造成的</li>
</ul>
<p>为什么中间的ACK和FIN不可以像三次握手那样合为一个报文段呢？</p>
<ul>
<li>socket网络编程中，执行close()方法会触发内核发送FIN报文（用户态调用的close()）,但是如果被动关闭方还有数据要处理，会等数据处理完毕后再调用close()，而ACK报文是系统内核完成，过程很快，所以ACK和FIN不能和为一个包</li>
</ul>
<p>为什么TIME_WAIT是2MSL？</p>
<ul>
<li>保证最后的ACK可以送达到被动关闭方，能够正常关闭</li>
</ul>
</blockquote>
<ul>
<li><p>可靠传输：</p>
<ul>
<li>校验：与UDP一样，增加伪首部</li>
<li>序号：一个报文段第一个字节的序号</li>
<li>确认：累计确认机制</li>
<li>重传：超时重传</li>
</ul>
</li>
<li><p>重传机制：</p>
<ul>
<li><p>超时重传：超时未收到指定的ACK报文就再发送，略大于RTT(一个往返时间)</p>
</li>
<li><p>快速重传：服务A发送seq1~6给服务B，但是seq2丢失，服务A只会收到ACK2，然后就再发送seq2</p>
<blockquote>
<p>A只知道seq2未送达，所以发seq2，是否需要一起发送seq3~6？引入SACK</p>
</blockquote>
</li>
<li><p>SACK：双方开启，在TCP头部加入SACK，可以将已接收的信息发送到发送方，避免少发或者多发</p>
</li>
<li><p>D-SACK(Duplicate )：</p>
</li>
</ul>
</li>
<li><p>滑动窗口：</p>
<ul>
<li>已发送且收到ACK确认</li>
<li>已发送但未收到ACK确认</li>
<li>未发送但大小在接收方处理范围</li>
<li>未发送但总大小超过接收方处理范围</li>
</ul>
</li>
<li><p>流量控制：控制接收方窗口，为了防止接收方爆炸</p>
<ul>
<li>通过设置报文段中的窗口字段来实现动态控制</li>
<li>零窗口问题：发送方收到了接收方的零窗口通知，启动计时器，一段时间后再询问接收方窗口大小(防止接收方窗口变更消息丢失而引发的死锁)</li>
<li>小窗口问题(糊涂窗口综合症)：由于接收方处理数据能力，导致缓冲区的大小越来越小(20,10,5,4,2,1…)，进而发送方可发送的数据量也越来越小，最终造成流量的浪费。解决：设置最小窗口阈值</li>
</ul>
</li>
<li><p>拥塞控制：控制发送方窗口cwnd，为了防止网络环境爆炸</p>
<ul>
<li><p>慢启动：建立连接后，先发送1个单位，接收ack应答后再发送2个单位，接收后再发送4个单位，直到达到慢启动门限，一般是2^16：65535字节</p>
</li>
<li><p>拥塞避免：达到慢启动门限后，指数增长变成线性（收到一个ack增加一个字节）</p>
</li>
<li><p>超时重传：cwdn变为1，再重新慢启动</p>
</li>
<li><p>快恢复</p>
<p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/image-20240714112452253.png" alt="image-20240714112452253" style="zoom:50%;"></p>
</li>
</ul>
</li>
<li><p>TCP的半连接队列(SYN队列)和全连接队列(accept 队列)</p>
<ul>
<li><p>建立握手前，服务端接收到客户端请求后，内核会将连接存储在半连接队列中，并发送SYN+ACK</p>
</li>
<li><p>接收到客户端的第三次握手后，内核会移除SYN队列，创建完全的连接，加入到accept队列中</p>
</li>
<li><p>半连接队列满之后，就无法接收新的TCP连接了（SYN洪泛攻击就是利用这个特性）</p>
<blockquote>
<p>SYN洪泛攻击如何解决？</p>
<p>利用SYN cookie：不保存半连接队列，生成一个序列(cookie)发送给请求连接方，cookie为由源IP、目的IP、源端口、目的端口以及一个服务器密钥组合后生成的hash，请求方第三次的握手需要携带这个序列，然后再由服务端来解析判断是不是同一组请求，如果第三次握手没有携带这个序列，则被判断为是攻击者，不做任何处理，也就避免了半连接队列爆</p>
</blockquote>
</li>
</ul>
</li>
<li><p>如何优化TCP连接？</p>
<ul>
<li><p>三次握手的优化</p>
<ul>
<li>客户端：SYN重传次数</li>
<li>服务端：SYN半连接队列、accept 全连接队列长度、ACK+SYN的重传次数</li>
</ul>
</li>
<li><p>四次挥手的优化</p>
<ul>
<li>主动方：FIN报文重传次数、FIN_WAIT_2状态时间、TIME_WAIT状态上限</li>
<li>被动方：</li>
</ul>
</li>
<li><p>数据传输的优化：主要是针对滑动窗口</p>
<ul>
<li>扩大窗口大小：连接的缓存区（滑动窗口）根据网络传输能力设置</li>
<li>调整发送方缓存区范围</li>
<li>调整接收方缓存区范围</li>
<li>打开缓存区动态调节</li>
<li>调整内存范围</li>
</ul>
</li>
</ul>
</li>
<li><p>怎么理解TCP是面向字节流的传输？（UDP是面向报文）</p>
<ul>
<li>一次消息通过多次发送——粘包问题</li>
<li>解决粘包：固定长度、特殊字符(HTTP)、自定义消息结构体</li>
</ul>
</li>
<li><p>为什么TCP每次建立连接的时候，初始化序列号不一样？</p>
<ul>
<li>防止历史报文被错误接收。四次挥手的时候不是有一个2MSL的时长吗？（如果没有正常的断开，有错误的可能）</li>
<li>随机生成的序列号会冲突吗？是基于时钟计时器递增的，基本不会出现</li>
</ul>
</li>
<li><p>syn包什么时候会被丢弃</p>
<ul>
<li>TCP两个队列满了（半连接SYN队列和全连接accpet队列），造成SYN报文丢弃</li>
</ul>
</li>
<li><p>已建立连接的TCP，客户端突然掉线了，服务端不知道，客户端再上线的时候发起SYN握手，服务器怎么做？</p>
<ul>
<li>客户端的 IP、服务端 IP、目的端口都没变，关键看源端口和上次是否一致？<ul>
<li>一致：但是大概率与服务端的期望SYN不一致，服务端会返回期望的ACK报文，客户端收到后发现也不是期望的报文，于是回RST报文，释放连接</li>
<li>不一致：相当于建立一个新的连接。原来的连接由客户端内核返回一个RST报文，兜底是服务端检测客户端没有活动，释放连接</li>
</ul>
</li>
</ul>
</li>
<li><p>四次挥手的时候如果FIN报文比ACK先到达主动方会发生什么（第三次比第二次快到）</p>
<ul>
<li>在FIN_WAIT_2状态的时候收到了乱序的FIN报文，会被加入到乱序队列中，并不会加入到TIME_WAIT状态，等再次收到数据包的时候（第二次挥手的包），会从乱序队列中找对应的乱序的FIN报文（有FIN标志），则进入TIME_WAIT状态</li>
</ul>
</li>
<li><p>拔掉网线后，之前的TCP连接还在吗</p>
<ul>
<li>拔掉网线后，有数据传输：如果在超时重传阈值之前恢复，则没有影响，反之服务端会断开连接，客户端再次发送的时候，服务端内核就会恢复RST报文</li>
<li>拔掉网线后没有数据传输：没有开启TCP保活机制，则会一直存在，开启的话会探活，超出次数则断开</li>
</ul>
</li>
<li><p>HTTPS中TCP和TLS顺序？</p>
<ul>
<li>先TCP三次握手再TLS</li>
</ul>
</li>
<li><p>TCP协议的缺点</p>
<ul>
<li>升级困难，因为是在内核中的，应用程序无法升级</li>
<li>TCP建立连接延迟：三次握手</li>
<li>TCP存在队头阻塞的情况：如果seq1~5中seq2丢失，内核是无法处理seq3~5的</li>
<li>网络迁移需要重新建立TCP连接：四元组发生了变化（源 IP、源端口、目的 IP、目的端口）</li>
</ul>
</li>
<li><p>如何基于UDP实现可靠传输？<strong>QUIC</strong>协议</p>
</li>
<li><p>UDP和TCP可以使用同样的端口吗？可以，因为在内核中是两个完全独立的软件模块。</p>
</li>
<li><p>半包：发送方发送的数据过大，超过了缓冲区，导致数据接收不完整的问题</p>
</li>
<li>粘包：拆包后进行合并，由于信息不完整导致的信息错乱问题</li>
</ul>
<h3 id="6-4-IP"><a href="#6-4-IP" class="headerlink" title="6.4 IP"></a>6.4 IP</h3><ul>
<li><p>类型</p>
<ul>
<li>A类：      0 +   7位网络号 + 24位主机号</li>
<li>B类：    10 + 14位网络号 + 16位主机号</li>
<li>C类：  110 + 21位网络号 +   8位主机号</li>
<li>D类：1110 + 28位组播地址，多用于多播</li>
<li>E类： 1111 + 预留后用</li>
</ul>
</li>
<li><p>主机号全为0指某个网络，全为1指定某个网络下的所有主机，用于广播</p>
</li>
<li><p>优点：简单明了、选路（基于网络地址）简单（因为可以通过前3位快速判断是ABC类）</p>
</li>
<li><p>缺点：</p>
<ul>
<li>同一网络下没有地址层次</li>
<li>ABC不能很好的与现实匹配，C类地址的主机只有254，B类却有65534</li>
</ul>
</li>
<li><p>无分类地址CIDR：表示形式 <code>a.b.c.d/x</code>，前x位为网络号</p>
</li>
<li><p>子网划分：将主机号部分再分为子网网络号 + 子网主机号</p>
<p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/image-20240715221921171.png" alt="image-20240715221921171" style="zoom:50%;"> </p>
</li>
<li><p>IPv6：128位，每16位作为一组 </p>
</li>
<li><p>NAT技术：IP地址有32位，最多只能 2 ^ 32 = 4294967296 台设备加入互联网，为了解决地址不足的问题，引入NAT</p>
</li>
<li><p>IP协议的相关技术</p>
<ul>
<li><p>DNS 域名解析：越往右层级越高</p>
<ul>
<li>查缓存 ==&gt; 查操作系统本机域名解析文件 <code>hosts</code> ==&gt; 进行DNS域名查询</li>
</ul>
</li>
<li><p>ARP 与 RARP 协议：查询IP地址的下一跳对应的MAC地址，RARP相反</p>
<ul>
<li>主机广播发送ARP请求 ==&gt; 同一链路的所有设备查询如果有就返回ARP响应</li>
</ul>
</li>
<li><p>DHCP 动态获取 IP 地址</p>
<ul>
<li>DHCP 客户端进程监听的是 68 端口号，DHCP 服务端进程监听的是 67 端口号</li>
<li>客户端发起<strong>DHCP发现报文</strong>，但是此时客户端没有IP地址，也不知道DHCP服务器IP地址，就通过广播发送UDP</li>
<li>服务端收到后发送<strong>DHCP 提供报文</strong>，也是广播发送：提供可租约的 IP 地址、子网掩码、默认网关、DNS 服务器以及 IP 地址租用期。</li>
<li>客户端收到一个或多个报文后，选择一个服务端，发送<strong>DHCP 请求报文</strong></li>
<li>服务端 DHCP ACK 报文对 DHCP 请求报文进行响应，应答所要求的参数</li>
</ul>
</li>
<li><p>NAT 网络地址转换：IP 地址 + 端口号一起进行转换</p>
<p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/image-20240715223854138.png" alt="image-20240715223854138" style="zoom:50%;"></p>
<ul>
<li>缺点：<ul>
<li>外部无法主动与NAT内部服务建立连接，因为没有转换记录</li>
<li>转换地址的性能开销</li>
<li>依赖于转换表，如果NAT路由器重启了，所有TCP连接都将会重置</li>
</ul>
</li>
<li>如何解决？<ul>
<li>Ipv6</li>
<li>NAT穿透技术</li>
</ul>
</li>
</ul>
</li>
<li><p>ICMP 互联网控制报文协议：确认 IP 包是否成功送达目标地址、报告发送过程中 IP 包被废弃的原因和改善网络设置等。</p>
<ul>
<li>查询报文（诊断）和差错报文（通知出错原因）</li>
<li>常见差错报文类型<ul>
<li>目标不可达消息 —— 类型 为 <code>3</code></li>
<li>原点抑制消息 —— 类型 <code>4</code></li>
<li>重定向消息 —— 类型 <code>5</code></li>
<li>超时消息 —— 类型 <code>11</code></li>
</ul>
</li>
</ul>
</li>
<li><p>IGMP 因特网组管理协议：管理D类地址，组播</p>
</li>
</ul>
</li>
<li><p>Ping的原理：基于ICMP协议进行</p>
</li>
<li><p>断网了还能ping 127.0.0.1吗？可以</p>
</li>
<li><p>localhost 和 127.0.0.1</p>
<ul>
<li>本质上localhost 是域名，是在本机中的hosts文件中定义的指向127.0.0.1</li>
</ul>
</li>
</ul>
<h2 id="七-操作系统"><a href="#七-操作系统" class="headerlink" title="七 操作系统"></a>七 操作系统</h2><h3 id="7-1-硬件结构"><a href="#7-1-硬件结构" class="headerlink" title="7.1 硬件结构"></a>7.1 硬件结构</h3><ul>
<li><p>内存；CPU；总线；输入、输出设备</p>
</li>
<li><p>存储器的结构：寄存器、CPU Cache(L1,L2,L3)、内存、SSD/HDD 硬盘</p>
<ul>
<li>L1 L2是各核心独有的</li>
</ul>
</li>
<li><p>多核心CPU的缓存一致性(L1 L2)</p>
<ul>
<li>通过写传播和事务的串行化</li>
</ul>
</li>
<li><p>总线嗅探：写传播的实现，通过广播来告诉其他核心数据变化</p>
</li>
<li><p>MESI协议</p>
<ul>
<li><em>Modified</em>，已修改</li>
<li><em>Exclusive</em>，独占</li>
<li><em>Shared</em>，共享</li>
<li><em>Invalidated</em>，已失效</li>
</ul>
</li>
<li><p>CPU如何执行任务的</p>
<ul>
<li>如何读写数据：CPU三级缓存<ul>
<li>伪共享问题：CPU从内存中读取数据是Cache Line 为单位(一组数据)，如果两个核AB读取了空间上连续的变量ab，分别只修改了a、b，但是会造成数据的不一致问题</li>
<li>如何避免：多个线程共享的热点数据，避免这些数据在同一个Cache Line中</li>
</ul>
</li>
<li>如何选择线程：linux内核中，线程和进程都是 <code>task_struct</code> 结构体<ul>
<li>调度算法</li>
</ul>
</li>
</ul>
</li>
<li><p><code>0.1 + 0.2 == 0.3?</code></p>
<ul>
<li><p>负数的二进制：1(符号位，正数是0) +( 正数部分的补码+1)</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-1 : 1 1111111 11111111 11111111</span><br><span class="line">1  : 0 0000000 00000000 00000001 (int类型)</span><br><span class="line">补码: 1 1111111 11111111 11111110</span><br><span class="line">再+1: 1 1111111 11111111 11111111</span><br></pre></td></tr></tbody></table></figure>
</li>
</ul>
</li>
</ul>
<h3 id="7-2-操作系统结构"><a href="#7-2-操作系统结构" class="headerlink" title="7.2 操作系统结构"></a>7.2 操作系统结构</h3><ul>
<li>内核的能力<ul>
<li>管理进程、线程，决定哪个进程、线程使用 CPU，也就是进程调度的能力；</li>
<li>管理内存，决定内存的分配和回收，也就是内存管理的能力；</li>
<li>管理硬件设备，为进程与硬件设备之间提供通信能力，也就是硬件通信能力；</li>
<li>提供系统调用，如果应用程序要运行更高权限运行的服务，那么就需要有系统调用，它是用户程序与操作系统之间的接口。</li>
</ul>
</li>
</ul>
<h3 id="7-3-内存管理"><a href="#7-3-内存管理" class="headerlink" title="7.3 内存管理"></a>7.3 内存管理</h3><ul>
<li><p>虚拟内存：为了让不同的进程同时运行而互不干涉，操作系统提供一种映射，将不同进程的虚拟地址和物理地址映射</p>
<ul>
<li>如果没有虚拟内存，同一个代码多线程运行的时候就会产生物理地址冲突</li>
<li>虚拟内存可以使得<strong>进程对运行内存超过物理内存大小</strong>，因为程序运行符合局部性原理，CPU 访问内存会有很明显的重复访问的倾向性，对于那些没有被经常使用到的内存，我们可以把它换出到物理内存之外，比如硬盘上的 swap 区域。</li>
<li>由于每个进程都有自己的页表，所以每个进程的虚拟内存空间就是相互独立的。进程也没有办法访问其他进程的页表，所以这些页表是私有的，这就<strong>解决了多进程之间地址冲突的问题</strong>。</li>
<li>页表里的页表项中除了物理地址之外，还有一些标记属性的比特，比如控制一个页的读写权限，标记该页是否存在等。在内存访问方面，操作系统提供了<strong>更好的安全性</strong>。</li>
</ul>
</li>
<li><p>如何管理虚拟地址和物理地址之间的关系</p>
<ul>
<li><p>内存分段：带来内存外碎片和内存交换效率低(解决碎片进行swap重分配的过程)的问题</p>
<p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/image-20240717222754454.png" alt="image-20240717222754454" style="zoom:33%;"></p>
</li>
<li><p>内存分页：会出现内存内碎片、对进程来说不太友好</p>
<ul>
<li>换入Swap In和换出Swap Out是指操作系统内存不够时候将页表写到硬盘暂时释放的过程，因为一次只写几页，所以效率较高</li>
</ul>
<p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/image-20240717223025442.png" alt="image-20240717223025442" style="zoom:33%;"></p>
<ul>
<li>带来的问题：页表内存大 ==&gt; 多级页表</li>
</ul>
</li>
<li><p>段页式内存管理：对于进程来说看到的是段表，对物理内存来说看到的是页表</p>
<p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/image-20240717223731697.png" alt="image-20240717223731697" style="zoom:50%;"></p>
</li>
</ul>
</li>
<li><p>操作系统怎么分配内存的？ <code>malloc()</code>：分配的是虚拟内存，如果没有被访问是不会映射到物理内存的，当程序开始读写的时候才分配</p>
</li>
<li><p>内存满了怎么办？当物理内存满了，会发送<strong>缺页中断</strong>，进程切换到内核态</p>
<ul>
<li>后台内存回收：异步的，不阻塞进程</li>
<li>直接内存回收：同步的，会阻塞进程，后台回收更不上的时候触发</li>
<li>触发OOM机制：根据算法kill占用物理内存高的进程</li>
</ul>
</li>
<li><p>回收哪些文件？文件页、匿名页</p>
</li>
<li><p>4GB的物理内存机器申请8GB的内存</p>
<ul>
<li>32位操作系统：无法申请，最多3GB（内核1GB，用户3GB）</li>
<li>64位操作系统：可以，但是如果使用的时候超出了4GB，且没有开启swap机制，会OOM</li>
</ul>
</li>
<li><p>如何避免预读失效和缓存污染的问题？本质是LRU算法</p>
<ul>
<li>Redis的做法是LRU，Mysql和Linux的做法是改进的LRU算法</li>
<li>Linux读取：在文件系统中增加Page Cache页缓存，属于内存里的数据，加快访问速度</li>
<li><p>Mysqld读取：Innodb存储引擎中设计了一个Buffer Pool缓冲池，属于内存里的数据，修改数据直接修改缓冲池，后台再写入磁盘</p>
</li>
<li><p>Linux和Mysql的LRU操作单位都是页</p>
</li>
<li>什么是预读？如果需要磁盘A的0-3kb数据，linux会读取一个页(0-4kb)，为了减少将来的IO次数，会预读3个page，也就是0-16kb都会读取。</li>
<li>什么是预读失效？就是后面预读的数据没有被用到</li>
<li>如何避免预读失效？改进的LRU<ul>
<li>Linux：实现两个LRU链表，活跃LRU、非活跃LRU链表</li>
<li>Mysql：在一个LRU链表中划分为：young 区域 和 old 区域</li>
<li>预读的数据就放在非活跃链表/old区域即可</li>
</ul>
</li>
<li>什么是缓存污染？只访问一次的数据放到链表头部，多了之后就会淘汰热点数据，如果这些数据长时间不被访问就会造成污染，导致下次访问热点数据的时候产生大量的IO</li>
<li>如何解决缓存污染？<ul>
<li>Linux：非活跃链表的数据读取两次才进入活跃LRU头部</li>
<li>Mysql：old区域被访问两次且两次时间间隔在1s以上才会进入young区域</li>
</ul>
</li>
</ul>
</li>
<li><p>深入理解虚拟内存</p>
<ul>
<li><p>划分：</p>
<p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/image-20240718220702762.png" alt="image-20240718220702762" style="zoom:33%;"></p>
<ul>
<li>代码段：用户的代码</li>
<li>数据段：代码中指定的初始值的全局变量和静态变量</li>
<li>BSS段：没有指定初始值的全局变量和静态变量，加载进内存后初始化为0</li>
<li>堆：以上是编译阶段申请的，堆是用于存放运行过程中动态生成的内存</li>
<li>文件映射与匿名映射区：动态链接库中的代码段、数据段、BSS段，以及内存映射区域的文件映射与匿名映射区</li>
<li>栈：程序调用函数过程中使用到的局部方法和函数参数</li>
</ul>
</li>
<li><p>范围</p>
<ul>
<li>32位系统中指针的寻址范围是2^32，所能表达的区域大小就是4GB，其中用户态3GB，内核空间1GB</li>
<li>64位系统中指针的寻址范围是2^64，但是只用了48位来描述空间，也就是256TB，内核、用户各一半</li>
</ul>
</li>
<li><p>内核是如何划分和管理的？</p>
<ul>
<li><p><code>mm_struct</code> 结构体定义上述不同区域的范围，通过task_size 域来划分用户和内核空间</p>
</li>
<li><p>若干个<code>vm_area_struct</code>结构体一一对应了上述的区域</p>
<p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/image-20240718222727080.png" alt="image-20240718222727080" style="zoom: 50%;"></p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="7-4-进程管理"><a href="#7-4-进程管理" class="headerlink" title="7.4 进程管理"></a>7.4 进程管理</h3><ul>
<li><p>进程：代码编译为二进制可执行文件，运行文件后装载进入内存，CPU会执行程序中的命令，运行中的命令就是进程</p>
</li>
<li><p>线程：进程由若干个线程组成，操作系统中执独立运行的最小单位</p>
</li>
<li><p>并发：单个CPU一个时间段执行了多个进程</p>
</li>
<li><p>并行：多个CPU一个时间点执行了多个进程</p>
</li>
<li><p>进程状态：</p>
<p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/image-20240719201817005.png" alt="image-20240719201817005" style="zoom: 50%;"></p>
<ul>
<li>多个进程阻塞的时候，会占用物理内存空间，所以在虚拟内存管理的操作系统中，会把阻塞状态的进程的物理内存换出到磁盘，这个时候进程的状态就变成了<strong>挂起</strong></li>
</ul>
</li>
<li><p>PCB(process control block)：进程控制块，用于描述进程，1对1</p>
<ul>
<li>进程描述信息：进程标识符、用户标识符(进程归属的进程)</li>
<li>进程控制和管理信息：当前进程的状态、进程优先级</li>
<li>资源分配清单：有关内存地址空间或虚拟地址空间的信息</li>
<li>CPU相关信息：CPU中各个寄存器的值，进程被切换的时候需要保存CPU的状态信息</li>
</ul>
</li>
<li><p>多个PCB通过链表的结构把状态相同的进程串在一起，组成各种队列：阻塞队列、就绪队列等</p>
</li>
<li><p>进程的控制</p>
<ul>
<li>创建进程：申请一个空白的PCB，填入相关信息，分配内存资源，并加入到就绪队列中</li>
<li>终止进程（正常结束、异常结束以及外界干预(信号 <code>kill</code> 掉)）：查找PCB、如果处于执行状态，就立即结束、如果有子进程就交给1号进程管理、归还资源给操作系统、从PCB队列删除</li>
<li>阻塞进程：找到PCB、阻塞、插入到阻塞队列中</li>
<li>唤醒进程：找到PCB、设置状态为就绪、插入就绪队列</li>
</ul>
</li>
<li><p>进程的上下文切换：一个进程切换到另一个进程运行</p>
<ul>
<li>CPU 寄存器和程序计数是 CPU 在运行任何任务前，所必须依赖的环境，这些环境就叫做 <strong>CPU 上下文</strong>。</li>
<li>所以就是存储和读取PCB中的CPU相关信息的过程，</li>
</ul>
</li>
<li><p>线程和进程</p>
<ul>
<li>进程是资源（包括内存、打开的文件等）分配的单位，线程是 CPU 调度的单位；</li>
<li>进程拥有一个完整的资源平台，而线程只独享必不可少的资源，如寄存器和栈；</li>
<li>线程同样具有就绪、阻塞、执行三种基本状态，同样具有状态之间的转换关系；</li>
<li>线程能减少并发执行的时间和空间开销；</li>
</ul>
<blockquote>
<p>为什么线程能减少并发执行的时间和空间开销？</p>
<ul>
<li>线程的<strong>创建时间</strong>比进程快，因为进程在创建的过程中，还需要资源管理信息，比如内存管理信息、文件管理信息，而线程在创建的过程中，不会涉及这些资源管理信息，而是共享它们；</li>
<li>线程的<strong>终止时间</strong>比进程快，因为线程释放的资源相比进程少很多；</li>
<li>同一个进程内的线程切换比进程切换快，因为线程具有相同的地址空间（虚拟内存共享），这意味着同一个进程的线程都具有同一个页表，那么在切换的时候<strong>不需要切换页表</strong>。而对于进程之间的切换，切换的时候要把页表给切换掉，而页表的切换过程开销是比较大的；</li>
<li>由于同一进程的各线程间共享内存和文件资源，那么在线程之间数据传递的时候，就<strong>不需要经过内核</strong>了，这就使得线程之间的数据交互效率更高了；</li>
</ul>
</blockquote>
</li>
<li><p>线程的上下文切换和进程的区别</p>
<ul>
<li>如果是不同进程的线程切换，就和切换进程一样</li>
<li>如果是同一进程内的线程切换，只需要切换线程的私有数据、寄存器等不共享的数据，开销会小很多(没了虚拟内存等资源切换)</li>
</ul>
</li>
<li><p>线程的实现：</p>
<ul>
<li>用户线程：在用户空间实现的线程</li>
<li>内核线程：在内核中实现的线程，是由内核管理的线程，多个用户线程对1个内核线程</li>
<li>轻量级线程：在内核中来支持用户线程；</li>
</ul>
</li>
<li><p>用户线程的管理：基于用户态的线程管理库来实现的。线程控制块（Thread Control Block, TCB） 也是在库里面来实现的，</p>
<ul>
<li>对于操作系统而言是看不到这个TCB的，TCB是进程的私有</li>
<li>TCB中跟踪记录了各个线程的状态信息（PC、栈指针、寄存器）</li>
<li>优点：切换由线程管理库实现，不用用户态和内核态切换，速度快；由TCB记录线程信息</li>
<li>缺点：操作系统不参与其调度，如果一个线程发起系统调用而阻塞，那进程所包含的用户线程都不能执行了；</li>
</ul>
</li>
<li><p>内核线程的管理：也是通过TCB</p>
<ul>
<li>内核线程的TCB是操作系统来管理的</li>
<li>优点：如果某个内核线程发起系统调用而被阻塞，并不会影响其他内核线程的运行；</li>
<li>缺点：内核来维护进程和线程的上下文信息，如 PCB 和 TCB；线程的创建、终止和切换都是通过系统调用的方式来进行，开销大</li>
</ul>
</li>
<li><p>进程之间的通信：关键是如何通过内核空间来通信</p>
<p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/image-20240803220346902.png" alt="image-20240803220346902" style="zoom:50%;"></p>
<ul>
<li><p>管道：<code>mkfifo myPipe</code>创建一个管道，本质是内核空间里面的内存（队列），两端分别实现读写</p>
<ul>
<li>如果是父子进程，在fork的时候就会创建管道，并绑定到</li>
<li>如果不是父子进程，则是通过共同父进程例如shell</li>
<li>但是效率低</li>
</ul>
</li>
<li><p>消息队列：本质是保存在内核中的消息链表</p>
<ul>
<li>通信异步但是不适合大数据的传输    </li>
<li>还存在用户态到内核态的数据拷贝开销</li>
</ul>
</li>
<li><p>共享内存</p>
<ul>
<li>解决用户态、内核态的开销，虚拟内存映射到相同的物理内存中即可</li>
<li>带来了写写问题</li>
</ul>
</li>
<li><p>信号量：表示资源的数量 <code>&gt;= 0</code> 表示可以访问</p>
<ul>
<li>用于进程之间的互斥和同步</li>
</ul>
</li>
<li><p>信号：<code>kill -l</code> 查看所有的信号</p>
<ul>
<li>用于异常情况下的工作模式，比如shell中<code>ctrl + C</code> 产生<code>SIGINT</code>信号，表示终止进程</li>
</ul>
</li>
<li><p>socket：用于跨网络与不同主机的进程通信</p>
<ul>
<li><p>系统调用：<code>int socket(int domain, int type, int protocal)</code></p>
</li>
<li><p>简述TCP</p>
<p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/image-20240803223017983.png" alt="image-20240803223017983" style="zoom: 50%;"></p>
<ul>
<li>服务端、客户端初始化socket，得到文件描述符</li>
<li>服务端调用<code>bind</code>，绑定IP和端口</li>
<li>服务端调用<code>listen</code>，进行监听</li>
<li>服务端调用<code>accept</code>，等待客户端连接</li>
<li>客户端调用<code>connet</code>，请求连接</li>
<li>服务端调用<code>accept</code>，返回用于传输<code>socket</code>的文件描述符</li>
<li>客户端调用<code>write</code>写数据，服务端调用<code>read</code>读数据</li>
<li>客户端调用<code>close</code>断开，服务端<code>read</code>的时候就会读到<code>EOF</code>，处理完毕后，服务端调用<code>close</code>，关闭</li>
</ul>
</li>
</ul>
</li>
<li><p>多线程冲突问题</p>
<ul>
<li>锁：加锁、解锁</li>
<li>信号量：P(-1)、V(+1)操作,实现对临界区的互斥访问</li>
</ul>
</li>
<li><p>死锁问题</p>
<ul>
<li>互斥条件：多个线程不能同时使用同一个资源</li>
<li>持有并等待条件：线程在等待资源的同时不会释放自己持有的资源</li>
<li>不可剥夺条件：线程正在使用的资源不可被剥夺</li>
<li><p>循环等待条件：死锁发生时，两个线程获取资源构成了链</p>
</li>
<li><p>从以上四个条件进行破坏</p>
</li>
</ul>
</li>
<li><p>锁分类</p>
<ul>
<li>乐观锁：CAS</li>
<li>悲观锁：互斥锁、自旋锁</li>
</ul>
</li>
<li><p>一个进程可以创建多少线程</p>
<ul>
<li>进程虚拟内存空间的上限（32位3G，64位128T）</li>
<li>系统参数的限制</li>
</ul>
</li>
<li><p>线程崩溃进程也会崩溃吗？不一定，比如线程崩溃不会导致JVM进程崩溃</p>
<ul>
<li>线程崩溃后通过信号（SIGSEGV ）来告诉进程，JVM自定义了自己的信号处理函数，拦截了SIGSEGV 信号</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="7-5-调度算法"><a href="#7-5-调度算法" class="headerlink" title="7.5 调度算法"></a>7.5 调度算法</h3><ul>
<li>进程调度算法<ul>
<li>先到先服务</li>
<li>最短作业时间</li>
<li>高响应比优先调度算法：优先权= (等待时间 + 要求服务时间) / 要求服务时间</li>
<li>时间片轮转调度算法</li>
<li>最高优先级调度算法</li>
<li>多级反馈队列调度算法：时间片+ 优先级<ul>
<li>优先级越高时间片越短，最开始进入优先级最高的队列，没执行完进入下一级队列</li>
</ul>
</li>
</ul>
</li>
<li>内存页面置换算法：当出现缺页异常，需调入新页面而内存已满时，选择被置换的物理页面<ul>
<li>最佳页面置换算法：选择未来最长时间不访问的页面。</li>
<li>先进先出置换算法：选择在内存驻留时间很长的页面进行中置换</li>
<li>最近最久未使用的置换算法（LRU）</li>
<li>时钟页面置换算法</li>
</ul>
</li>
<li>磁盘调度算法：优化磁盘的访问请求顺序<ul>
<li>先来先服务</li>
<li>最短寻道时间优先算法</li>
<li>扫描算法：避免磁头在一个小区域来回扫动</li>
<li>循环扫描算法</li>
<li>LOOK 与 C-LOOK算法</li>
</ul>
</li>
</ul>
<h3 id="7-6-文件系统"><a href="#7-6-文件系统" class="headerlink" title="7.6 文件系统"></a>7.6 文件系统</h3><ul>
<li><p>linux文件数据结构</p>
<ul>
<li>索引节点<em>inode</em>：记录文件的元信息，唯一标识，会被存储于硬盘</li>
<li>目录项<em>dentry</em>：记录文件名、与其他目录项的层级关系，由内核维护，缓存于内存（与inode多对一）</li>
</ul>
</li>
<li><p>文件如何存储在硬盘？</p>
<ul>
<li><p>磁盘最小读取单位是扇区 512B，为提高效率，linux以逻辑块为单位：8个扇区 4KB</p>
<p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/image-20240804120447481.png" alt="image-20240804120447481" style="zoom:50%;"></p>
</li>
</ul>
</li>
<li><p>虚拟文件系统（Virtual File System，VFS）</p>
<ul>
<li>针对文件系统种类繁多(磁盘、内存、网络)，为给用户提供统一的接口，在用户层和文件系统中提供的中间层</li>
</ul>
</li>
<li><p>文件存储</p>
<ul>
<li>连续存储</li>
<li>非连续：链表+索引(指向文件头)</li>
</ul>
</li>
<li><p>空闲空间管理</p>
<ul>
<li><p>空闲表法</p>
</li>
<li><p>空闲链表法</p>
</li>
<li><p>位图（linux使用），每位代表 块</p>
<ul>
<li><p>假设是在一个块中，共可以表示 <code>4 * 1024 * 8 = 2^15</code> 个空闲块，最大的空间是 <code>2^15 * 4 * 1024 = 2^27</code> 个 byte，也就是 128M。</p>
</li>
<li><p>N个 一个块的位图 + 一系列的块 称为块组，用来表示文件</p>
<p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/image-20240804124456116.png" alt="image-20240804124456116" style="zoom:50%;"></p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>软链接和硬链接：给某个文件取个别名</p>
<ul>
<li>硬链接：多个目录项中的「索引节点」指向一个文件，删除所有的硬链接以及源文件才彻底删除</li>
<li>软链接：相当于重新创建一个文件，有独立的inode，内容是另一个文件的路径</li>
</ul>
</li>
<li><p>文件IO</p>
<ul>
<li>缓存IO/非缓存IO：前者是通过标准库的缓存实现文件的加速访问，标准库再通过系统调用访问文件。</li>
<li>直接与非直接 IO：是否使用了内核缓存</li>
<li><p>阻塞与非阻塞IO：用户线程执行<code>read</code>线程是否会被阻塞</p>
<ul>
<li>阻塞等待的是「内核数据准备好」和「数据从内核态拷贝到用户态」这两个过程</li>
</ul>
</li>
<li><p>同步与异步IO：</p>
</li>
</ul>
</li>
</ul>
<h3 id="7-7-设备管理"><a href="#7-7-设备管理" class="headerlink" title="7.7 设备管理"></a>7.7 设备管理</h3><ul>
<li><p>从键盘敲入字母发生了什么</p>
<p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/image-20240804133806467.png" alt="image-20240804133806467" style="zoom:50%;"></p>
<ul>
<li>输入字符后，<strong>键盘控制器</strong>就会产生扫描码数据，并将其缓冲在键盘控制器的寄存器中，紧接着键盘控制器通过总线给 CPU 发送<strong>中断请求</strong></li>
<li>CPU 收到中断请求后，操作系统会<strong>保存被中断进程的 CPU 上下文</strong>，然后调用键盘的<strong>中断处理程序</strong></li>
<li>键盘中断处理程序：<strong>键盘驱动程序</strong>初始化注册的，功能是从键盘控制器的寄存器缓冲区读取扫描码，再根据扫描码找到字符，并翻译为对应的ASCII码,放到显示字符读缓冲区队列,由显示器读取</li>
</ul>
</li>
</ul>
<h3 id="7-8-网络管理"><a href="#7-8-网络管理" class="headerlink" title="7.8 网络管理"></a>7.8 网络管理</h3><ul>
<li><p>DMA—直接内存访问(Direct Memory Access) 技术</p>
<p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/image-20240804135136727.png" alt="image-20240804135136727" style="zoom: 67%;"></p>
<ul>
<li>为了解决CPU读取磁盘内容带来的CPU中断问题,DMA读取完数据后发送中断信号给CPU,让CPU读数据</li>
</ul>
</li>
<li><p>传统的文件传输</p>
<p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/image-20240804135524908.png" alt="image-20240804135524908" style="zoom:50%;"></p>
<ul>
<li>发生了4次用户态内核态的转换以及4次数据拷贝,如何优化?<ul>
<li>减少切换次数和数据拷贝次数</li>
</ul>
</li>
</ul>
</li>
<li><p>零拷贝技术（kafka，nginx使用）</p>
<ul>
<li><code>mmap()</code>：将<code>read()</code> 改为<code>mmap()</code> 。改进是在内存中建立一个到磁盘的映射，数据直接同步在内存，由操作系统异步同步内存到硬盘的数据。适合小数据的传输，rocketMQ<ul>
<li>4次上下文切换(用户态 -&gt; 内核态 -&gt; 用户态 -&gt; 内核态 -&gt; 用户态)和3次拷贝(磁盘DMA拷贝到内核缓冲区 -&gt; 内核缓冲区CPU拷贝到socket缓冲区 -&gt; socket缓冲区DMA拷贝到协议引擎)</li>
</ul>
</li>
<li><code>sendfile()</code>：将<code>read()</code> 改为<code>sendfile()</code>。 改进是直接在内核态中进行缓存区到socket缓冲区的数据拷贝<ul>
<li>2次上下文切换(用户态 -&gt; 内核态 -&gt; 用户态)和2次拷贝(磁盘DMA拷贝到内核缓冲区 -&gt; 内核缓冲区DMA拷贝到协议引擎)</li>
</ul>
</li>
</ul>
</li>
<li><p><code>page cache</code>：缓存最近被访问的数据，零拷贝技术的基础</p>
<ul>
<li>解决机械硬盘寻址慢的问题</li>
</ul>
</li>
<li><p>网络socket基本过程：见进程管理部分</p>
<ul>
<li>最大连接数限制：文件描述符(socket也是文件)限制1024默认、系统内存限制</li>
</ul>
</li>
<li><p>IO多路复用：一个进程维护多个Socket</p>
<ul>
<li><p>select：将socket放到一个文件描述符集合（固定长度1024的 BitsMap）。需要2次遍历文件描述符集合，2次拷贝文件描述符集合</p>
</li>
<li><p>poll：bitsMap变为了链表</p>
</li>
<li><p>epoll：</p>
<ul>
<li><p>文件描述符使用红黑树O(logn),只在内核维护，减少了很多的遍历和复制</p>
</li>
<li><p>使用事件驱动机制，内核维护了一个链表记录就绪事件，当有socket事件发生的时候，通过回调函数内核将其加入到列表中，当用户调用 <code>epoll_wait()</code> 函数时，只会返回有事件发生的文件描述符的个数（<strong>但是还是会拷贝</strong>），不需要像select/poll那样轮询整个socket集合</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li><p>Reactor/Proactor：对IO多路复用的封装</p>
<ul>
<li>Reactor(同步非阻塞)、Proactor(异步)</li>
<li>对象<ul>
<li>reactor：监听和分发事件</li>
<li>acceptor：获取事件</li>
<li>handler：处理业务</li>
</ul>
</li>
<li>单reactor/单进程线程模型<ul>
<li>只有一个进程；handler处理业务的时候进程无法处理其他的连接</li>
</ul>
</li>
<li>单reactor/多线程进程模型<ul>
<li>reactor通过select（IO多路复用接口）监听，根据事件类型分发给handler和acceptor</li>
</ul>
</li>
<li>多reactor/多线程进程模型（nginx）<ul>
<li>主线程接收连接，子线程处理连接</li>
</ul>
</li>
<li>Proactor</li>
</ul>
</li>
<li><p>一致性哈希：解决多个请求分配客户端请求的问题</p>
<ul>
<li><p>哈希算法的不足：比如取模，如果节点的数量发生变化，则需要进行额外的数据迁移</p>
</li>
<li><p>一致性哈希算法解决的问题：分布式系统扩容或缩容的数据迁移问题</p>
</li>
<li><p>步骤：计算在哈希环中的位置，顺时针取遇到的第一个节点</p>
<p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/image-20240804150519055.png" alt="image-20240804150519055" style="zoom: 33%;"></p>
<ul>
<li>如果发生节点的增删，只影响前后节点，对全局其他节点无影响</li>
</ul>
</li>
<li><p>问题：</p>
<ul>
<li>不保证数据的均匀性</li>
</ul>
</li>
<li><p>改进：增加虚拟节点，环上的点就是虚拟节点，增加一个映射到真实节点</p>
</li>
</ul>
</li>
</ul>
<h2 id="八-工具"><a href="#八-工具" class="headerlink" title="八 工具"></a>八 工具</h2><h3 id="1-git"><a href="#1-git" class="headerlink" title="1 git"></a>1 git</h3><ul>
<li><p>命令</p>
<figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">git init</span><br><span class="line"></span><br><span class="line">git status</span><br><span class="line"></span><br><span class="line">git <span class="built_in">clone</span> url <span class="comment"># 支持http(s) ssh git等协议</span></span><br><span class="line"></span><br><span class="line">git checkout branch|tag|commit <span class="comment"># 切换到指定分支</span></span><br><span class="line"></span><br><span class="line">git merge branchName <span class="comment"># 将branchName的修改合并到当前分支中</span></span><br><span class="line"></span><br><span class="line">git add .</span><br><span class="line"></span><br><span class="line">git commit -m <span class="string">"message"</span></span><br><span class="line"></span><br><span class="line">git push origin master <span class="comment"># 将本地的 master 分支推送到 origin 主机的 master 分支</span></span><br><span class="line"></span><br><span class="line">git reset HEAD <span class="comment"># 取消已经暂存的文件</span></span><br><span class="line"></span><br><span class="line">git revert HEAD <span class="comment"># 撤销前一次操作</span></span><br><span class="line">git revert commit <span class="comment"># 撤销指定操作 </span></span><br><span class="line"></span><br><span class="line">git remote add origin git@github.com:JSLite/test.git <span class="comment"># 添加一个新的远程仓库 add &lt;remote_name&gt; &lt;remote_url&gt;</span></span><br><span class="line"></span><br><span class="line">git diff --<span class="built_in">stat</span>   <span class="comment"># 查看简单的diff结果   </span></span><br><span class="line">git diff branch     <span class="comment"># 比较Worktree和branch之间的差异 </span></span><br><span class="line"></span><br><span class="line">git merge --squash branchName <span class="comment"># 将branchName的多次提交统一变更到当分支（此后还需要再add commit push）</span></span><br><span class="line"></span><br><span class="line">git <span class="built_in">log</span> <span class="comment"># 日志相关</span></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>已经push的操作如何回退？</p>
<p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/image-20240519144816183.png" alt="image-20240519144816183"></p>
<ul>
<li><p>要回到vesion2</p>
</li>
<li><p>不保留git记录</p>
<ul>
<li><p>先reset到要回退的版本：<code>git reset commitID</code></p>
</li>
<li><p>然后强制push上去： <code>git push origin master:master -f</code> </p>
<p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/image-20240519145122665.png" alt="image-20240519145122665" style="zoom:33%;"></p>
</li>
</ul>
</li>
<li><p>保留git记录</p>
<ul>
<li><p><code>git revert commitID</code>，选择merge</p>
</li>
<li><p>然后push</p>
<p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/image-20240519145010549.png" alt="image-20240519145010549" style="zoom:33%;"></p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>分支的多次commit变成一次提交到master</p>
<ul>
<li><p>方法一：先从版本库回退内容到暂存区，再重新提交工作区的内容</p>
<ul>
<li><code>git reset --soft commitID</code>，此时版本回到commitID对应的状态，但是保留了改动(也就是之后多次的commit修改内容)</li>
<li>然后git add commit push</li>
</ul>
</li>
<li><p>方法二：rebase</p>
<ul>
<li><p>git log 查看提交记录，找到最早的那次提交的commitID的前一次</p>
<ul>
<li>我想合并commit1678 就找到commit1的前一次的id</li>
</ul>
<p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/image-20240519155033222.png" alt="image-20240519155033222"></p>
</li>
<li><p><code>git rebase -i commitID</code>，随后在vim编辑器中修改前面的提交由pick变为fixup</p>
<ul>
<li>fixup：使用commit，丢弃commit信息。</li>
<li>pick：使用commit。</li>
<li>squash：使用commit，将commit信息合入上一个commit。</li>
<li>reword：使用commit，修改commit信息。</li>
</ul>
<p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/image-20240519154428674.png" alt="image-20240519154428674" style="zoom:67%;"><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/image-20240519155543233.png" alt="image-20240519155543233" style="zoom: 67%;"></p>
<ul>
<li>可以通过<code>git reflog</code>取消rebase</li>
</ul>
</li>
<li><p>最后<code>git push --force</code>即可</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="2-maven"><a href="#2-maven" class="headerlink" title="2 maven"></a>2 maven</h3><h2 id="九-Spring"><a href="#九-Spring" class="headerlink" title="九 Spring"></a>九 Spring</h2><h3 id="9-1-简介"><a href="#9-1-简介" class="headerlink" title="9.1 简介"></a>9.1 简介</h3><ul>
<li>特性：<ul>
<li>非侵入</li>
<li>控制反转IOC：由框架管理bean，是一种思想</li>
<li>依赖注入DI：控制反转的实现方式，是一种实现方式</li>
<li>切面AOP</li>
<li>容器管理</li>
</ul>
</li>
</ul>
<p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/image-20240706162256753.png" alt="image-20240706162256753" style="zoom:50%;"></p>
<ul>
<li>core container：spring核心容器，由Beans、Core、Context、SpEL模块组成<ul>
<li>Beans：基础，提供了控制反转和依赖注入</li>
<li>Core：封装了底层，包括资源访问、类型转化等工具</li>
<li>Context上下文：ApplicationContext接口</li>
<li>SpEL：语言表达式支持</li>
</ul>
</li>
<li>Data Access/Integration：数据访问/集成<ul>
<li>JDBC：提供了JDBC模块，</li>
<li>ORM：提供了ORM框架集成的API，包括JPA、JDO、Hibernate 和 MyBatis 等</li>
<li>OXM：提供了XML与Java对象的转化功能</li>
<li>JMS：Java消息服务，异步通信</li>
<li>Transactions：编程和声明式事务的管理</li>
</ul>
</li>
<li>Web：web模块<ul>
<li>Web</li>
<li>Servlet：提供了spring mvc web框架实现</li>
<li>WebSocket：实现双向通信</li>
<li>Webflux</li>
<li>Portlet 模块</li>
</ul>
</li>
<li>AOP、Aspects、Instrumentation和Messaging</li>
<li>Test模块：支持Junit 和 TestNG 测试框架，还有模型http请求等功能</li>
<li>spring的启动过程<ul>
<li>加载配置文件：xml，javaConfig类，配置数据库连接、事务管理、AOP等</li>
<li>实例化容器：实例化BeanFactory，如创建ApplicationContext；并加载BeanDefinitions</li>
<li>解析BeanDefinitions：Bean的元数据、作用域、依赖关系等</li>
<li>实例化Bean</li>
<li>依赖注入</li>
<li>处理Bean生命周期初始化方法</li>
<li>处理BeanPostProcessor</li>
<li>代理切面处理</li>
<li>发布事件</li>
<li>完成启动</li>
</ul>
</li>
</ul>
<h3 id="9-2-控制反转IOC、及DI"><a href="#9-2-控制反转IOC、及DI" class="headerlink" title="9.2 控制反转IOC、及DI"></a>9.2 控制反转IOC、及DI</h3><ul>
<li><p>三种配置方式</p>
<ul>
<li><p>xml</p>
<figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag"> http://www.springframework.org/schema/beans/spring-beans.xsd"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- services --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"userService"</span> <span class="attr">class</span>=<span class="string">"tech.pdai.springframework.service.UserServiceImpl"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"userDao"</span> <span class="attr">ref</span>=<span class="string">"userDao"</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- additional collaborators and configuration for this bean go here --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- more bean definitions for services go here --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>java配置：创建配置类，<code>@Configuration</code>注解声明，在bean中用<code>@bean</code>声明</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BeansConfig</span> {</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> user dao</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean("userDao")</span></span><br><span class="line">    <span class="keyword">public</span> UserDaoImpl <span class="title function_">userDao</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">UserDaoImpl</span>();</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> user service</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean("userService")</span></span><br><span class="line">    <span class="keyword">public</span> UserServiceImpl <span class="title function_">userService</span><span class="params">()</span> {</span><br><span class="line">        <span class="type">UserServiceImpl</span> <span class="variable">userService</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserServiceImpl</span>();</span><br><span class="line">        userService.setUserDao(userDao());</span><br><span class="line">        <span class="keyword">return</span> userService;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>注解配置：<code>@Component</code>，<code>@Controller</code>，<code>@Service</code>，<code>@Repository</code>，但是要配置spring 的注解扫描器ComponentScan</p>
</li>
</ul>
</li>
<li><p>依赖注入：一种设计模式，用于解耦成员和管理类之间的关系，核心思想是将对象的创建交给外部（IOC）容器管理</p>
<ul>
<li><p>构造方法注入，xml中<code>&lt;constructor-arg&gt;</code></p>
</li>
<li><p>setter注入，xml中的<code>&lt;property&gt;</code></p>
</li>
</ul>
</li>
<li><p>自动装配：是依赖注入的一种自动化形式，不需要开发者显示的指定哪些依赖要注入到哪个类中，由spring自动完成</p>
<ul>
<li><p>byName</p>
</li>
<li><p>byType：如果多个bean类型相同，则需要byName</p>
</li>
<li><p>构造器注入：容器查找类型相匹配的bean注入</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span> <span class="comment">// 三个属性Constructor，byType，byName，默认byType(查找set方法)</span></span><br><span class="line"><span class="meta">@Qualifier("helloWorldDao")</span> <span class="comment">// byName,如果没有找到会抛异常，防止这个可以@Autowired(required = false)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Inject</span> <span class="comment">// byType,javaEE提供</span></span><br><span class="line"><span class="meta">@Resource</span> <span class="comment">// byName,javaEE提供</span></span><br><span class="line"><span class="meta">@Named</span> <span class="comment">// 和Qualifier一样，javaEE提供</span></span><br><span class="line"><span class="keyword">private</span> HelloDao helloDao;</span><br></pre></td></tr></tbody></table></figure>
</li>
</ul>
</li>
<li><p>spring IOC的设计</p>
<ul>
<li>加载Bean的配置(如xml)</li>
<li>根据bean定义加载生成bean的实例，并放置在容器中</li>
<li>统一管理bean(工厂模式)</li>
</ul>
</li>
<li><p><code>interface BeanFactory</code></p>
</li>
<li><p><code>interface ApplicationContext</code>：IoC容器的接口类</p>
<ul>
<li>除了对bean的管理外，还包括了资源访问、国际化、应用事件</li>
</ul>
</li>
<li><p>循环依赖：三级缓存</p>
<ul>
<li><p>一级缓存singletonObjects：已经初始化好的bean，即已经完成初始化好的注入对象的代理</p>
</li>
<li><p>二级缓存earlySingletonObjects：还没有完全被初始化好的中间对象代理</p>
</li>
<li><p>三级缓存singletonFactory：存放的是还未初始化完的bean，不是代理对象</p>
</li>
<li><p>为什么需要三级？</p>
<ul>
<li>针对于AOP，singletonFactory缓存相当于是返回的是A的代理</li>
</ul>
</li>
<li><p>过程：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/daimzh/p/13256413.html">https://www.cnblogs.com/daimzh/p/13256413.html</a></p>
<p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/image-20240321165705162.png" alt="image-20240321165705162" style="zoom: 50%;"></p>
</li>
<li><p>ps：</p>
<ul>
<li>不能解决构造器的依赖（使用<code>@Lazy</code>解决）</li>
<li>只能解决单例bean的循环依赖（多实例Bean是每次调用一次getBean都会执行一次构造方法并且给属性赋值，根本没有三级缓存，因此不能解决循环依赖）</li>
</ul>
</li>
<li><p>自动装配（spring boot）</p>
<ul>
<li>依赖注入的plus，简化了依赖注入的配置而生成的</li>
<li>主启动类上的注解<strong><code>@SpringbootApplication</code></strong>是一个复合注解，其中比较重要的<ul>
<li><code>@SpringbootConfiguration</code>：springboot的相关配置</li>
<li><code>@EnableAutoConfiguration</code></li>
<li><code>@ComponentScan</code>：扫描一些包并注入</li>
</ul>
</li>
<li>重点<strong><code>@EnableAutoConfiguration</code></strong>，也是一个复合注解<ul>
<li><code>@import(AutoConfigurationImportSelect.class)</code></li>
</ul>
</li>
<li><p><code>AutoConfigurationImportSelect</code> implements了<strong><code>DeferredImportSelector</code></strong></p>
<ul>
<li><p>因为是Deferred,所以自动配置类会放在最后加载,方便扩展和覆盖</p>
</li>
<li><p>其中重写了<strong><code>selectImports()</code></strong>方法：获取所有符合条件的类的全限定类名，加载到IOC容器中</p>
<ul>
<li><p>判断是否开启了自动装配：<code>spring.boot.enableautoconfiguration=true</code></p>
</li>
<li><p>获取<code>@EnableAutoConfiguration</code>中的<code>exclude</code>和<code>excludeName</code></p>
</li>
<li><p>读取所有spring boot start下面的classpath:/META-INF/spring.factories文件(key-value形式)</p>
</li>
<li><p>通过<code>@ConditionalOn</code>排除无效的自动配置类</p>
</li>
</ul>
</li>
</ul>
</li>
<li>配置文件的信息如何加载到bean中：classpath:/META-INF/spring.factories文件存储了一些键信息（<strong>SpringBoot约定大于配置的理念</strong>），然后加载的时候配置文件的值就被加载到这个文件中了</li>
<li>两种<ul>
<li><code>@Autowired</code>：根据类型自动注入<ul>
<li><code>@Qualifier</code>：格外指定bean的id（当IOC根据属性类型去容器中找找到多个相同类型的组件的时候需要使用）</li>
</ul>
</li>
<li><code>@Resource</code>：根据bean的名称自动注入<ul>
<li>这个是Java规范</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="9-3-AOP"><a href="#9-3-AOP" class="headerlink" title="9.3 AOP"></a>9.3 AOP</h3><ul>
<li>目的：AOP 的目的是将横切关注点（如日志记录、事务管理、权限控制、接口限流、接口幂等等）从核心业务逻辑中分离出来，通过动态代理、字节码操作等技术，实现代码的复用和解耦，提高代码的可维护性和可扩展性。</li>
<li>概念：<ul>
<li>连接点：表示需要在程序中插入横切关注点的扩展点</li>
<li>切入点：选择一组相关连接点的模式，即可以认为连接点的集合</li>
<li>通知：前置通知、后置通知、环绕通知、最终通知、异常通知<ul>
<li><code>@After @Around @Before @AfterReturning @AfterThrowing</code></li>
</ul>
</li>
<li>切面：公共代码</li>
<li>引入：引入允许我们向现有的类添加新方法或属性</li>
<li>织入：把切面应用到目标对象并创建新的代理对象的过程<ul>
<li>动态织入：通过动态代理完成，运行期织入（Spring AOP采用的方式）</li>
<li>静态织入：AspectJ，编译期织入</li>
</ul>
</li>
<li>AOP代理：JDK(反射)和CGLib(继承)两种方式<ul>
<li>都是运行期间生成字节码，jdk直接生成class字节码，cglib使用ASM框架写的class字节码。后者更加复杂，代理类生成效率更低</li>
<li>jdk动态代理是通过反射机制来执行方法，cglib是通过FastClass机制（索引分配直接调用）直接调用方法，后者动态代理类执行效率更高，但是cglib无法增强final方法(AspectJ可以)</li>
</ul>
</li>
</ul>
</li>
<li><p>最佳实践</p>
<ul>
<li><code>@Aspect</code>：定义切面</li>
<li><code>@pointcut</code>：定义切点</li>
<li><code>@After @Around @Before @AfterReturning @AfterThrowing</code>：定义通知</li>
</ul>
</li>
<li><p>Spring AOP和AspectJ关系：Spring AOP更易用，AspectJ更强大</p>
</li>
</ul>
<h3 id="9-4-Sping-MVC"><a href="#9-4-Sping-MVC" class="headerlink" title="9.4 Sping MVC"></a>9.4 Sping MVC</h3><ul>
<li><p>Spring MVC是Spring在Spring Container Core和AOP等技术基础上，遵循上述Web MVC的规范推出的web开发框架，目的是为了简化Java栈的web开发</p>
<p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/image-20240706173809020.png" alt="image-20240706173809020" style="zoom: 67%;"></p>
<ul>
<li>核心组件<ul>
<li>DispatcherServlet：前端控制器，负责将请求分派给相应的处理器(Controller)</li>
<li>HandlerMapping：适配找到Handler</li>
<li>HandlerAdapter：适配处理器，用来找到Controller方法</li>
<li>Controller：处理用户请求，返回ModelAndView对象</li>
<li>ModelAndView：包含模型和视图</li>
<li>ViewResolver：解析视图</li>
</ul>
</li>
</ul>
</li>
<li><p>拦截器 Interceptor，类似于servlet中的Filter（但是Filter是基于Servlet层面的，会比Interceptor先被执行）</p>
<ul>
<li><p>实现<code>HandlerInterceptor</code>接口</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">HandlerInterceptor</span> {</span><br><span class="line">    <span class="keyword">default</span> <span class="type">boolean</span> <span class="title function_">preHandle</span><span class="params">(...)</span></span><br><span class="line">    <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">postHandle</span><span class="params">(...)</span></span><br><span class="line">    <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">afterCompletion</span><span class="params">(...)</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>注册拦截器：实现<code>WebMvcConfigurer</code>接口，重写<code>addInterceptors()</code>方法注册拦截器</p>
</li>
<li><p>配置拦截器：<code>addPathPatterns()</code>设计对应url路径，<code>excludePathPatterns()</code>排除路径</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebMvcConfig</span> <span class="keyword">implements</span> <span class="title class_">WebMvcConfigurer</span> {</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> PermissionInterceptor permissionInterceptor;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> CookieInterceptor cookieInterceptor;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> {</span><br><span class="line">        registry.addInterceptor(permissionInterceptor).addPathPatterns(<span class="string">"/**"</span>);</span><br><span class="line">        registry.addInterceptor(cookieInterceptor).excludePathPatterns(<span class="string">"/path"</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>配置类上使用<code>@EnableWebMvc</code>启动mvc配置</p>
</li>
</ul>
</li>
</ul>
<h3 id="9-5-Bean"><a href="#9-5-Bean" class="headerlink" title="9.5 Bean"></a>9.5 Bean</h3><ul>
<li><p>生命周期</p>
<ul>
<li><code>BeanFactoryPostProcessor</code>如果和bean关联，则<code>postProcessBeanFactory()</code>：尝试从Bean工厂中获取Bean</li>
<li><code>InstantiationAwareBeanPostProcessor</code> <ul>
<li>postProcessBeforeInstantiation()，如果这里返回了bean实例，就会直接跳到postProcessAfterInitialization()</li>
<li>postProcessAfterInstantiation()，bean实例化完后调用</li>
</ul>
</li>
<li>bean构造函数</li>
<li>bean调用setter方法初始化</li>
<li>如果实现了<code>xxxAware</code>接口(bean需要实现这些接口)，调用对应的<code>setxxx()</code> 方法<ul>
<li><code>BeanNameAware</code>接口：传入当前 Bean 的 id 值</li>
<li><code>BeanClassLoaderAware</code>接口：传入classLoader的引用</li>
<li><code>BeanFactoryAware</code>：传入当前工厂实例的引用</li>
<li><code>EnvironmentAware</code>传入当前 Environment 实例的引用</li>
<li><code>ApplicationContextAware</code>传入当前 ApplicationContext 实例的引用</li>
</ul>
</li>
<li>如果实现了<code>BeanPostProcessor</code>接口<ul>
<li><code>postProcessBeforeInitialzation()</code>，bean的init方法之前，Spring 的 AOP 就是利用它实现的</li>
</ul>
</li>
<li>如果实现了<code>InitializingBean</code>接口(或者@PostConstruct) ，则调用<code>afterPropertiesSet()</code>方法</li>
<li>调用bean自身的<code>initMethod()</code>方法（<code>@Bean</code>注解）</li>
<li><p>如果实现了<code>BeanPostProcessor</code>接口</p>
<ul>
<li><code>postProcessAfterInitialization()</code>，bean初始化后</li>
</ul>
</li>
<li><p>使用bean</p>
</li>
<li>如果实现了<code>DisposableBean</code>接口，则销毁的时候调用<code>destroy()</code>方法</li>
<li>执行bean自身的<code>destroyMethod()</code>方法 （<code>@Bean</code>注解）</li>
</ul>
</li>
</ul>
<p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/image-20240706180733761.png" alt="image-20240706180733761"></p>
<ul>
<li>作用域<ul>
<li>singleton 单例 </li>
<li>prototype 原型</li>
<li>request</li>
<li>session</li>
<li>application</li>
<li>websoket</li>
</ul>
</li>
</ul>
<h3 id="9-6-事务"><a href="#9-6-事务" class="headerlink" title="9.6 事务"></a>9.6 事务</h3><ul>
<li><p><code>@Transactional</code>：原理是基于ThreadLocal，动态代理</p>
</li>
<li><p>什么时候spring 的事务会失效？</p>
<ul>
<li>多线程</li>
<li>异常被catch了，没有抛出，这样事务无法捕获到异常</li>
<li>同一个类方法的调用如果没有用代理类会失败</li>
<li>注解作用于非public方法，或者final、static方法，无法被代理，事务失效</li>
<li>数据库用的MyISAM，引擎本身不支持事务</li>
</ul>
</li>
</ul>
<h3 id="9-7-常用注解"><a href="#9-7-常用注解" class="headerlink" title="9.7 常用注解"></a>9.7 常用注解</h3><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@PropertyResource</span></span><br><span class="line"><span class="meta">@Conditional</span>：类加载条件</span><br><span class="line"><span class="meta">@Bean</span>、<span class="meta">@Component</span>、<span class="meta">@Controller</span>、<span class="meta">@Service</span>、<span class="meta">@Repository</span></span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="meta">@Primary</span>：用于声明接口多个实现类优先加载的bean</span><br><span class="line"><span class="meta">@Value("${app.version}")</span></span><br><span class="line"><span class="meta">@Profile("dev")</span>：标注bean加载的环境</span><br><span class="line"><span class="meta">@PostConstruct</span>、<span class="meta">@PreDestroy</span>：声明周期方法</span><br><span class="line"><span class="meta">@ResponseBody</span>、<span class="meta">@ResponseStatus</span>：标注在方法上</span><br><span class="line"><span class="meta">@PathVariable</span>、<span class="meta">@RequestBody</span>、<span class="meta">@ModelAttribute</span>、<span class="meta">@RequestHeader</span>、<span class="meta">@CookieValue</span>、<span class="meta">@SessionAttribute</span>、<span class="meta">@Valid</span>：标注在参数上</span><br><span class="line">    <span class="comment">// @Valid表示开启参数验证(对象上要有字段约束，如@NotNull)</span></span><br><span class="line"><span class="meta">@ExceptionHandler(xxxException.class)</span></span><br><span class="line"><span class="meta">@Schedule(cron = "...")</span></span><br></pre></td></tr></tbody></table></figure>
<h2 id="十-Spring-Boot"><a href="#十-Spring-Boot" class="headerlink" title="十 Spring Boot"></a>十 Spring Boot</h2><ul>
<li>解决spring配置重量级的问题，约定大于配置</li>
</ul>
<h3 id="10-1-常用注解"><a href="#10-1-常用注解" class="headerlink" title="10.1 常用注解"></a>10.1 常用注解</h3><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span> <span class="comment">// main</span></span><br><span class="line"><span class="meta">@EnableAutoConfiguration</span> <span class="comment">// 自动装配 src/main/resources的META-INF/spring.factories 的bean</span></span><br><span class="line"><span class="meta">@ImportResource</span> <span class="comment">// 加载xml 启动类上</span></span><br><span class="line"><span class="meta">@Value</span> <span class="comment">// application.properties的属性</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping("/api/demo")</span></span><br><span class="line"><span class="meta">@RequestParam(value = "demo", required = false)</span> <span class="comment">// 作用于request入参 https://www.d.com/info?demo=ddd</span></span><br><span class="line"><span class="meta">@PathVariable("name")</span> <span class="comment">// 用于获取url请求中的参数 https://www.d.com/name/info</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="meta">@Bean(name = "xxx", initMethod = "xxx", destoryMethod = "xxx")</span></span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@Repository</span> <span class="comment">// 用于标注数据访问组件</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@ComponentScan</span></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="meta">@Qualifier("beanName")</span> <span class="comment">// 和@Autowired一起使用，表示byName方式加载bean</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@Import(Config.class)</span></span><br><span class="line"><span class="meta">@ControllerAdvice</span></span><br><span class="line"><span class="meta">@ControllerAdvice</span>、<span class="meta">@ExceptionHandler</span>：分别作用于类和方法</span><br></pre></td></tr></tbody></table></figure>
<h3 id="10-2-开发实践"><a href="#10-2-开发实践" class="headerlink" title="10.2 开发实践"></a>10.2 开发实践</h3><ul>
<li><p>对参数进行统一校验：为了解决在Controller中频繁对入参对象校验的不优雅</p>
<figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- spring validation是对hibernate validation的二次封装，后者是对validation-api标准的实现 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-validation<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span> </span><br></pre></td></tr></tbody></table></figure>
<p>定义入参对象类，在字段中添加相关注解</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@NotEmpty(message = "xxx")</span></span><br><span class="line"><span class="meta">@Email(message = "xxx")</span></span><br><span class="line"><span class="meta">@Pattern(regexp = "xxx", message = "xxx")</span> <span class="comment">// 正则匹配</span></span><br><span class="line"><span class="meta">@Length(min = 0, max = 10, message = "xxx")</span></span><br><span class="line"><span class="meta">@Range(min = 0, max = 10, message = "xxx")</span></span><br></pre></td></tr></tbody></table></figure>
<p>Controller中入参添加<code>@Valid</code>注释</p>
</li>
<li><p>统一异常处理：<code>@ControllerAdvice</code>及<code>@ExceptionHandler</code></p>
</li>
<li><p>接口版本控制：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">相同URL，用不同的版本参数区分</span><br><span class="line">	api.man.tech/user?version=v1 </span><br><span class="line">	api.man.tech/user?version=v2 </span><br><span class="line">区分不同的接口域名，不同的版本有不同的子域名, 路由到不同的实例:</span><br><span class="line">	v1.man.pdai.tech/user </span><br><span class="line">	v2.man.pdai.tech/user </span><br><span class="line">网关路由不同子目录到不同的实例</span><br><span class="line">	api.man.tech/v1/user</span><br><span class="line">	api.man.tech/v2/user</span><br><span class="line">同一实例，用注解隔离不同版本控制</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>接口文档生成swagger</p>
</li>
<li><p>访问外部接口（调三方服务）</p>
<ul>
<li>采用原生http请求</li>
<li>feign消费（依赖 + <code>@EnableFeignClients</code>）：本质也是http</li>
<li>采用RestTemplate方法</li>
</ul>
</li>
<li><p>保证接口的幂等性：</p>
<blockquote>
<p> 哪些操作需要保证幂等性？PUT和POST，DELETE如果需要返回删除的行数则也需要</p>
</blockquote>
<ul>
<li>数据库加悲观锁</li>
<li>唯一索引：注意是分布式ID，针对插入操作</li>
<li>乐观锁：版本号，针对更新操作</li>
<li>分布式锁：redis</li>
</ul>
</li>
<li><p>针对接口进行签名：防篡改</p>
<ul>
<li><p>认证和授权</p>
</li>
<li><p>https</p>
</li>
<li><p>接口签名(加密)：1. 对请求参数按key进行字母排序 2. 排序完连接用&amp; 3. 加密字符串得到sig，拼接到后面</p>
<p><code>https://man.xxxx.com/info?key=value&amp;timetamp=xxxx&amp;sign=xxxx-xxx-xxx-xxxx</code></p>
</li>
</ul>
</li>
<li><p>接口限流</p>
<ul>
<li>单实例：限流总资源数、总并发数、某接口的请求总量、某个时间窗的请求数</li>
<li>分布式：redis+lua 或者 nginx+lua</li>
</ul>
</li>
<li><p>跨域请求</p>
<ul>
<li><p><code>@Configuration</code>实现WebMvcConfigurer接口，重写addCorsMappings方法，</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyWebMvcConfigurer</span> <span class="keyword">implements</span> <span class="title class_">WebMvcConfigurer</span> {</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addCorsMappings</span><span class="params">(CorsRegistry registry)</span> {</span><br><span class="line">        registry.addMapping(<span class="string">"/user/*"</span>)</span><br><span class="line">            	.allowedOrigins(<span class="string">"http://localhost:8080"</span>)</span><br><span class="line">            	.allowedMethods(<span class="string">"GET"</span>, <span class="string">"POST"</span>, <span class="string">"PUT"</span>, <span class="string">"DELETE"</span>);</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
</li>
</ul>
</li>
</ul>
<h3 id="10-3-其他"><a href="#10-3-其他" class="headerlink" title="10.3 其他"></a>10.3 其他</h3><ul>
<li><p>自动装配——SpringBoot约定大于配置的理念的产物</p>
<ul>
<li>依赖注入的plus，简化了依赖注入的配置而生成的</li>
<li>主启动类上的注解<strong><code>@SpringbootApplication</code></strong>是一个复合注解，其中比较重要的<ul>
<li><code>@SpringbootConfiguration</code>：springboot的相关配置</li>
<li><code>@EnableAutoConfiguration</code></li>
<li><code>@ComponentScan</code>：扫描一些包并注入</li>
</ul>
</li>
<li>重点<strong><code>@EnableAutoConfiguration</code></strong>，也是一个复合注解<ul>
<li><code>@import(AutoConfigurationImportSelect.class)</code></li>
</ul>
</li>
<li><p><code>AutoConfigurationImportSelect</code> implements了<strong><code>DeferredImportSelector</code></strong></p>
<ul>
<li><p>因为是Deferred,所以自动配置类会放在最后加载,方便扩展和覆盖</p>
</li>
<li><p>其中重写了<strong><code>selectImports()</code></strong>方法：获取所有符合条件的类的全限定类名，加载到IOC容器中</p>
<ul>
<li><p>判断是否开启了自动装配：<code>spring.boot.enableautoconfiguration=true</code></p>
</li>
<li><p>获取<code>@EnableAutoConfiguration</code>中的<code>exclude</code>和<code>excludeName</code></p>
</li>
<li><p>读取所有spring boot start下面的classpath:/META-INF/spring.factories文件(key-value形式)</p>
</li>
<li><p>通过<code>@ConditionalOn</code>排除无效的自动配置类</p>
</li>
</ul>
</li>
</ul>
</li>
<li>配置文件的信息如何加载到bean中：classpath:/META-INF/spring.factories文件存储了一些键信息（<strong>SpringBoot约定大于配置的理念</strong>），然后加载的时候配置文件的值就被加载到这个文件中了</li>
<li>两种<ul>
<li><code>@Autowired</code>：根据类型自动注入<ul>
<li><code>@Qualifier</code>：格外指定bean的id（当IOC根据属性类型去容器中找找到多个相同类型的组件的时候需要使用）</li>
</ul>
</li>
<li><code>@Resource</code>：根据bean的名称自动注入<ul>
<li>这个是Java规范</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>springboot启动web服务的过程：<code>run()</code>方法里面会创建web服务器，默认是TomcatWebServer，还有jettyWebServer、NettyWebServer、UndertowServletWebServer、UndertowWebServer</p>
<ul>
<li>Tomcat：默认</li>
<li>Jetty：轻量级，适合嵌入式和IoT应用</li>
<li>Undertow：非常轻量级，启动速度快，支持非阻塞IO</li>
<li>Netty：高性能</li>
</ul>
</li>
<li><p>配置文件优先级：<code>.properties &gt; .yml</code></p>
<p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/image-20240826143834619.png" alt="image-20240826143834619"></p>
</li>
<li><p>spring boot的jar包结构</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">mySpringboot.jar</span><br><span class="line">|—— Boot-INF/</span><br><span class="line">|	 |—— classes/</span><br><span class="line">|	 |—— lib/</span><br><span class="line">|	 |—— META-INF/</span><br><span class="line">|—— MEAT-INF/</span><br><span class="line">	 |—— MANIFEST.MF 指定了启动类和主类</span><br><span class="line">	 </span><br><span class="line">	 </span><br><span class="line">普通jar.jar</span><br><span class="line">|—— com/</span><br><span class="line">|—— MEAT-INF/</span><br><span class="line">	 |—— MANIFEST.MF 指定了启动类和主类</span><br></pre></td></tr></tbody></table></figure>
</li>
</ul>
<h3 id="10-4-spring-cloud"><a href="#10-4-spring-cloud" class="headerlink" title="10.4 spring cloud"></a>10.4 spring cloud</h3><ul>
<li>四大板块<ul>
<li>服务注册中心与配置中心</li>
<li>负载均衡</li>
<li>服务容错</li>
<li>服务治理</li>
</ul>
</li>
<li>配置中心：Zookeeper，nacos。这两个也可以做注册中心</li>
<li><p>CAP：一致性、可用性、分区容忍性</p>
<ul>
<li><p>CA：</p>
</li>
<li><p>CP：</p>
</li>
</ul>
</li>
<li><p>Eureka(AP)、Zookeeper(CP)、Nacos(AP和CP)</p>
</li>
<li><p>Nacos：分级存储模型</p>
<ul>
<li><p>NameSpace</p>
</li>
<li><p>Group</p>
</li>
<li><p>Service</p>
</li>
<li><p>Cluster</p>
</li>
<li><p>instance</p>
</li>
</ul>
</li>
<li><p>服务降级、服务熔断、服务限流</p>
</li>
<li>网关：路由转发、鉴权、缓存加速、协议转换、日志监控、服务保护</li>
</ul>
<h2 id="十一-其他中间件"><a href="#十一-其他中间件" class="headerlink" title="十一 其他中间件"></a>十一 其他中间件</h2><h3 id="1-Mybatis"><a href="#1-Mybatis" class="headerlink" title="1 Mybatis"></a>1 Mybatis</h3><ul>
<li>一种半自动ORM：查询关联对象或关联集合对象时，需要手动编写 sql 来完成</li>
<li><p>全自动ORM查询时可以不再写SQL。典型的框架如Hibernate</p>
</li>
<li><p>xml开发方式</p>
<ul>
<li>定义xml</li>
</ul>
<figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">"tech.pdai.springboot.mysql57.mybatis.xml.dao.IUserDao"</span>&gt;</span>  定义mapper关联的dao</span><br><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">type</span>=<span class="string">"tech.pdai.springboot.mysql57.mybatis.xml.entity.User"</span> <span class="attr">id</span>=<span class="string">"UserResult"</span>&gt;</span>  定义sql返回对象</span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"findById"</span> <span class="attr">parameterType</span>=<span class="string">"Long"</span> <span class="attr">resultMap</span>=<span class="string">"UserResult"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">delete</span> <span class="attr">...</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">update</span> <span class="attr">...</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">insert</span> <span class="attr">...</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>定义dao：<code>IUserDao</code>，使用<code>@mapper</code>注解关联，定义xml中相关的对应方法</li>
<li>定义service及实现类调用dao</li>
<li>定义controller调用service</li>
</ul>
</li>
<li><p>注解开发</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Results(</span></span><br><span class="line"><span class="meta">        id = "UserResult1",</span></span><br><span class="line"><span class="meta">        value = {</span></span><br><span class="line"><span class="meta">                @Result(id = true, property = "id", column = "id"),</span></span><br><span class="line"><span class="meta">                @Result(property = "userName", column = "user_name"),</span></span><br><span class="line"><span class="meta">                @Result(property = "password", column = "password")</span></span><br><span class="line"><span class="meta">        }</span></span><br><span class="line"><span class="meta">)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@ResultMap("UserResult1")</span></span><br><span class="line"><span class="meta">@Select("select u.id, u.password, u.user_name from tb_user u")</span></span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>PageHelper：底层是使用的ThreadLocal存储分页数据-</p>
<ul>
<li>只有紧跟在PageHelper.startPage方法后的第一个Mybatis的查询（Select）方法会被分页</li>
</ul>
</li>
<li><p>数据库连接池：C3P0、DBCP、BoneCP、Druid(best)</p>
</li>
<li><p>文件上传：异步、分片、断点续传、秒传(如果之前上传过就马上到100%)</p>
<ul>
<li>异步：<code>@EnableAsync</code>开启异步，<code>@Async</code>作用于方法，开启子线程执行</li>
<li>分片：先切割再上传</li>
<li>断点续传：将分片的chuck md5信息保存在db中，记录上传记录</li>
<li>秒传：类似断点续传</li>
</ul>
</li>
</ul>
<h3 id="2-RabbitMQ"><a href="#2-RabbitMQ" class="headerlink" title="2 RabbitMQ"></a>2 RabbitMQ</h3><ul>
<li>优势在于稳定</li>
<li>命名中心：namesrv，存储broker、主题、生产消费信息</li>
<li>路由键、绑定键</li>
<li>对象<ul>
<li>producer</li>
<li>consumer</li>
<li>exchange：不存储消息，只是用来转发消息<ul>
<li>direct exchange：根据消息路由键精确匹配队列</li>
<li>fanout exchange：消息广播</li>
<li>topic exchange：根据消息路由键匹配队列（通配符* #）</li>
<li>headers exchange：根据消息头匹配队列</li>
</ul>
</li>
<li>queue</li>
<li>brocker</li>
</ul>
</li>
<li>如何进入死信队列？<ul>
<li>消息被拒绝，且requeue参数为false</li>
<li>消息在队列中过期（TTL）未消费</li>
<li>队列超出长度限制</li>
</ul>
</li>
<li><p>消息如何路由</p>
<ul>
<li>生产者发送消息到交换机</li>
<li>交换机根据路由键和绑定键发送到一个或多个队内中</li>
</ul>
</li>
<li><p>消息的持久化</p>
<ul>
<li><p>将队列和交换机的Durable设置为True</p>
<p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/image-20240819175128997.png" alt="image-20240819175128997"></p>
</li>
</ul>
</li>
<li><p>不足</p>
<ul>
<li>性能：相比于kafka来说性能较低，常用于中小企业</li>
<li>开发语言限制，是erlang</li>
</ul>
</li>
<li>rabbitMQ实现延迟队列<ul>
<li>本身不支持，通过TTL（消息存活时间） 和 DLX（死信交换机）</li>
</ul>
</li>
</ul>
<h3 id="3-kafka"><a href="#3-kafka" class="headerlink" title="3 kafka"></a>3 kafka</h3><ul>
<li>优势在于快、吞吐量大</li>
<li><p>命名中心：zookeeper，存储broker、主题、生产消费信息，协调服务实现故障监听与转移</p>
<ul>
<li>特点：强一致性，zookeeper中某个节点发生数据变化，会通知其他节点通知更新，超过半数更新完毕才算写入完成</li>
</ul>
</li>
<li><p>对象：</p>
<ul>
<li><p>producer</p>
</li>
<li><p>consumer</p>
<ul>
<li>需要自己从 broker 拉取消息，一个 consumer 连接到一个 partition ，从中依次读取消息，动态的更新 offset</li>
<li>采用pull的方式的好处是可以避免consumer处的消息堆积</li>
<li>多个 consumer 构成一个消费组group，一个group只负责一个topic，group会保证一条消息只被一个consumer消费</li>
</ul>
</li>
<li><p>brocker：服务器，多个brocker组成集群</p>
</li>
<li><p>topic：消息主题</p>
</li>
<li><p>partition：主题内分区，物理上分区，实现负载均衡</p>
<ul>
<li>一个topic分为多个partition，partition内部的消息是有序的(offset偏移量)，但是对于topic来说，消息是无序的</li>
<li>消息写入partition：hash（注意热点问题）、轮询、自定义</li>
<li>多个partition可以放到多个broker，进行水平能力的扩展</li>
</ul>
</li>
<li><p>group：消费者组</p>
<ul>
<li>1个topic可以对应多个group</li>
</ul>
<p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/image-20240828145638999.png" style="zoom:50%;"></p>
</li>
</ul>
</li>
<li><p>特性</p>
<ul>
<li>高吞吐、低延迟，收发消息很快（零拷贝技术<code>sendfile()</code>）</li>
<li>高伸缩性：每个主题topic包含多个分区partition，主题中的分区可以分布在不同的主机brocker中</li>
<li>持久行、可靠性：可持久化数据，底层十基于Zookeeper存储的</li>
<li>容错性：允许集群中的节点失败，某个节点宕机、kafka集群能够正常工作</li>
</ul>
</li>
<li><p>使用场景</p>
<ul>
<li>活动跟踪：跟踪用户行为，浏览数据发送的kafka，生成报告进行个性化展示</li>
<li>传递消息</li>
<li>日志记录：把数据库的更新发送到Kafka上，用来记录数据库更新，落hive表等</li>
<li>流式处理</li>
<li>限流、削峰、解耦</li>
</ul>
</li>
<li><p>模式</p>
<ul>
<li>点对点</li>
<li>发布订阅模式</li>
</ul>
</li>
<li><p><strong>为什么kafka快？</strong></p>
<ul>
<li>顺序读写：<ul>
<li>kafka将来自product的数据，顺序追加在partition，partition就是一个文件，以此实现顺序写入</li>
<li>consumer从broker读取数据时，因为自带了偏移量，接着上次读取的位置继续读，以此是实现顺序读</li>
</ul>
</li>
<li>零拷贝<code>sendfile()</code>。最重要<ul>
<li>为什么rocketmq不用<code>sendfile</code>而用<code>mmap</code>，因为其将所有的队列的数据都写入了commitLog，消费者批量消费时需要读出来进行应用层过滤(要进入用户态)，所以不用</li>
</ul>
</li>
<li>页缓存(page cache)：消息写道page cache中，等系统统一写入磁盘（可能会有丢失，比如断电）</li>
<li>批量接收和发送消息。减少网络开销</li>
</ul>
</li>
<li><p>美团mafka相对于kafka的改进</p>
<ul>
<li>多租户支持，隔离流量</li>
<li>性能优化</li>
<li>内支持运维工具，兼容性</li>
</ul>
</li>
<li><p>如何保证消息不丢失？</p>
<ul>
<li>从生产者到broker：做好try catch，以及重试</li>
<li>brocker存储消息：在消息刷盘后再给生产者响应，集群部署的话还需要写到副本</li>
<li>从broker到消费者：保证消费者消费完业务后再返回给brocker信息，然后是注意消息消费的幂等性（版本号、唯一键、关键key等）</li>
</ul>
</li>
<li><p>如何保证消息不被重复消费？</p>
<ul>
<li>消息队列的幂等性机制，全局id</li>
<li>消费者自身维护消息的消费记录</li>
<li>分布式锁</li>
</ul>
</li>
<li><p>消息堆积问题？</p>
</li>
<li><p>kafka的事务？让插入的多个topic要么全成功，要么全失败</p>
</li>
</ul>
<h2 id="十二-RPC"><a href="#十二-RPC" class="headerlink" title="十二 RPC"></a>十二 RPC</h2><ul>
<li><strong>RPC</strong>（<strong>R</strong>emote <strong>P</strong>rocedure <strong>C</strong>all），又叫做<strong>远程过程调用</strong>。它本身并不是一个具体的协议，而是一种<strong>调用方式</strong><ul>
<li>gRPC，thrift</li>
</ul>
</li>
<li>发展历史：TCP ==&gt; RPC ==&gt; HTTP</li>
<li>为什么有了RPC还要有HTTP？<ul>
<li>RPC 是针对于Client/Server (C/S) 架构下使用的，如果只需要连接自家的服务器，用RPC是足够的，但是浏览器Browser/Server (B/S)架构，需要访问其他公司的服务器，所以诞生了HTTP</li>
</ul>
</li>
<li>RPC框架<ul>
<li>Dubbo：阿里巴巴开源，仅支持java</li>
<li>Spring Cloud：仅支持java</li>
<li>gRPC：google开源，多语言</li>
<li>Thrift：facebook开源，多语言</li>
</ul>
</li>
<li>Thrift组件<ul>
<li>Transport：传输组件，负责网络读写相关</li>
<li>Protocol：协议和解编码组件，负责对网络数据传输的序列/反序列化</li>
<li>Processor：服务调用组件</li>
<li>Server：服务器</li>
</ul>
</li>
<li>基本过程<ul>
<li>客户端发起调用</li>
<li>客户端存根stub处理：根据调用的方法名、参数等打包编码为特定格式的消息体</li>
<li>网络传输</li>
<li>服务端存根stub处理：进行拆包和解码，获取方法名和参数</li>
<li>服务端执行调用</li>
<li>逆向返回结果</li>
</ul>
</li>
<li>泛化调用<ul>
<li>在不依赖服务A（没有服务A提供的接口）情况下远程调用服务A的接口</li>
<li>只要调用端将服务需要知道的信息：接口名、业务分组名、参数等封装为请求发送给服务器，服务端解析并处理即可</li>
<li>实现：<ul>
<li>通过一个<code>GenericService</code>来生成动态代理，来实现在没有接口情况下的RPC调用</li>
<li>对于服务端，在获取Tprotocol时，会判断是否泛化调用，如果是泛化调用，会向泛化调用，会向链路中添加泛化调用标识，用于服务端判断是否是泛化调用</li>
<li>在调用时，与普通的调用基本一致，会在请求中额外添加被调用的服务名、方法名等信息在请求header中，用于服务端处理时查找相应的类信息</li>
<li>处理请求时，根据客户端传递的标识，判断是否是泛化调用，如果是则使用<code>GenericServiceTProcessor</code>处理请求</li>
</ul>
</li>
</ul>
</li>
<li>如何手写一个RPC框架？<ul>
<li>动态代理（屏蔽底层调用细节）</li>
<li>序列化（网络传输扁平化数据）：二进制、json等</li>
<li>协议（识别数据）</li>
<li>网络传输（I/O相关，一般使用netty，基于Java NIO做的封装）：同步非阻塞IO</li>
<li>对于多集群来说，还需要一个注册中心做服务发现、路由、负载均衡、异常重试、限流熔断等</li>
</ul>
</li>
<li>RPC和HTTP？<ul>
<li>层级<ul>
<li>Http位于应用层，基于TCP/IP</li>
<li>RPC不是网络模型中的具体层级的协议，它的实现可以依赖于HTTP(应用层)，也可以依赖于TCP(多数)或者UDP</li>
</ul>
</li>
<li>服务发现：<ul>
<li>HTTP是通过DNS获取到IP地址和端口信息</li>
<li>RPC是通过专门的中间服务去做。注册中心</li>
</ul>
</li>
<li>底层连接形式：<ul>
<li>主流的Http1.1建立TCP连接后会保持连接(keep live)，之后的请求相应复用</li>
<li>RPC一般会有一个连接池。不过不少的编程语言会给http加一个连接池(golang)</li>
</ul>
</li>
<li>传输内容<ul>
<li>HTTP以传输文本为主，一般header和body使用JSON序列号反序列化做</li>
<li>RPC定制化程度高，可以采用定制化的协议存储数据结构体</li>
<li>ps：其实http2之后进行了很多的改进，性能可能比RPC更好，gRPC底层用的就是Http2</li>
</ul>
</li>
<li>通信瓶颈：<ul>
<li>RPC主要在于网络、序列反序列化开销、服务器负载、协议开销</li>
<li>http主要在于TCP连接建立、http头部冗余、请求/响应模型的限制、加密解密的开销</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="十三-异步"><a href="#十三-异步" class="headerlink" title="十三 异步"></a>十三 异步</h2><ul>
<li>为什么需要异步？<ul>
<li>调用多个下游服务，串行调用容易导致时间过长的问题</li>
</ul>
</li>
<li>异步和多线程的区别？<ul>
<li>资源利用率：异步通常基于回调机制，允许在等待IO的时候释放线程，线程池会阻塞等待</li>
<li>编码复杂性：多线程需要处理线程同步，线程安全等问题</li>
<li>场景：异步适用于IO密集，多线程适用于CPU密集型</li>
</ul>
</li>
</ul>
<h3 id="13-1-CompletableFuture"><a href="#13-1-CompletableFuture" class="headerlink" title="13.1 CompletableFuture"></a>13.1 CompletableFuture</h3><p><a target="_blank" rel="noopener" href="https://tech.meituan.com/2022/05/12/principles-and-practices-of-completablefuture.html">https://tech.meituan.com/2022/05/12/principles-and-practices-of-completablefuture.html</a></p>
<ul>
<li><p>实现了两个接口：<code>Future</code> 和 <code>Completionstage</code>，前者是java5引入的异步计算，后者用于表示异步执行过程中的一个步骤(<code>thenApply()</code>、<code>thenCombine()</code>等都是<code>Completionstage</code>的方法)</p>
</li>
<li><p>原理：观察者模式</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CompletableFuture</span>&lt;T&gt; <span class="keyword">implements</span> <span class="title class_">Future</span>&lt;T&gt;, CompletionStage&lt;T&gt; {</span><br><span class="line">    <span class="keyword">volatile</span> Object result; 	<span class="comment">// 存储CF执行结果</span></span><br><span class="line">    <span class="keyword">volatile</span> Completion stack;	<span class="comment">// 栈结构，stack为栈顶。表示当前CF当前完成后需要触发的依赖动作</span></span><br><span class="line">    <span class="comment">// CompletableFuture中的每个方法都对应了一个Completion子类，Completion本身是观察者的基类</span></span><br><span class="line">    ...</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p><code>Future</code>的局限性</p>
<ul>
<li>向线程池提交异步任务发起RPC调用，主线程只能阻塞获取Future结果</li>
<li>调用RPC服务通常需要回调的方法完成Future，Future的执行结果依赖向线程池提交的任务返回结果，不支持通过回调的方式来设置返回结果</li>
<li>多个RPC串行执行，后一个RPC依赖前一个响应结果，主线程阻塞组装调用关系，没有回调唤醒机制，主线程反复被阻塞</li>
<li>多个RPC串行执行，后面的RPC依赖前两个RPC的结果作为入参。主线程阻塞等待，当相互依赖的RPC较多时，代码可读性差</li>
<li>Future提供的接口没有异常处理的功能，不能异步处理异常，只能try检查get方法是否抛出异常</li>
</ul>
</li>
<li><p>使用</p>
<ul>
<li><p>创建</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> CompletableFuture&lt;Void&gt; <span class="title function_">runAsync</span><span class="params">(Runnable runnable)</span>; <span class="comment">// 创建无返回任务的异步任务</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> CompletableFuture&lt;Void&gt; <span class="title function_">runAsync</span><span class="params">(Runnable runnable, Executor ex)</span>; <span class="comment">// 指定线程池</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;U&gt; CompletableFuture&lt;U&gt; <span class="title function_">supplyAsync</span><span class="params">(Supplier&lt;U&gt; supplier)</span>; <span class="comment">// 创建有返回值的...</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;U&gt; CompletableFuture&lt;U&gt; <span class="title function_">supplyAsync</span><span class="params">(Supplier&lt;U&gt; supplier, Executor ex)</span>; <span class="comment">// </span></span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>异步回调</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;U&gt; CompletionStage&lt;U&gt; <span class="title function_">thenApply</span><span class="params">(Function&lt;? <span class="built_in">super</span> T, ? extends U&gt; var1)</span>; <span class="comment">// 串行,返回的是一个嵌套的CF，需要get() join()解开</span></span><br><span class="line">CompletionStage&lt;Void&gt; <span class="title function_">thenAccept</span><span class="params">(Consumer&lt;? <span class="built_in">super</span> T&gt; var1)</span>; <span class="comment">// 串行，无返回值</span></span><br><span class="line">thenCombine <span class="comment">// 二元依赖 A B都执行完再到C，直接返回CF，比thenApply方便</span></span><br><span class="line">thenCompose <span class="comment">// 串行执行</span></span><br><span class="line">allOf</span><br><span class="line">anyOf</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>异常处理</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">handle</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>结果获取(注意设置超时时间)</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">join</span><br><span class="line">get</span><br></pre></td></tr></tbody></table></figure>
</li>
</ul>
</li>
</ul>
<h3 id="13-2-Loader"><a href="#13-2-Loader" class="headerlink" title="13.2 Loader"></a>13.2 Loader</h3><ul>
<li>为解决代码难以读懂的问题，一个Loader加载若干个异步调用，通过Loader工厂加载loader</li>
</ul>
<h3 id="13-3-Director"><a href="#13-3-Director" class="headerlink" title="13.3 Director"></a>13.3 Director</h3><ul>
<li>为解决代码难以调试的问题，本质是维护一个有向无环图，来实现异步调用的加载</li>
</ul>
<h2 id="十四-项目场景"><a href="#十四-项目场景" class="headerlink" title="十四 项目场景"></a>十四 项目场景</h2><h3 id="14-1-课程秒杀活动"><a href="#14-1-课程秒杀活动" class="headerlink" title="14.1 课程秒杀活动"></a>14.1 课程秒杀活动</h3><ul>
<li><p>瞬间流量</p>
<ul>
<li><p>前端：</p>
<ul>
<li><p>缓存静态资源</p>
</li>
<li><p>防止多次重复点击</p>
</li>
<li><p>前端到后端的限流（若干个请求取随机部分到后端）</p>
</li>
</ul>
</li>
<li><p>后端</p>
<ul>
<li>热点数据行，删除库存变为insert（容易超卖——lua脚本）</li>
<li>库存拆分，分解到不同的数据库中减小单库压力</li>
<li>消息队列：削峰填谷，非核心业务放到后面做</li>
</ul>
</li>
</ul>
</li>
<li><p>超卖（数据一致性）</p>
<ul>
<li>分布式锁（redis）</li>
<li>redis+lua，保证操作的原子性——这里注意添加一条消息存储订单数据</li>
<li>幂等性设计</li>
</ul>
</li>
<li><p>业务降级和代码降级</p>
</li>
</ul>
<h3 id="14-2-订单超时取消"><a href="#14-2-订单超时取消" class="headerlink" title="14.2 订单超时取消"></a>14.2 订单超时取消</h3><ul>
<li>定时任务：xxl-job，比如定时1min扫描一次表，以时间戳+状态来取数据，判断数据是否超时</li>
<li>redis缓存，设置缓存存在时间：在点击下单的时候给redis设置一个定时缓存，支付的时候再判断缓存是否存在</li>
<li>延时队列<ul>
<li>消息队列的延时任务：下单的是发送一条延时队列（rocketMQ支持，rabbit MQ和kafka需要设计）</li>
<li>redis zset 也可以实现：任务添加到zset，到期时间作为score，获取score值最小的元素与系统时间的关系，没到期就sleep</li>
</ul>
</li>
</ul>
<h3 id="14-3-统计接口的调用次数"><a href="#14-3-统计接口的调用次数" class="headerlink" title="14.3 统计接口的调用次数"></a>14.3 统计接口的调用次数</h3><ul>
<li>ConcurrentHashMap&lt;接口名, 次数&gt; + AtomicInteger + 定时任务</li>
<li>MQ</li>
<li>日志打点记录，后台记录到es中</li>
</ul>
<h3 id="14-4-项目中的文件上传系统"><a href="#14-4-项目中的文件上传系统" class="headerlink" title="14.4 项目中的文件上传系统"></a>14.4 项目中的文件上传系统</h3><ul>
<li>大文件上传：分块上传，再合并，比较md5码</li>
<li>如何避免重复文件：md5</li>
<li>限流：限制上传次数、频次、总文件大小</li>
</ul>
<h3 id="14-5-限流怎么做"><a href="#14-5-限流怎么做" class="headerlink" title="14.5 限流怎么做"></a>14.5 限流怎么做</h3><ul>
<li>redis 分布式锁、incr对象</li>
<li>漏桶算法（宽进严出）：队列实现</li>
<li>令牌桶算法：定速往桶里放令牌，请求来的时候如果桶里有令牌就拿令牌走，没令牌就放弃（面对突发流量有更好的表现）</li>
</ul>
<h3 id="14-6-序列化错误问题"><a href="#14-6-序列化错误问题" class="headerlink" title="14.6 序列化错误问题"></a>14.6 序列化错误问题</h3><ul>
<li>设计<code>StereoWarehouse</code>的后期新增了一个字段，运行客户端打开之前做的案例的时候发现模型无法正常打开，查看报错发现反序列化失败，后续排查的时候发现<code>BaseObj</code>对象是被序列化存储在磁盘中的，未显示的指定<code>serialVersionUID</code>，jdk会根据当前类的结构，继承关系等信息计算出一个序列号，当类的信息发生变化的也发生了变化，导致反序列化失败</li>
<li>解决：设计的demo模型比较简单，重新做了一个并fix了这个bug</li>
<li>也可以回退版本，显示的指定序列号后保存，再更新到当前版本后打开。</li>
</ul>
<h2 id="十五-面试"><a href="#十五-面试" class="headerlink" title="十五 面试"></a>十五 面试</h2><h3 id="8-23-快手1"><a href="#8-23-快手1" class="headerlink" title="8.23 快手1"></a>8.23 快手1</h3><ul>
<li>自我介绍 MT 4min，FS 3min，XC没让介绍了，基本就在问MT实习，问了下实习了多久</li>
<li>介绍一下做的项目中给你带来最多收获的 ： 统一履约接口，事件分发，RPC，泛化调用，异步框架</li>
<li>RPC用的什么，为什么快： thrift，<ul>
<li>自定义传输协议，精简；二进制传输，http是json序列反序列；RPC服务基于TCP/IP，长连接</li>
</ul>
</li>
<li>说一下泛化调用 ： 调用方没有服务方提供的API（SDK）的情况下，对服务方进行调用</li>
<li>RPC最主要的是什么 ： 一开始说了代理、网关面试官提示了一下，是服务注册上报</li>
<li>MQ用的什么： kafka，</li>
<li>怎么了解的 kafka：对比了rabbitMQ和kafka的区别：分区；顺序读写；零拷贝；页缓存(数据丢失原因)；批量收发</li>
<li>异步框架是什么：CF，loader，director框架，讲了一下框架的底层原理</li>
<li>讲一个业务开发，设计到了什么技术：KA，讲了一下kafka2hive，讲了日志打点的设计发展历程体现一下自己的思考（rpc接口 —&gt; 耦合高；注解解耦 —&gt; 历史代码不好处理；最后才一个一个搞）<ul>
<li>补充了一下sdk的方式</li>
</ul>
</li>
<li>MT转正情况</li>
<li>怎么理解error和exception：都继承了Throwable，前者不可恢复，后者用于catch处理业务异常IOException和RuntimeException</li>
<li><strong>为什么只有java才有exception</strong><ul>
<li>准确的说是只有java会强制check exception，核心目标是划分责任</li>
</ul>
</li>
<li><strong>数据结构：堆和栈</strong><ul>
<li>堆：堆通常是一个可以被看做一棵树的数组对象</li>
<li>栈：是只允许在一端进行插入或删除的线性表</li>
</ul>
</li>
<li><strong>操作系统：堆和栈</strong><ul>
<li>堆：堆是在程序运行时申请的动态内存，而不是在程序编译时，申请某个大小的内存空间。</li>
<li>栈：是操作系统在建立某个进程时或者线程，为这个线程建立的存储区域，在编译的时候可以指定需要的栈的大小</li>
</ul>
</li>
<li>DFS和BFS：深度和广度优先</li>
<li>网络4层结构和7层：应用层、传输层、网络层、网络接口层<ul>
<li><strong>7层</strong>：应用层、表示层、会话层、传输层、网络层、数据链路层、物理层</li>
</ul>
</li>
<li>http和https区别：多了一个tls，CA非对称加密算法</li>
<li><p>为什么用非对称又用对称加密：速度</p>
</li>
<li><p>讲一下设计模式</p>
<ul>
<li>build模式：实现构造器的按需创建</li>
<li>工厂模式：封装对象的创建，IOC思想</li>
<li>装饰模式：IO</li>
</ul>
</li>
<li>spring中的设计模式<ul>
<li>工厂模式：Factory</li>
<li>代理模式：AOP</li>
<li>单例模式：单例bean</li>
<li>适配器模式：Spring AOP的<code>AdvicorAdapter</code></li>
<li>观察者模式：<code>ApplicationListener</code>，CF也使用到了观察者模式</li>
<li>责任链模式</li>
</ul>
</li>
<li><p>手撕：两数之和</p>
<ul>
<li>用一个map，O(N)，当时没反应过来，用的for</li>
</ul>
</li>
<li><p>总结：面试官太好了 疯狂给机会</p>
</li>
</ul>
<h3 id="8-24-快手2"><a href="#8-24-快手2" class="headerlink" title="8.24 快手2"></a>8.24 快手2</h3><ul>
<li><p>自我介绍 MT 3min40s，FS 2min，XC 2min</p>
</li>
<li><p>上线是自己上的还是？mentor</p>
</li>
<li><p>困难点？RPC，异步框架</p>
</li>
<li><p>遇到的问题？升级jar依赖冲突，回滚</p>
</li>
<li><p>事后有复盘吗？没有</p>
</li>
<li><p><strong>BeanFactory和FactoryBean</strong>？BeanFactory是IOC基础，常用ApplicationContext；FactoryBean是工厂类的接口，负责创建bean</p>
<ul>
<li><p>BeanFactory</p>
<ul>
<li>bean实例化和管理：BeanFactory负责创建、初始化和管理Bean的生命周期。它会根据配置文件中定义的Bean定义来创建Bean的实例。</li>
<li>依赖注入：BeanFactory负责解决Bean之间的依赖关系，确保每个Bean都能获取它所依赖的其他Bean</li>
<li>配置元数据的管理：xml、注解、Java配置的数据</li>
<li>延迟初始化：lazy</li>
<li>AOP支持</li>
<li>通常不直接使用，用ApplicationContext</li>
</ul>
</li>
<li><p>FactoryBean</p>
<ul>
<li><p>自定义bean创建过程</p>
</li>
<li><p>懒加载</p>
</li>
<li><p>bean的包装：创建代理</p>
</li>
<li><p>处理复杂逻辑</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">FactoryBean</span>&lt;T&gt; {</span><br><span class="line">    <span class="type">String</span> <span class="variable">OBJECT_TYPE_ATTRIBUTE</span> <span class="operator">=</span> <span class="string">"factoryBeanObjectType"</span>;</span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    T <span class="title function_">getObject</span><span class="params">()</span> <span class="keyword">throws</span> Exception;</span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    Class&lt;?&gt; getObjectType();</span><br><span class="line">    <span class="keyword">default</span> <span class="type">boolean</span> <span class="title function_">isSingleton</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AFactoryBean</span> <span class="keyword">implements</span> <span class="title class_">FactoryBean</span>&lt;A&gt; {</span><br><span class="line">	<span class="keyword">public</span> A <span class="title function_">getObject</span><span class="params">()</span> <span class="keyword">throws</span> Exception {</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">A</span>();</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">getBean(<span class="string">"A"</span>)会得到A这个bean</span><br><span class="line"><span class="title function_">getBean</span><span class="params">(<span class="string">"&amp;A"</span>)</span>会得到AFactoryBean</span><br></pre></td></tr></tbody></table></figure>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li><p><strong>举例一下FactoryBean，可以从框架出发</strong></p>
<ul>
<li>mybatis：SqlSessionFactory</li>
</ul>
</li>
<li><p>spring的设计模式：单例、责任链、代理、观察者、工厂</p>
</li>
<li><p>为什么用单例模式：</p>
<ul>
<li>一个全局使用的类频繁地创建与销毁</li>
<li>节省系统资源</li>
</ul>
</li>
<li><p>消息堆积怎么处理？</p>
<ul>
<li>生产者：业务层面消息精简</li>
<li>broker：增加分区，先持久化存储</li>
<li>消费者：扩容</li>
<li>批量消费</li>
<li>降级处理</li>
</ul>
</li>
<li><p>能无线扩容吗？不能，举例了redis集群分片哈希槽</p>
</li>
<li><p><strong>关于跨域问题？</strong></p>
<ul>
<li>由于浏览器的同源策略：协议、主机名、端口号，任何一个不一致都会导致跨域问题</li>
<li>JSONP：利用了<code>&lt;script&gt;</code>标签不受同源策略限制的特性</li>
<li>CORS：Http请求头，服务器在响应头添加<code>Access-Control-Allow-Origin</code></li>
<li>反向代理：反向代理服务器和服务端在一个域名下，可以实现转发</li>
<li>WebSocket：可以用于跨域通信</li>
<li>spring处理方案<ul>
<li>Controller添加<code>@CrossOrigin</code>注解</li>
<li>添加<code>WebMvcConfiguration</code>全局配置</li>
<li>Filter</li>
<li>GateWay端增加CorsFilter拦截器</li>
</ul>
</li>
</ul>
</li>
<li><p>ThreadLocal的理解？ThreadLocalMap，对Entry是一个弱引用，内存泄漏风险</p>
<ul>
<li>Entry的key是ThreadLocal，v是设置的值</li>
<li>gc的时候如果外部对ThreadLocal没有强引用会回收ThreadLocal，导致entry的key是null，但是value没有被回收</li>
</ul>
</li>
<li><p>ThreadLocal可以被继承吗？不能</p>
</li>
<li><p>如果子线程需要继承怎么办？<code>public class InheritableThreadLocal&lt;T&gt; extends ThreadLocal&lt;T&gt;</code></p>
</li>
<li><p>mysql的锁机制？</p>
<ul>
<li>乐观锁</li>
<li>悲观锁<ul>
<li>表锁</li>
<li>行锁 innodb<ul>
<li>行锁</li>
<li>间隙锁（幻读）</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>MVCC的理解</p>
<ul>
<li>隐藏主键</li>
<li>undolog</li>
<li>readview</li>
</ul>
</li>
<li><p>MVCC和锁？MVCC不加锁，事务并发修改</p>
</li>
<li><p><strong>如果遇到网站攻击怎么处理？</strong>讲了大量请求用黑名单、直接攻击数据库用redis缓存</p>
<ul>
<li>CC攻击（应用层）：大量的请求——网关黑名单</li>
<li>DDOS攻击（多个层面）：利用大量的计算机和代理服务器同时向服务端发送大量请求。比如SYN攻击、UDP攻击、ICMP攻击<ul>
<li>流量清洗</li>
</ul>
</li>
<li>CC攻击模拟了正常请求，更能防御</li>
</ul>
</li>
<li><p>做的项目用了什么设计模式？</p>
<ul>
<li>AOP</li>
</ul>
</li>
<li><p>手撕：int num交换两位使得数字结果最大，上午刚写完oppo笔试手感火热秒了</p>
</li>
<li><p>聊天环节：电商、直播、广告、游戏，前三者基本饱和，目前发展游戏——自研化、精品化</p>
<ul>
<li>对内平台工具、对外登录、支付、防沉迷等</li>
<li>杭州</li>
</ul>
</li>
</ul>
<h3 id="8-26-淘天1"><a href="#8-26-淘天1" class="headerlink" title="8.26 淘天1"></a>8.26 淘天1</h3><ul>
<li>淘工厂</li>
<li>自我介绍 MT 3min，FS 2min，XC 跳过</li>
<li>转正情况</li>
<li>MT技术架构</li>
<li>项目有没有本地运行</li>
<li>spring没有启动起来怎么排查问题：启动日志</li>
<li>日志输出在哪里？log4j</li>
<li>升级jar包后bean没有依赖的问题是什么？这段答的比较差</li>
<li>mybatis使用的是声明？xml，显式的时候sql</li>
<li>显式的使用sql有什么问题</li>
<li>写sql的时候考虑的效率问题？慢查询——联表放在业务、命中索引</li>
<li>如何考虑建立索引？</li>
<li>索引的类型</li>
<li>如何分析慢查询？explain</li>
<li>MT redis使用场景？缓存、分布式锁</li>
<li>redis和mysql如何保证数据一致性？旁路缓存、读写穿透、异步缓存</li>
<li>为什么先更新数据库再删除redis？高并发下的数据一致</li>
<li>kafka使用场景</li>
<li>为什么需要kafka2hive？方便查询</li>
<li>PRC调用的流程？依赖client、配置bean、调用</li>
<li>RPC版本升级怎么处理？如果接口中新增参数，会不匹配报错</li>
<li><strong>如果接口的对象删除了一个字段有没有问题？</strong><ul>
<li>用的json，会忽略额外的字段，比如A对象ab 2个字段，传入的JSON有abc 3个字段，那么序列化的时候只会注入ab两个字段</li>
</ul>
</li>
<li>反问环节？业务：淘工厂</li>
</ul>
<h3 id="8-26-字节1"><a href="#8-26-字节1" class="headerlink" title="8.26 字节1"></a>8.26 字节1</h3><ul>
<li>MT 3min，FS 2min，XC 0</li>
<li>遇到的问题？商家履约一体化对RPC和异步的理解</li>
<li>RPC的超时时间？全局定义，bean定义</li>
<li>CF的理解？底层是维护了一个栈结构</li>
<li>多次部分退背景，面临的问题，如何处理涉及商品券商品的处理</li>
<li>灰度、降级开关的目的，设置原则</li>
<li>灰度如何实现？代码层面，也有平台层面</li>
<li>上线后如何观测？业务上商家反馈，代码上观察日志</li>
<li>KA大盘上报过程？监控平台提供上报SDK，wm sg yy phf调用<ul>
<li>可以说一下方式的演变（KS）</li>
</ul>
</li>
<li>线上问题举一个例子？网关无限重试问题<ul>
<li>线下环境一直推送订单给KD，KD因为缓存接口地址错误，导致一直请求到线上，出现大量告警</li>
<li>初步措施：网关限流</li>
<li>排查：网关回调和通知策略一致，导致失败的时候还进行了重试，引发循环调用</li>
<li>为什么线上没有问题：7.9-7.11hive没有失败数据</li>
<li>短期方案：改为不额外通知，只有最后失败的时候才通知</li>
<li>长期方案：<ul>
<li>网关对推送加标，进行过滤</li>
<li>WM差异化处理延迟和回调接口</li>
</ul>
</li>
</ul>
</li>
<li>没有做打点吗？这里记错了，客诉产生的同时也出现了线上告警</li>
<li>并发安全？分布式锁；并发集合类</li>
<li>分布式锁怎么用的？订单索引模型，redis setnx</li>
<li>分布式锁过期问题？看门狗机制，代码中没用过</li>
<li>线程池？复用线程减少创建销毁的性能开销，核心参数</li>
<li>核心线程数设置原则？任务类型，IO or CPU</li>
<li>消息队列？解耦，削峰填谷，<strong>异步</strong></li>
<li>如何保证消息不被重复消费？保证事务的幂等，给消息设置一个全局唯一的id</li>
<li>spring bean的生命周期<ul>
<li>bean构造函数、setter、aware接口、BeanPostProcessor接口、InitializingBean接口、init方法、BeanPostProcessor接口、使用、DisposableBean接口，DisposableBean方法</li>
</ul>
</li>
<li>mysql 慢查询问题？explain<ul>
<li>开启慢查询日志</li>
</ul>
</li>
<li><p><strong>最左匹配原则</strong>，(a,b,c) 如果使用了(a,c)也会使用，只不过只会命中a </p>
</li>
<li><p>链表倒数第k个节点</p>
</li>
<li>做的中台</li>
</ul>
<h3 id="8-27-百度1"><a href="#8-27-百度1" class="headerlink" title="8.27 百度1"></a>8.27 百度1</h3><ul>
<li>MT 2min30s，FS 2min30s，XC 30s</li>
<li>web服务和客户端的区别？资源的存放</li>
<li><p>简述一下履约组的业务，怎么学习的，技术架构，如何划分的微服务？订单全生命周期</p>
</li>
<li><p>RPC和HTTP？</p>
</li>
<li><p>HTTP和TCP长连接的含义？</p>
<ul>
<li>HTTP协议的长连接和短连接，本质上是TCP协议的长连接和短连接。</li>
<li>HTTP1.0默认短连接，当客户访问一个web资源的时候，每遇到一个资源就建立一个tcp连接</li>
<li>HTTP1.1默认长连接，当一个网页打开后不会断开，复用TCP的连接</li>
</ul>
</li>
<li>短连接谁主动断开？一般是客户端</li>
<li><strong>长连接如何判断包的顺序</strong>？比如发出A，B两个请求，如何判断收到的C响应对应的哪个？<ul>
<li>传输层：TCP层面来说有序列号</li>
<li>应用层：HTTP在请求头或者请求体中添加UUID</li>
<li>HTTP2使用了流来隔离每个请求和响应</li>
</ul>
</li>
<li>异步框架？CF</li>
<li>线程池如何定义？核心线程数设置原则</li>
<li>最大线程数的设置原则</li>
<li><p>线程池释放空闲线程是怎么选择的？推测可能是LRU</p>
<ul>
<li>根据keepAliveTime，JVM当前状态等，具体会删哪个无法推测</li>
</ul>
</li>
<li><p>IOC和AOP</p>
</li>
<li>bean的生命周期</li>
<li>IOC底层的数据结构</li>
<li><p>循环依赖</p>
</li>
<li><p>kafka？分区、0拷贝</p>
</li>
<li>0拷贝？没有用户态和内核态的切换，没有CPU的拷贝（DMA）</li>
<li><strong>分区数量和生产者、消费者的数量关系</strong><ul>
<li>1个 producer 可以生产不同 topic 的消息，</li>
<li>1个 topic 的消息被存放到不同的分区 partition 中，可以指定也可以 hash 自动计算</li>
<li>partition 的消息以 offset 的偏移顺序存储</li>
<li>1个topic的消息被多个consumer消费，这些consumer组成group，单个partition的消息只能由单个consumer消费，主动拉取的方式并更新offset偏移量</li>
<li>1个topic也可以有多个consumer group</li>
</ul>
</li>
<li>字符串中第一个只出现1次的字符。用的linkedHashMap<ul>
<li>用一个int[52] 即可</li>
</ul>
</li>
</ul>
<h3 id="8-31-得物1（全八股）"><a href="#8-31-得物1（全八股）" class="headerlink" title="8.31 得物1（全八股）"></a>8.31 得物1（全八股）</h3><ul>
<li><p>自我介绍</p>
</li>
<li><p>mysql索引结构，其他的数据结构呢？hash、二叉树、AVI树、红黑树、B+树</p>
</li>
<li>如何考虑自建索引？</li>
<li>mysql事务</li>
<li><p>不可重复读和幻读的解决？MVCC，以及加间隙锁</p>
</li>
<li><p>间隙锁的缺点？并发性能，死锁问题</p>
</li>
<li><p>死锁条件以及破坏？4个</p>
</li>
<li><p>redis分布式锁</p>
</li>
<li>redis setnx为什么是原子性？单线程</li>
<li>IO模型，多路复用这些</li>
<li>异步模型的应用？讲了Future，</li>
<li>算法：三数之和为0<ul>
<li>三指针，排序，固定a，然后从b=a+1 c=arr[n-1]，b c指针向中间靠，复杂度O(n2)</li>
</ul>
</li>
</ul>
<h3 id="8-31-pdd1"><a href="#8-31-pdd1" class="headerlink" title="8.31 pdd1"></a>8.31 pdd1</h3><ul>
<li>自我介绍</li>
<li>MT主要难点：RPC的异步编排，Loader，Director</li>
<li>如果是一个任务不涉及到RPC，用单线程还是多线程？单线程<ul>
<li>ListenableFuture</li>
</ul>
</li>
<li>使用线程池的缺点？只讲到了线程上下文切换的性能开销<ul>
<li>切换性能开销</li>
<li>线程池管理开销</li>
<li>任务调度延迟</li>
</ul>
</li>
<li>java的线程是用户态还是内核态？用户态</li>
<li>两者区别，<strong>从用户切换的内核方式</strong>？系统调用<ul>
<li>中断：当硬件设备（如时钟、中断控制器、I/O设备）发生事件时，会触发中断。中断会强制CPU从当前正在执行的用户态代码切换到内核态，以执行相应的中断处理程序。</li>
<li>系统调用</li>
<li>异常：异常是由CPU在执行指令时检测到某些错误或特殊情况（如除零、无效内存访问、缺页等）引发的。异常会导致从用户态切换到内核态，以便操作系统处理这些异常。</li>
</ul>
</li>
<li>ConcurrentHashMap</li>
<li>java锁的底层锁的是什么？只回答到了对象上的描述文件（忘了叫啥了）<ul>
<li>对象头的Mark Word：存储锁的信息，如锁的状态、线程ID、哈希码</li>
<li>java对象头<ul>
<li>Mark Word：哈希码（HashCode）、GC标记、锁标志位、锁的线程ID、偏向锁的线程ID、年龄信息等。</li>
<li>Class Pointer（类型指针）：通过它找到存储的实例</li>
<li>Array Length（数组长度，只有数组对象有）</li>
</ul>
</li>
</ul>
</li>
<li>JVM结构</li>
<li>堆的划分：老年和新生，CMS和G1</li>
<li>MT用的什么：CMS</li>
<li>新生代细分：Eden，S0，S1</li>
<li>手撕：很离谱的手撕（面试官自己想的）<ul>
<li>一个list存储了若干个Item，Item的内部有一个String text的对象，表示RPC请求内容，要求将这个list表示的若干个请求分发为多次发送，使得每次请求的Item数量不超过一个max值且数量尽可能的均匀，对于每次请求，是由若干个Item组成，要求Item的长度尽可能的相等（一个Item可以被切割为若干份）</li>
<li>不知道他在说什么，题目也改来改去</li>
</ul>
</li>
</ul>
<h3 id="9-2-oppo1"><a href="#9-2-oppo1" class="headerlink" title="9.2 oppo1"></a>9.2 oppo1</h3><ul>
<li>自我介绍</li>
<li>多次部分退背景，做了哪些开发</li>
<li>设计模式，开发过程中用了哪些模式</li>
<li>fs开发，怎么做的节拍统计</li>
<li>遇到的问题？fs的立体仓库堆垛机</li>
<li>MT的困难？异步的理解过程</li>
<li>设计rpc接口的异常处理</li>
</ul>
<h3 id="9-2-字节2（十分开放）"><a href="#9-2-字节2（十分开放）" class="headerlink" title="9.2 字节2（十分开放）"></a>9.2 字节2（十分开放）</h3><ul>
<li>自我介绍</li>
<li>学习路线是怎么制定的</li>
<li>minIO实现分布式的部署怎么去做？类举了redis集群</li>
<li>哈希槽理解？哈希映射</li>
<li>哈希槽的扩容缩容问题？<ul>
<li>渐进式rehash</li>
</ul>
</li>
<li>redis集群？<ul>
<li>主从</li>
<li>集群</li>
<li>数据持久化</li>
</ul>
</li>
<li>es，如果一个es对应多个实体，如何避免回表<ul>
<li>同步双写</li>
<li>异步双写：消息队列、内存队列</li>
<li>定期同步</li>
<li><strong>数据订阅：利用binlog：canal Server 是一个伪装的slave节点，接收到binlog日志后，发送到MQ, 其他的 存储消费 MQ里边 的binlog日志，实现数据订阅。</strong>（业务侵入小、实时性好）</li>
</ul>
</li>
<li><p>如果读取到的mysql从节点的数据不是最新的怎么办？利用版本号判断，如果不是采用重试机制</p>
</li>
<li><p>做指标监控？</p>
<ul>
<li>同环比监控</li>
<li>接口时延、成功率等进行监控</li>
</ul>
</li>
<li><p>SLA指标？</p>
<ul>
<li>可用性TP99</li>
<li>准确性</li>
<li>系统容量QPS</li>
</ul>
</li>
<li>如何减少告警后人为的干预？AI训练</li>
<li>手撕：字符串的无重复组合。递归秒了</li>
</ul>
<h3 id="9-2-阿里1"><a href="#9-2-阿里1" class="headerlink" title="9.2 阿里1"></a>9.2 阿里1</h3><ul>
<li>20min极速，开门见山，自我介绍都不用（KPI）</li>
<li>项目过程中遇到的问题。异步编排</li>
<li>技术上的挑战？KA，AOP的思路</li>
<li>日志文件怎么收集到kafka？定时任务</li>
<li>为什么用kafka，和rabbitMQ对比？kafka的吞吐量、分区</li>
<li>如何检测异常？同环比对比</li>
<li>kafka2Hive，如何减少？用缓存</li>
<li>mysql索引结构？B+</li>
<li>es和mysql区别？倒排索引的过程</li>
<li>docker了解吗？</li>
<li>JWT原理？无状态，header、payload、签名三部分</li>
<li>如果用户退出登录，要让这个JWT立即失效怎么做？<ul>
<li>JWT设置有效时间</li>
<li>退出后将用户设置到一个退出名单中（有点session的意思）</li>
<li>JWT增加版本号，退出后改变版本号</li>
<li>服务端设置加密的key，为每个用户生成唯一的key，失效则改变key</li>
</ul>
</li>
</ul>
<h3 id="9-3-阿里云1"><a href="#9-3-阿里云1" class="headerlink" title="9.3 阿里云1"></a>9.3 阿里云1</h3><ul>
<li>八股盛宴</li>
<li>JDK、JRE、JVM关系</li>
<li>concurrentHashmap和hashTable</li>
<li><strong>concurrentHashmap两种实现方法</strong><ul>
<li>jdk8之前：分段锁，segment进行分段加锁</li>
<li>jdk8及之后：节点锁，对节点进行加锁，粒度更细。同时也支持CAS算法进行无锁操作</li>
</ul>
</li>
<li>垃圾回收算法：标记清除、复制、标记整理、分代收集</li>
<li>新生代和老年代</li>
<li>内存泄漏和内存溢出的区别<ul>
<li>泄露memory leak：指程序在申请内存后，无法释放已申请的内存空间（threadlocal）</li>
<li>溢出out of memory：指程序在申请内存时，没有足够的内存空间供其使用</li>
</ul>
</li>
<li><strong>进程被杀掉后泄漏的内存会被回收吗</strong>？操作系统会回收这部分的内存</li>
<li>线程同步和互斥的方法？<ul>
<li>同步：信号量、事件、消息队列</li>
<li>互斥：互斥锁、临界区、读写锁、原子操作</li>
</ul>
</li>
<li><strong>事件的理解</strong><ul>
<li>事件可以是一个信号、一个消息、一个状态变化等，它使得线程或任务能够基于这个条件进行等待或继续执行。</li>
</ul>
</li>
<li>死锁的理解？四大条件</li>
<li>操作系统进程和线程区别</li>
<li>TCP三次握手</li>
<li>TCP的可靠传输：确认机制、超时重传、流量控制、拥塞控制</li>
<li><p>Https过程</p>
</li>
<li><p>数据库的事务：原子性、一致性、隔离性、持久性</p>
</li>
<li><p>索引优缺点</p>
</li>
<li><p>索引不用B+树可以吗？IO、范围查询、数据结构优化三方面</p>
</li>
<li><p>设计模式</p>
</li>
<li><p>观察者模式解决的问题：实现对象之间的一对多依赖关系，当一个对象的状态发生变化时，所有依赖于它的对象都得到通知并被自动更新。</p>
</li>
<li>不用观察者模式怎么做：轮询、发布-订阅模式、回调机制、状态共享或事件驱动架构</li>
<li>算法：一个序列非常非常大，找出最大最小值。<ul>
<li>可以分段，使用并行的方式去找，最后再同步结果</li>
</ul>
</li>
<li>一致性哈希：哈希环</li>
<li>MT最大的挑战</li>
<li>RPC过程</li>
<li>FS挑战</li>
<li>做的公共云，AI的应用，后续还有两轮技术</li>
</ul>
<link rel="stylesheet" href="https://cdn1.tianli0.top/gh/zhheo/Post-Abstract-AI@0.15.2/tianli_gpt.css">

<script>
let tianliGPT_postSelector = '#post #article-container';
let tianliGPT_key = 'c9b7741d290063ab872e';
</script>
<script src="https://cdn1.tianli0.top/gh/zhheo/Post-Abstract-AI@0.15.2/tianli_gpt.js"></script>



</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="http://yileman.github.io">myl</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://yileman.github.io/posts/54082.html">http://yileman.github.io/posts/54082.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://yileman.github.io" target="_blank">myl's blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E5%9F%BA%E7%A1%80/">基础</a></div><div class="post_share"><div class="social-share" data-image="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/cover/article_cover2.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer=""></script></div></div><nav class="pagination-post" id="pagination"><div class="next-post pull-full"><a href="/posts/28758.html" title="计算机网络"><img class="cover" src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/cover/article_cover19.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">计算机网络</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/posts/1079.html" title="操作系统"><img class="cover" src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/cover/article_cover20.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-04-08</div><div class="title">操作系统</div></div></a></div><div><a href="/posts/28758.html" title="计算机网络"><img class="cover" src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/cover/article_cover19.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-04-18</div><div class="title">计算机网络</div></div></a></div></div></div><hr class="custom-hr"><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="twikoo-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/touxiang.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"></div><div class="author-info__name">myl</div><div class="author-info__description">后端学习</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">23</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">8</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">4</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/yileman"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">写写记记</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80-JavaSE"><span class="toc-number">1.</span> <span class="toc-text">一 JavaSE</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.1.</span> <span class="toc-text">1数据类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E6%8E%A5%E5%8F%A3"><span class="toc-number">1.2.</span> <span class="toc-text">2 接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E6%8A%BD%E8%B1%A1%E7%B1%BB"><span class="toc-number">1.3.</span> <span class="toc-text">3 抽象类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-Object%E7%B1%BB%E9%80%9A%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-number">1.4.</span> <span class="toc-text">4 Object类通用方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-static"><span class="toc-number">1.5.</span> <span class="toc-text">5 static</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E5%8F%8D%E5%B0%84"><span class="toc-number">1.6.</span> <span class="toc-text">6 反射</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-%E5%BC%82%E5%B8%B8"><span class="toc-number">1.7.</span> <span class="toc-text">7 异常</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-%E6%B3%9B%E5%9E%8B"><span class="toc-number">1.8.</span> <span class="toc-text">8 泛型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-%E6%B3%A8%E8%A7%A3"><span class="toc-number">1.9.</span> <span class="toc-text">9 注解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-SPI%E6%9C%BA%E5%88%B6"><span class="toc-number">1.10.</span> <span class="toc-text">10 SPI机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6"><span class="toc-number">1.11.</span> <span class="toc-text">11 集合框架</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.12.</span> <span class="toc-text">12 设计模式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C-JVM"><span class="toc-number">2.</span> <span class="toc-text">二 JVM</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E7%B1%BB%E5%8A%A0%E8%BD%BD"><span class="toc-number">2.1.</span> <span class="toc-text">1 类加载</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84"><span class="toc-number">2.2.</span> <span class="toc-text">2 内存结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B"><span class="toc-number">2.3.</span> <span class="toc-text">3 java内存模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6"><span class="toc-number">2.4.</span> <span class="toc-text">4 垃圾回收</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-JVM%E5%8F%82%E6%95%B0-%E8%B0%83%E4%BC%98"><span class="toc-number">2.5.</span> <span class="toc-text">5 JVM参数/调优</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7"><span class="toc-number">2.6.</span> <span class="toc-text">6 分析工具</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-JVM%E8%BF%9C%E7%A8%8B%E8%B0%83%E8%AF%95remote-debug"><span class="toc-number">2.7.</span> <span class="toc-text">7 JVM远程调试remote debug</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-linux-%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5"><span class="toc-number">2.8.</span> <span class="toc-text">8 linux 问题排查</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89-%E5%B9%B6%E5%8F%91"><span class="toc-number">3.</span> <span class="toc-text">三 并发</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E7%90%86%E8%AE%BA"><span class="toc-number">3.1.</span> <span class="toc-text">1 理论</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E7%BA%BF%E7%A8%8B"><span class="toc-number">3.2.</span> <span class="toc-text">2 线程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E9%94%81"><span class="toc-number">3.3.</span> <span class="toc-text">3 锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">3.4.</span> <span class="toc-text">4 关键字</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-JUC%E6%A1%86%E6%9E%B6"><span class="toc-number">3.5.</span> <span class="toc-text">5 JUC框架</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B-IO"><span class="toc-number">4.</span> <span class="toc-text">四 IO</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-JavaIO"><span class="toc-number">4.1.</span> <span class="toc-text">1 JavaIO</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-JavaIO%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E2%80%94%E8%A3%85%E9%A5%B0%E8%80%85"><span class="toc-number">4.2.</span> <span class="toc-text">2 JavaIO设计模式—装饰者</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-IO%E4%B8%AD%E5%B8%B8%E8%A7%81%E7%B1%BB%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">4.3.</span> <span class="toc-text">3 IO中常见类的使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-Unix-IO%E6%A8%A1%E5%9E%8B"><span class="toc-number">4.4.</span> <span class="toc-text">4 Unix IO模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-NIO"><span class="toc-number">4.5.</span> <span class="toc-text">5 NIO</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94-%E6%95%B0%E6%8D%AE%E5%BA%93"><span class="toc-number">5.</span> <span class="toc-text">五 数据库</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E6%A6%82%E8%BF%B0"><span class="toc-number">5.1.</span> <span class="toc-text">1 概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93%E2%80%94MySQL"><span class="toc-number">5.2.</span> <span class="toc-text">2 关系型数据库—MySQL</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-NoSQL%E2%80%94Redis"><span class="toc-number">5.3.</span> <span class="toc-text">3 NoSQL—Redis</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-NoSQL%E2%80%94ES"><span class="toc-number">5.4.</span> <span class="toc-text">4 NoSQL—ES</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AD-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C"><span class="toc-number">6.</span> <span class="toc-text">六 计算机网络</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-1-base"><span class="toc-number">6.1.</span> <span class="toc-text">6.1 base</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-2-Http"><span class="toc-number">6.2.</span> <span class="toc-text">6.2 Http</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-3-TCP"><span class="toc-number">6.3.</span> <span class="toc-text">6.3 TCP</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-4-IP"><span class="toc-number">6.4.</span> <span class="toc-text">6.4 IP</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%83-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F"><span class="toc-number">7.</span> <span class="toc-text">七 操作系统</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#7-1-%E7%A1%AC%E4%BB%B6%E7%BB%93%E6%9E%84"><span class="toc-number">7.1.</span> <span class="toc-text">7.1 硬件结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-2-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84"><span class="toc-number">7.2.</span> <span class="toc-text">7.2 操作系统结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-3-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86"><span class="toc-number">7.3.</span> <span class="toc-text">7.3 内存管理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-4-%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86"><span class="toc-number">7.4.</span> <span class="toc-text">7.4 进程管理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-5-%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95"><span class="toc-number">7.5.</span> <span class="toc-text">7.5 调度算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-6-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F"><span class="toc-number">7.6.</span> <span class="toc-text">7.6 文件系统</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-7-%E8%AE%BE%E5%A4%87%E7%AE%A1%E7%90%86"><span class="toc-number">7.7.</span> <span class="toc-text">7.7 设备管理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-8-%E7%BD%91%E7%BB%9C%E7%AE%A1%E7%90%86"><span class="toc-number">7.8.</span> <span class="toc-text">7.8 网络管理</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AB-%E5%B7%A5%E5%85%B7"><span class="toc-number">8.</span> <span class="toc-text">八 工具</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-git"><span class="toc-number">8.1.</span> <span class="toc-text">1 git</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-maven"><span class="toc-number">8.2.</span> <span class="toc-text">2 maven</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B9%9D-Spring"><span class="toc-number">9.</span> <span class="toc-text">九 Spring</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#9-1-%E7%AE%80%E4%BB%8B"><span class="toc-number">9.1.</span> <span class="toc-text">9.1 简介</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-2-%E6%8E%A7%E5%88%B6%E5%8F%8D%E8%BD%ACIOC%E3%80%81%E5%8F%8ADI"><span class="toc-number">9.2.</span> <span class="toc-text">9.2 控制反转IOC、及DI</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-3-AOP"><span class="toc-number">9.3.</span> <span class="toc-text">9.3 AOP</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-4-Sping-MVC"><span class="toc-number">9.4.</span> <span class="toc-text">9.4 Sping MVC</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-5-Bean"><span class="toc-number">9.5.</span> <span class="toc-text">9.5 Bean</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-6-%E4%BA%8B%E5%8A%A1"><span class="toc-number">9.6.</span> <span class="toc-text">9.6 事务</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-7-%E5%B8%B8%E7%94%A8%E6%B3%A8%E8%A7%A3"><span class="toc-number">9.7.</span> <span class="toc-text">9.7 常用注解</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%81-Spring-Boot"><span class="toc-number">10.</span> <span class="toc-text">十 Spring Boot</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#10-1-%E5%B8%B8%E7%94%A8%E6%B3%A8%E8%A7%A3"><span class="toc-number">10.1.</span> <span class="toc-text">10.1 常用注解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-2-%E5%BC%80%E5%8F%91%E5%AE%9E%E8%B7%B5"><span class="toc-number">10.2.</span> <span class="toc-text">10.2 开发实践</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-3-%E5%85%B6%E4%BB%96"><span class="toc-number">10.3.</span> <span class="toc-text">10.3 其他</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-4-spring-cloud"><span class="toc-number">10.4.</span> <span class="toc-text">10.4 spring cloud</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%81%E4%B8%80-%E5%85%B6%E4%BB%96%E4%B8%AD%E9%97%B4%E4%BB%B6"><span class="toc-number">11.</span> <span class="toc-text">十一 其他中间件</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-Mybatis"><span class="toc-number">11.1.</span> <span class="toc-text">1 Mybatis</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-RabbitMQ"><span class="toc-number">11.2.</span> <span class="toc-text">2 RabbitMQ</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-kafka"><span class="toc-number">11.3.</span> <span class="toc-text">3 kafka</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%81%E4%BA%8C-RPC"><span class="toc-number">12.</span> <span class="toc-text">十二 RPC</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%81%E4%B8%89-%E5%BC%82%E6%AD%A5"><span class="toc-number">13.</span> <span class="toc-text">十三 异步</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#13-1-CompletableFuture"><span class="toc-number">13.1.</span> <span class="toc-text">13.1 CompletableFuture</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-2-Loader"><span class="toc-number">13.2.</span> <span class="toc-text">13.2 Loader</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-3-Director"><span class="toc-number">13.3.</span> <span class="toc-text">13.3 Director</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%81%E5%9B%9B-%E9%A1%B9%E7%9B%AE%E5%9C%BA%E6%99%AF"><span class="toc-number">14.</span> <span class="toc-text">十四 项目场景</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#14-1-%E8%AF%BE%E7%A8%8B%E7%A7%92%E6%9D%80%E6%B4%BB%E5%8A%A8"><span class="toc-number">14.1.</span> <span class="toc-text">14.1 课程秒杀活动</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-2-%E8%AE%A2%E5%8D%95%E8%B6%85%E6%97%B6%E5%8F%96%E6%B6%88"><span class="toc-number">14.2.</span> <span class="toc-text">14.2 订单超时取消</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-3-%E7%BB%9F%E8%AE%A1%E6%8E%A5%E5%8F%A3%E7%9A%84%E8%B0%83%E7%94%A8%E6%AC%A1%E6%95%B0"><span class="toc-number">14.3.</span> <span class="toc-text">14.3 统计接口的调用次数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-4-%E9%A1%B9%E7%9B%AE%E4%B8%AD%E7%9A%84%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E7%B3%BB%E7%BB%9F"><span class="toc-number">14.4.</span> <span class="toc-text">14.4 项目中的文件上传系统</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-5-%E9%99%90%E6%B5%81%E6%80%8E%E4%B9%88%E5%81%9A"><span class="toc-number">14.5.</span> <span class="toc-text">14.5 限流怎么做</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-6-%E5%BA%8F%E5%88%97%E5%8C%96%E9%94%99%E8%AF%AF%E9%97%AE%E9%A2%98"><span class="toc-number">14.6.</span> <span class="toc-text">14.6 序列化错误问题</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%81%E4%BA%94-%E9%9D%A2%E8%AF%95"><span class="toc-number">15.</span> <span class="toc-text">十五 面试</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#8-23-%E5%BF%AB%E6%89%8B1"><span class="toc-number">15.1.</span> <span class="toc-text">8.23 快手1</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-24-%E5%BF%AB%E6%89%8B2"><span class="toc-number">15.2.</span> <span class="toc-text">8.24 快手2</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-26-%E6%B7%98%E5%A4%A91"><span class="toc-number">15.3.</span> <span class="toc-text">8.26 淘天1</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-26-%E5%AD%97%E8%8A%821"><span class="toc-number">15.4.</span> <span class="toc-text">8.26 字节1</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-27-%E7%99%BE%E5%BA%A61"><span class="toc-number">15.5.</span> <span class="toc-text">8.27 百度1</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-31-%E5%BE%97%E7%89%A91%EF%BC%88%E5%85%A8%E5%85%AB%E8%82%A1%EF%BC%89"><span class="toc-number">15.6.</span> <span class="toc-text">8.31 得物1（全八股）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-31-pdd1"><span class="toc-number">15.7.</span> <span class="toc-text">8.31 pdd1</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-2-oppo1"><span class="toc-number">15.8.</span> <span class="toc-text">9.2 oppo1</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-2-%E5%AD%97%E8%8A%822%EF%BC%88%E5%8D%81%E5%88%86%E5%BC%80%E6%94%BE%EF%BC%89"><span class="toc-number">15.9.</span> <span class="toc-text">9.2 字节2（十分开放）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-2-%E9%98%BF%E9%87%8C1"><span class="toc-number">15.10.</span> <span class="toc-text">9.2 阿里1</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-3-%E9%98%BF%E9%87%8C%E4%BA%911"><span class="toc-number">15.11.</span> <span class="toc-text">9.3 阿里云1</span></a></li></ol></li></ol></div></div></div></div></main><footer id="footer" style="background: transparent"><div id="footer-wrap"><div class="copyright">©2024 By myl</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=4.13.0"></script><script src="/js/main.js?v=4.13.0"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"><script>(() => {
  const getCount = () => {
    const countELement = document.getElementById('twikoo-count')
    if(!countELement) return
    twikoo.getCommentsCount({
      envId: 'https://comments.manyile.top/',
      region: 'ap-shanghai',
      urls: [window.location.pathname],
      includeReply: false
    }).then(res => {
      countELement.textContent = res[0].count
    }).catch(err => {
      console.error(err)
    })
  }

  const init = () => {
    twikoo.init(Object.assign({
      el: '#twikoo-wrap',
      envId: 'https://comments.manyile.top/',
      region: 'ap-shanghai',
      onCommentLoaded: () => {
        btf.loadLightbox(document.querySelectorAll('#twikoo .tk-content img:not(.tk-owo-emotion)'))
      }
    }, null))

    GLOBAL_CONFIG_SITE.isPost && getCount()
  }

  const loadTwikoo = () => {
    if (typeof twikoo === 'object') setTimeout(init,0)
    else getScript('https://cdn.jsdelivr.net/npm/twikoo@1.6.31/dist/twikoo.all.min.js').then(init)
  }

  if ('Twikoo' === 'Twikoo' || !true) {
    if (true) btf.loadComment(document.getElementById('twikoo-wrap'), loadTwikoo)
    else loadTwikoo()
  } else {
    window.loadOtherComment = loadTwikoo
  }
})()</script></div><script type="text/javascript" src="https://unpkg.zhimg.com/jquery@latest/dist/jquery.min.js"></script><script data-pjax="" type="text/javascript" src="/js/nav.js"></script><div class="aplayer no-destroy" data-id="2664875269" data-server="netease" data-type="playlist" data-fixed="true" data-mini="true" data-listfolded="false" data-order="random" data-preload="none" data-autoplay="false" muted=""></div><script data-pjax="" type="text/javascript" src="/js/randomPaper.js"></script><script type="text/javascript" src="/js/rightMenu.js"></script><script>let tianliGPT_postSelector = '\#post \#article-container';let tianliGPT_key = 'c9b7741d290063ab872e';</script><script src="https://cdn1.tianli0.top/gh/zhheo/Post-Abstract-AI@0.15.2/tianli_gpt.js"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer@1.10.1/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/aplayer@1.10.1/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/metingjs/dist/Meting.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax@0.2.8/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {

  // removeEventListener
  btf.removeGlobalFnEvent('pjax')
  btf.removeGlobalFnEvent('themeChange')

  document.getElementById('rightside').classList.remove('rightside-show')
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

  typeof disqusjs === 'object' && disqusjs.destroy()
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', e => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async="" data-pjax="" src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"></div></div><hr><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js?v=4.13.0"></script></div></div><div class="js-pjax" id="rightMenu"><div class="rightMenu-group rightMenu-small"><a class="rightMenu-item" href="javascript:window.history.back();"><i class="fa fa-arrow-left"></i></a><a class="rightMenu-item" href="javascript:window.history.forward();"><i class="fa fa-arrow-right"></i></a><a class="rightMenu-item" href="javascript:window.location.reload();"><i class="fa fa-refresh"></i></a><a class="rightMenu-item" href="javascript:rmf.scrollToTop();"><i class="fa fa-arrow-up"></i></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-text"><a class="rightMenu-item" href="javascript:rmf.copySelect();"><i class="fa fa-copy"></i><span>复制</span></a><a class="rightMenu-item" href="javascript:window.open(&quot;https://www.baidu.com/s?wd=&quot;+window.getSelection().toString());window.location.reload();"><i class="iconfont icon-baidu"></i><span>百度搜索</span></a><a class="rightMenu-item" href="javascript:rmf.searchinThisPage();"><i class="fas fa-search"></i><span>站内搜索</span></a><a class="rightMenu-item" href="#post-comment" onclick="rmf.yinyong()"><i class="fa-solid fa-message"></i><span>引用文本评论</span></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-too"><a class="rightMenu-item" href="javascript:window.open(window.getSelection().toString());window.location.reload();"><i class="fa fa-link"></i><span>转到链接</span></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-paste"><a class="rightMenu-item" href="javascript:rmf.paste()"><i class="fa fa-copy"></i><span>粘贴</span></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-post"><a class="rightMenu-item" href="#post-comment"><i class="fas fa-comment"></i><span>空降评论</span></a><a class="rightMenu-item" href="javascript:switchCommentBarrage()"><i class="iconfont icon-danmu"></i><span>开/关评论弹幕</span></a><a class="rightMenu-item" href="javascript:rmf.copyWordsLink()"><i class="fa fa-link"></i><span>复制本文地址</span></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-to"><a class="rightMenu-item" href="javascript:rmf.openWithNewTab()"><i class="fa fa-window-restore"></i><span>新窗口打开</span></a><a class="rightMenu-item" id="menu-too" href="javascript:rmf.open()"><i class="fa fa-link"></i><span>转到链接</span></a><a class="rightMenu-item" href="javascript:rmf.copyLink()"><i class="fa fa-copy"></i><span>复制链接</span></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-img"><a class="rightMenu-item" href="javascript:rmf.saveAs()"><i class="fa fa-download"></i><span>保存图片</span></a><a class="rightMenu-item" href="javascript:rmf.openWithNewTab()"><i class="fa fa-window-restore"></i><span>在新窗口打开</span></a><a class="rightMenu-item" href="javascript:rmf.click()"><i class="fa fa-arrows-alt"></i><span>全屏显示</span></a><a class="rightMenu-item" href="javascript:rmf.copyLink()"><i class="fa fa-copy"></i><span>复制图片链接</span></a></div><div class="rightMenu-group rightMenu-line"><a class="rightMenu-item" href="javascript:randomPost()"><i class="fa fa-paper-plane"></i><span>随便逛逛</span></a><a class="rightMenu-item" href="javascript:rmf.switchDarkMode();"><i class="fa fa-moon"></i><span>昼夜切换</span></a><a class="rightMenu-item" href="javascript:fullScreen();"><i class="fas fa-expand"></i><span>进入全屏</span></a></div></div><!-- hexo injector body_end start --><script data-pjax="">function electric_clock_injector_config(){
                var parent_div_git = document.getElementsByClassName('sticky_layout')[0];
                var item_html = '<div class="card-widget card-clock"><div class="card-glass"><div class="card-background"><div class="card-content"><div id="hexo_electric_clock"><img id="card-clock-loading" src="https://cdn.jsdelivr.net/gh/Zfour/Butterfly-clock/clock/images/weather/loading.gif" style="height: 120px; width: 100%;" data-ll-status="loading" class="entered loading"></div></div></div></div></div>';
                console.log('已挂载electric_clock')
                // parent_div_git.innerHTML=item_html+parent_div_git.innerHTML // 无报错，但不影响使用(支持pjax跳转)
                parent_div_git.insertAdjacentHTML("afterbegin",item_html) // 有报错，但不影响使用(支持pjax跳转)
            }if( document.getElementsByClassName('sticky_layout')[0] && (location.pathname ==='all'|| 'all' ==='all')){

            electric_clock_injector_config()
        } </script><script src="https://pv.sohu.com/cityjson?ie=utf-8"></script><script data-pjax="" src="https://cdn.jsdelivr.net/gh/Zfour/hexo-electric-clock@1.0.6/clock.js"></script><script async="" src="//at.alicdn.com/t/font_2032782_8d5kxvn09md.js"></script><!-- hexo injector body_end end --></body></html>