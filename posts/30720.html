<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Spring高级 | myl's blog</title><meta name="author" content="myl"><meta name="copyright" content="myl"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Spring高级https://www.bilibili.com/video/BV1P44y1N7QG?p=26&amp;spm_id_from=pageDriver&amp;vd_source=1a39594354c31d775ddc587407a55282 Ⅰ 容器与bean一 容器接口1.1 BeanFactory 简介 是ApplicationContext的父接口 它才是Spring的核">
<meta property="og:type" content="article">
<meta property="og:title" content="Spring高级">
<meta property="og:url" content="http://yileman.github.io/posts/30720.html">
<meta property="og:site_name" content="myl's blog">
<meta property="og:description" content="Spring高级https://www.bilibili.com/video/BV1P44y1N7QG?p=26&amp;spm_id_from=pageDriver&amp;vd_source=1a39594354c31d775ddc587407a55282 Ⅰ 容器与bean一 容器接口1.1 BeanFactory 简介 是ApplicationContext的父接口 它才是Spring的核">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/cover/article_cover10.png">
<meta property="article:published_time" content="2023-12-10T00:00:00.000Z">
<meta property="article:modified_time" content="2024-03-29T03:48:07.102Z">
<meta property="article:author" content="myl">
<meta property="article:tag" content="java高级">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/cover/article_cover10.png"><link rel="shortcut icon" href="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/touxiang.jpg"><link rel="canonical" href="http://yileman.github.io/posts/30720.html"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="preconnect" href="//busuanzi.ibruce.info"><link rel="stylesheet" href="/css/index.css?v=4.13.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.11.1/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Spring高级',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-03-29 11:48:07'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><link rel="stylesheet" href="/css/modify.css"><link rel="stylesheet" href="/css/user.css"><link rel="stylesheet" href="/css/rightMenu.css"><link rel="stylesheet" href="/css/iconfont.css"><link rel="stylesheet" href="/css/mouse.css"><link rel="stylesheet" href="/css/custom.css" media="defer" onload="this.media='all'"><!-- hexo injector head_end start --><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Zfour/hexo-electric-clock@1.0.6/clock.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Zfour/Butterfly-double-row-display@1.00/cardlistpost.min.css">
<style>#recent-posts > .recent-post-item >.recent-post-info > .article-meta-wrap > .tags:before {content:"\A";
  white-space: pre;}#recent-posts > .recent-post-item >.recent-post-info > .article-meta-wrap > .tags > .article-meta__separator{display:none}</style>
<link rel="stylesheet" href="https://unpkg.com/hexo-butterfly-tag-plugins-plus-chinese@latest/lib/assets/font-awesome-animation.min.css" media="defer" onload="this.media='all'"><link rel="stylesheet" href="https://unpkg.com/hexo-butterfly-tag-plugins-plus-chinese@latest/lib/tag_plugins.css" media="defer" onload="this.media='all'"><script src="https://unpkg.com/hexo-butterfly-tag-plugins-plus-chinese@latest/lib/assets/carousel-touch.js"></script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.1.1"></head><body><div id="loading-box"><div class="pokeball-back"></div><div class="pokeball-loading"><div class="pokeball" id="pokeball-normal"></div><div class="pokeball" id="pokeball-great"></div><div class="pokeball" id="pokeball-ultra"></div><div class="pokeball" id="pokeball-master"></div><div class="pokeball" id="pokeball-safari"></div></div></div><script>(()=>{
  const $loadingBox = document.getElementById('loading-box')
  const $body = document.body
  const preloader = {
    endLoading: () => {
      //- console.log("end")
      $body.style.overflow = 'auto'

      document.getElementById('loading-box').style.transition = 'opacity 3s ease 0s'
      document.getElementById('loading-box').style.opacity = '0'
      setTimeout(function(){
        document.getElementById('loading-box').classList.add("loaded")
      }, 3000);

      //- $loadingBox.classList.add('loaded')
    },
    initLoading: () => {
      $body.style.overflow = ''
      $loadingBox.classList.remove('loaded')
      
    }
  }

  preloader.initLoading()
  //- setTimeout(function(){preloader.endLoading();}, 3000);
  window.addEventListener('load',() => { preloader.endLoading() })
  document.getElementById('loading-box').addEventListener('click',()=> {preloader.endLoading()})

  if (true) {
    document.addEventListener('pjax:send', () => { preloader.initLoading() })
    document.addEventListener('pjax:complete', () => { preloader.endLoading() })
  }
})()</script><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/touxiang.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">20</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">7</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">4</div></a></div><hr class="custom-hr"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page" href="/comments/"><i class="fa-fw fa fa-link"></i><span> 留言板</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/cover/article_cover10.png')"><nav id="nav"><span id="blog-info"><a href="/" title="myl's blog"><span class="site-name">myl's blog</span></a></span><div id="menus"></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page" href="/comments/"><i class="fa-fw fa fa-link"></i><span> 留言板</span></a></div></div><center id="name-container"><a id="page-name" href="javascript:scrollToTop()">PAGE_NAME</a></center><div id="nav-right"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div id="randomPost"><a class="site-page social-icon search" href="javascript:;" onclick="randomPost()" title="随机访问一篇文章"><i class="fas fa-circle-notch fa-fw"></i></a></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Spring高级</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-12-10T00:00:00.000Z" title="发表于 2023-12-10 08:00:00">2023-12-10</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-03-29T03:48:07.102Z" title="更新于 2024-03-29 11:48:07">2024-03-29</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/study/">study</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Spring高级"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><div class="top-img" style="background-image: url('https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/cover/article_cover10.png');"></div><article class="post-content" id="article-container"><h1 id="Spring高级"><a href="#Spring高级" class="headerlink" title="Spring高级"></a>Spring高级</h1><p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1P44y1N7QG?p=26&amp;spm_id_from=pageDriver&amp;vd_source=1a39594354c31d775ddc587407a55282">https://www.bilibili.com/video/BV1P44y1N7QG?p=26&amp;spm_id_from=pageDriver&amp;vd_source=1a39594354c31d775ddc587407a55282</a></p>
<h2 id="Ⅰ-容器与bean"><a href="#Ⅰ-容器与bean" class="headerlink" title="Ⅰ 容器与bean"></a>Ⅰ 容器与bean</h2><h3 id="一-容器接口"><a href="#一-容器接口" class="headerlink" title="一 容器接口"></a>一 容器接口</h3><h4 id="1-1-BeanFactory"><a href="#1-1-BeanFactory" class="headerlink" title="1.1 BeanFactory"></a>1.1 BeanFactory</h4><ul>
<li>简介<ul>
<li>是ApplicationContext的父接口</li>
<li>它才是Spring的核心容器，主要的ApplicationContext的实现都组合了他的功能</li>
</ul>
</li>
<li>功能<ul>
<li>表面只有getBean</li>
<li>实际上控制反转、基本的依赖注入，直至Bean的声明周期的各种功能，都由它的实现类提供</li>
</ul>
</li>
</ul>
<h4 id="1-2-ApplicationContext"><a href="#1-2-ApplicationContext" class="headerlink" title="1.2 ApplicationContext"></a>1.2 ApplicationContext</h4><ul>
<li><p>比BeanFactory多的一些容器接口  </p>
<ul>
<li><p>国际化</p>
<ul>
<li><code>context.getMessage("hi", null, Locale.ENGLISH)</code></li>
</ul>
</li>
<li><p>根据通配符获取资源</p>
<ul>
<li><code>context.getResource(...)</code></li>
</ul>
</li>
<li><p>获取配置信息</p>
<ul>
<li><code>context.getEnvironment().getProperty()</code></li>
</ul>
</li>
<li><p>发布事件（实现组件解耦）</p>
<ul>
<li><p><code>context.getBean(..).register(...)</code></p>
<p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/Spring高级.assets/image-20231127202739234.png" alt="image-20231127202739234"></p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="二-容器实现"><a href="#二-容器实现" class="headerlink" title="二  容器实现"></a>二  容器实现</h3><h4 id="2-1-BeanFactory实现特点"><a href="#2-1-BeanFactory实现特点" class="headerlink" title="2.1 BeanFactory实现特点"></a>2.1 BeanFactory实现特点</h4><ul>
<li><p><code>DefaultListableBeanFactory</code></p>
<ul>
<li><p>是 BeanFactory 最重要的实现，像<strong>控制反转</strong>和<strong>依赖注入</strong>功能，都是它来实现</p>
<p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/Spring高级.assets/image-20231127203722980.png" alt="image-20231127203722980"></p>
<ul>
<li>bean的定义</li>
<li>注册bean</li>
</ul>
</li>
<li><p>不能解析bean内部的bean</p>
<ul>
<li><p>解决：给bean工厂添加后处理器并将其加入与bean工厂的联系（<code>addBeanPostProcessor</code>）</p>
<p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/Spring高级.assets/image-20231127203924081.png" alt="image-20231127203924081"></p>
<p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/Spring高级.assets/image-20231127204756823.png" alt="image-20231127204756823"></p>
</li>
<li><p>针对bean的生命周期的各个阶段提供 扩展,如<code>@Autowired</code> <code>@Resource</code>…</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>特点</p>
<ul>
<li>不会主动对beanFactory后处理器</li>
<li>不会主动添加Bean后处理器</li>
<li>不会主动实例化单例</li>
<li>不会解析beanFactory 还不会解析 <code>${}</code> <code>#{}</code></li>
</ul>
</li>
<li><p>后处理器的排序</p>
<ul>
<li>先添加进去的后处理器的优先级高，如果一个bean同时加了<code>@Autowired</code> 和<code>@Resource</code>，则看这两个后处理器谁先被加入bean容器谁就优先执行</li>
<li>也可以通过比较器来改变后处理器的优先级</li>
</ul>
</li>
</ul>
<h4 id="2-2-ApplicationContext常见实现"><a href="#2-2-ApplicationContext常见实现" class="headerlink" title="2.2 ApplicationContext常见实现"></a>2.2 ApplicationContext常见实现</h4><ul>
<li><p><code>ClassPathXmlApplicationContext</code></p>
<ul>
<li><p>基于类路径下读取xml配置文件加载bean</p>
<p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/Spring高级.assets/image-20231127210244668.png" alt="image-20231127210244668"></p>
</li>
</ul>
</li>
<li><p><code>FileSystemXmlApplicationContext</code></p>
<ul>
<li>基于文件路径读取xml</li>
</ul>
</li>
<li><p><strong>读取xml的原理</strong></p>
<ul>
<li><code>XmlBeanDefinitionReader</code>读取xml中的xml然后加入到<code>DefaultListableBeanFactory</code>中</li>
</ul>
</li>
<li><p><code>AnnotationApplicationContext</code></p>
<ul>
<li><p>基于注解,通过配置类加载bean</p>
<p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/Spring高级.assets/image-20231127211045533.png" alt="image-20231127211045533"></p>
<ul>
<li>其中Config类需要<code>@Configuration</code>修饰</li>
</ul>
</li>
<li><p>这里加了<code>@Autowired</code> 和<code>@Resource</code>等后处理器</p>
</li>
</ul>
</li>
<li><p><code>AnnotationConfigServletWebServerApplicationContext</code></p>
<ul>
<li><p>用于web环境,基于java配置类加载bean</p>
</li>
<li><p>配置类中需要定义</p>
<ul>
<li><code>ServletWebServerFactory</code>:web服务器容器(tomcat)</li>
<li><code>DispatcherServlet</code>:前控制器,所有请求先经过它</li>
<li><code>DispatcherServletRegistrationBean</code>:将前控制器注册到服务器中</li>
<li>controller</li>
</ul>
<p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/Spring高级.assets/image-20231127212543543.png" alt="image-20231127212543543"></p>
</li>
</ul>
</li>
</ul>
<h3 id="三-bean生命周期"><a href="#三-bean生命周期" class="headerlink" title="三 bean生命周期"></a>三 bean生命周期</h3><h4 id="3-1-生命周期"><a href="#3-1-生命周期" class="headerlink" title="3.1 生命周期"></a>3.1 生命周期</h4><ol>
<li><p>创建：根据 bean 的构造方法或者工厂方法来创建 bean 实例对象</p>
</li>
<li><p>依赖注入：根据 @Autowired，@Value 或其它一些手段，为 bean 的成员变量填充值、建立关系</p>
</li>
<li><p>初始化：回调各种 Aware 接口，调用对象的各种初始化方法</p>
</li>
<li><p>可用</p>
</li>
<li><p>销毁：在容器关闭时，会销毁所有单例对象（即调用它们的销毁方法）</p>
<ul>
<li>prototype 对象也能够销毁，不过需要容器这边主动调用</li>
</ul>
<p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/Spring高级.assets/image-20231127212949420.png" alt="image-20231127212949420"></p>
</li>
</ol>
<h4 id="3-2-生命周期增强方法"><a href="#3-2-生命周期增强方法" class="headerlink" title="3.2 生命周期增强方法"></a>3.2 生命周期增强方法</h4><ul>
<li><p>创建前后的增强</p>
<ul>
<li><p><code>postProcessBeforeInstantiation</code></p>
<ul>
<li>这里返回的对象若不为 null 会替换掉原本的 bean，并且仅会走 postProcessAfterInitialization 流程</li>
</ul>
</li>
<li><p><code>postProcessAfterInstantiation</code></p>
<ul>
<li>这里如果返回 false 会跳过依赖注入阶段</li>
</ul>
</li>
</ul>
</li>
<li><p>依赖注入前的增强</p>
<ul>
<li><code>postProcessProperties</code><ul>
<li>如 <code>@Autowired</code>、<code>@Value</code>、<code>@Resource</code> </li>
</ul>
</li>
</ul>
</li>
<li><p>初始化前后的增强</p>
<ul>
<li><code>postProcessBeforeInitialization</code><ul>
<li>这里返回的对象会替换掉原本的 bean</li>
<li>如 <code>@PostConstruct</code>、<code>@ConfigurationProperties</code></li>
</ul>
</li>
<li><code>postProcessAfterInitialization</code> <ul>
<li>这里返回的对象会替换掉原本的 bean</li>
<li>如代理增强</li>
</ul>
</li>
</ul>
</li>
<li><p>销毁之前的增强</p>
<ul>
<li><code>postProcessBeforeDestruction</code><ul>
<li>如 <code>@PreDestroy</code> </li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="3-3-模板方法设计模式"><a href="#3-3-模板方法设计模式" class="headerlink" title="3.3 模板方法设计模式"></a>3.3 模板方法设计模式</h4><ul>
<li>后处理器原理</li>
</ul>
<p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/Spring高级.assets/image-20231127213721710.png" alt="image-20231127213721710"></p>
<ul>
<li>通过实现<code>BeanPostProcessor</code>接口，可以实现在不改变<code>getBean</code>方法的前提下扩展功能 </li>
</ul>
<h3 id="四-Bean后处理器"><a href="#四-Bean后处理器" class="headerlink" title="四 Bean后处理器"></a>四 Bean后处理器</h3><ul>
<li><p>作用:为Bean生命周期各个阶段提供扩展</p>
</li>
<li><p><code>GenericApplicationContext</code>:一个比较干净的容器(没有定义后处理器)</p>
<ul>
<li><code>registerBean()</code>:注册bean,后处理器</li>
<li><code>refresh()</code>:初始化容器</li>
<li><code>close()</code>:销毁容器</li>
</ul>
</li>
<li><p>常见bean后处理器</p>
<ul>
<li><code>AutowiredAnnotationBeanPostProcessor</code><ul>
<li>解析<code>@Autowired</code> <code>@Value</code></li>
</ul>
</li>
</ul>
<p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/Spring高级.assets/image-20231127215306236.png" alt="image-20231127215306236"></p>
<ul>
<li><code>CommonAnnotationBeanPostProcessor</code><ul>
<li>解析<code>@Resource</code> <code>@PostConstruct</code> <code>@PreDestroy</code></li>
</ul>
</li>
<li><code>ConfigurationPropertiesBindingPostProcessor.register()</code><ul>
<li>解析<code>@configurationProperties</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="五-BeanFactory后处理器"><a href="#五-BeanFactory后处理器" class="headerlink" title="五 BeanFactory后处理器"></a>五 BeanFactory后处理器</h3><h4 id="5-1-介绍"><a href="#5-1-介绍" class="headerlink" title="5.1 介绍"></a>5.1 介绍</h4><ul>
<li>作用:为BeanFactory提供扩展</li>
<li><p>常见BeanFactory后处理器</p>
<ul>
<li><code>ConfigurationClassPostProcessor</code><ul>
<li>解析<code>@ComponentScan</code> <code>@Bean</code> <code>@Import</code> <code>@ImportResource</code>…</li>
</ul>
</li>
<li><code>MapperScannerConfigurer</code><ul>
<li>扫描mapper接口</li>
<li>基本方式是创建MapperFactoryBean，然后通过Mapper接口类创建对应对象</li>
<li>在此基础上扫描包，读取Mapper接口，然后再创建</li>
</ul>
</li>
</ul>
</li>
<li><p>使用注册</p>
<p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/Spring高级.assets/image-20231127220822227.png" alt="image-20231127220822227"></p>
</li>
</ul>
<h4 id="5-2-常见BeanFactory后处理器1"><a href="#5-2-常见BeanFactory后处理器1" class="headerlink" title="5.2 常见BeanFactory后处理器1"></a>5.2 常见BeanFactory后处理器1</h4><ul>
<li><p><code>ConfigurationClassPostProcessor</code>原理</p>
</li>
<li><p>以<code>@ComponentScan</code>为例</p>
<ul>
<li><p>判断当前类是否有<code>@ComponentScan</code></p>
</li>
<li><p>如果有则获取<code>@ComponentScan</code>扫描的包下的所有class文件是否加了<code>@Component</code>及其衍生注解</p>
<p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/Spring高级.assets/image-20231127221432603.png" alt="image-20231127221432603"></p>
</li>
<li><p>如果加了<code>@Component</code>及其衍生注解，则获取到这个bean，起名字并加入到bean工厂 </p>
<ul>
<li><code>BeanDefinitionBuilder</code>(获取bean)</li>
</ul>
<p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/Spring高级.assets/image-20231127221719123.png" alt="image-20231127221719123"></p>
</li>
</ul>
</li>
</ul>
<h4 id="5-3-常见BeanFactory后处理器2"><a href="#5-3-常见BeanFactory后处理器2" class="headerlink" title="5.3 常见BeanFactory后处理器2"></a>5.3 常见BeanFactory后处理器2</h4><ul>
<li><p><code>MapperScannerConfigurer</code></p>
</li>
<li><p>Mapper 接口被 Spring 管理的本质：实际是被作为 MapperFactoryBean 注册到容器中</p>
</li>
<li><p>原理</p>
<ul>
<li><p>扫描Mapper包</p>
</li>
<li><p>判断是不是Interface</p>
</li>
<li><p>根据接口创建MapperFactoryBean注入到bean工厂中</p>
<p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/Spring高级.assets/image-20231127223637027.png" alt="image-20231127223637027"></p>
<ul>
<li><p>上面的bd2的作用是生成name，最终不会添加到容器</p>
<p>不然的话添加到容器的就是<code>MapperFactoryBean</code>了</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="六-Aware-接口"><a href="#六-Aware-接口" class="headerlink" title="六 Aware 接口"></a>六 Aware 接口</h3><h4 id="6-1-Aware-接口"><a href="#6-1-Aware-接口" class="headerlink" title="6.1 Aware 接口"></a>6.1 Aware 接口</h4><ul>
<li><p>用于注入一些与容器相关的信息</p>
<ul>
<li><p><code>BeanNameAware</code>注入bean的名字</p>
<p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/Spring高级.assets/image-20231128201148264.png" alt="image-20231128201148264"></p>
</li>
<li><p><code>BeanFactoryAware</code>注入<code>BeanFactory</code> 容器</p>
</li>
<li><p><code>ApplicationContextAware</code> 注入 <code>ApplicationContext</code> 容器</p>
<p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/Spring高级.assets/image-20231128201236286.png" alt="image-20231128201236286"></p>
</li>
<li><p><code>EmbeddedValueResolverAware</code> 注入 <code>${}</code> 解析器</p>
</li>
</ul>
</li>
</ul>
<h4 id="6-2-InitializingBean-接口"><a href="#6-2-InitializingBean-接口" class="headerlink" title="6.2 InitializingBean 接口"></a>6.2 InitializingBean 接口</h4><ul>
<li><p>InitializingBean 接口提供了一种【内置】的初始化手段</p>
</li>
<li><p>对比</p>
<ul>
<li><p>内置的注入(ApplicationContextAware)和初始化(InitializingBean )不受扩展功能的影响，总会被执行</p>
</li>
<li><p>而扩展功能受某些情况影响可能会失效</p>
<p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/Spring高级.assets/image-20231128202809671.png" alt="image-20231128202809671"></p>
</li>
<li><p>因此 Spring 框架内部的类常用内置注入和初始化</p>
</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">sequenceDiagram </span><br><span class="line">participant ac as ApplicationContext</span><br><span class="line">participant bfpp as BeanFactoryPostProcessor</span><br><span class="line">participant bpp as BeanPostProcessor</span><br><span class="line">participant config as Java配置类</span><br><span class="line">ac -&gt;&gt; bfpp : 1. 执行 BeanFactoryPostProcessor(bean工厂后处理器)</span><br><span class="line">ac -&gt;&gt; bpp : 2. 注册 BeanPostProcessor(bean后处理器)</span><br><span class="line">ac -&gt;&gt; +config : 3. 创建和初始化</span><br><span class="line">bpp -&gt;&gt; config : 3.1 依赖注入扩展(如 @Value 和 @Autowired)</span><br><span class="line">bpp -&gt;&gt; config : 3.2 初始化扩展(如 @PostConstruct)</span><br><span class="line">ac -&gt;&gt; config : 3.3 执行 Aware 及 InitializingBean</span><br><span class="line">config --&gt;&gt; -ac : 3.4 创建成功</span><br></pre></td></tr></tbody></table></figure>
<h3 id="七-初始化与销毁"><a href="#七-初始化与销毁" class="headerlink" title="七 初始化与销毁"></a>七 初始化与销毁</h3><h4 id="7-1-初始化"><a href="#7-1-初始化" class="headerlink" title="7.1 初始化"></a>7.1 初始化</h4><ul>
<li><p>初始化手段</p>
<ul>
<li><p><code>@PostConstruct</code></p>
<p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/Spring高级.assets/image-20231128211206737.png" alt="image-20231128211206737"></p>
</li>
<li><p><code>@Bean(initMethod)</code> </p>
<p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/Spring高级.assets/image-20231128211002711.png" alt="image-20231128211002711"></p>
<ul>
<li>执行Bean1内定义的init3方法</li>
</ul>
</li>
<li><p>实现 <code>InitializingBean</code> 接口</p>
<p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/Spring高级.assets/image-20231128211218810.png" alt="image-20231128211218810"></p>
</li>
</ul>
</li>
<li><p>三种初始化手段的执行顺序</p>
<ol>
<li><code>@PostConstruct</code> 标注的初始化方法</li>
<li><code>InitializingBean</code> 接口的初始化方法</li>
<li><code>@Bean(initMethod)</code> 指定的初始化方法</li>
</ol>
</li>
</ul>
<h4 id="7-2-销毁"><a href="#7-2-销毁" class="headerlink" title="7.2 销毁"></a>7.2 销毁</h4><ul>
<li>顺序为<ol>
<li><code>@PreDestroy</code> 标注的销毁方法</li>
<li><code>DisposableBean</code> 接口的销毁方法</li>
<li><code>@Bean(destroyMethod)</code> 指定的销毁方法</li>
</ol>
</li>
</ul>
<h3 id="八-Scope"><a href="#八-Scope" class="headerlink" title="八 Scope"></a>八 Scope</h3><h4 id="8-1-Scope类型"><a href="#8-1-Scope类型" class="headerlink" title="8.1 Scope类型"></a>8.1 Scope类型</h4><ul>
<li><code>singleton</code>，容器启动时创建（未设置延迟），容器关闭时销毁</li>
<li><code>prototype</code>，每次使用时创建，不会自动销毁，需要调用 DefaultListableBeanFactory.destroyBean(bean) 销毁</li>
<li><code>request</code>，每次请求用到此 bean 时创建，请求结束时销毁</li>
<li><code>session</code>，每个会话用到此 bean 时创建，会话结束时销毁</li>
<li><code>application</code>，web 容器用到此 bean 时创建，容器停止时销毁</li>
</ul>
<h4 id="8-2-在singleton中使用其他几种scope的Bean"><a href="#8-2-在singleton中使用其他几种scope的Bean" class="headerlink" title="8.2 在singleton中使用其他几种scope的Bean"></a>8.2 在singleton中使用其他几种scope的Bean</h4><ul>
<li><p>单例对象，依赖注入仅发生一次，后续用的始终是第一次依赖注入的对象</p>
<p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/Spring高级.assets/image-20231128215002221.png" alt="image-20231128215002221"></p>
<ul>
<li>e是单例，其中有一个多例的bean f</li>
</ul>
</li>
<li><p>解决</p>
<ul>
<li><p><code>@Lazy</code>生成代理</p>
<ul>
<li><p>代理对象还是同一个，但是每次使用代理对象的任意方法时，由代理创建新的f对象</p>
<p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/Spring高级.assets/image-20231128215138340.png" alt="image-20231128215138340"></p>
</li>
</ul>
</li>
<li><p><code>@Scope(proxyMode = ScopedProxyMode.TARGET_CLASS)</code></p>
</li>
<li><p><code>ObjectFactory</code></p>
</li>
<li><p><code>ApplicationContext.getBean</code></p>
</li>
</ul>
</li>
<li><p>解决的理念都是：推迟其他scope bean的获取</p>
</li>
</ul>
<h2 id="Ⅱ-AOP"><a href="#Ⅱ-AOP" class="headerlink" title="Ⅱ AOP"></a>Ⅱ AOP</h2><p>AOP 底层实现方式之一是代理，由代理结合通知和目标，提供增强功能</p>
<p>除此以外，aspectj 提供了两种另外的 AOP 底层实现：</p>
<ul>
<li><p>第一种是通过 ajc 编译器在<strong>编译</strong> class 类文件时，就把通知的增强功能，织入到目标类的字节码中</p>
</li>
<li><p>第二种是通过 agent 在<strong>加载</strong>目标类时，修改目标类的字节码，织入增强功能</p>
</li>
<li>作为对比，之前学习的代理是<strong>运行</strong>时生成新的字节码</li>
</ul>
<p>简单比较的话：</p>
<ul>
<li><code>aspectj</code> 在编译和加载时，修改目标字节码，性能较高，并没有用spring</li>
<li><code>aspectj</code> 因为不用代理，能突破一些技术上的限制，例如对构造、对静态方法、对 final 也能增强</li>
<li>但 <code>aspectj</code> 侵入性较强，且需要学习新的 <code>aspectj</code> 特有语法，因此没有广泛流行</li>
</ul>
<h3 id="一-ajc增强"><a href="#一-ajc增强" class="headerlink" title="一 ajc增强"></a>一 ajc增强</h3><ul>
<li>编译器也能修改 class 实现增强</li>
<li>编译器增强能突破代理仅能通过方法重写增强的限制：可以对构造方法、静态方法等实现增强</li>
</ul>
<h3 id="二-agent增强"><a href="#二-agent增强" class="headerlink" title="二 agent增强"></a>二 agent增强</h3><ul>
<li>类加载时可以通过 agent 修改 class 实现增强</li>
</ul>
<h3 id="三-proxy增强"><a href="#三-proxy增强" class="headerlink" title="三 proxy增强"></a>三 proxy增强</h3><h4 id="3-1-jdk-动态代理"><a href="#3-1-jdk-动态代理" class="headerlink" title="3.1  jdk 动态代理"></a>3.1  jdk 动态代理</h4><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/Spring高级.assets/image-20231128223224135.png" alt="image-20231128223224135"></p>
<ul>
<li>jdk 动态代理要求目标<strong>必须</strong>实现接口，生成的代理类实现相同接口，因此代理与目标之间是平级兄弟关系</li>
</ul>
<h4 id="3-2-cglib代理"><a href="#3-2-cglib代理" class="headerlink" title="3.2 cglib代理"></a>3.2 cglib代理</h4><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CglibProxyDemo</span> {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Target</span> {</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">foo</span><span class="params">()</span> {</span><br><span class="line">            System.out.println(<span class="string">"target foo"</span>);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] param)</span> {</span><br><span class="line">        <span class="comment">// 目标对象</span></span><br><span class="line">        <span class="type">Target</span> <span class="variable">target</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Target</span>();</span><br><span class="line">        <span class="comment">// 代理对象</span></span><br><span class="line">        <span class="type">Target</span> <span class="variable">proxy</span> <span class="operator">=</span> (Target) Enhancer.create(Target.class, </span><br><span class="line">                (MethodInterceptor) (p, method, args, methodProxy) -&gt; {</span><br><span class="line">            System.out.println(<span class="string">"proxy before..."</span>);</span><br><span class="line">            <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> method.invoke(target, args);<span class="comment">//用反射调用目标，性能稍弱</span></span><br><span class="line">            <span class="comment">//Object result = methodProxy.invoke(target, args); //避免反射的调用，需要目标</span></span><br><span class="line">            <span class="comment">//Object result = methodProxy.invokeSuper(target, args); //同上但是需要代理</span></span><br><span class="line">            <span class="comment">//spring用的第二种方法</span></span><br><span class="line">            System.out.println(<span class="string">"proxy after..."</span>);</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        });</span><br><span class="line">        <span class="comment">// 调用代理</span></span><br><span class="line">        proxy.foo();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>cglib 不要求目标实现接口，它生成的代理类是目标的子类，因此代理与目标之间是子父关系</li>
<li>父类以及父类的方法不能是final修饰的（本质是方法的重写）</li>
</ul>
<h3 id="四-jdk代理原理"><a href="#四-jdk代理原理" class="headerlink" title="四 jdk代理原理"></a>四 jdk代理原理</h3><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">A12</span> {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">interface</span> <span class="title class_">Foo</span> {</span><br><span class="line">        <span class="keyword">void</span> <span class="title function_">foo</span><span class="params">()</span>;</span><br><span class="line">        <span class="type">int</span> <span class="title function_">bar</span><span class="params">()</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Target</span> <span class="keyword">implements</span> <span class="title class_">Foo</span> {</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">foo</span><span class="params">()</span> {</span><br><span class="line">            System.out.println(<span class="string">"target foo"</span>);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">bar</span><span class="params">()</span> {</span><br><span class="line">            System.out.println(<span class="string">"target bar"</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">100</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] param)</span> {</span><br><span class="line">        <span class="comment">// ⬇️1. 创建代理，这时传入 InvocationHandler</span></span><br><span class="line">        <span class="type">Foo</span> <span class="variable">proxy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">$Proxy0</span>(<span class="keyword">new</span> <span class="title class_">InvocationHandler</span>() {    </span><br><span class="line">            <span class="comment">// ⬇️5. 进入 InvocationHandler</span></span><br><span class="line">            <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable{</span><br><span class="line">                <span class="comment">// ⬇️6. 功能增强</span></span><br><span class="line">                System.out.println(<span class="string">"before..."</span>);</span><br><span class="line">                <span class="comment">// ⬇️7. 反射调用目标方法</span></span><br><span class="line">                <span class="keyword">return</span> method.invoke(<span class="keyword">new</span> <span class="title class_">Target</span>(), args);</span><br><span class="line">            }</span><br><span class="line">        });</span><br><span class="line">        <span class="comment">// ⬇️2. 调用代理方法</span></span><br><span class="line">        proxy.foo();</span><br><span class="line">        proxy.bar();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>模拟代理实现</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.UndeclaredThrowableException;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ⬇️这就是 jdk 代理类的源码, 秘密都在里面</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">$Proxy0</span> <span class="keyword">extends</span> <span class="title class_">Proxy</span> <span class="keyword">implements</span> <span class="title class_">A12</span>.Foo {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> $Proxy0(InvocationHandler h) {</span><br><span class="line">        <span class="built_in">super</span>(h);</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// ⬇️3. 进入代理方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">foo</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            <span class="comment">// ⬇️4. 回调 InvocationHandler</span></span><br><span class="line">            h.invoke(<span class="built_in">this</span>, foo, <span class="keyword">new</span> <span class="title class_">Object</span>[<span class="number">0</span>]);</span><br><span class="line">        } <span class="keyword">catch</span> (RuntimeException | Error e) {</span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">        } <span class="keyword">catch</span> (Throwable e) {</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UndeclaredThrowableException</span>(e);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">bar</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> h.invoke(<span class="built_in">this</span>, bar, <span class="keyword">new</span> <span class="title class_">Object</span>[<span class="number">0</span>]);</span><br><span class="line">            <span class="keyword">return</span> (<span class="type">int</span>) result;</span><br><span class="line">        } <span class="keyword">catch</span> (RuntimeException | Error e) {</span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">        } <span class="keyword">catch</span> (Throwable e) {</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UndeclaredThrowableException</span>(e);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> Method foo;</span><br><span class="line">    <span class="keyword">static</span> Method bar;</span><br><span class="line">    <span class="keyword">static</span> {</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            foo = A12.Foo.class.getMethod(<span class="string">"foo"</span>);</span><br><span class="line">            bar = A12.Foo.class.getMethod(<span class="string">"bar"</span>);</span><br><span class="line">        } <span class="keyword">catch</span> (NoSuchMethodException e) {</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoSuchMethodError</span>(e.getMessage());</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>优化：反射创建性能低<ul>
<li>前 16 次反射性能较低</li>
<li>第 17 次调用会生成代理类，优化为非反射调用</li>
<li>会用 arthas 的 jad 工具反编译第 17 次调用生成的代理类</li>
</ul>
</li>
</ul>
<h3 id="五-cglib代理原理"><a href="#五-cglib代理原理" class="headerlink" title="五 cglib代理原理"></a>五 cglib代理原理</h3><ul>
<li>和JDK动态代理原理差不多<ul>
<li>回调的接口换了一下，<code>InvocationHandler</code> 改成了 <code>MethodInterceptor</code></li>
<li>调用目标时有所改进，见下面代码片段<ol>
<li>method.invoke 是反射调用，必须调用到足够次数才会进行优化</li>
<li>methodProxy.invoke 是不反射调用，它会正常（间接）调用目标对象的方法（Spring 采用）</li>
<li>methodProxy.invokeSuper 也是不反射调用，它会正常（间接）调用代理对象的方法，可以省略目标对象</li>
</ol>
</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">A14Application</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InvocationTargetException {</span><br><span class="line"></span><br><span class="line">        <span class="type">Target</span> <span class="variable">target</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Target</span>();</span><br><span class="line">        <span class="type">Proxy</span> <span class="variable">proxy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Proxy</span>();</span><br><span class="line">        </span><br><span class="line">        proxy.setCallbacks(<span class="keyword">new</span> <span class="title class_">Callback</span>[]{(MethodInterceptor) (p, m, a, mp) -&gt; {</span><br><span class="line">            System.out.println(<span class="string">"proxy before..."</span> + mp.getSignature());</span><br><span class="line">            <span class="comment">// ⬇️调用目标方法(三种)</span></span><br><span class="line"><span class="comment">//            Object result = m.invoke(target, a);  // ⬅️反射调用(m是Method对象)</span></span><br><span class="line">            <span class="comment">//mp是MethodProxy对象</span></span><br><span class="line"><span class="comment">//            Object result = mp.invoke(target, a); // ⬅️非反射调用, 结合目标用</span></span><br><span class="line">            <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> mp.invokeSuper(p, a);   <span class="comment">// ⬅️非反射调用, 结合代理用</span></span><br><span class="line">            System.out.println(<span class="string">"proxy after..."</span> + mp.getSignature());</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        }});</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// ⬇️调用代理方法</span></span><br><span class="line">        proxy.save();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h3 id="六-cglib如何避免发射调用"><a href="#六-cglib如何避免发射调用" class="headerlink" title="六 cglib如何避免发射调用"></a>六 cglib如何避免发射调用</h3><h4 id="6-1-MethodProxy实现"><a href="#6-1-MethodProxy实现" class="headerlink" title="6.1 MethodProxy实现"></a>6.1 MethodProxy实现</h4><ul>
<li>当调用 <code>MethodProxy</code> 的 invoke 或 invokeSuper 方法时, 会动态生成两个类<ul>
<li><code>ProxyFastClass</code> 配合代理对象一起使用, 避免反射</li>
<li><code>TargetFastClass</code> 配合目标对象一起使用, 避免反射 (Spring 用的这种)</li>
</ul>
</li>
<li><code>TargetFastClass</code> 记录了 Target 中方法与编号的对应关系<ul>
<li>save(long) 编号 2</li>
<li>save(int) 编号 1 </li>
<li>save() 编号 0</li>
<li>首先根据方法名和参数个数、类型, 用 switch 和 if 找到这些方法编号</li>
<li>然后再根据编号去调用目标方法, 又用了一大堆 switch 和 if, 但避免了反射</li>
</ul>
</li>
<li><code>ProxyFastClass</code> 记录了 Proxy 中方法与编号的对应关系，不过 Proxy 额外提供了下面几个方法<ul>
<li>saveSuper(long) 编号 2，不增强，仅是调用 super.save(long)</li>
<li>saveSuper(int) 编号 1，不增强, 仅是调用 super.save(int)</li>
<li>saveSuper() 编号 0，不增强, 仅是调用 super.save()</li>
<li>查找方式与 TargetFastClass 类似</li>
</ul>
</li>
<li>为什么有这么麻烦的一套东西呢？<ul>
<li>避免反射, 提高性能, 代价是一个代理类配两个 FastClass 类, 代理类中还得增加仅调用 super 的一堆方法</li>
<li>用编号处理方法对应关系比较省内存, 另外, 最初获得方法顺序是不确定的, 这个过程没法固定死</li>
</ul>
</li>
</ul>
<h3 id="七-jdk和cglib的统一"><a href="#七-jdk和cglib的统一" class="headerlink" title="七 jdk和cglib的统一"></a>七 jdk和cglib的统一</h3><h4 id="7-1-Spring的代理选择规则"><a href="#7-1-Spring的代理选择规则" class="headerlink" title="7.1 Spring的代理选择规则"></a>7.1 Spring的代理选择规则</h4><ul>
<li><p>Spring 中对切点、通知、切面的抽象如下</p>
<ul>
<li>切点：接口 Pointcut，典型实现 <code>AspectJExpressionPointcut</code></li>
<li>通知：典型接口为 <code>MethodInterceptor</code> 代表环绕通知</li>
<li>切面：Advisor，包含一个 Advice 通知，<code>PointcutAdvisor</code> 包含一个 Advice 通知和一个 Pointcut</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">classDiagram</span><br><span class="line"></span><br><span class="line">class Advice</span><br><span class="line">class MethodInterceptor</span><br><span class="line">class Advisor</span><br><span class="line">class PointcutAdvisor</span><br><span class="line"></span><br><span class="line">Pointcut &lt;|-- AspectJExpressionPointcut</span><br><span class="line">Advice &lt;|-- MethodInterceptor</span><br><span class="line">Advisor &lt;|-- PointcutAdvisor</span><br><span class="line">PointcutAdvisor o-- "一" Pointcut</span><br><span class="line">PointcutAdvisor o-- "一" Advice</span><br><span class="line"></span><br><span class="line">&lt;&lt;interface&gt;&gt; Advice</span><br><span class="line">&lt;&lt;interface&gt;&gt; MethodInterceptor</span><br><span class="line">&lt;&lt;interface&gt;&gt; Pointcut</span><br><span class="line">&lt;&lt;interface&gt;&gt; Advisor</span><br><span class="line">&lt;&lt;interface&gt;&gt; PointcutAdvisor</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><p>代理相关类图</p>
<ul>
<li>AopProxyFactory 根据 proxyTargetClass 等设置选择 AopProxy 实现</li>
<li>AopProxy 通过 getProxy 创建代理对象</li>
<li>图中 Proxy 都实现了 Advised 接口，能够获得关联的切面集合与目标（其实是从 ProxyFactory 取得）</li>
<li>调用代理方法时，会借助 ProxyFactory 将通知统一转为环绕通知：MethodInterceptor</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">classDiagram</span><br><span class="line"></span><br><span class="line">Advised &lt;|-- ProxyFactory</span><br><span class="line">ProxyFactory o-- Target</span><br><span class="line">ProxyFactory o-- "多" Advisor</span><br><span class="line"></span><br><span class="line">ProxyFactory --&gt; AopProxyFactory : 使用</span><br><span class="line">AopProxyFactory --&gt; AopProxy</span><br><span class="line">Advised &lt;|-- 基于CGLIB的Proxy</span><br><span class="line">基于CGLIB的Proxy &lt;-- ObjenesisCglibAopProxy : 创建</span><br><span class="line">AopProxy &lt;|-- ObjenesisCglibAopProxy</span><br><span class="line">AopProxy &lt;|-- JdkDynamicAopProxy</span><br><span class="line">基于JDK的Proxy &lt;-- JdkDynamicAopProxy : 创建</span><br><span class="line">Advised &lt;|-- 基于JDK的Proxy</span><br><span class="line"></span><br><span class="line">class AopProxy {</span><br><span class="line">   +getProxy() Object</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">class ProxyFactory {</span><br><span class="line">	proxyTargetClass : boolean</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">class ObjenesisCglibAopProxy {</span><br><span class="line">	advised : ProxyFactory</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">class JdkDynamicAopProxy {</span><br><span class="line">	advised : ProxyFactory</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">&lt;&lt;interface&gt;&gt; Advised</span><br><span class="line">&lt;&lt;interface&gt;&gt; AopProxyFactory</span><br><span class="line">&lt;&lt;interface&gt;&gt; AopProxy</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><p>ProxyFactory 用来创建代理</p>
<ul>
<li><p>如果指定了接口，且 proxyTargetClass = false，使用 JdkDynamicAopProxy</p>
</li>
<li><p>如果没有指定接口，或者 proxyTargetClass = true，使用 ObjenesisCglibAopProxy</p>
<ul>
<li>例外：如果目标是接口类型或已经是 Jdk 代理，使用 JdkDynamicAopProxy                     </li>
</ul>
<p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/Spring高级.assets/image-20231130221021934.png" alt="image-20231130221021934">                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             </p>
</li>
</ul>
</li>
</ul>
<h4 id="7-2-底层切点实现"><a href="#7-2-底层切点实现" class="headerlink" title="7.2 底层切点实现"></a>7.2 底层切点实现</h4><ul>
<li><p>切点的匹配</p>
<ul>
<li><p>常见 aspectj 切点用法</p>
<p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/Spring高级.assets/image-20231203130810802.png" alt="image-20231203130810802"></p>
</li>
<li><p>aspectj 切点的局限性，实际的 <code>@Transactional</code> 切点实现</p>
<ul>
<li><p>不能处理加在类上的注解或者加在接口上的注解（加在类上表示类中所有方法都匹配，接口类似）</p>
</li>
<li><p>实际的实现（多加了一些判断）</p>
<p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/Spring高级.assets/image-20231203131333433.png" alt="image-20231203131333433"></p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="7-3-底层切面实现"><a href="#7-3-底层切面实现" class="headerlink" title="7.3 底层切面实现"></a>7.3 底层切面实现</h4><ul>
<li><p>高级的<code>@Aspect</code>切面</p>
<p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/Spring高级.assets/image-20231203132443723.png" alt="image-20231203132443723"></p>
</li>
<li><p>低级的Advisor切面</p>
<p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/Spring高级.assets/image-20231203132454991.png" alt="image-20231203132454991"></p>
</li>
<li><p>一些方法</p>
<ul>
<li><code>AnnotationAwareAspectJAutoProxyCreator</code> 的作用<ul>
<li>将高级 @Aspect 切面统一为低级 Advisor 切面</li>
<li>在合适的时机创建代理</li>
</ul>
</li>
<li><code>findEligibleAdvisors</code> 找到有【资格】的 Advisors<ul>
<li>有【资格】的 Advisor 一部分是低级的, 可以由自己编写, 如本例 A17 中的 advisor3</li>
<li>有【资格】的 Advisor 另一部分是高级的, 由解析 @Aspect 后获得</li>
</ul>
</li>
<li><code>wrapIfNecessary</code><ul>
<li>它内部调用 <code>findEligibleAdvisors</code>, 只要返回集合不空, 则表示需要创建代理</li>
<li>它的调用时机通常在原始对象初始化后执行, 但碰到循环依赖会提前至依赖注入之前执行</li>
</ul>
</li>
</ul>
</li>
<li><p>高级转换未低级切面的时机及代理生成时机</p>
<ul>
<li>代理的创建时机<ul>
<li>初始化之后 (无循环依赖时)</li>
<li>实例创建后, 依赖注入前 (有循环依赖时), 并暂存于二级缓存</li>
</ul>
</li>
<li>依赖注入与初始化不应该被增强, 仍应被施加于原始对象</li>
</ul>
</li>
<li><p>切面的控制顺序</p>
<ul>
<li><code>@Order</code></li>
</ul>
</li>
<li><p>高级切面解析为低级切面的过程</p>
<ul>
<li><p>拿到类中所有的方法</p>
</li>
<li><p>解析方法是否有注解（<code>@Before</code>，<code>@After</code>…）</p>
</li>
<li><p>拿到注解，并获取到切点表达式，然后创建切点对象</p>
</li>
<li><p>创建通知类，参数是方法、切点以及切面实例对象</p>
</li>
<li><p>创建切面<code>Advisor</code>并放到一个集合中</p>
<p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/Spring高级.assets/image-20231203140403263.png" alt="image-20231203140403263"></p>
</li>
</ul>
</li>
</ul>
<h4 id="7-4-底层通知实现"><a href="#7-4-底层通知实现" class="headerlink" title="7.4 底层通知实现"></a>7.4 底层通知实现</h4><ul>
<li><p>静态通知</p>
<ul>
<li><p>通过 <code>proxyFactory</code> 的 <code>getInterceptorsAndDynamicInterceptionAdvice()</code> 将其他通知统一转换为 <code>MethodInterceptor</code> 环绕通知</p>
<ul>
<li><code>MethodBeforeAdviceAdapter</code> 将 <code>@Before</code> <code>AspectJMethodBeforeAdvice</code> 适配为 <code>MethodBeforeAdviceInterceptor</code></li>
<li><code>AfterReturningAdviceAdapter</code> 将 <code>@AfterReturning</code> <code>AspectJAfterReturningAdvice</code> 适配为 <code>AfterReturningAdviceInterceptor</code></li>
<li>这体现的是适配器设计模式</li>
</ul>
</li>
<li><p>所谓静态通知，体现在上面方法的 <code>Interceptors</code> 部分，这些通知调用时无需再次检查切点，直接调用即可</p>
</li>
<li><p>结合目标与环绕通知链，创建 <code>MethodInvocation</code> 对象，通过它完成整个调用（递归）</p>
<p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/Spring高级.assets/image-20231203144733359.png" alt="image-20231203144733359"></p>
</li>
</ul>
</li>
<li><p>动态通知</p>
<ul>
<li><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/Spring高级.assets/image-20231203145127731.png" alt="image-20231203145127731"></li>
<li>动态通知：<ul>
<li>需要参数的绑定（性能稍微低一些，因为需要处理参数）</li>
<li>需要切点。静态执行时不需要切点</li>
</ul>
</li>
<li>过程<ul>
<li>通过 <code>proxyFactory</code> 的 <code>getInterceptorsAndDynamicInterceptionAdvice()</code> 将其他通知统一转换为 <code>MethodInterceptor</code> 环绕通知</li>
<li>所谓动态通知，体现在上面方法的 <code>DynamicInterceptionAdvice</code> 部分，这些通知调用时因为要为通知方法绑定参数，还需再次利用切点表达式</li>
<li>动态通知调用复杂程度高，性能较低</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="Ⅲ-Web-MVC"><a href="#Ⅲ-Web-MVC" class="headerlink" title="Ⅲ Web MVC"></a>Ⅲ Web MVC</h2><p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/Spring高级.assets/image-20231207153421513.png" alt="image-20231207153421513"></p>
<p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/Spring高级.assets/image-20231207154139758.png" alt="image-20231207154139758"></p>
<h3 id="一-Controller解析请求"><a href="#一-Controller解析请求" class="headerlink" title="一 Controller解析请求"></a>一 Controller解析请求</h3><h4 id="1-1-DispatcherServlet-初始化"><a href="#1-1-DispatcherServlet-初始化" class="headerlink" title="1.1 DispatcherServlet 初始化"></a>1.1 DispatcherServlet 初始化</h4><ul>
<li><p>创建WebConfig配置类</p>
<ul>
<li>三个必须组件：web容器工厂、DispatcherServlet 、注册DispatcherServlet （Spring MVC入口）</li>
</ul>
<p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/Spring高级.assets/image-20231203153928889.png" alt="image-20231203153928889"></p>
</li>
<li><p>创建<code>AnnotationConfigServletWebServerApplicationContext</code>，导入配置类</p>
<p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/Spring高级.assets/image-20231203153855015.png" alt="image-20231203153855015"></p>
</li>
<li><p><code>DispatcherServlet</code>初始化时间</p>
<ul>
<li>默认在首次使用的时候才会初始化</li>
<li>也可以修改为tomcat初始化的时候就初始化</li>
</ul>
</li>
<li><p><code>DispatcherServlet</code>初始化过程</p>
<ul>
<li>在初始化时会从 Spring 容器中找一些 Web 需要的组件, 如 <code>HandlerMapping</code>、<code>HandlerAdapter</code> 等，并逐一调用它们的初始化</li>
</ul>
</li>
</ul>
<h4 id="1-2-RequestMappingHandlerMapping初始化"><a href="#1-2-RequestMappingHandlerMapping初始化" class="headerlink" title="1.2 RequestMappingHandlerMapping初始化"></a>1.2 RequestMappingHandlerMapping初始化</h4><ul>
<li><code>RequestMappingHandlerMapping</code> 初始化时，会收集所有 <code>@RequestMapping</code> 映射信息，封装为 Map，其中<ul>
<li>key 是 RequestMappingInfo 类型，包括请求路径、请求方法等信息</li>
<li>value 是 HandlerMethod 类型，包括控制器方法对象、控制器对象</li>
<li>有了这个 Map，就可以在请求到达时，快速完成映射，找到 HandlerMethod 并与匹配的拦截器一起返回给 DispatcherServlet</li>
</ul>
</li>
</ul>
<h4 id="1-3-RequestMappingHandlerAdapter初始化"><a href="#1-3-RequestMappingHandlerAdapter初始化" class="headerlink" title="1.3 RequestMappingHandlerAdapter初始化"></a>1.3 RequestMappingHandlerAdapter初始化</h4><ul>
<li><p><code>RequestMappingHandlerAdapter</code> 初始化时，会准备 <code>HandlerMethod</code> 调用时需要的各个组件，如：</p>
<ul>
<li>HandlerMethodArgumentResolver 解析控制器方法参数</li>
<li>HandlerMethodReturnValueHandler 处理控制器方法返回值<ul>
<li>一般是将返回值转为json发送到响应体中</li>
</ul>
</li>
</ul>
</li>
<li><p>自定义参数与自定义返回值处理器</p>
<ul>
<li><p>继承<code>HandlerMethodArgumentResolver</code>并重写相关方法</p>
<p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/Spring高级.assets/image-20231206203820252.png" alt="image-20231206203820252"></p>
<ul>
<li><p>e要在配置类中在<code>RequestMappingHandlerAdapter</code>中添加这个处理器</p>
<p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/Spring高级.assets/image-20231206203939295.png" alt="image-20231206203939295"></p>
</li>
</ul>
</li>
<li><p>继承<code>HandlerMethodReturnValueHandler</code>并重写相关方法</p>
<p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/Spring高级.assets/image-20231206204616764.png" alt="image-20231206204616764"></p>
<ul>
<li>同样的也需要在配置类中的<code>RequestMappingHandlerAdapter</code>中添加这个处理器（略）</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="二-参数解析器"><a href="#二-参数解析器" class="headerlink" title="二 参数解析器"></a>二 参数解析器</h3><ul>
<li><p>常见参数解析器</p>
<ul>
<li><p><code>@RequesParam</code>、<code>@PathVariable</code>、<code>@RquestHeader</code>、<code>@CookieValue</code>、<code>@Value</code>、<code>@ModelAttribute</code>、<code>@RequestBody</code></p>
<p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/Spring高级.assets/image-20231206205750880.png" alt="image-20231206205750880"></p>
</li>
</ul>
</li>
<li><p>组合模式在Spring中的应用</p>
<ul>
<li><p>组合解析器</p>
<p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/Spring高级.assets/image-20231206212857993.png" alt="image-20231206212857993"></p>
</li>
</ul>
</li>
<li><p>获取参数名</p>
<ul>
<li>如果编译时添加了 <code>-parameters</code> 可以生成参数表, 反射时就可以拿到参数名</li>
<li>如果编译时添加了 <code>-g</code> 可以生成调试信息, 但分为两种情况<ul>
<li>普通类, 会包含局部变量表, 用 asm 可以拿到参数名</li>
<li>接口, 不会包含局部变量表, 无法获得参数名<ul>
<li>这也是 MyBatis 在实现 Mapper 接口时为何要提供 @Param 注解来辅助获得参数名</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="三-对象绑定和类型转换"><a href="#三-对象绑定和类型转换" class="headerlink" title="三 对象绑定和类型转换"></a>三 对象绑定和类型转换</h3><h4 id="3-1-底层第一套转换接口与实现"><a href="#3-1-底层第一套转换接口与实现" class="headerlink" title="3.1 底层第一套转换接口与实现"></a>3.1 底层第一套转换接口与实现</h4><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">classDiagram</span><br><span class="line"></span><br><span class="line">Formatter --|&gt; Printer</span><br><span class="line">Formatter --|&gt; Parser</span><br><span class="line"></span><br><span class="line">class Converters {</span><br><span class="line">   Set~GenericConverter~</span><br><span class="line">}</span><br><span class="line">class Converter</span><br><span class="line"></span><br><span class="line">class ConversionService</span><br><span class="line">class FormattingConversionService</span><br><span class="line"></span><br><span class="line">ConversionService &lt;|-- FormattingConversionService</span><br><span class="line">FormattingConversionService o-- Converters</span><br><span class="line"></span><br><span class="line">Printer --&gt; Adapter1</span><br><span class="line">Adapter1 --&gt; Converters</span><br><span class="line">Parser --&gt; Adapter2</span><br><span class="line">Adapter2 --&gt; Converters</span><br><span class="line">Converter --&gt; Adapter3</span><br><span class="line">Adapter3 --&gt; Converters</span><br><span class="line"></span><br><span class="line">&lt;&lt;interface&gt;&gt; Formatter</span><br><span class="line">&lt;&lt;interface&gt;&gt; Printer</span><br><span class="line">&lt;&lt;interface&gt;&gt; Parser</span><br><span class="line">&lt;&lt;interface&gt;&gt; Converter</span><br><span class="line">&lt;&lt;interface&gt;&gt; ConversionService</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>Printer 把其它类型转为 String</li>
<li>Parser 把 String 转为其它类型</li>
<li>Formatter 综合 Printer 与 Parser 功能</li>
<li>Converter 把类型 S 转为类型 T</li>
<li>Printer、Parser、Converter 经过适配转换成 GenericConverter 放入 Converters 集合</li>
<li>FormattingConversionService 利用其它们实现转换</li>
</ul>
<h4 id="3-2-底层第二套转换接口"><a href="#3-2-底层第二套转换接口" class="headerlink" title="3.2 底层第二套转换接口"></a>3.2 底层第二套转换接口</h4><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">classDiagram</span><br><span class="line"></span><br><span class="line">PropertyEditorRegistry o-- "多" PropertyEditor</span><br><span class="line"></span><br><span class="line">&lt;&lt;interface&gt;&gt; PropertyEditorRegistry</span><br><span class="line">&lt;&lt;interface&gt;&gt; PropertyEditor</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>PropertyEditor 把 String 与其它类型相互转换</li>
<li>PropertyEditorRegistry 可以注册多个 PropertyEditor 对象</li>
<li>与第一套接口直接可以通过 FormatterPropertyEditorAdapter 来进行适配</li>
</ul>
<h4 id="3-3-高层接口与实现"><a href="#3-3-高层接口与实现" class="headerlink" title="3.3 高层接口与实现"></a>3.3 高层接口与实现</h4><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">classDiagram</span><br><span class="line">TypeConverter &lt;|-- SimpleTypeConverter</span><br><span class="line">TypeConverter &lt;|-- BeanWrapperImpl</span><br><span class="line">TypeConverter &lt;|-- DirectFieldAccessor</span><br><span class="line">TypeConverter &lt;|-- ServletRequestDataBinder</span><br><span class="line"></span><br><span class="line">SimpleTypeConverter --&gt; TypeConverterDelegate</span><br><span class="line">BeanWrapperImpl --&gt; TypeConverterDelegate</span><br><span class="line">DirectFieldAccessor --&gt; TypeConverterDelegate</span><br><span class="line">ServletRequestDataBinder --&gt; TypeConverterDelegate</span><br><span class="line"></span><br><span class="line">TypeConverterDelegate --&gt; ConversionService</span><br><span class="line">TypeConverterDelegate --&gt; PropertyEditorRegistry</span><br><span class="line"></span><br><span class="line">&lt;&lt;interface&gt;&gt; TypeConverter</span><br><span class="line">&lt;&lt;interface&gt;&gt; ConversionService</span><br><span class="line">&lt;&lt;interface&gt;&gt; PropertyEditorRegistry</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>它们都实现了 TypeConverter 这个高层转换接口，在转换时，会用到 TypeConverter Delegate 委派ConversionService 与 PropertyEditorRegistry 真正执行转换（Facade 门面模式）<ul>
<li>首先看是否有自定义转换器, @InitBinder 添加的即属于这种 (用了适配器模式把 Formatter 转为需要的 PropertyEditor)</li>
<li>再看有没有 ConversionService 转换</li>
<li>再利用默认的 PropertyEditor 转换</li>
<li>最后有一些特殊处理</li>
</ul>
</li>
<li>SimpleTypeConverter 仅做类型转换</li>
<li>BeanWrapperImpl 为 bean 的属性赋值，当需要时做类型转换，走 Property</li>
<li>DirectFieldAccessor 为 bean 的属性赋值，当需要时做类型转换，走 Field</li>
<li>ServletRequestDataBinder 为 bean 的属性执行绑定，当需要时做类型转换，根据 directFieldAccess 选择走 Property 还是 Field，具备校验与获取校验结果功能</li>
</ul>
<h4 id="3-4-示例"><a href="#3-4-示例" class="headerlink" title="3.4 示例"></a>3.4 示例</h4><ul>
<li><code>SimpleTypeConverter</code></li>
</ul>
<p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/Spring高级.assets/image-20231206215723463.png" alt="image-20231206215723463"></p>
<ul>
<li><p><code>BeanWrapperImpl</code></p>
<p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/Spring高级.assets/image-20231206215907603.png" alt="image-20231206215907603"></p>
</li>
<li><p><code>DirectFieldAccessor</code></p>
<p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/Spring高级.assets/image-20231206215936147.png" alt="image-20231206215936147"></p>
</li>
<li><p><code>ServletRequesrDataBinder</code></p>
<p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/Spring高级.assets/image-20231206220014794.png" alt="image-20231206220014794"></p>
</li>
</ul>
<h4 id="3-5-绑定器工厂"><a href="#3-5-绑定器工厂" class="headerlink" title="3.5 绑定器工厂"></a>3.5 绑定器工厂</h4><ul>
<li><p>将创建DataBinder的过程放到工厂里面(没有功能)，通过一些方式可以自定义转换功能 <code>ServletRequestDataBinderFactory</code></p>
</li>
<li><p>扩展转换功能</p>
<ul>
<li><code>@initBinder</code></li>
<li><code>ConversionService</code></li>
<li>同时用了以上两者</li>
<li>默认使用<code>ConversionService</code></li>
</ul>
</li>
</ul>
<h4 id="3-6-如何获取泛型参数"><a href="#3-6-如何获取泛型参数" class="headerlink" title="3.6 如何获取泛型参数"></a>3.6 如何获取泛型参数</h4><ul>
<li>开发框架中用</li>
<li>java api获取泛型参数</li>
<li>Spring api获取</li>
</ul>
<h3 id="四-ControllerAdvice"><a href="#四-ControllerAdvice" class="headerlink" title="四 @ControllerAdvice"></a>四 <code>@ControllerAdvice</code></h3><ul>
<li><p>和AOP的代理没关系，只是借鉴了Advice这个名字</p>
</li>
<li><p><code>@ExceptionHandler</code>：处理异常的</p>
</li>
<li><p><code>@ModelAttribute</code>：补充模型数据</p>
</li>
<li><p><code>@InitBinder</code>：类型转换器</p>
</li>
</ul>
<h4 id="4-1-InitBinder"><a href="#4-1-InitBinder" class="headerlink" title="4.1 @InitBinder"></a>4.1 <code>@InitBinder</code></h4><ul>
<li><p>加在ControllerAdivce中的是全局的，加在Controller中的是局部的</p>
<p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/Spring高级.assets/image-20231207144031836.png" alt="image-20231207144031836"></p>
</li>
<li><p>RequestMappingHandlerAdapter 初始化时会解析 @ControllerAdvice 中的 @InitBinder 方法</p>
</li>
<li>RequestMappingHandlerAdapter 会以类为单位，在该类首次使用时，解析此类的 @InitBinder 方法</li>
<li>以上两种 @InitBinder 的解析结果都会缓存来避免重复解析</li>
<li>控制器方法调用时，会综合利用本类的 @InitBinder 方法和 @ControllerAdvice 中的 @InitBinder 方法创建绑定工厂</li>
</ul>
<h4 id="4-2-ModelAttribute"><a href="#4-2-ModelAttribute" class="headerlink" title="4.2 @ModelAttribute"></a>4.2 <code>@ModelAttribute</code></h4><ul>
<li><p>加在参数上</p>
<ul>
<li><p>将模型数据加到modelandview中</p>
<p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/Spring高级.assets/image-20231207151201385.png" alt="image-20231207151201385"></p>
</li>
<li><p>没有指定名字（图中 的“u”）则以类名首字母小写存</p>
</li>
</ul>
</li>
<li><p>加载类方法上</p>
<ul>
<li><p>将方法返回结果加到modelandview中</p>
<p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/Spring高级.assets/image-20231207151326746.png" alt="image-20231207151326746"></p>
</li>
<li><p>没有指定名字则以方法返回值首字母小写存</p>
</li>
</ul>
</li>
</ul>
<h4 id="4-3-控制器方法执行流程"><a href="#4-3-控制器方法执行流程" class="headerlink" title="4.3 控制器方法执行流程"></a>4.3 控制器方法执行流程</h4><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">classDiagram</span><br><span class="line">class ServletInvocableHandlerMethod {</span><br><span class="line">	+invokeAndHandle(ServletWebRequest,ModelAndViewContainer)</span><br><span class="line">}</span><br><span class="line">HandlerMethod &lt;|-- ServletInvocableHandlerMethod</span><br><span class="line">HandlerMethod o-- bean</span><br><span class="line">HandlerMethod o-- method</span><br><span class="line">ServletInvocableHandlerMethod o-- WebDataBinderFactory</span><br><span class="line">ServletInvocableHandlerMethod o-- ParameterNameDiscoverer</span><br><span class="line">ServletInvocableHandlerMethod o-- HandlerMethodArgumentResolverComposite</span><br><span class="line">ServletInvocableHandlerMethod o-- HandlerMethodReturnValueHandlerComposite</span><br></pre></td></tr></tbody></table></figure>
<p>HandlerMethod 需要</p>
<ul>
<li>bean 即是哪个 Controller</li>
<li>method 即是 Controller 中的哪个方法</li>
</ul>
<p>ServletInvocableHandlerMethod 需要</p>
<ul>
<li>WebDataBinderFactory 负责对象绑定、类型转换</li>
<li>ParameterNameDiscoverer 负责参数名解析</li>
<li>HandlerMethodArgumentResolverComposite 负责解析参数</li>
<li>HandlerMethodReturnValueHandlerComposite 负责处理返回值</li>
</ul>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">sequenceDiagram</span><br><span class="line">participant adapter as RequestMappingHandlerAdapter</span><br><span class="line">participant bf as WebDataBinderFactory</span><br><span class="line">participant mf as ModelFactory</span><br><span class="line">participant container as ModelAndViewContainer</span><br><span class="line">adapter -&gt;&gt; +bf: 准备 @InitBinder</span><br><span class="line">bf --&gt;&gt; -adapter: </span><br><span class="line">adapter -&gt;&gt; +mf: 准备 @ModelAttribute</span><br><span class="line">mf -&gt;&gt; +container: 添加Model数据</span><br><span class="line">container --&gt;&gt; -mf: </span><br><span class="line">mf --&gt;&gt; -adapter: </span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">sequenceDiagram</span><br><span class="line">participant adapter as RequestMappingHandlerAdapter</span><br><span class="line">participant ihm as ServletInvocableHandlerMethod</span><br><span class="line">participant ar as ArgumentResolvers</span><br><span class="line">participant rh as ReturnValueHandlers</span><br><span class="line">participant container as ModelAndViewContainer</span><br><span class="line"></span><br><span class="line">adapter -&gt;&gt; +ihm: invokeAndHandle</span><br><span class="line">ihm -&gt;&gt; +ar: 获取 args</span><br><span class="line">ar -&gt;&gt; ar: 有的解析器涉及 RequestBodyAdvice</span><br><span class="line">ar -&gt;&gt; container: 有的解析器涉及数据绑定生成模型数据</span><br><span class="line">container --&gt;&gt; ar: </span><br><span class="line">ar --&gt;&gt; -ihm: args</span><br><span class="line">ihm -&gt;&gt; ihm: method.invoke(bean,args) 得到 returnValue</span><br><span class="line">ihm -&gt;&gt; +rh: 处理 returnValue</span><br><span class="line">rh -&gt;&gt; rh: 有的处理器涉及 ResponseBodyAdvice</span><br><span class="line">rh -&gt;&gt; +container: 添加Model数据,处理视图名,是否渲染等</span><br><span class="line">container --&gt;&gt; -rh: </span><br><span class="line">rh --&gt;&gt; -ihm: </span><br><span class="line">ihm --&gt;&gt; -adapter: </span><br><span class="line">adapter -&gt;&gt; +container: 获取 ModelAndView</span><br><span class="line">container --&gt;&gt; -adapter: </span><br></pre></td></tr></tbody></table></figure>
<h3 id="五-返回值处理器"><a href="#五-返回值处理器" class="headerlink" title="五 返回值处理器"></a>五 返回值处理器</h3><ul>
<li>返回值类型<ul>
<li><code>ModelAndView</code></li>
<li><code>String</code></li>
<li><code>void</code></li>
<li><code>Object</code></li>
</ul>
</li>
<li>常见返回值处理器<ul>
<li>返回值类型为ModelAndView，分别获取其模型和视图名，放入 ModelAndViewContainer</li>
<li>返回值类型为 String 时，把它当做视图名，放入 ModelAndViewContainer</li>
<li>返回值添加了 @ModelAttribute 注解时，将返回值作为模型，放入 ModelAndViewContainer<ul>
<li>此时需找到默认视图名</li>
</ul>
</li>
<li>返回值省略 @ModelAttribute 注解且返回非简单类型时，将返回值作为模型，放入 ModelAndViewContainer<ul>
<li>此时需找到默认视图名</li>
</ul>
</li>
<li>返回值类型为 ResponseEntity 时<ul>
<li>此时走 MessageConverter，并设置 ModelAndViewContainer.requestHandled 为 true</li>
</ul>
</li>
<li>返回值类型为 HttpHeaders 时<ul>
<li>会设置 ModelAndViewContainer.requestHandled 为 true</li>
</ul>
</li>
<li>返回值添加了 @ResponseBody 注解时<ul>
<li>此时走 MessageConverter，并设置 ModelAndViewContainer.requestHandled 为 true</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="六-异常处理"><a href="#六-异常处理" class="headerlink" title="六 异常处理"></a>六 异常处理</h3><ul>
<li><code>ExceptionHandlerExceptionResolver</code><ul>
<li>它能够重用参数解析器、返回值处理器，实现组件重用</li>
<li>它能够支持嵌套异常</li>
</ul>
</li>
<li><code>@ExceptionHandler</code> 只能处理发生在 mvc 流程中的异常，例如控制器内、拦截器内</li>
</ul>
<h4 id="6-1-tomcat异常处理"><a href="#6-1-tomcat异常处理" class="headerlink" title="6.1 tomcat异常处理"></a>6.1 tomcat异常处理</h4><ul>
<li>比ExceptionHandler更高级，处理的异常等级更高，比如Filter的异常</li>
<li>在 Spring Boot 中，是这么实现的：<ol>
<li>因为内嵌了 Tomcat 容器，因此可以配置  Tomcat 的错误页面，Filter 与 错误页面之间是通过请求转发跳转的，可以在这里做手脚</li>
<li>先通过 ErrorPageRegistrarBeanPostProcessor 这个后处理器配置错误页面地址，默认为 <code>/error</code> 也可以通过 <code>${server.error.path}</code> 进行配置</li>
<li>当 Filter 发生异常时，不会走 Spring 流程，但会走 Tomcat 的错误处理，于是就希望转发至 <code>/error</code> 这个地址<ul>
<li>当然，如果没有 @ExceptionHandler，那么最终也会走到 Tomcat 的错误处理</li>
</ul>
</li>
<li>Spring Boot 又提供了一个 BasicErrorController，它就是一个标准 @Controller，@RequestMapping 配置为 <code>/error</code>，所以处理异常的职责就又回到了 Spring</li>
<li>异常信息由于会被 Tomcat 放入 request 作用域，因此 BasicErrorController 里也能获取到</li>
<li>具体异常信息会由 DefaultErrorAttributes 封装好</li>
<li>BasicErrorController 通过 Accept 头判断需要生成哪种 MediaType 的响应<ul>
<li>如果要的不是 text/html，走 MessageConverter 流程</li>
<li>如果需要 text/html，走 mvc 流程，此时又分两种情况<ul>
<li>配置了 ErrorViewResolver，根据状态码去找 View</li>
<li>没配置或没找到，用 BeanNameViewResolver 根据一个固定为 error 的名字找到 View，即所谓的 WhitelabelErrorView</li>
</ul>
</li>
</ul>
</li>
</ol>
</li>
</ul>
<h3 id="七-其他的Handler"><a href="#七-其他的Handler" class="headerlink" title="七 其他的Handler"></a>七 其他的Handler</h3><ul>
<li><p><code>@BeanNameUrlHandlerMapping</code>:请求路径不找Controller方法而是对应的bean</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> BeanNameUrlHandlerMapping <span class="title function_">beanNameUrlHandlerMapping</span><span class="params">()</span> {</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">BeanNameUrlHandlerMapping</span>();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> SimpleControllerHandlerAdapter <span class="title function_">simpleControllerHandlerAdapter</span><span class="params">()</span> {</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">SimpleControllerHandlerAdapter</span>();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean("/c3")</span><span class="comment">// /c3的请求将访问这个bean作为控制器，bean需要实现Controller接口</span></span><br><span class="line"><span class="keyword">public</span> Controller <span class="title function_">controller3</span><span class="params">()</span> {</span><br><span class="line">    <span class="keyword">return</span> (request, response) -&gt; {</span><br><span class="line">        response.getWriter().print(<span class="string">"this is c3"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    };</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>BeanNameUrlHandlerMapping，以 / 开头的 bean 的名字会被当作映射路径</li>
<li>这些 bean 本身当作 handler，要求实现 Controller 接口</li>
<li>SimpleControllerHandlerAdapter，调用 handler</li>
<li>模拟实现这组映射器和适配器</li>
</ul>
</li>
<li><p>总结</p>
<ul>
<li><code>HandlerMapping</code> 负责建立请求与控制器之间的映射关系<ul>
<li>RequestMappingHandlerMapping (与 @RequestMapping 匹配)</li>
<li>WelcomePageHandlerMapping    (/)</li>
<li>BeanNameUrlHandlerMapping    (与 bean 的名字匹配 以 / 开头)</li>
<li>RouterFunctionMapping        (函数式 RequestPredicate, HandlerFunction)</li>
<li>SimpleUrlHandlerMapping      (静态资源 通配符 /<strong> /img/</strong>)</li>
<li>之间也会有顺序问题, boot 中默认顺序如上</li>
</ul>
</li>
<li><code>HandlerAdapter</code> 负责实现对各种各样的 handler 的适配调用<ul>
<li>RequestMappingHandlerAdapter 处理：@RequestMapping 方法<ul>
<li>参数解析器、返回值处理器体现了组合模式</li>
</ul>
</li>
<li>SimpleControllerHandlerAdapter 处理：Controller 接口</li>
<li>HandlerFunctionAdapter 处理：HandlerFunction 函数式接口</li>
<li>HttpRequestHandlerAdapter 处理：HttpRequestHandler 接口 (静态资源处理)</li>
<li>这也是典型适配器模式体现</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="八-MVC处理流程"><a href="#八-MVC处理流程" class="headerlink" title="八 MVC处理流程"></a>八 MVC处理流程</h3><ul>
<li>当浏览器发送一个请求 <code>http://localhost:8080/hello</code> 后，请求到达服务器，其处理流程是：</li>
<li><p>服务器提供了 DispatcherServlet，它使用的是标准 Servlet 技术</p>
<ul>
<li>路径：默认映射路径为 <code>/</code>，即会匹配到所有请求 URL，可作为请求的统一入口，也被称之为<strong>前控制器</strong><ul>
<li>jsp 不会匹配到 DispatcherServlet</li>
<li>其它有路径的 Servlet 匹配优先级也高于 DispatcherServlet</li>
</ul>
</li>
<li>创建：在 Boot 中，由 DispatcherServletAutoConfiguration 这个自动配置类提供 DispatcherServlet 的 bean</li>
<li>初始化：DispatcherServlet 初始化时会优先到容器里寻找各种组件，作为它的成员变量<ul>
<li><code>HandlerMapping</code>，初始化时记录映射关系</li>
<li><code>HandlerAdapter</code>，初始化时准备参数解析器、返回值处理器、消息转换器</li>
<li><code>HandlerExceptionResolver</code>，初始化时准备参数解析器、返回值处理器、消息转换器</li>
<li>ViewResolver</li>
</ul>
</li>
</ul>
</li>
<li><p>DispatcherServlet 会利用 RequestMappingHandlerMapping 查找控制器方法</p>
<ul>
<li><p>例如根据 /hello 路径找到 @RequestMapping(“/hello”) 对应的控制器方法</p>
</li>
<li><p>控制器方法会被封装为 HandlerMethod 对象，并结合匹配到的拦截器一起返回给 DispatcherServlet </p>
</li>
<li><p>HandlerMethod 和拦截器合在一起称为 HandlerExecutionChain（调用链）对象</p>
</li>
</ul>
</li>
<li><p>DispatcherServlet 接下来会：</p>
<ol>
<li>调用拦截器的 preHandle 方法</li>
<li>RequestMappingHandlerAdapter 调用 handle 方法，准备数据绑定工厂、模型工厂、ModelAndViewContainer、将 HandlerMethod 完善为 ServletInvocableHandlerMethod<ul>
<li>@ControllerAdvice 全局增强点1️⃣：补充模型数据</li>
<li>@ControllerAdvice 全局增强点2️⃣：补充自定义类型转换器</li>
<li>使用 HandlerMethodArgumentResolver 准备参数<ul>
<li>@ControllerAdvice 全局增强点3️⃣：RequestBody 增强</li>
</ul>
</li>
<li>调用 ServletInvocableHandlerMethod </li>
<li>使用 HandlerMethodReturnValueHandler 处理返回值<ul>
<li>@ControllerAdvice 全局增强点4️⃣：ResponseBody 增强</li>
</ul>
</li>
<li>根据 ModelAndViewContainer 获取 ModelAndView<ul>
<li>如果返回的 ModelAndView 为 null，不走第 4 步视图解析及渲染流程<ul>
<li>例如，有的返回值处理器调用了 HttpMessageConverter 来将结果转换为 JSON，这时 ModelAndView 就为 null</li>
</ul>
</li>
<li>如果返回的 ModelAndView 不为 null，会在第 4 步走视图解析及渲染流程</li>
</ul>
</li>
</ul>
</li>
<li>调用拦截器的 postHandle 方法</li>
<li>处理异常或视图渲染<ul>
<li>如果 1~3 出现异常，走 ExceptionHandlerExceptionResolver 处理异常流程<ul>
<li>@ControllerAdvice 全局增强点5️⃣：@ExceptionHandler 异常处理</li>
</ul>
</li>
<li>正常，走视图解析及渲染流程</li>
</ul>
</li>
<li>调用拦截器的 afterCompletion 方法</li>
</ol>
</li>
</ul>
<h2 id="Ⅳ-Spring-boot"><a href="#Ⅳ-Spring-boot" class="headerlink" title="Ⅳ Spring boot"></a>Ⅳ Spring boot</h2><h3 id="一-Boot启动过程"><a href="#一-Boot启动过程" class="headerlink" title="一 Boot启动过程"></a>一 Boot启动过程</h3><h4 id="1-1-构造分析"><a href="#1-1-构造分析" class="headerlink" title="1.1 构造分析"></a>1.1 构造分析</h4><ul>
<li><code>springApplication</code>构造<ol>
<li>记录 BeanDefinition 源</li>
<li>推断应用类型</li>
<li>记录 ApplicationContext 初始化器</li>
<li>记录监听器</li>
<li>推断主启动类</li>
</ol>
</li>
</ul>
<h4 id="1-2-run分析"><a href="#1-2-run分析" class="headerlink" title="1.2 run分析"></a>1.2 run分析</h4><ul>
<li><p>执行run方法</p>
<ol>
<li><p>得到 <code>SpringApplicationRunListeners</code>，名字取得不好，实际是事件发布器</p>
<ul>
<li>发布 application starting 事件1️⃣</li>
</ul>
</li>
<li>封装启动 args</li>
<li>准备 Environment 添加命令行参数（*）<ul>
<li>ApplicationEnvironment</li>
</ul>
</li>
<li><p>ConfigurationPropertySources 处理（*）</p>
<ul>
<li>发布 application environment 已准备事件2️⃣</li>
</ul>
</li>
<li>通过 EnvironmentPostProcessorApplicationListener 进行 env 后处理（*）<ul>
<li>application.properties，由 StandardConfigDataLocationResolver 解析</li>
<li>spring.application.json</li>
</ul>
</li>
<li>绑定 spring.main 到 SpringApplication 对象（*）</li>
<li>打印 banner（*）</li>
<li>创建容器</li>
<li><p>准备容器</p>
<ul>
<li>发布 application context 已初始化事件3️⃣</li>
</ul>
</li>
<li><p>加载 bean 定义</p>
<ul>
<li>发布 application prepared 事件4️⃣</li>
</ul>
</li>
<li><p>refresh 容器</p>
<ul>
<li>发布 application started 事件5️⃣</li>
</ul>
</li>
<li><p>执行 runner</p>
<ul>
<li><p>发布 application ready 事件6️⃣</p>
</li>
<li><p>这其中有异常，发布 application failed 事件7️⃣</p>
</li>
</ul>
</li>
</ol>
</li>
</ul>
<h3 id="二-tomcat内嵌容器"><a href="#二-tomcat内嵌容器" class="headerlink" title="二 tomcat内嵌容器"></a>二 tomcat内嵌容器</h3><ul>
<li><p>tomcat基本结构</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Server</span><br><span class="line">└───Service</span><br><span class="line">    ├───Connector (协议, 端口)</span><br><span class="line">    └───Engine</span><br><span class="line">        └───Host(虚拟主机 localhost)</span><br><span class="line">            ├───Context1(应用1, 可以设置虚拟路径, / 即 url 起始路径; 项目磁盘路径, 即 docBase)</span><br><span class="line">            │   │   index.html</span><br><span class="line">            │   └───WEB-INF</span><br><span class="line">            │       │   web.xml (servlet, filter, listener) 3.0</span><br><span class="line">            │       ├───classes (servlet, controller, service ...)</span><br><span class="line">            │       ├───jsp</span><br><span class="line">            │       └───lib (第三方 jar 包)</span><br><span class="line">            └───Context2 (应用2)</span><br><span class="line">                │   index.html</span><br><span class="line">                └───WEB-INF</span><br><span class="line">                        web.xml</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>tomcat内嵌容器</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> LifecycleException, IOException {</span><br><span class="line">    <span class="comment">// 1.创建 Tomcat 对象</span></span><br><span class="line">    <span class="type">Tomcat</span> <span class="variable">tomcat</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Tomcat</span>();</span><br><span class="line">    tomcat.setBaseDir(<span class="string">"tomcat"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.创建项目文件夹, 即 docBase 文件夹</span></span><br><span class="line">    <span class="type">File</span> <span class="variable">docBase</span> <span class="operator">=</span> Files.createTempDirectory(<span class="string">"boot."</span>).toFile();</span><br><span class="line">    docBase.deleteOnExit();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3.创建 Tomcat 项目, 在 Tomcat 中称为 Context</span></span><br><span class="line">    <span class="type">Context</span> <span class="variable">context</span> <span class="operator">=</span> tomcat.addContext(<span class="string">""</span>, docBase.getAbsolutePath());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4.编程添加 Servlet</span></span><br><span class="line">    context.addServletContainerInitializer(<span class="keyword">new</span> <span class="title class_">ServletContainerInitializer</span>() {</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onStartup</span><span class="params">(Set&lt;Class&lt;?&gt;&gt; c, ServletContext ctx)</span> <span class="keyword">throws</span> ServletException {</span><br><span class="line">            <span class="type">HelloServlet</span> <span class="variable">helloServlet</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HelloServlet</span>();<span class="comment">//这个是自定义的继承自HttpServlet的类</span></span><br><span class="line">            ctx.addServlet(<span class="string">"aaa"</span>, helloServlet).addMapping(<span class="string">"/hello"</span>);</span><br><span class="line">        }</span><br><span class="line">    }, Collections.emptySet());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5.启动 Tomcat</span></span><br><span class="line">    tomcat.start();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 6.创建连接器, 设置监听端口</span></span><br><span class="line">    <span class="type">Connector</span> <span class="variable">connector</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Connector</span>(<span class="keyword">new</span> <span class="title class_">Http11Nio2Protocol</span>());</span><br><span class="line">    connector.setPort(<span class="number">8080</span>);</span><br><span class="line">    tomcat.setConnector(connector);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>集成Spring容器</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">WebApplicationContext</span> <span class="variable">springContext</span> <span class="operator">=</span> getApplicationContext();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4.编程添加 Servlet</span></span><br><span class="line">context.addServletContainerInitializer(<span class="keyword">new</span> <span class="title class_">ServletContainerInitializer</span>() {</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onStartup</span><span class="params">(Set&lt;Class&lt;?&gt;&gt; c, ServletContext ctx)</span> <span class="keyword">throws</span> ServletException {</span><br><span class="line">        <span class="comment">// ⬇️通过 ServletRegistrationBean 添加 DispatcherServlet 等</span></span><br><span class="line">        <span class="keyword">for</span> (ServletRegistrationBean registrationBean : </span><br><span class="line">             springContext.getBeansOfType(ServletRegistrationBean.class).values()) {</span><br><span class="line">            registrationBean.onStartup(ctx);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}, Collections.emptySet());</span><br></pre></td></tr></tbody></table></figure>
</li>
</ul>
<h3 id="三-自动配置"><a href="#三-自动配置" class="headerlink" title="三 自动配置"></a>三 自动配置</h3><ul>
<li>自动配置类<code>EnableAutoConfiguration</code>中提供了常用的一些bean</li>
<li>如果冲突了怎么办<ul>
<li>解析时机 @Import先解析，本项目中的bean后解析</li>
<li>默认会同名覆盖，springboot中默认不能覆盖，会报错</li>
</ul>
</li>
</ul>
<h4 id="3-0-原理"><a href="#3-0-原理" class="headerlink" title="3.0 原理"></a>3.0 原理</h4><p>假设已有第三方的两个自动配置类</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span> <span class="comment">// ⬅️第三方的配置类</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">AutoConfiguration1</span> {</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Bean1 <span class="title function_">bean1</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Bean1</span>();</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span> <span class="comment">// ⬅️第三方的配置类</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">AutoConfiguration2</span> {</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Bean2 <span class="title function_">bean2</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Bean2</span>();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>提供一个配置文件 META-INF/spring.factories，key 为导入器类名，值为多个自动配置类名，用逗号分隔</p>
<figure class="highlight properties"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">MyImportSelector</span>=<span class="string">/</span></span><br><span class="line"><span class="attr">AutoConfiguration1,/</span></span><br><span class="line"><span class="attr">AutoConfiguration2</span></span><br></pre></td></tr></tbody></table></figure>
<p>引入自动配置</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span> <span class="comment">// ⬅️本项目的配置类</span></span><br><span class="line"><span class="meta">@Import(MyImportSelector.class)</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Config</span> { }</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">MyImportSelector</span> <span class="keyword">implements</span> <span class="title class_">DeferredImportSelector</span> {</span><br><span class="line">    <span class="comment">// ⬇️该方法从 META-INF/spring.factories 读取自动配置类名，返回的 String[] 即为要导入的配置类</span></span><br><span class="line">    <span class="keyword">public</span> String[] selectImports(AnnotationMetadata importingClassMetadata) {</span><br><span class="line">        <span class="keyword">return</span> SpringFactoriesLoader</span><br><span class="line">            .loadFactoryNames(MyImportSelector.class, <span class="literal">null</span>).toArray(<span class="keyword">new</span> <span class="title class_">String</span>[<span class="number">0</span>]);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>自动配置类本质上就是一个配置类而已，只是用 META-INF/spring.factories 管理，与应用配置类解耦</li>
<li>@Enable 打头的注解本质是利用了 @Import</li>
<li>@Import 配合 DeferredImportSelector 即可实现导入，selectImports 方法的返回值即为要导入的配置类名</li>
<li>DeferredImportSelector 的导入会在最后执行，为的是让其它配置优先解析</li>
</ul>
<h4 id="3-1-AOP自动配置"><a href="#3-1-AOP自动配置" class="headerlink" title="3.1 AOP自动配置"></a>3.1 AOP自动配置</h4><ul>
<li>AOP 自动配置类为 <code>org.springframework.boot.autoconfigure.aop.AopAutoConfiguration</code></li>
<li>可以通过 <code>spring.aop.auto=false</code> 禁用 aop 自动配置</li>
<li>AOP 自动配置的本质是通过 <code>@EnableAspectJAutoProxy</code> 来开启了自动代理，如果在引导类上自己添加了 <code>@EnableAspectJAutoProxy</code> 那么以自己添加的为准</li>
<li><code>@EnableAspectJAutoProxy</code> 的本质是向容器中添加了 <code>AnnotationAwareAspectJAutoProxyCreator</code> 这个 bean 后处理器，它能够找到容器中所有切面，并为匹配切点的目标类创建代理，创建代理的工作一般是在 bean 的初始化阶段完成的</li>
</ul>
<h4 id="3-2-DataSource自动配置"><a href="#3-2-DataSource自动配置" class="headerlink" title="3.2 DataSource自动配置"></a>3.2 DataSource自动配置</h4><ul>
<li>对应的自动配置类为：<code>org.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfiguration</code></li>
<li>它内部采用了条件装配，通过检查容器的 bean，以及类路径下的 class，来决定该 @Bean 是否生效</li>
</ul>
<p>简单说明一下，Spring Boot 支持两大类数据源：</p>
<ul>
<li><p>EmbeddedDatabase - 内嵌数据库连接池</p>
</li>
<li><p>PooledDataSource - 非内嵌数据库连接池</p>
<ul>
<li><p>hikari 提供的 HikariDataSource</p>
</li>
<li><p>tomcat-jdbc 提供的 DataSource</p>
</li>
<li><p>dbcp2 提供的 BasicDataSource</p>
</li>
<li><p>oracle 提供的 PoolDataSourceImpl</p>
</li>
</ul>
</li>
</ul>
<p>如果知道数据源的实现类类型，即指定了 <code>spring.datasource.type</code>，理论上可以支持所有数据源，但这样做的一个最大问题是无法订制每种数据源的详细配置（如最大、最小连接数等）</p>
<h4 id="3-3-MyBatis自动配置"><a href="#3-3-MyBatis自动配置" class="headerlink" title="3.3 MyBatis自动配置"></a>3.3 MyBatis自动配置</h4><ul>
<li>MyBatis 自动配置类为 <code>org.mybatis.spring.boot.autoconfigure.MybatisAutoConfiguration</code></li>
<li>它主要配置了两个 bean<ul>
<li>SqlSessionFactory - MyBatis 核心对象，用来创建 SqlSession</li>
<li>SqlSessionTemplate - SqlSession 的实现，此实现会与当前线程绑定</li>
<li>用 ImportBeanDefinitionRegistrar 的方式扫描所有标注了 @Mapper 注解的接口</li>
<li>用 AutoConfigurationPackages 来确定扫描的包</li>
</ul>
</li>
<li>还有一个相关的 bean：MybatisProperties，它会读取配置文件中带 <code>mybatis.</code> 前缀的配置项进行定制配置</li>
</ul>
<p>@MapperScan 注解的作用与 MybatisAutoConfiguration 类似，会注册 MapperScannerConfigurer 有如下区别</p>
<ul>
<li>@MapperScan 扫描具体包（当然也可以配置关注哪个注解）</li>
<li>@MapperScan 如果不指定扫描具体包，则会把引导类范围内，所有接口当做 Mapper 接口</li>
<li>MybatisAutoConfiguration 关注的是所有标注 @Mapper 注解的接口，会忽略掉非 @Mapper 标注的接口</li>
</ul>
<h4 id="3-4-事务自动配置"><a href="#3-4-事务自动配置" class="headerlink" title="3.4 事务自动配置"></a>3.4 事务自动配置</h4><ul>
<li><p>事务自动配置类有两个：</p>
<ul>
<li><code>org.springframework.boot.autoconfigure.jdbc.DataSourceTransactionManagerAutoConfiguration</code></li>
<li><code>org.springframework.boot.autoconfigure.transaction.TransactionAutoConfiguration</code></li>
</ul>
</li>
<li><p>前者配置了 DataSourceTransactionManager 用来执行事务的提交、回滚操作</p>
</li>
<li>后者功能上对标 @EnableTransactionManagement，包含以下三个 bean<ul>
<li>BeanFactoryTransactionAttributeSourceAdvisor 事务切面类，包含通知和切点</li>
<li>TransactionInterceptor 事务通知类，由它在目标方法调用前后加入事务操作</li>
<li>AnnotationTransactionAttributeSource 会解析 @Transactional 及事务属性，也包含了切点功能</li>
</ul>
</li>
<li>如果自己配置了 DataSourceTransactionManager 或是在引导类加了 @EnableTransactionManagement，则以自己配置的为准</li>
</ul>
<h4 id="3-5-MVC自动配置"><a href="#3-5-MVC自动配置" class="headerlink" title="3.5 MVC自动配置"></a>3.5 MVC自动配置</h4><ul>
<li><code>ServletWebServerFactoryAutoConfiguration</code><ul>
<li>提供 ServletWebServerFactory</li>
</ul>
</li>
<li><code>DispatcherServletAutoConfiguration</code><ul>
<li>提供 DispatcherServlet</li>
<li>提供 DispatcherServletRegistrationBean</li>
</ul>
</li>
<li><code>WebMvcAutoConfiguration</code><ul>
<li>配置 DispatcherServlet 的各项组件，提供的 bean 见过的有<ul>
<li>多项 HandlerMapping</li>
<li>多项 HandlerAdapter</li>
<li>HandlerExceptionResolver</li>
</ul>
</li>
</ul>
</li>
<li><code>ErrorMvcAutoConfiguration</code><ul>
<li>供的 bean 有 BasicErrorController</li>
</ul>
</li>
</ul>
<h3 id="四-条件装配类"><a href="#四-条件装配类" class="headerlink" title="四 条件装配类"></a>四 条件装配类</h3><ul>
<li><p><code>@Conditional()</code>确定要不要判断</p>
</li>
<li><p>实现了<code>Condition</code>接口的类来做具体的判断</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">MyCondition1</span> <span class="keyword">implements</span> <span class="title class_">Condition</span> { </span><br><span class="line">    <span class="comment">// ⬇️如果存在 Druid 依赖，条件成立</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">matches</span><span class="params">(ConditionContext context, AnnotatedTypeMetadata metadata)</span> {</span><br><span class="line">        <span class="keyword">return</span> ClassUtils.isPresent(<span class="string">"com.alibaba.druid.pool.DruidDataSource"</span>, <span class="literal">null</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>具体使用</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span> <span class="comment">// 第三方的配置类</span></span><br><span class="line"><span class="meta">@Conditional(MyCondition1.class)</span> <span class="comment">// ⬅️加入条件</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">AutoConfiguration1</span> {</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Bean1 <span class="title function_">bean1</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Bean1</span>();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>本质：</p>
<ul>
<li>一种特殊的if-else</li>
</ul>
<h3 id="五-FactoryBean"><a href="#五-FactoryBean" class="headerlink" title="五 FactoryBean"></a>五 FactoryBean</h3></li>
</ul>
<p><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/Spring高级.assets/image-20231210123453030.png" alt="image-20231210123453030"></p>
<ul>
<li>它的作用是用制造创建过程较为复杂的产品, 如 SqlSessionFactory, 但 @Bean 已具备等价功能</li>
<li>使用上较为古怪, 一不留神就会用错<ol>
<li>被 FactoryBean 创建的产品<ul>
<li>会认为创建、依赖注入、Aware 接口回调、前初始化这些都是 FactoryBean 的职责, 这些流程都不会走</li>
<li>唯有后初始化的流程会走, 也就是产品可以被代理增强</li>
<li>单例的产品不会存储于 BeanFactory 的 singletonObjects 成员中, 而是另一个 factoryBeanObjectCache 成员中</li>
</ul>
</li>
<li>按名字去获取时, 拿到的是产品对象, 名字前面加 &amp; 获取的是工厂对象</li>
</ol>
</li>
</ul>
<h3 id="六-index"><a href="#六-index" class="headerlink" title="六 @index"></a>六 <code>@index</code></h3><ul>
<li>在编译时就根据 <code>@Indexed</code> 生成 META-INF/spring.components 文件<ul>
<li>@Component注解中就间接使用了@Index</li>
</ul>
</li>
<li>扫描时<ul>
<li>如果发现 META-INF/spring.components 存在, 以它为准加载 bean definition</li>
<li>否则, 会遍历包下所有 class 资源 (包括 jar 内的)</li>
</ul>
</li>
<li>解决的问题，在编译期就找到 @Component 组件，节省运行期间扫描 @Component 的时间</li>
</ul>
<h3 id="七-代理"><a href="#七-代理" class="headerlink" title="七 代理"></a>七 代理</h3><ul>
<li><p>spring 代理的设计特点</p>
<ul>
<li><p>依赖注入和初始化影响的是原始对象</p>
<ul>
<li>因此 cglib 不能用 MethodProxy.invokeSuper()</li>
</ul>
</li>
<li><p>代理与目标是两个对象，二者成员变量并不共用数据</p>
</li>
</ul>
</li>
<li><p>static 方法、final 方法、private 方法均无法增强</p>
<ul>
<li>进一步理解代理增强基于方法重写</li>
</ul>
</li>
</ul>
<h3 id="八-Value"><a href="#八-Value" class="headerlink" title="八 @Value"></a>八 <code>@Value</code></h3><ul>
<li><code>${}</code></li>
<li><code>#{}</code></li>
<li>类型转换： <code>TypeConverter</code> </li>
</ul>
<h3 id="九-Autowired"><a href="#九-Autowired" class="headerlink" title="九 @Autowired"></a>九 <code>@Autowired</code></h3><ul>
<li><p><code>@Autowired</code> 本质上是根据成员变量或方法参数的类型进行装配</p>
</li>
<li><p><code>beanfactory.doResolveDependency()</code>要点</p>
<ul>
<li>结果包装为Optional<bean2> ObjectProvider<ul>
<li>如果待装配类型是 Optional，需要根据 Optional 泛型找到 bean，再封装为 Optional 对象装配</li>
<li>如果待装配的类型是 ObjectFactory，需要根据 ObjectFactory 泛型创建 ObjectFactory 对象装配<ul>
<li>此方法可以延迟真实 bean 的获取</li>
</ul>
</li>
</ul>
</bean2></li>
<li><p>对@Lazy的处理</p>
<ul>
<li>如果待装配的成员变量或方法参数上用 @Lazy 标注，会创建代理对象装配<ul>
<li>此方法可以延迟真实 bean 的获取</li>
<li>被装配的代理不作为 bean</li>
</ul>
</li>
</ul>
</li>
<li><p>其他</p>
<ul>
<li>如果待装配类型是数组，需要获取数组元素类型，根据此类型找到多个 bean 进行装配</li>
<li>如果待装配类型是 Collection 或其子接口，需要获取 Collection 泛型，根据此类型找到多个 bean</li>
<li>如果待装配类型是 ApplicationContext 等特殊类型<ul>
<li>会在 BeanFactory 的 resolvableDependencies 成员按类型查找装配</li>
<li>resolvableDependencies 是 map 集合，key 是特殊类型，value 是其对应对象</li>
<li>不能直接根据 key 进行查找，而是用 isAssignableFrom 逐一尝试右边类型是否可以被赋值给左边的 key 类型</li>
</ul>
</li>
<li>如果待装配类型有泛型参数<ul>
<li>需要利用 ContextAnnotationAutowireCandidateResolver 按泛型参数类型筛选</li>
</ul>
</li>
<li>如果待装配类型有 @Qualifier<ul>
<li>需要利用 ContextAnnotationAutowireCandidateResolver 按注解提供的 bean 名称筛选</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="十-事件监听器"><a href="#十-事件监听器" class="headerlink" title="十 事件监听器"></a>十 事件监听器</h3><h4 id="10-1-ApplicationListener"><a href="#10-1-ApplicationListener" class="headerlink" title="10.1 ApplicationListener"></a>10.1 ApplicationListener</h4><ul>
<li>实现 ApplicationListener 接口<ul>
<li>根据接口泛型确定事件类型</li>
</ul>
</li>
</ul>
<h4 id="10-2-EventListener"><a href="#10-2-EventListener" class="headerlink" title="10.2 @EventListener"></a>10.2 @EventListener</h4><ul>
<li>根据监听器方法参数确定事件类型</li>
<li>解析时机：在 SmartInitializingSingleton（所有单例初始化完成后），解析每个单例 bean</li>
</ul>
<h4 id="10-3-事件发布器"><a href="#10-3-事件发布器" class="headerlink" title="10.3 事件发布器"></a>10.3 事件发布器</h4><ul>
<li><code>addApplicationListenerBean</code> 负责收集容器中的监听器<ul>
<li>监听器会统一转换为 GenericApplicationListener 对象，以支持判断事件类型</li>
</ul>
</li>
<li><code>multicastEvent</code> 遍历监听器集合，发布事件<ul>
<li>发布前先通过 GenericApplicationListener.supportsEventType 判断支持该事件类型才发事件</li>
<li>可以利用线程池进行异步发事件优化</li>
</ul>
</li>
<li>如果发送的事件对象不是 ApplicationEvent 类型，Spring 会把它包装为 PayloadApplicationEvent 并用泛型技术解析事件对象的原始类型<ul>
<li>视频中未讲解</li>
</ul>
</li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="http://yileman.github.io">myl</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://yileman.github.io/posts/30720.html">http://yileman.github.io/posts/30720.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://yileman.github.io" target="_blank">myl's blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/java%E9%AB%98%E7%BA%A7/">java高级</a></div><div class="post_share"><div class="social-share" data-image="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/cover/article_cover10.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer=""></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/posts/57008.html" title="瑞吉外卖"><img class="cover" src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/cover/article_cover11.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">瑞吉外卖</div></div></a></div><div class="next-post pull-right"><a href="/posts/33757.html" title="SpringBoot"><img class="cover" src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/cover/article_cover9.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">SpringBoot</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/posts/18155.html" title="Spring"><img class="cover" src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/cover/article_cover5.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-11-29</div><div class="title">Spring</div></div></a></div><div><a href="/posts/33757.html" title="SpringBoot"><img class="cover" src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/cover/article_cover9.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-11-12</div><div class="title">SpringBoot</div></div></a></div><div><a href="/posts/54284.html" title="SSM"><img class="cover" src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/cover/article_cover7.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-10-16</div><div class="title">SSM</div></div></a></div><div><a href="/posts/55918.html" title="若依学习"><img class="cover" src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/cover/article_cover12.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-01-07</div><div class="title">若依学习</div></div></a></div><div><a href="/posts/17374.html" title="JVM"><img class="cover" src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/cover/article_cover1.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-03-12</div><div class="title">JVM</div></div></a></div><div><a href="/posts/65385.html" title="微服务"><img class="cover" src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/cover/article_cover14.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-01-18</div><div class="title">微服务</div></div></a></div></div></div><hr class="custom-hr"><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="twikoo-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/touxiang.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"></div><div class="author-info__name">myl</div><div class="author-info__description">后端学习</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">20</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">7</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">4</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/yileman"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">写写记记</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Spring%E9%AB%98%E7%BA%A7"><span class="toc-number">1.</span> <span class="toc-text">Spring高级</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E2%85%A0-%E5%AE%B9%E5%99%A8%E4%B8%8Ebean"><span class="toc-number">1.1.</span> <span class="toc-text">Ⅰ 容器与bean</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80-%E5%AE%B9%E5%99%A8%E6%8E%A5%E5%8F%A3"><span class="toc-number">1.1.1.</span> <span class="toc-text">一 容器接口</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-BeanFactory"><span class="toc-number">1.1.1.1.</span> <span class="toc-text">1.1 BeanFactory</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-ApplicationContext"><span class="toc-number">1.1.1.2.</span> <span class="toc-text">1.2 ApplicationContext</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C-%E5%AE%B9%E5%99%A8%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.1.2.</span> <span class="toc-text">二  容器实现</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-BeanFactory%E5%AE%9E%E7%8E%B0%E7%89%B9%E7%82%B9"><span class="toc-number">1.1.2.1.</span> <span class="toc-text">2.1 BeanFactory实现特点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-ApplicationContext%E5%B8%B8%E8%A7%81%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.1.2.2.</span> <span class="toc-text">2.2 ApplicationContext常见实现</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89-bean%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-number">1.1.3.</span> <span class="toc-text">三 bean生命周期</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-number">1.1.3.1.</span> <span class="toc-text">3.1 生命周期</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%A2%9E%E5%BC%BA%E6%96%B9%E6%B3%95"><span class="toc-number">1.1.3.2.</span> <span class="toc-text">3.2 生命周期增强方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.1.3.3.</span> <span class="toc-text">3.3 模板方法设计模式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9B-Bean%E5%90%8E%E5%A4%84%E7%90%86%E5%99%A8"><span class="toc-number">1.1.4.</span> <span class="toc-text">四 Bean后处理器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%94-BeanFactory%E5%90%8E%E5%A4%84%E7%90%86%E5%99%A8"><span class="toc-number">1.1.5.</span> <span class="toc-text">五 BeanFactory后处理器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#5-1-%E4%BB%8B%E7%BB%8D"><span class="toc-number">1.1.5.1.</span> <span class="toc-text">5.1 介绍</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-2-%E5%B8%B8%E8%A7%81BeanFactory%E5%90%8E%E5%A4%84%E7%90%86%E5%99%A81"><span class="toc-number">1.1.5.2.</span> <span class="toc-text">5.2 常见BeanFactory后处理器1</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-3-%E5%B8%B8%E8%A7%81BeanFactory%E5%90%8E%E5%A4%84%E7%90%86%E5%99%A82"><span class="toc-number">1.1.5.3.</span> <span class="toc-text">5.3 常见BeanFactory后处理器2</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%AD-Aware-%E6%8E%A5%E5%8F%A3"><span class="toc-number">1.1.6.</span> <span class="toc-text">六 Aware 接口</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#6-1-Aware-%E6%8E%A5%E5%8F%A3"><span class="toc-number">1.1.6.1.</span> <span class="toc-text">6.1 Aware 接口</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-2-InitializingBean-%E6%8E%A5%E5%8F%A3"><span class="toc-number">1.1.6.2.</span> <span class="toc-text">6.2 InitializingBean 接口</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%83-%E5%88%9D%E5%A7%8B%E5%8C%96%E4%B8%8E%E9%94%80%E6%AF%81"><span class="toc-number">1.1.7.</span> <span class="toc-text">七 初始化与销毁</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#7-1-%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">1.1.7.1.</span> <span class="toc-text">7.1 初始化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-2-%E9%94%80%E6%AF%81"><span class="toc-number">1.1.7.2.</span> <span class="toc-text">7.2 销毁</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%AB-Scope"><span class="toc-number">1.1.8.</span> <span class="toc-text">八 Scope</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#8-1-Scope%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.1.8.1.</span> <span class="toc-text">8.1 Scope类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-2-%E5%9C%A8singleton%E4%B8%AD%E4%BD%BF%E7%94%A8%E5%85%B6%E4%BB%96%E5%87%A0%E7%A7%8Dscope%E7%9A%84Bean"><span class="toc-number">1.1.8.2.</span> <span class="toc-text">8.2 在singleton中使用其他几种scope的Bean</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E2%85%A1-AOP"><span class="toc-number">1.2.</span> <span class="toc-text">Ⅱ AOP</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80-ajc%E5%A2%9E%E5%BC%BA"><span class="toc-number">1.2.1.</span> <span class="toc-text">一 ajc增强</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C-agent%E5%A2%9E%E5%BC%BA"><span class="toc-number">1.2.2.</span> <span class="toc-text">二 agent增强</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89-proxy%E5%A2%9E%E5%BC%BA"><span class="toc-number">1.2.3.</span> <span class="toc-text">三 proxy增强</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-jdk-%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86"><span class="toc-number">1.2.3.1.</span> <span class="toc-text">3.1  jdk 动态代理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-cglib%E4%BB%A3%E7%90%86"><span class="toc-number">1.2.3.2.</span> <span class="toc-text">3.2 cglib代理</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9B-jdk%E4%BB%A3%E7%90%86%E5%8E%9F%E7%90%86"><span class="toc-number">1.2.4.</span> <span class="toc-text">四 jdk代理原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%94-cglib%E4%BB%A3%E7%90%86%E5%8E%9F%E7%90%86"><span class="toc-number">1.2.5.</span> <span class="toc-text">五 cglib代理原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%AD-cglib%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%E5%8F%91%E5%B0%84%E8%B0%83%E7%94%A8"><span class="toc-number">1.2.6.</span> <span class="toc-text">六 cglib如何避免发射调用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#6-1-MethodProxy%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.2.6.1.</span> <span class="toc-text">6.1 MethodProxy实现</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%83-jdk%E5%92%8Ccglib%E7%9A%84%E7%BB%9F%E4%B8%80"><span class="toc-number">1.2.7.</span> <span class="toc-text">七 jdk和cglib的统一</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#7-1-Spring%E7%9A%84%E4%BB%A3%E7%90%86%E9%80%89%E6%8B%A9%E8%A7%84%E5%88%99"><span class="toc-number">1.2.7.1.</span> <span class="toc-text">7.1 Spring的代理选择规则</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-2-%E5%BA%95%E5%B1%82%E5%88%87%E7%82%B9%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.2.7.2.</span> <span class="toc-text">7.2 底层切点实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-3-%E5%BA%95%E5%B1%82%E5%88%87%E9%9D%A2%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.2.7.3.</span> <span class="toc-text">7.3 底层切面实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-4-%E5%BA%95%E5%B1%82%E9%80%9A%E7%9F%A5%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.2.7.4.</span> <span class="toc-text">7.4 底层通知实现</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E2%85%A2-Web-MVC"><span class="toc-number">1.3.</span> <span class="toc-text">Ⅲ Web MVC</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80-Controller%E8%A7%A3%E6%9E%90%E8%AF%B7%E6%B1%82"><span class="toc-number">1.3.1.</span> <span class="toc-text">一 Controller解析请求</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-DispatcherServlet-%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">1.3.1.1.</span> <span class="toc-text">1.1 DispatcherServlet 初始化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-RequestMappingHandlerMapping%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">1.3.1.2.</span> <span class="toc-text">1.2 RequestMappingHandlerMapping初始化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-3-RequestMappingHandlerAdapter%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">1.3.1.3.</span> <span class="toc-text">1.3 RequestMappingHandlerAdapter初始化</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C-%E5%8F%82%E6%95%B0%E8%A7%A3%E6%9E%90%E5%99%A8"><span class="toc-number">1.3.2.</span> <span class="toc-text">二 参数解析器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89-%E5%AF%B9%E8%B1%A1%E7%BB%91%E5%AE%9A%E5%92%8C%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-number">1.3.3.</span> <span class="toc-text">三 对象绑定和类型转换</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-%E5%BA%95%E5%B1%82%E7%AC%AC%E4%B8%80%E5%A5%97%E8%BD%AC%E6%8D%A2%E6%8E%A5%E5%8F%A3%E4%B8%8E%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.3.3.1.</span> <span class="toc-text">3.1 底层第一套转换接口与实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-%E5%BA%95%E5%B1%82%E7%AC%AC%E4%BA%8C%E5%A5%97%E8%BD%AC%E6%8D%A2%E6%8E%A5%E5%8F%A3"><span class="toc-number">1.3.3.2.</span> <span class="toc-text">3.2 底层第二套转换接口</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-%E9%AB%98%E5%B1%82%E6%8E%A5%E5%8F%A3%E4%B8%8E%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.3.3.3.</span> <span class="toc-text">3.3 高层接口与实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-4-%E7%A4%BA%E4%BE%8B"><span class="toc-number">1.3.3.4.</span> <span class="toc-text">3.4 示例</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-5-%E7%BB%91%E5%AE%9A%E5%99%A8%E5%B7%A5%E5%8E%82"><span class="toc-number">1.3.3.5.</span> <span class="toc-text">3.5 绑定器工厂</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-6-%E5%A6%82%E4%BD%95%E8%8E%B7%E5%8F%96%E6%B3%9B%E5%9E%8B%E5%8F%82%E6%95%B0"><span class="toc-number">1.3.3.6.</span> <span class="toc-text">3.6 如何获取泛型参数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9B-ControllerAdvice"><span class="toc-number">1.3.4.</span> <span class="toc-text">四 @ControllerAdvice</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1-InitBinder"><span class="toc-number">1.3.4.1.</span> <span class="toc-text">4.1 @InitBinder</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-ModelAttribute"><span class="toc-number">1.3.4.2.</span> <span class="toc-text">4.2 @ModelAttribute</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-3-%E6%8E%A7%E5%88%B6%E5%99%A8%E6%96%B9%E6%B3%95%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B"><span class="toc-number">1.3.4.3.</span> <span class="toc-text">4.3 控制器方法执行流程</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%94-%E8%BF%94%E5%9B%9E%E5%80%BC%E5%A4%84%E7%90%86%E5%99%A8"><span class="toc-number">1.3.5.</span> <span class="toc-text">五 返回值处理器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%AD-%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86"><span class="toc-number">1.3.6.</span> <span class="toc-text">六 异常处理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#6-1-tomcat%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86"><span class="toc-number">1.3.6.1.</span> <span class="toc-text">6.1 tomcat异常处理</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%83-%E5%85%B6%E4%BB%96%E7%9A%84Handler"><span class="toc-number">1.3.7.</span> <span class="toc-text">七 其他的Handler</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%AB-MVC%E5%A4%84%E7%90%86%E6%B5%81%E7%A8%8B"><span class="toc-number">1.3.8.</span> <span class="toc-text">八 MVC处理流程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E2%85%A3-Spring-boot"><span class="toc-number">1.4.</span> <span class="toc-text">Ⅳ Spring boot</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80-Boot%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B"><span class="toc-number">1.4.1.</span> <span class="toc-text">一 Boot启动过程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-%E6%9E%84%E9%80%A0%E5%88%86%E6%9E%90"><span class="toc-number">1.4.1.1.</span> <span class="toc-text">1.1 构造分析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-run%E5%88%86%E6%9E%90"><span class="toc-number">1.4.1.2.</span> <span class="toc-text">1.2 run分析</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C-tomcat%E5%86%85%E5%B5%8C%E5%AE%B9%E5%99%A8"><span class="toc-number">1.4.2.</span> <span class="toc-text">二 tomcat内嵌容器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89-%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE"><span class="toc-number">1.4.3.</span> <span class="toc-text">三 自动配置</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-0-%E5%8E%9F%E7%90%86"><span class="toc-number">1.4.3.1.</span> <span class="toc-text">3.0 原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-AOP%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE"><span class="toc-number">1.4.3.2.</span> <span class="toc-text">3.1 AOP自动配置</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-DataSource%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE"><span class="toc-number">1.4.3.3.</span> <span class="toc-text">3.2 DataSource自动配置</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-MyBatis%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE"><span class="toc-number">1.4.3.4.</span> <span class="toc-text">3.3 MyBatis自动配置</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-4-%E4%BA%8B%E5%8A%A1%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE"><span class="toc-number">1.4.3.5.</span> <span class="toc-text">3.4 事务自动配置</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-5-MVC%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE"><span class="toc-number">1.4.3.6.</span> <span class="toc-text">3.5 MVC自动配置</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9B-%E6%9D%A1%E4%BB%B6%E8%A3%85%E9%85%8D%E7%B1%BB"><span class="toc-number">1.4.4.</span> <span class="toc-text">四 条件装配类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%94-FactoryBean"><span class="toc-number">1.4.5.</span> <span class="toc-text">五 FactoryBean</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%AD-index"><span class="toc-number">1.4.6.</span> <span class="toc-text">六 @index</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%83-%E4%BB%A3%E7%90%86"><span class="toc-number">1.4.7.</span> <span class="toc-text">七 代理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%AB-Value"><span class="toc-number">1.4.8.</span> <span class="toc-text">八 @Value</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B9%9D-Autowired"><span class="toc-number">1.4.9.</span> <span class="toc-text">九 @Autowired</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%81-%E4%BA%8B%E4%BB%B6%E7%9B%91%E5%90%AC%E5%99%A8"><span class="toc-number">1.4.10.</span> <span class="toc-text">十 事件监听器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#10-1-ApplicationListener"><span class="toc-number">1.4.10.1.</span> <span class="toc-text">10.1 ApplicationListener</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10-2-EventListener"><span class="toc-number">1.4.10.2.</span> <span class="toc-text">10.2 @EventListener</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10-3-%E4%BA%8B%E4%BB%B6%E5%8F%91%E5%B8%83%E5%99%A8"><span class="toc-number">1.4.10.3.</span> <span class="toc-text">10.3 事件发布器</span></a></li></ol></li></ol></li></ol></li></ol></div></div></div></div></main><footer id="footer" style="background: transparent"><div id="footer-wrap"><div class="copyright">©2024 By myl</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=4.13.0"></script><script src="/js/main.js?v=4.13.0"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"><script>(() => {
  const getCount = () => {
    const countELement = document.getElementById('twikoo-count')
    if(!countELement) return
    twikoo.getCommentsCount({
      envId: 'https://www.manyile.top',
      region: 'ap-shanghai',
      urls: [window.location.pathname],
      includeReply: false
    }).then(res => {
      countELement.textContent = res[0].count
    }).catch(err => {
      console.error(err)
    })
  }

  const init = () => {
    twikoo.init(Object.assign({
      el: '#twikoo-wrap',
      envId: 'https://www.manyile.top',
      region: 'ap-shanghai',
      onCommentLoaded: () => {
        btf.loadLightbox(document.querySelectorAll('#twikoo .tk-content img:not(.tk-owo-emotion)'))
      }
    }, null))

    GLOBAL_CONFIG_SITE.isPost && getCount()
  }

  const loadTwikoo = () => {
    if (typeof twikoo === 'object') setTimeout(init,0)
    else getScript('https://cdn.jsdelivr.net/npm/twikoo@1.6.31/dist/twikoo.all.min.js').then(init)
  }

  if ('Twikoo' === 'Twikoo' || !true) {
    if (true) btf.loadComment(document.getElementById('twikoo-wrap'), loadTwikoo)
    else loadTwikoo()
  } else {
    window.loadOtherComment = loadTwikoo
  }
})()</script></div><script type="text/javascript" src="https://unpkg.zhimg.com/jquery@latest/dist/jquery.min.js"></script><script data-pjax="" type="text/javascript" src="/js/nav.js"></script><div class="aplayer no-destroy" data-id="2664875269" data-server="netease" data-type="playlist" data-fixed="true" data-mini="true" data-listfolded="false" data-order="random" data-preload="none" data-autoplay="false" muted=""></div><script data-pjax="" type="text/javascript" src="/js/randomPaper.js"></script><script type="text/javascript" src="/js/rightMenu.js"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer@1.10.1/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/aplayer@1.10.1/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/metingjs/dist/Meting.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax@0.2.8/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {

  // removeEventListener
  btf.removeGlobalFnEvent('pjax')
  btf.removeGlobalFnEvent('themeChange')

  document.getElementById('rightside').classList.remove('rightside-show')
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

  typeof disqusjs === 'object' && disqusjs.destroy()
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', e => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async="" data-pjax="" src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"></div></div><hr><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js?v=4.13.0"></script></div></div><div class="js-pjax" id="rightMenu"><div class="rightMenu-group rightMenu-small"><a class="rightMenu-item" href="javascript:window.history.back();"><i class="fa fa-arrow-left"></i></a><a class="rightMenu-item" href="javascript:window.history.forward();"><i class="fa fa-arrow-right"></i></a><a class="rightMenu-item" href="javascript:window.location.reload();"><i class="fa fa-refresh"></i></a><a class="rightMenu-item" href="javascript:rmf.scrollToTop();"><i class="fa fa-arrow-up"></i></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-text"><a class="rightMenu-item" href="javascript:rmf.copySelect();"><i class="fa fa-copy"></i><span>复制</span></a><a class="rightMenu-item" href="javascript:window.open(&quot;https://www.baidu.com/s?wd=&quot;+window.getSelection().toString());window.location.reload();"><i class="iconfont icon-baidu"></i><span>百度搜索</span></a><a class="rightMenu-item" href="javascript:rmf.searchinThisPage();"><i class="fas fa-search"></i><span>站内搜索</span></a><a class="rightMenu-item" href="#post-comment" onclick="rmf.yinyong()"><i class="fa-solid fa-message"></i><span>引用文本评论</span></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-too"><a class="rightMenu-item" href="javascript:window.open(window.getSelection().toString());window.location.reload();"><i class="fa fa-link"></i><span>转到链接</span></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-paste"><a class="rightMenu-item" href="javascript:rmf.paste()"><i class="fa fa-copy"></i><span>粘贴</span></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-post"><a class="rightMenu-item" href="#post-comment"><i class="fas fa-comment"></i><span>空降评论</span></a><a class="rightMenu-item" href="javascript:switchCommentBarrage()"><i class="iconfont icon-danmu"></i><span>开/关评论弹幕</span></a><a class="rightMenu-item" href="javascript:rmf.copyWordsLink()"><i class="fa fa-link"></i><span>复制本文地址</span></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-to"><a class="rightMenu-item" href="javascript:rmf.openWithNewTab()"><i class="fa fa-window-restore"></i><span>新窗口打开</span></a><a class="rightMenu-item" id="menu-too" href="javascript:rmf.open()"><i class="fa fa-link"></i><span>转到链接</span></a><a class="rightMenu-item" href="javascript:rmf.copyLink()"><i class="fa fa-copy"></i><span>复制链接</span></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-img"><a class="rightMenu-item" href="javascript:rmf.saveAs()"><i class="fa fa-download"></i><span>保存图片</span></a><a class="rightMenu-item" href="javascript:rmf.openWithNewTab()"><i class="fa fa-window-restore"></i><span>在新窗口打开</span></a><a class="rightMenu-item" href="javascript:rmf.click()"><i class="fa fa-arrows-alt"></i><span>全屏显示</span></a><a class="rightMenu-item" href="javascript:rmf.copyLink()"><i class="fa fa-copy"></i><span>复制图片链接</span></a></div><div class="rightMenu-group rightMenu-line"><a class="rightMenu-item" href="javascript:randomPost()"><i class="fa fa-paper-plane"></i><span>随便逛逛</span></a><a class="rightMenu-item" href="javascript:rmf.switchDarkMode();"><i class="fa fa-moon"></i><span>昼夜切换</span></a><a class="rightMenu-item" href="javascript:rmf.switchReadMode();"><i class="fa fa-book"></i><span>阅读模式</span></a><a class="rightMenu-item" href="javascript:fullScreen();"><i class="fas fa-expand"></i><span>进入全屏</span></a></div></div><!-- hexo injector body_end start --><script data-pjax="">function electric_clock_injector_config(){
                var parent_div_git = document.getElementsByClassName('sticky_layout')[0];
                var item_html = '<div class="card-widget card-clock"><div class="card-glass"><div class="card-background"><div class="card-content"><div id="hexo_electric_clock"><img id="card-clock-loading" src="https://cdn.jsdelivr.net/gh/Zfour/Butterfly-clock/clock/images/weather/loading.gif" style="height: 120px; width: 100%;" data-ll-status="loading" class="entered loading"></div></div></div></div></div>';
                console.log('已挂载electric_clock')
                // parent_div_git.innerHTML=item_html+parent_div_git.innerHTML // 无报错，但不影响使用(支持pjax跳转)
                parent_div_git.insertAdjacentHTML("afterbegin",item_html) // 有报错，但不影响使用(支持pjax跳转)
            }if( document.getElementsByClassName('sticky_layout')[0] && (location.pathname ==='all'|| 'all' ==='all')){

            electric_clock_injector_config()
        } </script><script src="https://pv.sohu.com/cityjson?ie=utf-8"></script><script data-pjax="" src="https://cdn.jsdelivr.net/gh/Zfour/hexo-electric-clock@1.0.6/clock.js"></script><script async="" src="//at.alicdn.com/t/font_2032782_8d5kxvn09md.js"></script><!-- hexo injector body_end end --></body></html>