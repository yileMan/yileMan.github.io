<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>数据结构与算法 | myl's blog</title><meta name="author" content="myl"><meta name="copyright" content="myl"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="数据结构与算法0725 一 队列、链表1.1 线性结构和非线性结构 线性结构 特点：一对一 顺序结构存储（数组）和链式存储结构（链表） 线性结构常见的有：数组、队列、链表和栈   非线性结构： 二维数组，多维数组，广义表，树结构，图结构    1.2 稀疏数组和队列 稀疏数组定义：当一个数组中大部分元素为０，或者为同一个值的数组时，可以使用稀疏数组来保存该数组。  稀疏数组的处理方法：  记录数组">
<meta property="og:type" content="article">
<meta property="og:title" content="数据结构与算法">
<meta property="og:url" content="http://yileman.github.io/posts/40445.html">
<meta property="og:site_name" content="myl's blog">
<meta property="og:description" content="数据结构与算法0725 一 队列、链表1.1 线性结构和非线性结构 线性结构 特点：一对一 顺序结构存储（数组）和链式存储结构（链表） 线性结构常见的有：数组、队列、链表和栈   非线性结构： 二维数组，多维数组，广义表，树结构，图结构    1.2 稀疏数组和队列 稀疏数组定义：当一个数组中大部分元素为０，或者为同一个值的数组时，可以使用稀疏数组来保存该数组。  稀疏数组的处理方法：  记录数组">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/cover/article_cover3.png">
<meta property="article:published_time" content="2022-09-17T16:00:00.000Z">
<meta property="article:modified_time" content="2024-03-29T03:46:55.774Z">
<meta property="article:author" content="myl">
<meta property="article:tag" content="java基础 算法">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/cover/article_cover3.png"><link rel="shortcut icon" href="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/touxiang.jpg"><link rel="canonical" href="http://yileman.github.io/posts/40445.html"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="preconnect" href="//busuanzi.ibruce.info"><link rel="stylesheet" href="/css/index.css?v=4.13.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.11.1/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '数据结构与算法',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-03-29 11:46:55'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><link rel="stylesheet" href="/css/modify.css"><link rel="stylesheet" href="/css/user.css"><link rel="stylesheet" href="/css/custom.css" media="defer" onload="this.media='all'"><!-- hexo injector head_end start --><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Zfour/Butterfly-double-row-display@1.00/cardlistpost.min.css">
<style>#recent-posts > .recent-post-item >.recent-post-info > .article-meta-wrap > .tags:before {content:"\A";
  white-space: pre;}#recent-posts > .recent-post-item >.recent-post-info > .article-meta-wrap > .tags > .article-meta__separator{display:none}</style>
<link rel="stylesheet" href="https://unpkg.com/hexo-butterfly-tag-plugins-plus-chinese@latest/lib/assets/font-awesome-animation.min.css" media="defer" onload="this.media='all'"><link rel="stylesheet" href="https://unpkg.com/hexo-butterfly-tag-plugins-plus-chinese@latest/lib/tag_plugins.css" media="defer" onload="this.media='all'"><script src="https://unpkg.com/hexo-butterfly-tag-plugins-plus-chinese@latest/lib/assets/carousel-touch.js"></script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.1.1"></head><body><div id="loading-box"><div class="pokeball-back"></div><div class="pokeball-loading"><div class="pokeball" id="pokeball-normal"></div><div class="pokeball" id="pokeball-great"></div><div class="pokeball" id="pokeball-ultra"></div><div class="pokeball" id="pokeball-master"></div><div class="pokeball" id="pokeball-safari"></div></div></div><script>(()=>{
  const $loadingBox = document.getElementById('loading-box')
  const $body = document.body
  const preloader = {
    endLoading: () => {
      //- console.log("end")
      $body.style.overflow = 'auto'

      document.getElementById('loading-box').style.transition = 'opacity 3s ease 0s'
      document.getElementById('loading-box').style.opacity = '0'
      setTimeout(function(){
        document.getElementById('loading-box').classList.add("loaded")
      }, 3000);

      //- $loadingBox.classList.add('loaded')
    },
    initLoading: () => {
      $body.style.overflow = ''
      $loadingBox.classList.remove('loaded')
      
    }
  }

  preloader.initLoading()
  //- setTimeout(function(){preloader.endLoading();}, 3000);
  window.addEventListener('load',() => { preloader.endLoading() })
  document.getElementById('loading-box').addEventListener('click',()=> {preloader.endLoading()})

  if (true) {
    document.addEventListener('pjax:send', () => { preloader.initLoading() })
    document.addEventListener('pjax:complete', () => { preloader.endLoading() })
  }
})()</script><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/touxiang.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">20</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">7</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">4</div></a></div><hr class="custom-hr"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page" href="/comments/"><i class="fa-fw fa fa-link"></i><span> 留言板</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/cover/article_cover3.png')"><nav id="nav"><span id="blog-info"><a href="/" title="myl's blog"><span class="site-name">myl's blog</span></a></span><div id="menus"></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page" href="/comments/"><i class="fa-fw fa fa-link"></i><span> 留言板</span></a></div></div><center id="name-container"><a id="page-name" href="javascript:scrollToTop()">PAGE_NAME</a></center><div id="nav-right"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i></a></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">数据结构与算法</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-09-17T16:00:00.000Z" title="发表于 2022-09-18 00:00:00">2022-09-18</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-03-29T03:46:55.774Z" title="更新于 2024-03-29 11:46:55">2024-03-29</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E7%AE%97%E6%B3%95/">算法</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="数据结构与算法"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><div class="top-img" style="background-image: url('https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/cover/article_cover3.png');"></div><article class="post-content" id="article-container"><h2 id="数据结构与算法"><a href="#数据结构与算法" class="headerlink" title="数据结构与算法"></a>数据结构与算法</h2><h3 id="0725-一-队列、链表"><a href="#0725-一-队列、链表" class="headerlink" title="0725 一 队列、链表"></a>0725 一 队列、链表</h3><h4 id="1-1-线性结构和非线性结构"><a href="#1-1-线性结构和非线性结构" class="headerlink" title="1.1 线性结构和非线性结构"></a>1.1 线性结构和非线性结构</h4><ul>
<li>线性结构<ul>
<li>特点：一对一</li>
<li>顺序结构存储（数组）和链式存储结构（链表）</li>
<li>线性结构常见的有：数组、队列、链表和栈</li>
</ul>
</li>
<li>非线性结构：<ul>
<li>二维数组，多维数组，广义表，树结构，图结构</li>
</ul>
</li>
</ul>
<h4 id="1-2-稀疏数组和队列"><a href="#1-2-稀疏数组和队列" class="headerlink" title="1.2 稀疏数组和队列"></a>1.2 稀疏数组和队列</h4><ul>
<li><p>稀疏数组定义：当一个数组中大部分元素为０，或者为同一个值的数组时，可以使用稀疏数组来保存该数组。</p>
</li>
<li><p>稀疏数组的处理方法：</p>
<ol>
<li>记录数组一共有几行几列，有多少个不同的值（第一个数据）</li>
<li>把具有不同值的元素的行列及值记录在一个小规模的数组中，从而缩小程序的规模<ol>
<li><img src="/TyporaImg/数据结构与算法.assets/image-20220725135327143.png" alt="image-20220725135327143"></li>
</ol>
</li>
</ol>
</li>
<li><p><u><em>稀疏数组和二维数组的转换练习：day0725/sparseArray.java</em></u></p>
</li>
<li>队列定义：队列是一个有序列表，可以用数组或是链表来实现。<ul>
<li>特点：先进先出，三个参数 <code>maxSize,front,rear</code></li>
<li>因为队列的输出、输入是分别从前后端来处理，因此需要两个变<strong>量</strong> front及rear分别记录队列前后端的下标，front 会随着数据输出而改变，而 rear则是随着数据输入而改变<ul>
<li><img src="/TyporaImg/数据结构与算法.assets/image-20220725135257863.png" alt="image-20220725135257863"></li>
<li>front指向队列第一个元素的前一位，rear指向队列的最后一位</li>
</ul>
</li>
<li>当front==rear时，队列为空，当rear==maxSize时，队列满</li>
<li>采用环形队列以优化队列<ul>
<li>调整：front指向队列的第一个元素，front初始值为0，rear指向队列的最后一个元素的后一位，rear初始值也为0</li>
<li>队列满条件： <code>(rear+1) % maxSize == front</code></li>
<li>队列空条件：<code>rear == front</code></li>
<li>队列中有效数据的个数： <code>(rear - front + maxSize) % maxSize//其实就是rear-front的绝对值</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="1-3-单向链表"><a href="#1-3-单向链表" class="headerlink" title="1.3 单向链表"></a>1.3 单向链表</h4><ul>
<li><p>链表是有序的列表，是以节点的方式来存储,是链式存储。</p>
</li>
<li><p>每个节点包含 data 域， next 域：指向下一个节点。链表分带头节点的链表和没有头节点的链表</p>
<ul>
<li><img src="/TyporaImg/数据结构与算法.assets/image-20220725151129673.png" alt="image-20220725151129673"></li>
</ul>
</li>
</ul>
<ul>
<li><p><u><em>单链表的定义：day0725/singleLinkedListDemo.java</em></u></p>
</li>
<li><p>增：<u><em>按顺序插入节点：day0725/singleLinkedListDemo.java</em></u>其中的<code>addByOrder</code>方法</p>
</li>
<li><p>修改节点 <code>update</code>方法</p>
</li>
<li><p>删除节点 <code>delete</code>方法；被删除的节点，将不会有其他引用指向，将被垃圾回收</p>
</li>
<li><p>获取链表倒数第k个元素：</p>
<ol>
<li><p>接收head和index</p>
</li>
<li><p>先从头到尾遍历，得到总长度size</p>
</li>
<li><p>遍历得到第size-index个元素，则为倒数第k个元素</p>
<p>注：对index检验其是否合理</p>
</li>
</ol>
</li>
<li><p>单链表的反转：<code>reverse</code>方法</p>
<ol>
<li>定义一个节点<code>reverseHead</code>为反转后的头</li>
<li>从头到尾遍历原链表，每遍历一个就将其取出，放在新链表最前端(类似于指定位置插入元素)</li>
<li>原链表中的元素<code>head.next = reverseHead.next</code>  </li>
</ol>
</li>
<li><p>从尾到头打印链表</p>
<ul>
<li>方法1：先将单链表反转再打印，但是这样做会破坏单链表的结构</li>
<li>方法2：利用栈，将各个节点压入到栈内，利用栈先进后出的特点实现逆序打印 <code>java.util.Stack类</code></li>
</ul>
</li>
</ul>
<h4 id="1-4-双向链表"><a href="#1-4-双向链表" class="headerlink" title="1.4 双向链表"></a>1.4 双向链表</h4><ul>
<li>单向链表的查找方向只有一个，而双向链表可以向前或者向后查找。</li>
<li>单向链表不能自我删除，需要靠辅助节点 ，而双向链表，则可以自我删除，所以前面我们单链表删除时节点，总是找到temp,temp是待删除节点的前一个节点</li>
<li>结构：多了一个pre指向前一个节点</li>
<li>遍历：和单链表一样，只是可以向前或者向后 </li>
<li>增：<ol>
<li>找到最后一个节点</li>
<li><code>temp.next = newNode;</code></li>
<li><code>newNode.pre = temp;</code></li>
</ol>
</li>
<li>删：<ol>
<li>直线找到要删除的节点</li>
<li><code>temp.pre.next = temp.next;//temp为要删除的节点</code></li>
<li><code>temp.next.pre = temp.pre;</code></li>
</ol>
</li>
<li>改：和单向链表一样</li>
<li><u><em>增删改查的代码实现：day0725/DoubleLinkedListDemo.java</em></u></li>
</ul>
<h4 id="1-5-单向环形问题和约瑟夫问题"><a href="#1-5-单向环形问题和约瑟夫问题" class="headerlink" title="1.5 单向环形问题和约瑟夫问题"></a>1.5 单向环形问题和约瑟夫问题</h4><ul>
<li><p>约瑟夫问题</p>
<p><img src="/TyporaImg/数据结构与算法.assets/image-20220725195717002.png" alt="image-20220725195717002"></p>
</li>
<li><p>构建一个单向的环形链表思路</p>
<ol>
<li>先创建第一个节点，让first指向该节点，并形成环形</li>
<li>后面每创建一个新的节点，就把该节点加入已有的环形链表中</li>
</ol>
</li>
<li><p>遍历：</p>
<ol>
<li>让第一个辅助指针（变量） <code>curBoy</code>指向first节点</li>
<li>然后通过while循环遍历该环形链表 <code>curBoy.next == first</code>结束</li>
</ol>
</li>
<li><p>约瑟夫问题的实现</p>
<ul>
<li><p>创建一个辅助指针helper，事先指向环形链表的最后这个节点</p>
</li>
<li><p>当小孩报数的时候，让first和helper指针同时移动m-1次</p>
</li>
<li><p>这个时候将first指向的小孩节点出圈，</p>
<p><code>first = first.next;</code></p>
<p><code>hleper.next = first;</code></p>
<p>原来first指向的节点就没有任何用，就会被回收</p>
</li>
</ul>
</li>
</ul>
<h3 id="0726-二-栈、前中后缀表达式、排序"><a href="#0726-二-栈、前中后缀表达式、排序" class="headerlink" title="0726 二  栈、前中后缀表达式、排序"></a>0726 二  栈、前中后缀表达式、排序</h3><h4 id="2-1-栈（Stack）"><a href="#2-1-栈（Stack）" class="headerlink" title="2.1 栈（Stack）"></a>2.1 栈（Stack）</h4><ul>
<li><p>先入后出</p>
</li>
<li><p>栈(stack)是限制线性表中元素的插入和删除<strong>只能在线性表的同一端</strong>进行的一种特殊线性表。允许插入和删除的一端，为变化的一端，称为<strong>栈顶</strong>(Top)，另一端为固定的一端，称为<strong>栈底</strong>(Bottom)。</p>
</li>
<li><p>出栈（pop）和入栈（push）</p>
</li>
<li><p>应用</p>
<ul>
<li>子程序的调用：在跳往子程序前，会先将下个指令的地址存到堆栈中，直到子程序执行完后再将地址取出，以回到原来的程序中</li>
<li>处理递归调用：和子程序的调用类似，只是除了储存下一个指令的地址外，也将参数、区域变量等数据存入堆栈中</li>
<li>表达式的转换</li>
<li>二叉树的遍历</li>
<li>图形的深度优先(depth一first)搜索法</li>
</ul>
</li>
<li><p>栈的数组实现</p>
<ul>
<li>定义一个top表示栈顶，初始化为-1</li>
<li>入栈操作：当有数据加入的时候，<code>top++;stack[top] = data;</code></li>
<li>出栈操作：<code>int value = stack[top];top--;return value;</code>    </li>
</ul>
</li>
<li><p>栈实现综合计算器：<u><em>使用栈完成一个表达式的结果：day0726/Calculator.java</em></u> <code>//有括号不行</code></p>
<ol>
<li><p>两个栈：数栈（存放数字）和符号栈（存放运算符）</p>
</li>
<li><p>创建一个index指针遍历表达式 <code>//String str = "3+2*6-2";</code></p>
</li>
<li><p>如果是一个数字，就直接加入到数栈中</p>
</li>
<li><p>如果是一个符号，分为两种情况</p>
<ul>
<li>当前符号栈为空，则直接加入到符号栈中</li>
<li>当前符号栈非空，进行比较：<ul>
<li>当前符号的优先级&lt;=栈中的操作符，就从数栈中pop出两个数字，从符号栈中pop出一个符号进行运算，将得到的结果入数栈，然后将当前操作符入符号栈</li>
<li>当前符号的优先级&gt;栈中的操作符，则直接入栈</li>
</ul>
</li>
</ul>
</li>
<li><p>当表达式扫描完毕，就顺序从数栈和符号栈中pop出相应的数和符号并运算</p>
<p>​            注：数栈中依次pop出ab连个数字，符号栈中pop出xxx运算符，则结果为<code>bxxxa</code></p>
</li>
<li><p>最后数栈中只有一个结果，即表达式的结果</p>
<p>注：对于多位数的处理：判断下一个数字是否为运算符。如果是则加入，如果不是则进行拼接，然后下一步循环的时候再对下下个字符进行判断处理</p>
</li>
</ol>
</li>
</ul>
<h4 id="2-2-前缀、中缀、后缀表达式"><a href="#2-2-前缀、中缀、后缀表达式" class="headerlink" title="2.2 前缀、中缀、后缀表达式"></a>2.2 前缀、中缀、后缀表达式</h4><ul>
<li><p>前缀表达式又称波兰式，<strong>前缀表达式的运算符位于操作数之前</strong></p>
<p><code>(3+4)×5-6 对应的前缀表达式就是 -×+3456</code></p>
</li>
<li><p>前缀表达式求值：从右至左扫描表达式，遇到数字时，将数字压入堆栈，遇到运算符时，弹出栈顶的两个数，用运算符对它们做相应的计算（栈顶元素 和 次顶元素），并将结果入栈；重复上述过程直到表达式最左端，最后运算得出的值即为表达式的结果</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//(3+4)×5-6 对应的前缀表达式就是 -×+3456, 针对前缀表达式求值步骤如下</span></span><br><span class="line"><span class="number">1.</span>从右至左扫描，将<span class="number">6</span>、<span class="number">5</span>、<span class="number">4</span>、<span class="number">3</span>压入堆栈</span><br><span class="line"><span class="number">2.</span>遇到+运算符，因此弹出<span class="number">3</span>和<span class="number">4</span>（<span class="number">3</span>为栈顶元素，<span class="number">4</span>为次顶元素），计算出<span class="number">3</span>+<span class="number">4</span>的值，得<span class="number">7</span>，再将<span class="number">7</span>入栈</span><br><span class="line"><span class="number">3.</span>接下来是×运算符，因此弹出<span class="number">7</span>和<span class="number">5</span>，计算出<span class="number">7</span>×<span class="number">5</span>=<span class="number">35</span>，将<span class="number">35</span>入栈</span><br><span class="line"><span class="number">4.</span>最后是-运算符，计算出<span class="number">35</span>-<span class="number">6</span>的值，即<span class="number">29</span>，由此得出最终结果</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>中缀表达式：就是<strong>常见的运算表达式</strong>，如(3+4)×5-6</p>
<p>但是计算机不易识别，一般会转换为其他的表达式来处理（常转为后缀表达式）</p>
</li>
<li><p>后缀表达式：又称<strong>逆波兰表达式</strong>,与前缀表达式相似，只是运算符位于操作数之后</p>
<p><code>(3+4)×5-6 对应的后缀表达式就是34+5×6–</code></p>
<p><img src="/TyporaImg/数据结构与算法.assets/image-20220726145733439.png" alt="image-20220726145733439"></p>
</li>
<li><p>后缀表达式求值：<strong>从左至右</strong>扫描表达式，遇到数字时，将数字压入堆栈，遇到运算符时，弹出栈顶的两个数，用运算符对它们做相应的计算（次顶元素 和 栈顶元素），并将结果入栈；重复上述过程直到表达式最右端，最后运算得出的值即为表达式的结果</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//(3+4)×5-6 对应的后缀表达式就是 34+5×6-, 针对后缀表达式求值步骤如下</span></span><br><span class="line"><span class="number">1.</span>从左至右扫描，将<span class="number">3</span>和<span class="number">4</span>压入堆栈；</span><br><span class="line"><span class="number">2.</span>遇到+运算符，因此弹出<span class="number">4</span>和<span class="number">3</span>（<span class="number">4</span>为栈顶元素，<span class="number">3</span>为次顶元素），计算出<span class="number">3</span>+<span class="number">4</span>的值，得<span class="number">7</span>，再将<span class="number">7</span>入栈；</span><br><span class="line"><span class="number">3.</span>将<span class="number">5</span>入栈；</span><br><span class="line"><span class="number">4.</span>接下来是×运算符，因此弹出<span class="number">5</span>和<span class="number">7</span>，计算出<span class="number">7</span>×<span class="number">5</span>=<span class="number">35</span>，将<span class="number">35</span>入栈；</span><br><span class="line"><span class="number">5.</span>将<span class="number">6</span>入栈；</span><br><span class="line"><span class="number">6.</span>最后是-运算符，计算出<span class="number">35</span>-<span class="number">6</span>的值，即<span class="number">29</span>，由此得出最终结果</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>逆波兰计算机实现：<u><em>day0726/PolandNatation.java</em></u> </p>
</li>
<li><p>中缀表达式转后缀表达式:代码实现在<code>PolandNatation.java</code>的<code>toInfixExpressionList</code>方法中</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>初始化两个栈：运算符栈s1和储存中间结果的栈s2；</span><br><span class="line"><span class="number">2.</span>从左至右扫描中缀表达式；</span><br><span class="line"><span class="number">3.</span>遇到操作数时，将其压s2；</span><br><span class="line"><span class="number">4.</span>遇到运算符时，比较其与s1栈顶运算符的优先级：</span><br><span class="line">	<span class="number">4.1</span> 如果s1为空，或栈顶运算符为左括号“(”，则直接将此运算符入栈；</span><br><span class="line">	<span class="number">4.2</span> 否则，若优先级比栈顶运算符的高，也将运算符压入s1；</span><br><span class="line">	<span class="number">4.3</span> 否则，将s1栈顶的运算符弹出并压入到s2中，再次转到(<span class="number">4.1</span>)与s1中新的栈顶运算符相比较；	</span><br><span class="line"><span class="number">5.</span>遇到括号时：</span><br><span class="line">    <span class="number">5.1</span> 如果是左括号“(”，则直接压入s1</span><br><span class="line">    <span class="number">5.2</span> 如果是右括号“)”，则依次弹出s1栈顶的运算符，并压入s2，直到遇到左括号为止，此时将这一对括号丢弃</span><br><span class="line"><span class="number">6.</span>重复步骤<span class="number">2</span>至<span class="number">5</span>，直到表达式的最右边</span><br><span class="line"><span class="number">7.</span>将s1中剩余的运算符依次弹出并压入s2</span><br><span class="line"><span class="number">8.</span>依次弹出s2中的元素并输出，结果的逆序即为中缀表达式对应的后缀表达式</span><br></pre></td></tr></tbody></table></figure>
<p><img src="/TyporaImg/数据结构与算法.assets/image-20220726153126279.png" alt="image-20220726153126279"></p>
</li>
</ul>
<h4 id="2-3-递归（Recursion）的调用场景"><a href="#2-3-递归（Recursion）的调用场景" class="headerlink" title="2.3 递归（Recursion）的调用场景"></a>2.3 递归（Recursion）的调用场景</h4><ul>
<li>递归解决的问题：8皇后问题 , 汉诺塔, 阶乘问题, 迷宫问题, 球和篮子的问题(google编程大赛)</li>
<li>各种算法中也会使用到递归，比如快排，归并排序，二分查找，分治算法等.</li>
<li>将用栈解决的问题—&gt;递归代码比较简洁</li>
<li><p>递归的原则</p>
<ul>
<li>执行一个方法时，就创建一个新的受保护的独立空间(栈空间)</li>
<li>方法的局部变量是独立的，不会相互影响, 比如n变量</li>
<li>如果方法中使用的是引用类型变量(比如数组)，就会共享该引用类型的数据.</li>
<li>递归必须向退出递归的条件逼近，否则就是无限递归,出现StackOverflowError，死龟了:)</li>
<li>当一个方法执行完毕，或者遇到return，就会返回，遵守谁调用，就将结果返回给谁，同时当方法执行完毕或者返回时，该方法也就执行完毕</li>
</ul>
</li>
<li><p>递归的内存 </p>
<p><img src="/TyporaImg/数据结构与算法.assets/image-20220726164350390.png" alt="image-20220726164350390"></p>
</li>
<li><p>八皇后问题：</p>
<p>在8×8格的国际象棋上摆放八个皇后，使其不能互相攻击，即：<strong>任意两个皇后都不能处于同一行、同一列或同一斜线上，问有多少种摆法</strong>。</p>
<p>​            思路：</p>
<ul>
<li>第一个皇后先放第一行第一列</li>
<li>第二个皇后放在第二行第一列、然后判断是否OK， 如果不OK，继续放在第二列、第三列、依次把所有列都放完，找到一个合适</li>
<li>继续第三个皇后，还是第一列、第二列……直到第8个皇后也能放在一个不冲突的位置，算是找到了一个正确解</li>
<li><p>当得到一个正确解时，在栈回退到上一个栈时，就会开始回溯，即将第一个皇后，放到第一列的所有正确解，全部得到.</p>
</li>
<li><p>然后回头继续第一个皇后放第二列，后面继续循环执行 1,2,3,4的步骤 </p>
</li>
</ul>
</li>
</ul>
<ul>
<li><p>八皇后问题实现：<u><em>day0726/Queue8.java</em></u> </p>
<p>说明:理论上应该创建一个二维数组来表示棋盘，但是实际上可以通过算法，用一个一维数组即可解决问题. arr[8] = {0 , 4, 7, 5, 2, 6, 1, 3} //对应arr 下标 表示第几行，即第几个皇后，arr[i] = val , val 表示第i+1个皇后，放在第i+1行的第val+1列</p>
</li>
</ul>
<h4 id="2-4-排序算法"><a href="#2-4-排序算法" class="headerlink" title="2.4 排序算法"></a>2.4 排序算法</h4><ul>
<li><img src="/TyporaImg/数据结构与算法.assets/image-20220726195248769.png" alt="image-20220726195248769"></li>
<li>直接插入、简单选择、冒泡比较常用</li>
</ul>
<h4 id="2-5-算法的时间复杂度"><a href="#2-5-算法的时间复杂度" class="headerlink" title="2.5 算法的时间复杂度"></a>2.5 算法的时间复杂度</h4><ul>
<li>度量一个程序(算法)执行时间的两种方法<ul>
<li>事后统计的方法</li>
<li>事前估算的方法</li>
</ul>
</li>
<li>时间频度：一个算法中的语句执行次数称为语句频度或时间频度。记为<code>T(n)</code></li>
<li><p>一般情况下，算法中的基本操作语句的重复执行次数是问题规模n的某个函数，用<code>T(n)</code>表示，若有某个辅助函数<code>f(n)</code>，使得当n趋近于无穷大时，<code>T(n)/f(n)</code> 的极限值为不等于零的常数，则称<code>f(n)</code>是<code>T(n)</code>的同数量级函数。记作 <code>T(n)=O(f(n))</code>，称<code>O(f(n))</code> 为算法的渐进时间复杂度，简称时间复杂度</p>
<ul>
<li>注：T(n) 不同，但时间复杂度可能相同。 如：<code>T(n)=n²+7n+6</code> 与 <code>T(n)=3n²+2n+2</code> 它们的T(n) 不同，但时间复杂度相同，都为O(n²)。</li>
<li>计算方法：<ol>
<li>用常数1代替运行时间中的所有加法常数 T(n)=n²+7n+6 =&gt; T(n)=n²+7n+1</li>
<li>修改后的运行次数函数中，只保留最高阶项 T(n)=n²+7n+1 =&gt; T(n) = n²</li>
<li>去除最高阶项的系数 T(n) = n² =&gt; T(n) = n² =&gt; O(n²)</li>
</ol>
</li>
</ul>
</li>
<li><p><img src="/TyporaImg/数据结构与算法.assets/image-20220726200251872.png" alt="image-20220726200251872"></p>
</li>
<li><p>常见时间复杂度</p>
<ul>
<li><p>常数阶<code>O(1)</code>:无论代码执行了多少行，只要是没有循环等复杂结构，那这个代码的时间复杂度就都是O(1)</p>
</li>
<li><p>对数阶<code>O(log2n)</code>:</p>
<p><img src="/TyporaImg/数据结构与算法.assets/image-20220726200456805.png" alt="image-20220726200456805"></p>
</li>
<li><p>线性阶<code>O(n)</code>:for循环里面的代码会执行n遍，因此它消耗的时间是随着n的变化而变化的，因此这类代码都可以用O(n)来表示它的时间复杂度</p>
</li>
<li><p>线性对数阶 <code>O(nlogN)</code>:线性对数阶<code>O(nlogN)</code> 其实非常容易理解，将时间复杂度为<code>O(logn)</code>的代码循环N遍的话（while套在for循环里面）那么它的时间复杂度就是 <code>n * O(logN)</code>，也就是了<code>O(nlogN)</code></p>
</li>
<li><p>平方阶<code>O(n2)</code>:将<code>O(n)</code>内代码嵌套一遍（两个for循环）</p>
</li>
<li><p>立方阶、k次方阶：相当于k个for循环嵌套</p>
</li>
</ul>
</li>
<li><p>常见排序算法的时间复杂度</p>
<p><img src="/TyporaImg/数据结构与算法.assets/image-20220726201016842.png" alt="image-20220726201016842"></p>
</li>
</ul>
<h4 id="2-6-算法空间复杂度"><a href="#2-6-算法空间复杂度" class="headerlink" title="2.6 算法空间复杂度"></a>2.6 算法空间复杂度</h4><ul>
<li><p>一个算法的空间复杂度(Space Complexity)定义为该算法所耗费的存储空间，它也是问题规模n的函数。</p>
<p>在做算法分析时，<strong>主要讨论的是时间复杂度</strong>。从用户使用体验上看，更看重的程序执行的速度。一些缓存产品(redis, memcache)和算法(基数排序)本质就是用空间换时间。</p>
</li>
</ul>
<h4 id="2-7-冒泡排序"><a href="#2-7-冒泡排序" class="headerlink" title="2.7 冒泡排序"></a>2.7 冒泡排序</h4><ul>
<li>通过对待排序序列从前向后（从下标较小的元素开始）,依次比较相邻元素的值，若发现逆序则交换，使值较大的元素逐渐从前移向后部，就象水底下的气泡一样逐渐向上冒。</li>
<li>冒泡排序的实现：<u><em>day0726/BubbleSort.java</em></u> </li>
<li>冒泡排序的优化：因为排序的过程中，各元素不断接近自己的位置，如果一趟比较下来没有进行过交换，就说明序列有序，因此要在排序过程中设置一个标志flag判断元素是否进行过交换。从而减少不必要的比较。</li>
</ul>
<h4 id="2-8-选择排序"><a href="#2-8-选择排序" class="headerlink" title="2.8 选择排序"></a>2.8 选择排序</h4><ul>
<li><p>选择式排序也属于内部排序法，是从欲排序的数据中，按指定的规则选出某一元素，再依规定交换位置后达到排序的目的。</p>
<p>比如第一次选出最小的和第一个元素交换位置，第二次再选出剩下的最小的和第二个元素交换位置，以此类推</p>
</li>
<li><p>冒泡排序的实现：<u><em>day0726/SelectSort.java</em></u> </p>
</li>
</ul>
<h3 id="0727-三-排序、查找、哈希表"><a href="#0727-三-排序、查找、哈希表" class="headerlink" title="0727 三 排序、查找、哈希表"></a>0727 三 排序、查找、哈希表</h3><h4 id="3-1-插入排序"><a href="#3-1-插入排序" class="headerlink" title="3.1 插入排序"></a>3.1 插入排序</h4><ul>
<li><p>把n个待排序的元素看成为一个有序表和一个无序表，开始时有序表中只包含一个元素，无序表中包含有n-1个元素，排序过程中每次从无序表中取出第一个元素，把它的排序码依次与有序表元素的排序码进行比较，将它插入到有序表中的适当位置，使之成为新的有序表。</p>
</li>
<li><p>思路图</p>
<p><img src="/TyporaImg/数据结构与算法.assets/image-20220727090206460.png" alt="image-20220727090206460"></p>
</li>
<li><p>插入排序的实现：<u><em>day0726/InsertSort.java</em></u> </p>
</li>
<li><p>插入排序的缺陷：当（从小到大排）插入的数较小，需要遍历的次数多，会导致插入排序的时间增加</p>
</li>
<li><p>希尔排序（缩小增量排序）：希尔排序是把记录按下标的一定增量分组，对每组使用直接插入排序算法排序；随着增量逐渐减少，每组包含的关键词越来越多，当增量减至1时，整个文件恰被分成一组，算法便终止</p>
<p><img src="/TyporaImg/数据结构与算法.assets/image-20220727092644327.png" alt="image-20220727092644327"></p>
<p>希尔排序的实现(里面有交换式和移位式)：<u><em>day0726/SheelSort.java</em></u> </p>
</li>
</ul>
<h4 id="3-2-快速排序"><a href="#3-2-快速排序" class="headerlink" title="3.2 快速排序"></a>3.2 快速排序</h4><ul>
<li>是对冒泡排序的一种改进</li>
<li>思想：通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列</li>
<li><img src="/TyporaImg/数据结构与算法.assets/image-20220727141201553.png" alt="image-20220727141201553"></li>
<li>快速排序的实现：<u><em>day0726/QuickSort.java</em></u> </li>
</ul>
<h4 id="3-3-归并排序"><a href="#3-3-归并排序" class="headerlink" title="3.3 归并排序"></a>3.3 归并排序</h4><ul>
<li><p>分而治之</p>
</li>
<li><p><img src="/TyporaImg/数据结构与算法.assets/image-20220727155649005.png" alt="image-20220727155649005"></p>
</li>
<li><p>重点为“治”的过程：将两个有序子序列合并为一个有序序列</p>
<p><img src="/TyporaImg/数据结构与算法.assets/image-20220727155805235.png" alt="image-20220727155805235"></p>
</li>
</ul>
<h4 id="3-4-基数排序（桶排序）"><a href="#3-4-基数排序（桶排序）" class="headerlink" title="3.4 基数排序（桶排序）"></a>3.4 基数排序（桶排序）</h4><ul>
<li><p>基数排序是桶排序的扩展</p>
</li>
<li><p>基本思想：将所有待比较数值统一为同样的数位长度，数位较短的数前面补零。然后，从最低位开始，依次进行一次排序。这样从最低位排序一直到最高位排序完成以后, 数列就变成一个有序序列</p>
</li>
<li><p>过程：</p>
<p><img src="/TyporaImg/数据结构与算法.assets/image-20220727181029645.png" alt="image-20220727181029645"></p>
<p><img src="/TyporaImg/数据结构与算法.assets/image-20220727181036126.png" alt="image-20220727181036126"></p>
<p><img src="/TyporaImg/数据结构与算法.assets/image-20220727181043233.png" alt="image-20220727181043233"></p>
</li>
<li><p>基数排序的实现：<u><em>day0726/RadixSort.java</em></u></p>
</li>
<li><p>说明：</p>
<ul>
<li>基数排序是对传统桶排序的扩展，速度很快</li>
<li>基数排序是经典的空间换时间的方式，占用内存很大, 当对海量数据排序时，容易造成 <code>OutOfMemoryError</code> 。</li>
<li>有负数的数组，我们不用基数排序来进行排序,如果要支持负数，参考:<a target="_blank" rel="noopener" href="https://code.i-harness.com/zh-CN/q/e98fa9">https://code.i-harness.com/zh-CN/q/e98fa9</a></li>
<li>基数排序时稳定的。[注:假定在待排序的记录序列中，存在多个具有相同的关键字的记录，若经过排序，这些记录的相对次序保持不变，即在原序列中，r[i]=r[j]，且r[i]在r[j]之前，而在排序后的序列中，r[i]仍在r[j]之前，则称这种排序算法是稳定的；否则称为不稳定的]</li>
</ul>
</li>
</ul>
<h4 id="3-5-常用排序算法对比"><a href="#3-5-常用排序算法对比" class="headerlink" title="3.5 常用排序算法对比"></a>3.5 常用排序算法对比</h4><p><img src="/TyporaImg/数据结构与算法.assets/image-20220727181531794.png" alt="image-20220727181531794"></p>
<h4 id="3-6-查找算法"><a href="#3-6-查找算法" class="headerlink" title="3.6 查找算法"></a>3.6 查找算法</h4><ul>
<li><p>常用查找</p>
<ul>
<li>顺序(线性)查找</li>
<li>二分查找/折半查找 </li>
<li>插值查找</li>
<li>斐波那契查找</li>
</ul>
</li>
<li><p>顺序（线性）查找：就是遍历搜索查找，直到找到想要的返回值 3.7 二分查找‘</p>
</li>
<li><p>二分查找：对于有序数组而言，每次从中间分开找 <code>mid = (left+right)/2</code>(向下取整)，直到得到想要的值</p>
<ul>
<li>结束递归的条件：找到了想要的值；递归完了整个数组 <code>left &gt; right</code></li>
<li>二分查找的实现：<u><em>day0726/BinartSearch.java</em></u></li>
</ul>
</li>
<li><p>插值查找：插值查找算法类似于二分查找，不同的是插值查找每次从<code>自适应mid</code>处开始查找</p>
<p><img src="/TyporaImg/数据结构与算法.assets/image-20220727195757725.png" alt="image-20220727195757725"></p>
<p>注：</p>
<ul>
<li><code>low</code>为<code>left</code>,<code>high</code>为<code>right</code>,<code>key</code>为待查找值</li>
<li>对于数据量较大，关键字分布比较均匀的查找表来说，采用插值查找速度较快。</li>
<li>数据分布不均匀的情况下，该方法不一定比折半查找要好</li>
</ul>
</li>
<li><p>斐波那契查找（黄金分隔法）：</p>
<ul>
<li>斐波那契数列：<code>F[k]=F[k-1]+F[k-2]</code></li>
<li>斐波那契查找原理与前两种相似，仅仅改变了中间结点（mid）的位置，mid不再是中间或插值得到，而是位于黄金分割点附近，即<code>mid=low+F(k-1)-1</code></li>
<li>但顺序表长度n不一定刚好等于F[k]-1，所以需要将原来的顺序表长度n增加至F[k]-1。这里的k值只要能使得F[k]-1恰好大于或等于n即可，由以下代码得到,顺序表长度增加后，新增的位置（从n+1到F[k]-1位置），都赋为n位置的值即可。</li>
<li>斐波那契查找的实现：<u><em>day0726/FibonacciSearch.java</em></u></li>
</ul>
</li>
</ul>
<h4 id="3-7-哈希表"><a href="#3-7-哈希表" class="headerlink" title="3.7 哈希表"></a>3.7 哈希表</h4><ul>
<li><p>散列表（Hash table，也叫哈希表），是根据关键码值(Key value)而直接进行访问的数据结构。也就是说，它通过把关键码值映射到表中一个位置来访问记录，以加快查找的速度。这个映射函数叫做散列函数，存放记录的数组叫做散列表。</p>
</li>
<li><p>形式：数组+链表或者数组+二叉树</p>
</li>
<li><p>使用链表实现哈希表，该链表不带表头（即第一个数据就存放员工信息）</p>
</li>
<li><p>使用哈希表来实现增删改查：<u><em>day0726/HashTabDemo.java</em></u></p>
<p><img src="/TyporaImg/数据结构与算法.assets/image-20220727204428888.png" alt="image-20220727204428888"></p>
</li>
</ul>
<h3 id="0728-四-二叉树、堆、赫夫曼树"><a href="#0728-四-二叉树、堆、赫夫曼树" class="headerlink" title="0728 四 二叉树、堆、赫夫曼树"></a>0728 四 二叉树、堆、赫夫曼树</h3><h4 id="4-1-树结构"><a href="#4-1-树结构" class="headerlink" title="4.1 树结构"></a>4.1 树结构</h4><ul>
<li><p>常见数据结构特点：</p>
<ul>
<li>数组：优点：通过下标方式访问元素，速度快。对于有序数组，还可使用二分查找提高检索速度。<pre><code>         缺点：如果要检索具体某个值，或者插入值(按一定顺序)会整体移动，效率较低
</code></pre></li>
<li>链式存储：优点：在一定程度上对数组存储方式有优化(比如：插入一个数值节点，只需要将插入节点，链接到链表中即可， 删除效率也很好)。<pre><code>          缺点：在进行检索时，效率仍然较低，比如(检索某个值，需要从头节点开始遍历) 
</code></pre></li>
<li>树存储：能提高数据存储，读取的效率, 比如利用 二叉排序树(Binary Sort Tree)，既可以保证数据的检索速度，同时也可以保证数据的插入，删除，修改的速度。</li>
</ul>
</li>
<li><p>树结构示意图：</p>
<p><img src="/TyporaImg/数据结构与算法.assets/image-20220728113952388.png" alt="image-20220728113952388"></p>
</li>
</ul>
<h4 id="4-2-二叉树"><a href="#4-2-二叉树" class="headerlink" title="4.2 二叉树"></a>4.2 二叉树</h4><ul>
<li><p>每个节点最多只能有两个子节点的一种形式称为二叉树</p>
</li>
<li><p>二叉树的子节点分为左节点和右节点</p>
</li>
<li><p>如果该二叉树的所有叶子节点都在最后一层，并且<code>结点总数= 2^n -1</code> , n 为层数，则我们称为满二叉树</p>
</li>
<li><p>如果该二叉树的所有叶子节点都在最后一层或者倒数第二层，而且最后一层的叶子节点在左边连续，倒数第二层的叶子节点在右边连续，我们称为完全二叉树</p>
<p><img src="/TyporaImg/数据结构与算法.assets/image-20220728115216390.png" alt="image-20220728115216390"></p>
</li>
<li><p>二叉树的遍历方式：前序、中序、后序遍历</p>
<ul>
<li><p>前序遍历：<strong>先输出父节点</strong>，再遍历左子树和右子树</p>
</li>
<li><p>中序遍历：先遍历左子树，<strong>再输出父节点</strong>，再遍历右子树</p>
</li>
<li><p>后序遍历：先遍历左子树，再遍历右子树，<strong>最后输出父节点</strong></p>
<p>注：看输出父节点的顺序，就确定是前序，中序还是后序</p>
</li>
</ul>
<p><img src="/TyporaImg/数据结构与算法.assets/image-20220728115651031.png" alt="image-20220728115651031"></p>
<p>二叉树节点遍历的实现：<u><em>day0728/BinaryTreeDemo.java</em></u></p>
</li>
<li><p>二叉树值的前中后序查找：<u><em>day0728/BinaryTreeDemo.java</em></u></p>
<p><img src="/TyporaImg/数据结构与算法.assets/image-20220728122246724.png" alt="image-20220728122246724"></p>
</li>
<li><p>删除：<u><em>day0728/BinaryTreeDemo.java</em></u></p>
<p><img src="/TyporaImg/数据结构与算法.assets/image-20220728123929107.png" alt="image-20220728123929107"></p>
</li>
</ul>
<h4 id="4-3-顺序存储二叉树"><a href="#4-3-顺序存储二叉树" class="headerlink" title="4.3 顺序存储二叉树"></a>4.3 顺序存储二叉树</h4><ul>
<li><p><img src="/TyporaImg/数据结构与算法.assets/image-20220728125820234.png" alt="image-20220728125820234"></p>
</li>
<li><p>代码实现：<u><em>day0728/ArrBinaryTreeDemo.java</em></u></p>
</li>
</ul>
<h4 id="4-4-线索化二叉树"><a href="#4-4-线索化二叉树" class="headerlink" title="4.4 线索化二叉树"></a>4.4 线索化二叉树</h4><ul>
<li><p>线索化二叉树的提出</p>
<p><img src="/TyporaImg/数据结构与算法.assets/image-20220728131356202.png" alt="image-20220728131356202"></p>
</li>
<li><p>思路分析</p>
<p><img src="/TyporaImg/数据结构与算法.assets/image-20220728131410325.png" alt="image-20220728131410325"></p>
</li>
<li><p>不同的遍历方式会产生不同的线索二叉树（前序遍历产生前序线索二叉树）</p>
</li>
<li><p>代码实现：<u><em>day0728/ThreadedBinaryTreeDemo.java</em></u></p>
</li>
</ul>
<h4 id="4-5-堆排序"><a href="#4-5-堆排序" class="headerlink" title="4.5 堆排序"></a>4.5 堆排序</h4><ul>
<li><p>堆排序是利用堆这种数据结构而设计的一种排序算法，堆排序是一种选择排序<strong>，</strong>它的最坏、最好平均时间复杂度均为O(nlogn)，它也是不稳定排序。</p>
</li>
<li><p>一般用数组来表示堆，下标为 i 的结点的父结点下标为<code>(i-1)/2</code>；其左右子结点分别为 <code>(2i + 1)、(2i + 2)</code></p>
</li>
<li><p>堆是具有以下性质的完全二叉树：每个结点的值都大于或等于其左右孩子结点的值，称为大顶堆, 注意 : 没有要求结点的左孩子的值和右孩子的值的大小关系。<code>arr[i] &gt;= arr[2*i+1] &amp;&amp; arr[i] &gt;= arr[2*i+2]</code></p>
</li>
<li><p>每个结点的值都小于或等于其左右孩子结点的值，称为小顶堆 <code>arr[i] &lt;= arr[2*i+1] &amp;&amp; arr[i] &lt;= arr[2*i+2]</code></p>
</li>
<li><p>堆排序的思想：</p>
<ul>
<li><p>将待排序序列构造成一个大顶堆</p>
</li>
<li><p>此时，整个序列的最大值就是堆顶的根节点</p>
</li>
<li><p>将其与末尾元素进行交换，此时末尾就为最大值。</p>
</li>
<li><p>然后将剩余n-1个元素重新构造成一个堆，这样会得到n个元素的次小值。如此反复执行，便能得到一个有序序列了。</p>
<video src="D:/javase_study/堆排序.mp4"></video>
</li>
</ul>
</li>
<li><p>代码实现：<u><em>day0728/HeapSort.java</em></u></p>
</li>
</ul>
<h4 id="4-6-赫夫曼树"><a href="#4-6-赫夫曼树" class="headerlink" title="4.6 赫夫曼树"></a>4.6 赫夫曼树</h4><ul>
<li><p>给定n个权值作为n个叶子结点，构造一棵二叉树，若该树的带权路径长度(wpl)达到最小，称这样的二叉树为最优二叉树，也称为哈夫曼树(Huffman Tree), 还有的书翻译为霍夫曼树。</p>
</li>
<li><p>赫夫曼树是带权路径长度最短的树，权值较大的结点离根较近。</p>
</li>
<li><p>两个概念：</p>
<ul>
<li>路径和路径长度：在一棵树中，从一个结点往下可以达到的孩子或孙子结点之间的通路，称为路径。通路中分支的数目称为路径长度。若规定根结点的层数为1，则从根结点到第L层结点的路径长度为L-1</li>
<li>结点的权及带权路径长度：若将树中结点赋给一个有着某种含义的数值，则这个数值称为该结点的权。结点的带权路径长度为：从根结点到该结点之间的路径长度与该结点的权的乘积</li>
<li><p>树的带权路径长度：树的带权路径长度规定为所有叶子结点的带权路径长度之和，记为WPL(weighted path length) ,权值越大的结点离根结点越近的二叉树才是最优二叉树。</p>
</li>
<li><p><img src="/TyporaImg/数据结构与算法.assets/image-20220728164457138.png" alt="image-20220728164457138"></p>
</li>
</ul>
</li>
<li><p>赫夫曼树的构造：</p>
<ol>
<li>从小到大进行排序, 将每一个数据，每个数据都是一个节点 ， 每个节点可以看成是一颗最简单的二叉树</li>
<li>取出根节点权值最小的两颗二叉树 </li>
<li>组成一颗新的二叉树, 该新的二叉树的根节点的权值是前面两颗二叉树根节点权值的和 </li>
<li>再将这颗新的二叉树，以根节点的权值大小 再次排序， 不断重复 1-2-3-4 的步骤，直到数列中，所有的数据都被处理，就得到一颗赫夫曼树</li>
</ol>
</li>
<li>赫夫曼树的构建代码实现：<u><em>day0728/HuffmanTree.java</em></u></li>
</ul>
<h4 id="4-7-赫夫曼编码"><a href="#4-7-赫夫曼编码" class="headerlink" title="4.7 赫夫曼编码"></a>4.7 赫夫曼编码</h4><ul>
<li><p>赫夫曼编码也翻译为 哈夫曼编码(Huffman Coding)，又称霍夫曼编码，是一种编码方式, 属于一种程序算法</p>
</li>
<li><p>赫夫曼编码是赫哈夫曼树在电讯通信中的经典的应用之一</p>
</li>
<li><p>赫夫曼编码广泛地用于数据文件压缩。其压缩率通常在20%-90%之间</p>
</li>
<li><p>赫夫曼码是可变字长编码(VLC)的一种。Huffman于1952年提出一种编码方法，称之为最佳编码</p>
</li>
<li><p>通讯领域编码的三种方式：</p>
<ul>
<li>定长编码</li>
<li>变长编码</li>
<li>赫夫曼编码</li>
</ul>
</li>
<li><p>赫夫曼编码过程：</p>
<p><img src="/TyporaImg/数据结构与算法.assets/image-20220728171943682.png" alt="image-20220728171943682"></p>
<p><img src="/TyporaImg/数据结构与算法.assets/image-20220728172035669.png" alt="image-20220728172035669"></p>
</li>
<li><p>赫夫曼编码实现文件压缩：<u><em>day0728/huffmanCode</em></u></p>
</li>
</ul>
<h3 id="0729-五-赫夫曼编码的数据压缩和解压、二叉排序树"><a href="#0729-五-赫夫曼编码的数据压缩和解压、二叉排序树" class="headerlink" title="0729 五 赫夫曼编码的数据压缩和解压、二叉排序树"></a>0729 五 赫夫曼编码的数据压缩和解压、二叉排序树</h3><h4 id="5-1-数据解压"><a href="#5-1-数据解压" class="headerlink" title="5.1 数据解压"></a>5.1 数据解压</h4><ul>
<li>编码的逆操作</li>
<li>赫夫曼编码实现文件解压：<u><em>day0728/huffmanCode</em></u></li>
<li>赫夫曼编码实现文件压缩与解压：<u><em>day0728/huffmanCode</em></u></li>
</ul>
<h4 id="5-2-赫夫曼编码压缩文件注意事项"><a href="#5-2-赫夫曼编码压缩文件注意事项" class="headerlink" title="5.2 赫夫曼编码压缩文件注意事项"></a>5.2 赫夫曼编码压缩文件注意事项</h4><ul>
<li>如果文件本身就是经过压缩处理的，那么使用赫夫曼编码再压缩效率不会有明显变化, 比如视频,ppt 等等文件</li>
<li>赫夫曼编码是按字节来处理的，因此可以处理所有的文件(二进制文件、文本文件)</li>
<li>如果一个文件中的内容，重复的数据不多，压缩效果也不会很明显</li>
</ul>
<h4 id="5-2-二叉排序树（BST）"><a href="#5-2-二叉排序树（BST）" class="headerlink" title="5.2 二叉排序树（BST）"></a>5.2 二叉排序树（BST）</h4><ul>
<li><p>使用数组、链表在查询和增删都各有优缺，用二叉排序树更好</p>
</li>
<li><p>二叉排序树BST: (Binary Sort(Search) Tree), 对于二叉排序树的任何一个非叶子节点，要求左子节点的值比当前节点的值小，右子节点的值比当前节点的值大。</p>
<p>注：如果有相同的值，可以将该节点放在左子节点或右子节点</p>
<p><img src="/TyporaImg/数据结构与算法.assets/image-20220729191918057.png" alt="image-20220729191918057"></p>
</li>
<li><p>二叉排序树的创建和遍历：<u><em>day0729/BinarySortTreeDemo.java</em></u></p>
</li>
<li><p>二叉树的删除</p>
<ul>
<li><p>删除叶子节点 (比如：2, 5, 9, 12)</p>
<ol>
<li>找到targetNode</li>
<li>找到targetNode的父节点parent</li>
<li>确定targetNode是parent的左子节点还是右子节点</li>
<li>根据前面的情况删除</li>
</ol>
</li>
<li><p>删除只有一颗子树的节点 (比如：1)</p>
<ol>
<li><p>找到targetNode和parent</p>
</li>
<li><p>确定targetNode是parent的左子节点还是右子节点</p>
</li>
<li><p>确定targetNode的子节点是左子节点还是右子节点</p>
</li>
<li><p>若targetNode有左子节点</p>
<ul>
<li>targetNode为parent的左子节点：<code>parent.left = targetNode.left</code> </li>
<li>targetNode为parent的右子节点：<code>parent.right= targetNode.left</code> </li>
</ul>
</li>
<li><p>若targetNode有右子节点</p>
<ul>
<li>targetNode为parent的左子节点：<code>parent.left = targetNode.right</code> </li>
<li>targetNode为parent的右子节点：<code>parent.right= targetNode.right</code> </li>
</ul>
</li>
</ol>
</li>
<li><p>删除有两颗子树的节点（比如：7, 3，10 ）</p>
<ol>
<li>找到targetNode和parent</li>
<li>确定targetNode是parent的左子节点还是右子节点</li>
<li>从targetNode的右子树找到最小的节点或者左子树最大的节点</li>
<li>用一个临时变量将最小节点的值保存</li>
<li>删除最小节点</li>
<li><code>targetNode.value = temp</code></li>
</ol>
</li>
</ul>
</li>
</ul>
<h3 id="0730-六-AVL树、多路查找树、图、常用十算法"><a href="#0730-六-AVL树、多路查找树、图、常用十算法" class="headerlink" title="0730 六 AVL树、多路查找树、图、常用十算法"></a>0730 六 AVL树、多路查找树、图、常用十算法</h3><h4 id="6-1-平衡二叉树（AVL树）"><a href="#6-1-平衡二叉树（AVL树）" class="headerlink" title="6.1 平衡二叉树（AVL树）"></a>6.1 平衡二叉树（AVL树）</h4><ul>
<li><p>BST的缺点</p>
<p><img src="/TyporaImg/数据结构与算法.assets/image-20220730141131882.png" alt="image-20220730141131882"></p>
</li>
<li><p>平衡二叉树也叫平衡二叉搜索树（Self-balancing binary search tree）又被称为AVL树， 可以保证查询效率较高</p>
</li>
<li><p>特点：它是一 棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。平衡二叉树的常用实现方法有红黑树、AVL（算法）、替罪羊树、Treap、伸展树等。</p>
<p><img src="/TyporaImg/数据结构与算法.assets/image-20220730141442032.png" alt="image-20220730141442032"></p>
<p>（前两个是AVL树，第三个不是，因为高度差为2）</p>
</li>
<li><p>构建平衡二叉树</p>
<p>：<u><em>day0730/AVLTreeDemo.java</em></u></p>
<ul>
<li><p>左旋转</p>
<ul>
<li>```java<br>//创建新节点，值为当前节点的值<br>//把新的节点的左子树设为当前节点的左子树<br>//把新节点的右子树设为当前节点的右子树的左子树<br>//把当前节点的值换成右子树的值<br>//把当前节点的右子树设置成右子树的右子树<br>//把当前节点的左子树设为新的节点<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">    ![image-20220730141952800](/TyporaImg/数据结构与算法.assets/image-20220730141952800.png)</span><br><span class="line"></span><br><span class="line">  - 右旋转</span><br><span class="line"></span><br><span class="line">    ![image-20220730142147504](/TyporaImg/数据结构与算法.assets/image-20220730142147504.png)</span><br><span class="line"></span><br><span class="line">  - 双旋转：某些情况下，单旋转不能完成平衡二叉树的转换</span><br><span class="line"></span><br><span class="line">    1. 当符合右旋转条件时</span><br><span class="line"></span><br><span class="line">    2. 如果左子树的右子树大于它的左子树高度</span><br><span class="line"></span><br><span class="line">    3. 先对这个节点的左节点进行左旋转</span><br><span class="line"></span><br><span class="line">    4. 再对当前节点进行右旋转</span><br><span class="line"></span><br><span class="line">       ![image-20220730151113211](/TyporaImg/数据结构与算法.assets/image-20220730151113211.png)</span><br><span class="line"></span><br><span class="line">#### 6.2 多路查找树</span><br><span class="line"></span><br><span class="line">- 二叉树的问题：当节点较多的时候：</span><br><span class="line"></span><br><span class="line">  - 多次I/O操作读取</span><br><span class="line">  - 高度变高导致速度降低</span><br><span class="line"></span><br><span class="line">- 引入多叉树：</span><br><span class="line"></span><br><span class="line">  - 如2-3树、2-3-4树</span><br><span class="line"></span><br><span class="line">    ![image-20220730182350142](/TyporaImg/数据结构与算法.assets/image-20220730182350142.png)</span><br><span class="line"></span><br><span class="line">  - B树</span><br><span class="line"></span><br><span class="line">- 2-3树</span><br><span class="line"></span><br><span class="line">  - 最简单 B树</span><br><span class="line"></span><br><span class="line">  - 特点：</span><br><span class="line"></span><br><span class="line">    - 2-3树的所有叶子节点都在同一层.(只要是B树都满足这个条件)</span><br><span class="line">    - 有两个子节点的节点叫二节点，二节点要么没有子节点，要么有两个子节点</span><br><span class="line">    - 有三个子节点的节点叫三节点，三节点要么没有子节点，要么有三个子节点</span><br><span class="line">    - 2-3树是由二节点和三节点构成的树</span><br><span class="line"></span><br><span class="line">  - 2-3树的构建过程</span><br><span class="line"></span><br><span class="line">    - 插入数据的规则：当不满足前三个特点的时候，就需要拆，先向上拆，如果上层满，则拆本层，拆后仍需要满足上面三个条件。</span><br><span class="line"></span><br><span class="line">      ![image-20220730183836147](/TyporaImg/数据结构与算法.assets/image-20220730183836147.png)</span><br><span class="line"></span><br><span class="line">      ![image-20220730183925033](/TyporaImg/数据结构与算法.assets/image-20220730183925033.png)</span><br><span class="line"></span><br><span class="line">- B树</span><br><span class="line"></span><br><span class="line">  - B-tree树即B树，B即Balanced，平衡的意思。有人把B-tree翻译成B-树，容易让人产生误解。会以为B-树是一种树，而B树又是另一种树。实际上，B-tree就是指的B树。</span><br><span class="line"></span><br><span class="line">  - B树的阶：节点的最多子节点个数。比如2-3树的阶是3，2-3-4树的阶是4</span><br><span class="line"></span><br><span class="line">  - B树的搜索，从根结点开始，对结点内的关键字（有序）序列进行二分查找，如果命中则结束，否则进入查询关键字所属范围的儿子结点；重复，直到所对应的儿子指针为空，或已经是叶子结点</span><br><span class="line"></span><br><span class="line">  - 关键字集合分布在整颗树中, 即叶子节点和非叶子节点都存放数据.</span><br><span class="line"></span><br><span class="line">  - 搜索有可能在非叶子结点结束</span><br><span class="line"></span><br><span class="line">  - 其搜索性能等价于在关键字全集内做一次二分查找</span><br><span class="line"></span><br><span class="line">    ![image-20220730184218884](/TyporaImg/数据结构与算法.assets/image-20220730184218884.png)</span><br><span class="line"></span><br><span class="line">- B+树</span><br><span class="line"></span><br><span class="line">  - 是B树的变体</span><br><span class="line"></span><br><span class="line">  - 所有数据都只在叶子节点中</span><br><span class="line"></span><br><span class="line">  - 所有关键字都出现在叶子结点的链表中（即数据只能在叶子节点[也叫稠密索引]），且链表中的关键字(数据)恰好是有序的。</span><br><span class="line"></span><br><span class="line">  - 非叶子结点相当于是叶子结点的索引（稀疏索引），叶子结点相当于是存储（关键字）数据的数据层</span><br><span class="line"></span><br><span class="line">  - 更适合文件索引系统</span><br><span class="line"></span><br><span class="line">  - B树和B+树各有自己的应用场景，不能说B+树完全比B树好，反之亦然.</span><br><span class="line"></span><br><span class="line">    ![image-20220730184405939](/TyporaImg/数据结构与算法.assets/image-20220730184405939.png)</span><br><span class="line"></span><br><span class="line">- B*树</span><br><span class="line"></span><br><span class="line">  - 是B+树的变体</span><br><span class="line"></span><br><span class="line">  - B树定义了非叶子结点关键字个数至少为(2/3)M，即块的最低使用率为2/3，而B+树的块的最低使用率为B+树的1/2。（这里M是它的度：节点的度指的是结点拥有的子树的数目。. 而整棵树的度指的是树中结点的最大的度）</span><br><span class="line"></span><br><span class="line">  - 从第1个特点我们可以看出，B*树分配新结点的概率比B+树要低，空间使用率更高</span><br><span class="line"></span><br><span class="line">    ![image-20220730184936013](/TyporaImg/数据结构与算法.assets/image-20220730184936013.png)</span><br><span class="line"></span><br><span class="line">#### 6.3 图</span><br><span class="line"></span><br><span class="line">- 线性表局限于一个直接前驱和一个直接后继的关系，树也只能有一个直接前驱也就是父节点，当我们需要表示多对多的关系时， 这里我们就用到了图</span><br><span class="line"></span><br><span class="line">- 图是一种数据结构，其中结点可以具有零个或多个相邻元素。两个结点之间的连接称为边。 结点也可以称为顶点</span><br><span class="line"></span><br><span class="line">- 常用概念：</span><br><span class="line"></span><br><span class="line">  - 顶点（vertex）</span><br><span class="line">  - 边（edge）</span><br><span class="line">  - 路径</span><br><span class="line">  - 无向图与有向图</span><br><span class="line">  - 带权图</span><br><span class="line"></span><br><span class="line">- 图的表示方式：</span><br><span class="line"></span><br><span class="line">  - 二维数组（邻接矩阵）</span><br><span class="line"></span><br><span class="line">    ![image-20220730185855050](/TyporaImg/数据结构与算法.assets/image-20220730185855050.png)</span><br><span class="line"></span><br><span class="line">  - 链表（邻接表）</span><br><span class="line"></span><br><span class="line">    - 邻接矩阵需要为每个顶点都分配n个边的空间，其实有很多边都是不存在,会造成空间的一定损失</span><br><span class="line">    - 邻接表的实现只关心存在的边，不关心不存在的边。因此没有空间浪费，邻接表由数组+链表组成![image-20220730185955246](/TyporaImg/数据结构与算法.assets/image-20220730185955246.png)</span><br><span class="line"></span><br><span class="line">- 图的创建和代码实现：&lt;u&gt;*day0730/Graph.java*&lt;/u&gt;</span><br><span class="line"></span><br><span class="line">#### 6.4 图的深度优先遍历算法（DFS: Depth First Search）</span><br><span class="line"></span><br><span class="line">- 从初始访问结点出发，初始访问结点可能有多个邻接结点，深度优先遍历的策略就是首先访问第一个邻接结点，然后再以这个被访问的邻接结点作为初始结点，访问它的第一个邻接结点， 可以这样理解：每次都在访问完当前结点后首先访问当前结点的第一个邻接结点</span><br><span class="line">- 我们可以看到，这样的访问策略是优先往纵向挖掘深入，而不是对一个结点的所有邻接结点进行横向访问</span><br><span class="line">- 步骤：</span><br><span class="line">  1. 访问初始结点v，并标记结点v为已访问。</span><br><span class="line">  2. 查找结点v的第一个邻接结点w。</span><br><span class="line">  3. 若w存在，则继续执行4，如果w不存在，则回到第1步，将从v的下一个结点继续。</span><br><span class="line">  4. 若w未被访问，对w进行深度优先遍历递归（即把w当做另一个v，然后进行步骤abc）。</span><br><span class="line">  5. 查找结点v的w邻接结点的下一个邻接结点，转到步骤3。</span><br><span class="line">- 代码实现：&lt;u&gt;*day0730/Graph.java*&lt;/u&gt;</span><br><span class="line"></span><br><span class="line">####  6.5 图的广度优先遍历算法(BFS: Broad First Search) </span><br><span class="line"></span><br><span class="line">- 类似于一个分层搜索的过程，广度优先遍历需要使用一个队列以保持访问过的结点的顺序，以便按这个顺序来访问这些结点的邻接结点</span><br><span class="line">- 步骤</span><br><span class="line">  1. 访问初始结点v并标记结点v为已访问。</span><br><span class="line">  2. 结点v入队列</span><br><span class="line">  3. 当队列非空时，继续执行，否则算法结束。</span><br><span class="line">  4. 出队列，取得队头结点u。</span><br><span class="line">  5. 查找结点u的第一个邻接结点w。</span><br><span class="line">  6. 若结点u的邻接结点w不存在，则转到步骤3；否则循环执行以下三个步骤：</span><br><span class="line">     - 6.1 若结点w尚未被访问，则访问结点w并标记为已访问。  </span><br><span class="line">     - 6.2 结点w入队列 </span><br><span class="line">     - 6.3 查找结点u的继w邻接结点后的下一个邻接结点w，转到步骤6。</span><br><span class="line">- 代码实现：&lt;u&gt;*day0730/Graph.java*&lt;/u&gt;</span><br><span class="line"></span><br><span class="line">#### 6.6 常用十算法 1二分查找算法（非递归）</span><br><span class="line"></span><br><span class="line">- 二分查找法只适用于从有序的数列中进行查找(比如数字和字母等)，将数列排序后再进行查找</span><br><span class="line">- 二分查找法的运行时间为对数时间O(㏒₂n) ，即查找到需要的目标位置最多只需要㏒₂n步，假设从[0,99]的队列(100个数，即n=100)中寻到目标数30，则需要查找步数为㏒₂100 , 即最多需要查找7次( 2^6 &lt; 100 &lt; 2^7)</span><br><span class="line">- 代码实现：&lt;u&gt;*Algorithm/BinarySearchNoRecur.java*&lt;/u&gt;</span><br><span class="line"></span><br><span class="line">#### 6.7 常用十算法 2分治算法</span><br><span class="line"></span><br><span class="line">- 分治法是一种很重要的算法。字面上的解释是“分而治之”，就是把一个复杂的问题分成两个或更多的相同或相似的子问题，再把子问题分成更小的子问题……直到最后子问题可以简单的直接求解，原问题的解即子问题的解的合并。这个技巧是很多高效算法的基础，如排序算法(快速排序，归并排序)，傅立叶变换(快速傅立叶变换)……</span><br><span class="line"></span><br><span class="line">- 经典问题：二分搜索、大整数乘法、棋盘覆盖、合并排序、快速排序、线性时间选择、最接近点对问题、循环赛日程表、汉诺塔</span><br><span class="line"></span><br><span class="line">- 分治算法设计模式</span><br><span class="line"></span><br><span class="line">  ```java</span><br><span class="line">  if |P|≤n0</span><br><span class="line">     then return(ADHOC(P))</span><br><span class="line">  //将P分解为较小的子问题 P1 ,P2 ,…,Pk</span><br><span class="line">  for i←1 to k</span><br><span class="line">  do yi ← Divide-and-Conquer(Pi)   递归解决Pi</span><br><span class="line">  T ← MERGE(y1,y2,…,yk)   合并子问题</span><br><span class="line">  return(T)</span><br></pre></td></tr></tbody></table></figure>
</li>
</ul>
</li>
</ul>
</li>
<li><p>代码实现哈诺塔问题：<u><em>Algorithm/Hanoitower.java</em></u></p>
<p><img src="/TyporaImg/数据结构与算法.assets/image-20220730203935359.png" alt="image-20220730203935359"></p>
</li>
</ul>
<h4 id="6-8-动态规划算法"><a href="#6-8-动态规划算法" class="headerlink" title="6.8 动态规划算法"></a>6.8 动态规划算法</h4><ul>
<li><p>动态规划(Dynamic Programming)算法的核心思想是：将大问题划分为小问题进行解决，从而一步步获取最优解的处理算法</p>
</li>
<li><p>动态规划算法与分治算法类似，其基本思想也是将待求解问题分解成若干个子问题，先求解子问题，然后从这些子问题的解得到原问题的解。</p>
</li>
<li><p>与分治法不同的是，适合于用动态规划求解的问题，经分解得到子问题往往不是互相独立的。 ( 即下一个子阶段的求解是建立在上一个子阶段的解的基础上，进行进一步的求解 )</p>
</li>
<li><p>动态规划可以通过填表的方式来逐步推进，得到最优解</p>
</li>
<li><p>01背包问题实现：<u><em>Algorithm/KnapsackProblem.java</em></u></p>
<p>思路：每次遍历到的第i个物品，根据w[i]和v[i]来确定是否需要将该物品放入背包中。即对于给定的n个物品，设v[i]、w[i]分别为第i个物品的价值和重量，C为背包的容量。再令v[i][j]表示在前i个物品中能够装入容量为j的背包中的最大价值。则我们有下面的结果：</p>
<ul>
<li><p>v[i][0]=v[0][j]=0; //表示填入表第一行和第一列是0</p>
</li>
<li><p>当w[i]&gt; j 时：v[i][j]=v[i-1][j]   // 当准备加入新增的商品的容量大于当前背包的容量时，就直接使用上一个单元格的装入策略</p>
</li>
<li><p>当j&gt;=w[i]时： v[i][j]=max{v[i-1][j], v[i]+v[i-1][j-w[i]]}  // 当准备加入的新增的商品的容量小于等于当前背包的容量,</p>
<p>装入的方式:<br>v[i-1][j]： 就是上一个单元格的装入的最大值<br>v[i] : 表示当前商品的价值<br>v[i-1][j-w[i]] ： 装入i-1商品，到剩余空间j-w[i]的最大值<br>当j&gt;=w[i]时： v[i][j]=max{v[i-1][j], v[i]+v[i-1][j-w[i]]} : </p>
</li>
</ul>
<p><img src="/TyporaImg/数据结构与算法.assets/image-20220730210931369.png" alt="image-20220730210931369"></p>
<p>另一种理解方式：</p>
<p><img src="/TyporaImg/数据结构与算法.assets/image-20220730211647928.png" alt="image-20220730211647928"></p>
<p>最优解的回溯：</p>
<p><img src="/TyporaImg/数据结构与算法.assets/image-20220731093245107.png" alt="image-20220731093245107"></p>
</li>
</ul>
<h3 id="0731-五-常用十算法"><a href="#0731-五-常用十算法" class="headerlink" title="0731 五 常用十算法"></a>0731 五 常用十算法</h3><h4 id="5-1-KMP算法"><a href="#5-1-KMP算法" class="headerlink" title="5.1 KMP算法"></a>5.1 KMP算法</h4><ul>
<li>查找字符产出现的最早位置</li>
<li>暴力匹配算法</li>
<li>KMP算法解释：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/zzuuoo666/p/9028287.html">https://www.cnblogs.com/zzuuoo666/p/9028287.html</a></li>
<li><a target="_blank" rel="noopener" href="http://www.ruanyifeng.com/blog/2013/05/Knuth%E2%80%93Morris%E2%80%93Pratt_algorithm.html(简版">http://www.ruanyifeng.com/blog/2013/05/Knuth%E2%80%93Morris%E2%80%93Pratt_algorithm.html(简版</a>)</li>
<li>主要是部分匹配表的推算</li>
<li>KMP算法实现：<u><em>Algorithm/KMP.java</em></u></li>
</ul>
<h4 id="5-2-贪心算法"><a href="#5-2-贪心算法" class="headerlink" title="5.2 贪心算法"></a>5.2 贪心算法</h4><ul>
<li><p>贪婪算法(贪心算法)是指在对问题进行求解时，在每一步选择中都采取最好或者最优(即最有利)的选择，从而希望能够导致结果是最好或者最优的算法</p>
</li>
<li><p>贪婪算法所得到的结果不一定是最优的结果(有时候会是最优解)，但是都是相对近似(接近)最优解的结果</p>
</li>
<li><p>贪心算法应用：广播台集合覆盖</p>
<p><img src="/TyporaImg/数据结构与算法.assets/image-20220731114816388.png" alt="image-20220731114816388"></p>
<ol>
<li>遍历所有的广播电台, 找到一个覆盖了最多未覆盖的地区的电台(此电台可能包含一些已覆盖的地区，但没有关系） </li>
<li>将这个电台加入到一个集合中(比如ArrayList), 想办法把该电台覆盖的地区在下次比较时去掉。</li>
<li>重复第1步直到覆盖了全部的地区</li>
</ol>
</li>
</ul>
<p>​                    代码实现：<u><em>Algorithm/Greedy.java</em></u></p>
<h4 id="5-3-普利姆算法"><a href="#5-3-普利姆算法" class="headerlink" title="5.3 普利姆算法"></a>5.3 普利姆算法</h4><ul>
<li><p><img src="/TyporaImg/数据结构与算法.assets/image-20220731120825787.png" alt="image-20220731120825787"></p>
</li>
<li><p>修路问题本质就是最小生成树（MST）问题</p>
</li>
<li><p>最小生成树(Minimum Cost Spanning Tree)：</p>
<ul>
<li>给定一个带权的无向连通图,如何选取一棵生成树,使树上所有边上权的总和为最小,这叫最小生成树 </li>
<li>N个顶点，一定有N-1条边</li>
<li>包含全部顶点</li>
<li>N-1条边都在图中</li>
<li>求最小生成树的算法主要是普里姆算法和克鲁斯卡尔算法</li>
</ul>
</li>
<li><p>Prim算法介绍：</p>
<ol>
<li><p>设G=(V,E)是连通网，T=(U,D)是最小生成树，V,U是顶点集合，E,D是边的集合 </p>
</li>
<li><p>若从顶点u开始构造最小生成树，则从集合V中取出顶点u放入集合U中，标记顶点v的visited[u]=1</p>
</li>
<li><p>若集合U中顶点ui与集合V-U中的顶点vj之间存在边，则寻找这些边中权值最小的边，但不能构成回路，将顶点vj加入集合U中，将边（ui,vj）加入集合D中，标记visited[vj]=1</p>
</li>
<li><p>重复步骤②，直到U与V相等，即所有顶点都被标记为访问过，此时D中有n-1条边</p>
<p><a target="_blank" rel="noopener" href="http://c.biancheng.net/algorithm/prim.html">http://c.biancheng.net/algorithm/prim.html</a></p>
</li>
</ol>
</li>
<li><p>代码实现：<u><em>Algorithm/Prim.java</em></u></p>
</li>
</ul>
<h4 id="5-4-克鲁斯卡尔算法：http-c-biancheng-net-algorithm-kruskal-html"><a href="#5-4-克鲁斯卡尔算法：http-c-biancheng-net-algorithm-kruskal-html" class="headerlink" title="5.4 克鲁斯卡尔算法：http://c.biancheng.net/algorithm/kruskal.html"></a>5.4 克鲁斯卡尔算法：<a target="_blank" rel="noopener" href="http://c.biancheng.net/algorithm/kruskal.html">http://c.biancheng.net/algorithm/kruskal.html</a></h4><ul>
<li><p>思路：按照权值从小到大的顺序选择n-1条边，并保证这n-1条边不构成回路</p>
</li>
<li><p>具体做法：首先构造一个只含n个顶点的森林，然后依权值从小到大从连通网中选择边加入到森林中，并使森林中不产生回路，直至森林变成一棵树为止</p>
</li>
<li><p>实现克鲁斯卡尔算法的难点在于“如何判断一个新边是否会和已选择的边构成环路”</p>
<p>选择加入的边的两个顶点不能指向同一个终点，否则将构成回路</p>
</li>
<li><p>代码实现：<u><em>Algorithm/Kruskal.java</em></u></p>
</li>
</ul>
<h4 id="5-5-迪杰斯特拉算法"><a href="#5-5-迪杰斯特拉算法" class="headerlink" title="5.5 迪杰斯特拉算法"></a>5.5 迪杰斯特拉算法</h4><ul>
<li><p>迪杰斯特拉(Dijkstra)算法是典型最短路径算法，用于计算一个结点到其他结点的最短路径。 它的主要特点是以起始点为中心向外层层扩展(广度优先搜索思想)，直到扩展到终点为止。</p>
</li>
<li><p>算法过程：</p>
<ol>
<li>设置出发顶点为v，顶点集合V{v1,v2,vi…}，v到V中各顶点的距离构成距离集合Dis，Dis{d1,d2,di…}，Dis集合记录着v到图中各顶点的距离(到自身可以看作0，v到vi距离对应为di)</li>
<li>从Dis中选择值最小的di并移出Dis集合，同时移出V集合中对应的顶点vi，此时的v到vi即为最短路径</li>
<li>更新Dis集合，更新规则为：比较v到V集合中顶点的距离值，与v通过vi到V集合中顶点的距离值，保留值较小的一个(同时也应该更新顶点的前驱节点为vi，表明是通过vi到达的)</li>
<li>重复执行两步骤，直到最短路径顶点为目标顶点即可结束</li>
</ol>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/346558578">https://zhuanlan.zhihu.com/p/346558578</a></p>
</li>
<li><p>代码实现：<u><em>Algorithm/Dijkstra.java</em></u></p>
</li>
</ul>
<h4 id="5-6-弗洛伊德算法-Floyd"><a href="#5-6-弗洛伊德算法-Floyd" class="headerlink" title="5.6 弗洛伊德算法(Floyd)"></a>5.6 弗洛伊德算法(Floyd)</h4><ol>
<li><p>弗洛伊德算法(Floyd)计算图中各个顶点之间的最短路径</p>
</li>
<li><p>迪杰斯特拉算法用于计算图中某一个顶点到其他顶点的最短路径。</p>
</li>
<li><p><strong>弗洛伊德算法</strong> VS <strong>迪杰斯特拉算法</strong>：迪杰斯特拉算法通过选定的被访问顶点，求出从出发访问顶点到其他顶点的最短路径；弗洛伊德算法中每一个顶点都是出发访问点，所以需要将每一个顶点看做被访问顶点，求出从每一个顶点到其他顶点的最短路径。</p>
</li>
<li><p>思路:</p>
<ol>
<li><p>设置顶点vi到顶点vk的最短路径已知为Lik，顶点vk到vj的最短路径已知为Lkj，顶点vi到vj的路径为Lij，则vi到vj的最短路径为：min((Lik+Lkj),Lij)，vk的取值为图中所有顶点，则可获得vi到vj的最短路径</p>
</li>
<li><p>至于vi到vk的最短路径Lik或者vk到vj的最短路径Lkj，是以同样的方式获得</p>
<p>主要是维护DP两张表（距离表，前驱关系表）</p>
</li>
</ol>
<p><img src="/TyporaImg/数据结构与算法.assets/image-20220731160421005.png" alt="image-20220731160421005"></p>
<p><img src="/TyporaImg/数据结构与算法.assets/image-20220731160431219.png" alt="image-20220731160431219"></p>
<p>代码实现：<u><em>Algorithm/Floyd.java</em></u></p>
<h4 id="5-7-骑士周游问题"><a href="#5-7-骑士周游问题" class="headerlink" title="5.7 骑士周游问题"></a>5.7 骑士周游问题</h4></li>
</ol>
<ul>
<li><p><img src="/TyporaImg/数据结构与算法.assets/image-20220731162306379.png" alt="image-20220731162306379"></p>
</li>
<li><p>分析：</p>
<ul>
<li>马踏棋盘问题(骑士周游问题)实际上是图的深度优先搜索(DFS)的应用。</li>
<li>如果使用回溯（就是深度优先搜索）来解决，假如马儿踏了53个点，如图：走到了第53个，坐标（1,0），发现已经走到尽头，没办法，那就只能回退了，查看其他的路径，就在棋盘上不停的回溯…… </li>
</ul>
</li>
<li><p>思路：</p>
<ul>
<li><img src="/TyporaImg/数据结构与算法.assets/image-20220731162614425.png" alt="image-20220731162614425"></li>
</ul>
</li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="http://yileman.github.io">myl</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://yileman.github.io/posts/40445.html">http://yileman.github.io/posts/40445.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://yileman.github.io" target="_blank">myl's blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/java%E5%9F%BA%E7%A1%80-%E7%AE%97%E6%B3%95/">java基础 算法</a></div><div class="post_share"><div class="social-share" data-image="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/cover/article_cover3.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer=""></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-full"><a href="/posts/20250.html" title="javase"><img class="cover" src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/cover/article_cover1.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">javase</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/posts/46256.html" title="力扣刷题"><img class="cover" src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/TyporaImg/cover/article_cover15.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-01-30</div><div class="title">力扣刷题</div></div></a></div></div></div><hr class="custom-hr"><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="twikoo-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://myl-mdimg.oss-cn-beijing.aliyuncs.com/touxiang.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"></div><div class="author-info__name">myl</div><div class="author-info__description">后端学习</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">20</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">7</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">4</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/yileman"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">写写记记</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95"><span class="toc-number">1.</span> <span class="toc-text">数据结构与算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#0725-%E4%B8%80-%E9%98%9F%E5%88%97%E3%80%81%E9%93%BE%E8%A1%A8"><span class="toc-number">1.1.</span> <span class="toc-text">0725 一 队列、链表</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%84%E5%92%8C%E9%9D%9E%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%84"><span class="toc-number">1.1.1.</span> <span class="toc-text">1.1 线性结构和非线性结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-%E7%A8%80%E7%96%8F%E6%95%B0%E7%BB%84%E5%92%8C%E9%98%9F%E5%88%97"><span class="toc-number">1.1.2.</span> <span class="toc-text">1.2 稀疏数组和队列</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-3-%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8"><span class="toc-number">1.1.3.</span> <span class="toc-text">1.3 单向链表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-4-%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8"><span class="toc-number">1.1.4.</span> <span class="toc-text">1.4 双向链表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-5-%E5%8D%95%E5%90%91%E7%8E%AF%E5%BD%A2%E9%97%AE%E9%A2%98%E5%92%8C%E7%BA%A6%E7%91%9F%E5%A4%AB%E9%97%AE%E9%A2%98"><span class="toc-number">1.1.5.</span> <span class="toc-text">1.5 单向环形问题和约瑟夫问题</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#0726-%E4%BA%8C-%E6%A0%88%E3%80%81%E5%89%8D%E4%B8%AD%E5%90%8E%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F%E3%80%81%E6%8E%92%E5%BA%8F"><span class="toc-number">1.2.</span> <span class="toc-text">0726 二  栈、前中后缀表达式、排序</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-%E6%A0%88%EF%BC%88Stack%EF%BC%89"><span class="toc-number">1.2.1.</span> <span class="toc-text">2.1 栈（Stack）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-%E5%89%8D%E7%BC%80%E3%80%81%E4%B8%AD%E7%BC%80%E3%80%81%E5%90%8E%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">1.2.2.</span> <span class="toc-text">2.2 前缀、中缀、后缀表达式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-%E9%80%92%E5%BD%92%EF%BC%88Recursion%EF%BC%89%E7%9A%84%E8%B0%83%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">1.2.3.</span> <span class="toc-text">2.3 递归（Recursion）的调用场景</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-4-%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95"><span class="toc-number">1.2.4.</span> <span class="toc-text">2.4 排序算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-5-%E7%AE%97%E6%B3%95%E7%9A%84%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6"><span class="toc-number">1.2.5.</span> <span class="toc-text">2.5 算法的时间复杂度</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-6-%E7%AE%97%E6%B3%95%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6"><span class="toc-number">1.2.6.</span> <span class="toc-text">2.6 算法空间复杂度</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-7-%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F"><span class="toc-number">1.2.7.</span> <span class="toc-text">2.7 冒泡排序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-8-%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F"><span class="toc-number">1.2.8.</span> <span class="toc-text">2.8 选择排序</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#0727-%E4%B8%89-%E6%8E%92%E5%BA%8F%E3%80%81%E6%9F%A5%E6%89%BE%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8"><span class="toc-number">1.3.</span> <span class="toc-text">0727 三 排序、查找、哈希表</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F"><span class="toc-number">1.3.1.</span> <span class="toc-text">3.1 插入排序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F"><span class="toc-number">1.3.2.</span> <span class="toc-text">3.2 快速排序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F"><span class="toc-number">1.3.3.</span> <span class="toc-text">3.3 归并排序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-4-%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F%EF%BC%88%E6%A1%B6%E6%8E%92%E5%BA%8F%EF%BC%89"><span class="toc-number">1.3.4.</span> <span class="toc-text">3.4 基数排序（桶排序）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-5-%E5%B8%B8%E7%94%A8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E5%AF%B9%E6%AF%94"><span class="toc-number">1.3.5.</span> <span class="toc-text">3.5 常用排序算法对比</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-6-%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95"><span class="toc-number">1.3.6.</span> <span class="toc-text">3.6 查找算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-7-%E5%93%88%E5%B8%8C%E8%A1%A8"><span class="toc-number">1.3.7.</span> <span class="toc-text">3.7 哈希表</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#0728-%E5%9B%9B-%E4%BA%8C%E5%8F%89%E6%A0%91%E3%80%81%E5%A0%86%E3%80%81%E8%B5%AB%E5%A4%AB%E6%9B%BC%E6%A0%91"><span class="toc-number">1.4.</span> <span class="toc-text">0728 四 二叉树、堆、赫夫曼树</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1-%E6%A0%91%E7%BB%93%E6%9E%84"><span class="toc-number">1.4.1.</span> <span class="toc-text">4.1 树结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">1.4.2.</span> <span class="toc-text">4.2 二叉树</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-3-%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">1.4.3.</span> <span class="toc-text">4.3 顺序存储二叉树</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-4-%E7%BA%BF%E7%B4%A2%E5%8C%96%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">1.4.4.</span> <span class="toc-text">4.4 线索化二叉树</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-5-%E5%A0%86%E6%8E%92%E5%BA%8F"><span class="toc-number">1.4.5.</span> <span class="toc-text">4.5 堆排序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-6-%E8%B5%AB%E5%A4%AB%E6%9B%BC%E6%A0%91"><span class="toc-number">1.4.6.</span> <span class="toc-text">4.6 赫夫曼树</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-7-%E8%B5%AB%E5%A4%AB%E6%9B%BC%E7%BC%96%E7%A0%81"><span class="toc-number">1.4.7.</span> <span class="toc-text">4.7 赫夫曼编码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#0729-%E4%BA%94-%E8%B5%AB%E5%A4%AB%E6%9B%BC%E7%BC%96%E7%A0%81%E7%9A%84%E6%95%B0%E6%8D%AE%E5%8E%8B%E7%BC%A9%E5%92%8C%E8%A7%A3%E5%8E%8B%E3%80%81%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91"><span class="toc-number">1.5.</span> <span class="toc-text">0729 五 赫夫曼编码的数据压缩和解压、二叉排序树</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#5-1-%E6%95%B0%E6%8D%AE%E8%A7%A3%E5%8E%8B"><span class="toc-number">1.5.1.</span> <span class="toc-text">5.1 数据解压</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-2-%E8%B5%AB%E5%A4%AB%E6%9B%BC%E7%BC%96%E7%A0%81%E5%8E%8B%E7%BC%A9%E6%96%87%E4%BB%B6%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-number">1.5.2.</span> <span class="toc-text">5.2 赫夫曼编码压缩文件注意事项</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-2-%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91%EF%BC%88BST%EF%BC%89"><span class="toc-number">1.5.3.</span> <span class="toc-text">5.2 二叉排序树（BST）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#0730-%E5%85%AD-AVL%E6%A0%91%E3%80%81%E5%A4%9A%E8%B7%AF%E6%9F%A5%E6%89%BE%E6%A0%91%E3%80%81%E5%9B%BE%E3%80%81%E5%B8%B8%E7%94%A8%E5%8D%81%E7%AE%97%E6%B3%95"><span class="toc-number">1.6.</span> <span class="toc-text">0730 六 AVL树、多路查找树、图、常用十算法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#6-1-%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91%EF%BC%88AVL%E6%A0%91%EF%BC%89"><span class="toc-number">1.6.1.</span> <span class="toc-text">6.1 平衡二叉树（AVL树）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-8-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%AE%97%E6%B3%95"><span class="toc-number">1.6.2.</span> <span class="toc-text">6.8 动态规划算法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#0731-%E4%BA%94-%E5%B8%B8%E7%94%A8%E5%8D%81%E7%AE%97%E6%B3%95"><span class="toc-number">1.7.</span> <span class="toc-text">0731 五 常用十算法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#5-1-KMP%E7%AE%97%E6%B3%95"><span class="toc-number">1.7.1.</span> <span class="toc-text">5.1 KMP算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-2-%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95"><span class="toc-number">1.7.2.</span> <span class="toc-text">5.2 贪心算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-3-%E6%99%AE%E5%88%A9%E5%A7%86%E7%AE%97%E6%B3%95"><span class="toc-number">1.7.3.</span> <span class="toc-text">5.3 普利姆算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-4-%E5%85%8B%E9%B2%81%E6%96%AF%E5%8D%A1%E5%B0%94%E7%AE%97%E6%B3%95%EF%BC%9Ahttp-c-biancheng-net-algorithm-kruskal-html"><span class="toc-number">1.7.4.</span> <span class="toc-text">5.4 克鲁斯卡尔算法：http://c.biancheng.net/algorithm/kruskal.html</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-5-%E8%BF%AA%E6%9D%B0%E6%96%AF%E7%89%B9%E6%8B%89%E7%AE%97%E6%B3%95"><span class="toc-number">1.7.5.</span> <span class="toc-text">5.5 迪杰斯特拉算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-6-%E5%BC%97%E6%B4%9B%E4%BC%8A%E5%BE%B7%E7%AE%97%E6%B3%95-Floyd"><span class="toc-number">1.7.6.</span> <span class="toc-text">5.6 弗洛伊德算法(Floyd)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-7-%E9%AA%91%E5%A3%AB%E5%91%A8%E6%B8%B8%E9%97%AE%E9%A2%98"><span class="toc-number">1.7.7.</span> <span class="toc-text">5.7 骑士周游问题</span></a></li></ol></li></ol></li></ol></div></div></div></div></main><footer id="footer" style="background: transparent"><div id="footer-wrap"><div class="copyright">©2024 By myl</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=4.13.0"></script><script src="/js/main.js?v=4.13.0"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"><script>(() => {
  const getCount = () => {
    const countELement = document.getElementById('twikoo-count')
    if(!countELement) return
    twikoo.getCommentsCount({
      envId: 'https://www.manyile.top',
      region: 'ap-shanghai',
      urls: [window.location.pathname],
      includeReply: false
    }).then(res => {
      countELement.textContent = res[0].count
    }).catch(err => {
      console.error(err)
    })
  }

  const init = () => {
    twikoo.init(Object.assign({
      el: '#twikoo-wrap',
      envId: 'https://www.manyile.top',
      region: 'ap-shanghai',
      onCommentLoaded: () => {
        btf.loadLightbox(document.querySelectorAll('#twikoo .tk-content img:not(.tk-owo-emotion)'))
      }
    }, null))

    GLOBAL_CONFIG_SITE.isPost && getCount()
  }

  const loadTwikoo = () => {
    if (typeof twikoo === 'object') setTimeout(init,0)
    else getScript('https://cdn.jsdelivr.net/npm/twikoo@1.6.31/dist/twikoo.all.min.js').then(init)
  }

  if ('Twikoo' === 'Twikoo' || !true) {
    if (true) btf.loadComment(document.getElementById('twikoo-wrap'), loadTwikoo)
    else loadTwikoo()
  } else {
    window.loadOtherComment = loadTwikoo
  }
})()</script></div><script type="text/javascript" src="https://unpkg.zhimg.com/jquery@latest/dist/jquery.min.js"></script><script data-pjax="" type="text/javascript" src="/js/nav.js"></script><div class="aplayer no-destroy" data-id="2664875269" data-server="netease" data-type="playlist" data-fixed="true" data-mini="true" data-listfolded="false" data-order="random" data-preload="none" data-autoplay="false" muted=""></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer@1.10.1/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/aplayer@1.10.1/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/metingjs/dist/Meting.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax@0.2.8/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {

  // removeEventListener
  btf.removeGlobalFnEvent('pjax')
  btf.removeGlobalFnEvent('themeChange')

  document.getElementById('rightside').classList.remove('rightside-show')
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

  typeof disqusjs === 'object' && disqusjs.destroy()
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', e => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async="" data-pjax="" src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"></div></div><hr><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js?v=4.13.0"></script></div></div><!-- hexo injector body_end start --><script async="" src="//at.alicdn.com/t/font_2032782_8d5kxvn09md.js"></script><!-- hexo injector body_end end --></body></html>